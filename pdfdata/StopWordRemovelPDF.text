 Thinking Java Fourth Edition Bruce Eckel President, MindView, Inc. teochew Comments readers: Thinking In Java read cover cover every Java programmer, kept close hand frequent reference. The exercises challenging, chapter Collections superb! Not book help pass Sun Certified Java Programmer exam; it’s also first book I turn whenever I Java question. Jim Pleger, Loudoun County (Virginia) Government Much better Java book I’ve seen. Make “by order magnitude”... complete, excellent right-to-the-point examples intelligent, dumbed-down, explanations ... In contrast many Java books I found unusually mature, consistent, intellectually honest, well-written precise. IMHO, ideal book studying Java. Anatoly Vorobey, Technion University, Haifa, Israel One absolutely best programming tutorials I’ve seen language. Joakim Ziegler, FIX sysop Thank wonderful, wonderful book Java. Dr. Gavin Pillay, Registrar, King Edward VIII Hospital, South Africa Thank awesome book. I really floundering (being non-C programmer), book brought speed fast I could read it. It’s really cool able understand underlying principles concepts start, rather try build conceptual model trial error. Hopefully I able attend seminar not-too-distant future. Randall R. Hawley, Automation Technician, Eli Lilly & Co. The best computer book writing I seen. Tom Holland This one best books I’ve read programming language… The best book ever written Java. Ravindra Pai, Oracle Corporation, SUNOS product line This best book Java I ever found! You done great job. Your depth amazing. I purchasing book published. I learning Java since October 96. I read books, consider “MUST READ.” These past months focused product written entirely Java. Your book helped solidify topics I shaky expanded knowledge base. I even used explanations information interviewing contractors help team. I found much Java knowledge asking things I learned reading book (e.g., difference arrays Vectors). Your book great! Steve Wilkinson, Senior Staff Specialist, MCI Telecommunications Great book. Best book Java I seen far. Jeff Sinclair, Software Engineer, Kestral Computing Thank Thinking Java. It’s time someone went beyond mere language description thoughtful, penetrating analytic tutorial doesn’t kowtow The Manufacturers. I’ve read almost others—only Patrick Winston’s found place heart. I’m already recommending customers. Thanks again. Richard Brooks, Java Consultant, Sun Professional Services, Dallas Bruce, book wonderful! Your explanations clear direct. Through fantastic book I gained tremendous amount Java knowledge. The exercises also FANTASTIC excellent job reinforcing ideas explained throughout chapters. I look forward reading books written you. Thank tremendous service providing writing great books. My code much better reading Thinking Java. I thank I’m sure programmers maintain code also grateful you. Yvonne Watkins, Java Artisan, Discover Technologies, Inc. Other books cover WHAT Java (describing syntax libraries) HOW Java (practical programming examples). Thinking Java book I know explains WHY Java; designed way was, works way does, sometimes doesn’t work, it’s better C++, it’s not. Although also good job teaching language, Thinking Java definitely thinking person’s choice Java book. Robert S. Stephenson Thanks writing great book. The I read better I like it. My students like it, too. Chuck Iverson I want commend work Thinking Java. It people like dignify future Internet I want thank effort. It much appreciated. Patrick Barrell, Network Officer Mamco, QAF Mfg. Inc. I really, really appreciate enthusiasm work. I download every revision online books looking languages exploring I would never dared (C#, C++, Python, Ruby, side effect). I least 15 Java books (I needed 3 make JavaScript PHP viable!) subscriptions Dr. Dobbs, JavaPro, JDJ, JavaWorld, etc., result pursuit Java (and Enterprise Java) certification I still keep book higher esteem. It truly thinking man’s book. I subscribe newsletter hope one day sit solve problems extend solutions guides (I’ll buy guides!) appreciation. But meantime, thanks lot. Joshua Long, www.starbuxman.com Most Java books fine start, beginning stuff lot examples. Yours far best advanced thinking book I’ve seen. Please publish soon! ... I also bought Thinking C++ I impressed Thinking Java. George Laframboise, LightWorx Technology Consulting, Inc. I wrote earlier favorable impressions regarding Thinking C++ (a book stands prominently shelf work). And today I’ve able delve Java e-book virtual hand, I must say (in best Chevy Chase Modern Problems), “I like it!” Very informative explanatory, without reading like dry textbook. You cover important yet least covered concepts Java development: whys. Sean Brady I develop Java C++, books lifesavers me. If I stumped particular concept, I know I count books a) explain thought clearly b) solid examples pertain I trying accomplish. I yet find another author I continually whole-heartedly recommend anyone willing listen. Josh Asbury, A^3 Software Consulting, Cincinnati, Ohio Your examples clear easy understand. You took care many important details Java can’t found easily weak Java documentation. And don’t waste reader’s time basic facts programmer already knows. Kai Engert, Innovative Software, Germany I’m great fan Thinking C++ recommended associates. As I go electronic version Java book, I’m finding you’ve retained high level writing. Thank you! Peter R. Neuwald VERY well-written Java book...I think you’ve done GREAT job it. As leader Chicagoarea Java special interest group, I’ve favorably mentioned book Web site several times recent meetings. I would like use Thinking Java basis part monthly SIG meeting, review discuss chapter succession. Mark Ertes By way, printed TIJ2 Russian still selling great, remains bestseller. Learning Java became synonym reading TIJ2, isn’t nice? Ivan Porty, translator publisher Thinking Java 2nd Edition Russian I really appreciate work book good. I recommend users Ph.D. students. Hugues Leroy // Irisa-Inria Rennes France, Head Scientific Computing Industrial Tranfert OK, I’ve read 40 pages Thinking Java, I’ve already found clearly written presented programming book I’ve come across...and I’m writer, myself, I probably little critical. I Thinking C++ order can’t wait crack it—I’m fairly new programming hitting learning curves head-on everywhere. So quick note say thanks excellent work. I begun burn little low enthusiasm slogging mucky, murky prose computer books— even ones came glowing recommendations. I feel whole lot better now. Glenn Becker, Educational Theatre Association Thank making wonderful book available. I found immensely useful finally understanding I experienced confusing Java C++. Reading book satisfying. Felix Bizaoui, Twin Oaks Industries, Louisa, Va. I must congratulate excellent book. I decided look Thinking Java based experience Thinking C++, I disappointed. Jaco van der Merwe, Software Specialist, DataFusion Systems Ltd, Stellenbosch, South Africa This one best Java books I’ve seen. E.F. Pritchard, Senior Software Engineer, Cambridge Animation Systems Ltd., United Kingdom Your book makes Java books I’ve read flipped seem doubly useless insulting. Brett Porter, Senior Programmer, Art & Logic I reading book week two compared books I read earlier Java, book seems given great start. I recommended book lot friends rated excellent. Please accept congratulations coming excellent book. Rama Krishna Bhupathi, Software Engineer, TCSI Corporation, San Jose Just wanted say “brilliant” piece work book is. I’ve using major reference in-house Java work. I find table contents right quickly locating section required. It’s also nice see book rehash API treats programmer like dummy. Grant Sayer, Java Components Group Leader, Ceedata Systems Pty Ltd, Australia Wow! A readable, in-depth Java book. There lot poor (and admittedly couple good) Java books there, I’ve seen definitely one best. John Root, Web Developer, Department Social Security, London I’ve started Thinking Java. I expect good I really liked Thinking C++ (which I read experienced C++ programmer, trying stay ahead curve) … You wonderful author. Kevin K. Lewis, Technologist, ObjectSpace, Inc. I think it’s great book. I learned I know Java book. Thank making available free Internet. If wouldn’t I’d know nothing Java all. But best thing book isn’t commercial brochure Java. It also shows bad sides Java. YOU done great job here. Frederik Fix, Belgium I hooked books time. A couple years ago, I wanted start C++, C++ Inside & Out took around fascinating world C++. It helped getting better opportunities life. Now, pursuit knowledge I wanted learn Java, I bumped Thinking Java—no doubts mind whether I need book. Just fantastic. It like rediscovering I get along book. It month since I started Java, heartfelt thanks you, I understanding better now. Anand Kumar S., Software Engineer, Computervision, India Your book stands excellent general introduction. Peter Robinson, University Cambridge Computer Laboratory It’s far best material I come across help learn Java I want know lucky I feel found it. THANKS! Chuck Peterson, Product Leader, Internet Product Line, IVIS International The book great. It’s third book Java I’ve started I’m two-thirds way now. I plan finish one. I found used internal classes Lucent Technologies friend told book Net. Good work. Jerry Nowlin, MTS, Lucent Technologies Of six Java books I’ve accumulated date, Thinking Java far best clearest. Michael Van Waas, Ph.D., President, TMR Associates I want say thanks Thinking Java. What wonderful book you’ve made here! Not mention downloadable free! As student I find books invaluable (I copy C++ Inside Out, another great book C++), teach how-to, also whys, course important building strong foundation languages C++ Java. I quite lot friends love programming I do, I’ve told books. They think it’s great! Thanks again! By way, I’m Indonesian I live Java. Ray Frederick Djajadinata, Student Trisakti University, Jakarta The mere fact made work free Net puts shock. I thought I’d let know much I appreciate respect you’re doing. Shane LeBouthillier, Computer Engineering student, University Alberta, Canada I tell much I look forward reading monthly column. As newbie world object oriented programming, I appreciate time thoughtfulness give even elementary topic. I downloaded book, bet I purchase hard copy published. Thanks help. Dan Cashmer, B. C. Ziegler & Co. Just want congratulate job well done. First I stumbled upon PDF version Thinking Java. Even I finished reading it, I ran store found Thinking C++. Now, I computer business eight years, consultant, software engineer, teacher/trainer, recently self-employed, I’d like think I seen enough (not “have seen all,” mind you, enough). However, books cause girlfriend call ”geek.” Not I anything concept—it I thought phase well beyond me. But I find truly enjoying books, like computer book I touched bought far. Excellent writing style, nice introduction every new topic, lots wisdom books. Well done. Simon Goland, simonsez@smartt.com, Simon Says Consulting, Inc. I must say Thinking Java great! That exactly kind documentation I looking for. Especially sections good poor software design using Java. Dirk Duehr, Lexikon Verlag, Bertelsmann AG, Germany Thank writing two great books (Thinking C++, Thinking Java). You helped immensely progression object oriented programming. Donald Lawson, DCL Enterprises Thank taking time write really helpful book Java. If teaching makes understand something, must pretty pleased yourself. Dominic Turner, GEAC Support It’s best Java book I ever read—and I read some. Jean-Yves MENGANT, Chief Software Architect NAT-SYSTEM, Paris, France Thinking Java gives best coverage explanation. Very easy read, I mean code fragments well. Ron Chan, Ph.D., Expert Choice, Inc., Pittsburgh, Pa. Your book great. I read lots programming books book still adds insights programming mind. Ningjian Wang, Information System Engineer, The Vanguard Group Thinking Java excellent readable book. I recommend students. Dr. Paul Gorman, Department Computer Science, University Otago, Dunedin, New Zealand With book, I understood object oriented programming means. ... I believe Java much straightforward often even easier Perl. Torsten Römer, Orange Denmark You make possible proverbial free lunch exist, soup kitchen type lunch gourmet delight appreciate good software books it. Jose Suriol, Scylax Corporation Thanks opportunity watching book grow masterpiece! IT IS THE BEST book subject I’ve read browsed. Jeff Lapchinsky, Programmer, Net Results Technologies Your book concise, accessible joy read. Keith Ritchie, Java Research & Development Team, KL Group Inc. It truly best book I’ve read Java! Daniel Eng The best book I seen Java! Rich Hoffarth, Senior Architect, West Group Thank wonderful book. I’m lot fun going chapters. Fred Trimble, Actium Corporation You mastered art slowly successfully making us grasp details. You make learning VERY easy satisfying. Thank truly wonderful tutorial. Rajesh Rau, Software Consultant Thinking Java rocks free world! Miko O’Sullivan, President, Idocs Inc. About Thinking C++: Winner 1995 Software Development Magazine Jolt Award Best Book Year “This book tremendous achievement. You owe copy shelf. The chapter iostreams comprehensive understandable treatment subject I’ve seen date.” Al Stevens Contributing Editor, Doctor Dobbs Journal “Eckel’s book one clearly explain rethink program construction object orientation. That book also excellent tutorial ins outs C++ added bonus.” Andrew Binstock Editor, Unix Review “Bruce continues amaze insight C++, Thinking C++ best collection ideas yet. If want clear answers difficult questions C++, buy outstanding book.” Gary Entsminger Author, The Tao Objects “Thinking C++ patiently methodically explores issues use inlines, references, operator overloading, inheritance, dynamic objects, well advanced topics proper use templates, exceptions multiple inheritance. The entire effort woven fabric includes Eckel’s philosophy object program design. A must every C++ developer’s bookshelf, Thinking C++ one C++ book must you’re serious development C++.” Richard Hale Shaw Contributing Editor, PC Magazine Thinking Java Fourth Edition Bruce Eckel President, MindView, Inc. Upper Saddle River, NJ ● Boston ● Indianapolis ● San Francisco New York ● Toronto ● Montreal ● London ● Munich ● Paris Madrid ● Capetown ● Sydney ● Tokyo ● Singapore ● Mexico City Many designations used manufacturers sellers distinguish products claimed trademarks. Where designations appear book, publisher aware trademark claim, designations printed initial capital letters capitals. Java trademark Sun Microsystems, Inc. Windows 95, Windows NT, Windows 2000, Windows XP trademarks Microsoft Corporation. All product names company names mentioned herein property respective owners. The author publisher taken care preparation book, make expressed implied warranty kind assume responsibility errors omissions. No liability assumed incidental consequential damages connection arising use information programs contained herein. The publisher offers excellent discounts book ordered quantity bulk purchases special sales, may include custom covers and/or content particular business, training goals, marketing focus, branding interests. For information, please contact: U.S. Corporate Government Sales (800) 382-3419 corpsales@pearsontechgroup.com For sales outside U.S., please contact: International Sales international@pearsoned.com Visit us Web: www.prenhallprofessional.com Cover design interior design Daniel Will-Harris, www.Will-Harris.com Library Congress Cataloging-in-Publication Data: Eckel, Bruce. Thinking Java / Bruce Eckel.—4th ed. p. cm. Includes bibliographical references index. ISBN 0-13-187248-6 (pbk. : alk. paper) 1. Java (Computer program language) I. Title. QA76.73.J38E25 2006 005.13’3—dc22 2005036339 Copyright © 2006 Bruce Eckel, President, MindView, Inc. All rights reserved. Printed United States America. This publication protected copyright, permission must obtained publisher prior prohibited reproduction, storage retrieval system, transmission form means, electronic, mechanical, photocopying, recording, likewise. For information regarding permissions, write to: Pearson Education, Inc. Rights Contracts Department One Lake Street Upper Saddle River, NJ 07458 Fax: (201) 236-3290 ISBN 0-13-187248-6 Text printed United States recycled paper Courier Stoughton, Massachusetts. First printing, January 2006 Dedication To Dawn Overview Preface Introduction Introduction Objects Everything Is Object Operators Controlling Execution Initialization & Cleanup Access Control Reusing Classes Polymorphism Interfaces Inner Classes Holding Your Objects Error Handling Exceptions Strings Type Information Generics Arrays Containers Depth I/O Enumerated Types Annotations Concurrency Graphical User Interfaces A: Supplements B: Resources Index 1 9 15 41 63 93 107 145 165 193 219 243 275 313 355 393 439 535 567 647 725 761 797 933 1035 1039 1045 What’s Inside Preface 1 Java SE5 SE6 .................. 2 Java SE6 ......................................... 2 The 4th edition........................ 2 Changes .......................................... 3 Note cover design ....... 4 Acknowledgements................ 4 Introduction 9 Prerequisites .......................... 9 Learning Java .......................10 Goals .....................................10 Teaching book ....... 11 JDK HTML documentation...................... 11 Exercises ............................... 12 Foundations Java ............ 12 Source code ........................... 12 Coding standards ......................... 14 Errors .................................... 14 Introduction Objects 15 The progress abstraction ........................ 15 An object interface ........................... 17 An object provides services................... 18 The hidden implementation .................... 19 Reusing implementation ................... 20 Inheritance............................ 21 Is-a vs. is-like-a relationships ......24 Interchangeable objects polymorphism ............. 25 The singly rooted hierarchy .............................. 28 Containers............................ 28 Parameterized types (Generics) ..29 Object creation & lifetime ... 30 Exception handling: dealing errors ............... 31 Concurrent programming ... 32 Java Internet .......... 33 What Web? .........................33 Client-side programming ............ 34 Server-side programming............38 Summary .............................. 38 Everything Is Object 41 You manipulate objects references ..................... 41 You must create objects ....................... 42 Where storage lives...................... 42 Special case: primitive types ....... 43 Arrays Java .............................. 44 You never need destroy object .................. 45 Scoping ........................................ 45 Scope objects ........................... 46 Creating new data types: class..................................... 46 Fields methods ..................... 47 Methods, arguments, return values ................. 48 The argument list......................... 49 Building Java program...... 50 Name visibility .............................50 Using components ............. 50 The static keyword ..................... 51 Your first Java program ....... 52 Compiling running ............... 54 Comments embedded documentation ..................... 55 Comment documentation............ 55 Syntax .......................................... 56 Embedded HTML ........................ 56 Some example tags ...................... 57 Documentation example ............. 59 Coding style .......................... 60 Summary .............................. 60 Exercises .............................. 60 Operators 63 Simpler print statements ..... 63 Using Java operators ........... 64 Precedence ........................... 64 Assignment .......................... 65 Aliasing method calls ....... 66 Mathematical operators....... 67 Unary minus plus operators .......................68 Auto increment decrement ............................ 69 Relational operators ............ 70 What finalize() for? ............. 120 Testing object equivalence...........70 Member initialization .........125 Logical operators .................. 71 Short-circuiting ............................ 72 Literals ..................................73 Exponential notation ................... 74 Bitwise operators .................. 75 Shift operators ......................76 Ternary if-else operator ......79 String operator + += .............................. 80 Common pitfalls using operators ........... 81 Casting operators.................. 81 Truncation rounding ........... 82 Promotion ................................... 83 Java “sizeof” ............. 83 A compendium operators .......................... 84 Summary............................... 91 Controlling Execution 93 true false..................... 93 if-else .................................. 93 Iteration ............................... 94 You must perform cleanup .........121 The termination condition .........121 How garbage collector works.. 122 Specifying initialization ............. 126 Constructor initialization ...127 Order initialization ................ 127 static data initialization ........... 128 Explicit static initialization ...... 130 Non-static instance initialization ................ 132 Array initialization ............. 133 Variable argument lists ............. 137 Enumerated types ............... 141 Summary ............................ 143 Access Control 145 package: library unit ................... 146 Code organization ...................... 147 Creating unique package names ........................... 148 A custom tool library .................. 151 Using imports change behavior..................... 152 Package caveat ........................... 153 Java access specifiers ..........153 Package access ........................... 153 public: interface access ............ 154 do-while ..................................... 95 private: can’t touch that! .. 155 ................................................ 95 protected: inheritance access . 156 The comma operator................... 96 Interface implementation .......... 158 Class access ........................ 159 Summary ............................ 162 Foreach syntax ......................97 return ................................. 99 break continue.......... 99 The infamous “goto” ........... 101 switch ................................104 Summary............................ 106 Initialization & Cleanup 107 Guaranteed initialization constructor ........... 107 Method overloading .......... 109 Reusing Classes 165 Composition syntax ........... 165 Inheritance syntax ............. 168 Initializing base class........... 169 Delegation ........................... 171 Combining composition inheritance ................... 173 Distinguishing Guaranteeing proper cleanup.... 174 overloaded methods .................. 110 Name hiding ...............................177 Overloading primitives ....... 111 Choosing composition vs. inheritance .................... 178 protected ......................... 180 Upcasting ............................ 181 Overloading return values .... 114 Default constructors ........... 114 The keyword ............... 116 Calling constructors constructors ...................... 118 The meaning static ............... 119 Cleanup: finalization garbage collection ........ 119 Why “upcasting”? ...................... 181 Composition vs. inheritance revisited ..................................... 182 The final keyword ............. 182 final data ................................... 183 final methods ............................ 186 final classes ............................... 187 final caution .............................. 188 Initialization class loading ................189 Initialization inheritance ... 189 Summary............................. 191 Polymorphism 193 Upcasting revisited ............. 193 Forgetting object type .......... 194 The twist ............................. 196 Method-call binding .................. 196 Producing right behavior ..... 196 Extensibility ............................... 199 Pitfall: “overriding” private methods ...................... 202 The link outer class .................... 244 Using .this .new ........ 246 Inner classes upcasting ..................... 247 Inner classes methods scopes ........... 249 Anonymous inner classes ........................251 Factory Method revisited .......... 254 Nested classes .................... 256 Classes inside interfaces ............ 257 Reaching outward multiplynested class ............... 259 Why inner classes? ............. 259 Pitfall: fields Closures & callbacks .................. 261 static methods .................. 203 Inner classes & Constructors polymorphism ................... 204 Order constructor calls ......... 204 Inheritance cleanup ........... 206 Behavior polymorphic methods inside constructors .... 210 Covariant return types........ 211 Designing inheritance .................. 212 Substitution vs. extension ......... 213 Downcasting runtime type information ......... 215 Summary............................. 217 Interfaces 219 Abstract classes methods ....................... 219 Interfaces ........................... 222 Complete decoupling ......... 225 “Multiple inheritance” Java ................................ 230 Extending interface inheritance .......................... 231 Name collisions combining Interfaces ................233 Adapting interface .... 234 Fields interfaces ............ 235 Initializing fields interfaces .. 236 Nesting interfaces .............. 237 Interfaces factories ..... 239 Summary............................. 241 Inner Classes 243 Creating inner classes ........ 243 control frameworks ................... 263 Inheriting inner classes ....................... 269 Can inner classes overridden? ................... 269 Local inner classes ..............271 Inner-class identifiers ........ 272 Summary ............................ 273 Holding Your Objects 275 Generics type-safe containers ........... 276 Basic concepts .................... 278 Adding groups elements ......................... 279 Printing containers ............ 281 List ..................................... 283 Iterator ............................. 286 ListIterator ............................ 288 LinkedList ....................... 289 Stack ................................. 291 Set ...................................... 292 Map ................................... 295 Queue................................ 298 PriorityQueue ........................299 Collection vs. Iterator ... 301 Foreach iterators......... 304 The Adapter Method idiom ...... 306 Summary ............................308 Error Handling Exceptions 313 Concepts ............................. 313 Basic exceptions.................. 314 split() ........................................382 Exception arguments ................. 315 Replace operations ....................383 Catching exception ........ 315 reset() .......................................384 The try block ............................. 316 Exception handlers .................... 316 Creating exceptions ................... 317 Exceptions logging .............. 319 The exception specification ....................... 322 Catching exception ..... 323 The stack trace .......................... 324 Rethrowing exception ........... 325 Exception chaining .................... 327 Standard Java exceptions .......................... 330 Special case: RuntimeException ............... 330 Performing cleanup finally ....................... 332 What’s finally for? ....................333 Using finally return .... 335 Pitfall: lost exception .......... 336 Exception restrictions ....... 338 Constructors ...................... 340 Exception matching ........... 344 Alternative approaches...... 345 History ...................................... 346 Perspectives ............................... 347 Passing exceptions Java I/O .............................. 385 Scanning input ................... 386 Scanner delimiters ................. 388 Scanning regular expressions ................... 389 StringTokenizer ............. 389 Summary ............................ 391 Type Information 393 The need RTTI.............. 393 The Class object ................ 395 Class literals ...............................399 Generic class references ............ 401 New cast syntax ........................ 403 Checking cast ....... 404 Using class literals .................... 409 A dynamic instanceof ..............411 Counting recursively .................. 412 Registered factories ........... 413 instanceof vs. Class equivalence......................... 416 Reflection: runtime class information ................417 A class method extractor ........... 418 Dynamic proxies ................ 420 Null Objects........................ 424 Mock Objects & Stubs ................429 console ............................ 349 Converting checked unchecked exceptions ........... 350 Exception guidelines ......... 352 Summary............................ 352 Strings Regular expressions 355 Immutable Strings ............355 Overloading ‘+’ vs. StringBuilder ................. 356 Unintended recursion ....... 359 Operations Strings ....... 361 Formatting output ............. 362 Interfaces type information ................ 430 Summary ............................ 436 Generics 439 Comparison C++........ 440 Simple generics .................. 440 A tuple library ............................442 A stack class ...............................444 RandomList ............................ 445 Generic interfaces .............. 446 Generic methods ................ 449 Leveraging type printf() .................................... 363 argument inference ...................450 System.out.format() ............ 363 Varargs generic methods .... 452 The Formatter class ............... 363 A generic method Format specifiers ...................... 364 use Generators............ 453 Formatter conversions........... 366 A general-purpose Generator . 453 String.format() ..................... 368 Simplifying tuple use ................. 455 Regular expressions........... 370 Basics .........................................370 Creating regular expressions ..... 372 Quantifiers ................................. 374 Pattern Matcher ............. 375 A Set utility................................ 456 Anonymous inner classes ....................... 459 Building complex models ................. 460 The mystery erasure ...... 462 The C++ approach .................... 464 Migration compatibility ............ 466 The problem erasure .........467 The action boundaries .... 468 Compensating erasure ........................... 471 Creating instances types ........ 472 Arrays generics ...................... 475 Arrays first-class objects ............... 536 Returning array ............. 539 Multidimensional arrays .................................. 540 Arrays generics ........... 543 Creating test data ............... 546 Arrays.fill() ............................. 546 Data Generators...................... 547 Creating arrays Generators ..................... 551 Bounds ............................... 479 Wildcards ........................... 482 Arrays utilities .................. 555 How smart compiler? ...... 484 Comparing arrays ...................... 556 Contravariance .......................... 485 Array element comparisons ...... 557 Unbounded wildcards............... 488 Sorting array .........................560 Capture conversion ................... 492 Searching sorted array ............ 561 Issues ................................. 493 Summary ............................ 564 No primitives type parameters .................... 493 Implementing parameterized interfaces ...........495 Casting warnings ............... 496 Overloading............................... 498 Base class hijacks interface .. 498 Self-bounded types ............ 500 Curiously recurring generics .... 500 Self-bounding ............................ 501 Argument covariance ................ 503 Dynamic type safety .......... 506 Exceptions ......................... 507 Mixins ................................ 509 Mixins C++ ........................... 509 Mixing interfaces ............... 510 Using Decorator pattern .......511 Mixins dynamic proxies .... 512 Copying array........................ 555 Containers Depth 567 Full container taxonomy.... 567 Filling containers ............... 568 A Generator solution .............. 569 Map generators ......................... 570 Using Abstract classes ............. 573 Collection functionality ....................... 580 Optional operations ........... 582 Unsupported operations............ 583 List functionality ............... 586 Sets storage order ...... 589 SortedSet ................................. 591 Queues ................................ 594 Priority queues........................... 594 Deques ....................................... 595 Latent typing....................... 514 Compensating lack latent typing ...... 518 Understanding Maps ........ 598 Reflection ................................... 518 Hashing hash codes .... 605 Applying method sequence .............................. 519 When don’t happen right interface .......... 521 Simulating latent typing adapters ............................. 523 Using function objects strategies ....................... 526 Summary: Is casting really bad? ...................... 531 Arrays Performance .............................. 599 SortedMap ............................. 602 LinkedHashMap ................... 603 Understanding hashCodeQ .... 607 Hashing speed ...................... 610 Overriding hashCode() ........... 613 Choosing implementation..............617 A performance test framework ........................... 618 Choosing Lists ............ 621 Microbenchmarking dangers ....626 Choosing Sets ............. 627 Further reading .......................... 533 Choosing Maps ...........629 535 Utilities ............................... 632 Why arrays special........535 Sorting searching Lists ...... 635 Making Collection Fetching primitives ................... 684 Map unmodifiable ............... 636 View buffers ...............................685 Synchronizing Data manipulation Collection Map ................... 637 buffers ............................... 688 Holding references ............ 639 Buffer details............................. 689 The WeakHashMap .............. 640 Memory-mapped files ...............692 Java 1.0/1.1 containers ...... 642 File locking................................. 695 Vector & Enumeration ........ 642 Compression ...................... 698 Hashtable ............................... 643 Simple compression Stack ........................................ 643 GZIP .................................. 698 BitSet ....................................... 644 Multifile storage Zip ..........699 Summary............................ 646 Java ARchives (JARs) ................ 701 I/O 647 The File class .................... 647 Object serialization ............ 703 Finding class ........................ 706 Controlling serialization ............ 707 A directory lister ........................647 Using persistence....................... 713 Directory utilities ...................... 650 XML.................................... 718 Preferences ..........................721 Summary ............................ 722 Checking creating directories .............654 Input output ............... 656 Types InputStream............. 657 Types OutputStream ......... 658 Adding attributes useful interfaces.......... 659 Reading InputStream FilterlnputStream ........ 660 Writing OutputStream FilterOutputStream ...... 661 Readers & Writers ......... 662 Sources sinks data ......... 662 Modifying stream behavior ...... 663 Unchanged classes .................... 664 Off itself: RandomAccessFile ....... 665 Typical uses I/O streams.................... 665 Buffered input file ......................665 Input memory .................. 666 Formatted memory input ..........667 Basic file output ........................ 668 Storing recovering data ..... 669 Reading writing random-access files .................. 670 Piped streams ............................ 672 File reading & writing utilities ............... 672 Enumerated Types 725 Basic enum features ......... 725 Using static imports enums ............................... 726 Adding methods enum ........................ 727 Overriding enum methods ....... 728 enums switch statements............. 728 The mystery values() ........................ 729 Implements, inherits ......................... 732 Random selection .............. 732 Using interfaces organization.................. 734 Using EnumSet instead flags ................... 737 Using EnumMap ............. 739 Constant-specific methods .............................. 740 Chain Responsibility enums ............................... 743 State machines enums ..... 746 Reading binary files ................... 674 Multiple dispatching ........... 751 Standard I/O.......................675 Dispatching enums .......... 753 Reading standard input .... 675 Using Changing System.out constant-specific methods ......... 755 PrintWriter ...................... 676 Dispatching Redirecting standard I/O .......... 676 EnumMaps ...................... 756 Process control ................... 677 New I/O ............................. 679 Using 2-D array....................... 757 Converting data.......................... 681 Summary ............................ 759 Annotations 761 Synchronizing objects .............................. 841 Basic syntax ....................... 762 Thread local storage ..................843 Defining annotations ................. 762 Terminating tasks .............. 844 Meta-annotations ...................... 763 Writing annotation processors ........765 The ornamental garden ............ 844 Terminating blocked ........ 847 Interruption .............................. 848 Annotation elements ................. 765 Checking interrupt ..........854 Default value constraints ...........766 Cooperation tasks ..................... 856 Generating external files............ 766 Annotations don’t support inheritance ................... 769 Implementing processor......769 Using apt process annotations ............ 772 Using Visitor pattern apt .............................. 775 Annotation-based unit testing ..........................778 Using @Unit generics....... 785 No “suites” necessary .................786 Implementing @Unit ............... 787 Removing test code .................... 792 Summary.............................795 Concurrency 797 The many faces concurrency ....................... 798 Faster execution .........................798 Improving code design ............. 800 Basic threading .................. 801 Defining tasks ............................801 The Thread class ..................... 802 Using Executors ..................... 804 Producing return values tasks ................................. 806 Sleeping ..................................... 808 Priority ...................................... 809 wait() notifyAll() ............ 857 notify() vs. notifyAll() ........... 861 Producers consumers ........ 863 Producer-consumers queues ................................ 868 Using pipes I/O tasks ............................. 872 Deadlock............................. 874 New library components ........................ 879 CountDownLatch .................. 879 CyclicBarrier .......................... 881 DelayQueue ........................... 883 PriorityBlockingQueue....... 885 The greenhouse controller ScheduledExecutor ......887 Semaphore ............................. 890 Exchanger .............................. 893 Simulation .......................... 896 Bank teller simulation .............. 896 The restaurant simulation ........ 900 Distributing work ..................... 904 Performance tuning ........... 909 Comparing mutex technologies ................... 909 Lock-free containers .................. 916 Optimistic locking...................... 922 ReadWriteLocks .................... 923 Daemon threads.........................810 Active objects ..................... 925 Summary ............................ 929 Coding variations ....................... 814 Further reading.......................... 931 Yielding ......................................810 Terminology ............................... 819 Joining thread ......................... 819 Creating responsive user interfaces ............................ 821 Thread groups ........................... 822 Catching exceptions .................. 822 Sharing resources .............. 824 Graphical User Interfaces 933 Applets ............................... 935 Swing basics ....................... 935 A display framework .................. 937 resource contention ...................827 Making button ................. 938 Capturing event............. 939 Text areas ........................... 941 Controlling layout .............. 942 Atomicity volatility ............. 831 BorderLayout .........................942 Atomic classes ........................... 836 FlowLayout ............................. 943 Critical sections ..........................837 GridLayout ..............................944 Improperly accessing resources ................... 825 Resolving shared GridBagLayout.......................944 Absolute positioning ..................945 Connecting Java .................. 1016 BoxLayout ...............................945 Data models The best approach? ....................945 data binding ...................... 1018 The Swing event model ..... 945 Building deploying............ 1019 Event listener types ........... 946 Creating SWT applications ...................... 1020 Tracking multiple events ........... 951 A selection Swing components ............ 953 Installing SWT ......................... 1020 Buttons .......................................953 Eliminating redundant code.... 1023 Icons.......................................... 955 Menus ...................................... 1024 Tool tips ..................................... 957 Tabbed panes, buttons, Text fields ................................... 957 events ................................ 1025 Borders .......................................959 Graphics ................................... 1028 A mini-editor..............................959 Concurrency SWT................ 1030 Hello, SWT ............................... 1021 Check boxes .............................. 960 SWT vs. Swing?........................ 1032 Radio buttons............................. 961 Summary .......................... 1033 Combo boxes (drop-down lists) ...................... 962 List boxes .................................. 963 Resources ................................. 1033 A: Supplements Downloadable supplements ..................... 1035 Thinking C: Foundations Java ....... 1035 Thinking Java seminar............................. 1035 Hands-On Java seminar-on-CD ................ 1036 Thinking Objects seminar............................. 1036 Thinking Enterprise Java ................ 1036 Thinking Patterns (with Java) ....................... 1037 Thinking Patterns seminar............................. 1037 Design consulting reviews ...................... 1038 Tabbed panes .............................965 Message boxes ...........................965 Menus......................................... 967 Pop-up menus ............................ 972 Drawing ...................................... 973 Dialog boxes ............................... 975 File dialogs .................................978 HTML Swing components .................... 980 Sliders progress bars ......... 980 Selecting look & feel ................... 981 Trees, tables & clipboard .......... 983 JNLP Java Web Start ................... 983 Concurrency & Swing ........ 988 Long-running tasks................... 988 Visual threading ........................ 994 Visual programming JavaBeans ................... 996 What JavaBean? ................. 996 Extracting Beanlnfo Introspector ............ 998 1035 B: Resources A sophisticated Bean ..... 1002 1039 Packaging Bean .................... 1008 Software ........................... 1039 Editors & IDEs ................. 1039 Books ................................ 1039 More complex Bean support .. 1009 Analysis & design ..................... 1040 More Beans .......................... 1010 Python ...................................... 1042 Alternatives Swing........ 1010 Building Flash Web clients Flex ................ 1011 My list books ................ 1042 JavaBeans synchronization .......................1005 Hello, Flex ................................. 1011 Compiling MXML .................... 1012 MXML ActionScript.......... 1013 Containers controls........... 1013 Effects styles ..................... 1015 Events....................................... 1016 Index 1045 Preface I originally approached Java “just another programming language,” many senses is. But time passed I studied deeply, I began see fundamental intent language different languages I seen point. Programming managing complexity: complexity problem want solve, laid upon complexity machine solved. Because complexity, programming projects fail. And yet, programming languages I aware, almost none gone decided main design goal would conquer complexity developing maintaining programs. 1 Of course, many language design decisions made complexity mind, point always issues considered essential added mix. Inevitably, issues cause programmers eventually “hit wall” language. For example, C++ backwards-compatible C (to allow easy migration C programmers), well efficient. Those useful goals account much success C++, also expose extra complexity prevents projects finished (certainly, blame programmers management, language help catching mistakes, shouldn’t it?). As another example, Visual BASIC (VB) tied BASIC, wasn’t really designed extensible language, extensions piled upon VB produced truly unmaintainable syntax. Perl backwards-compatible awk, sed, grep, Unix tools meant replace, result often accused producing “write-only code” (that is, can’t read it). On hand, C++, VB, Perl, languages like Smalltalk design efforts focused issue complexity result remarkably successful solving certain types problems. What impressed I come understand Java somewhere mix Sun’s design objectives, seems goal reducing complexity programmer. As say, “We care reducing time difficulty producing robust code.” In early days, goal resulted code didn’t run fast (although improved time), indeed produced amazing reductions development time—half less time takes create equivalent C++ program. This result alone save incredible amounts time money, Java doesn’t stop there. It goes wrap many complex tasks become important, multithreading network programming, language features libraries times make tasks easy. And finally, tackles really big complexity problems: cross-platform programs, dynamic code changes, even security, fit complexity spectrum anywhere “impediment” “show-stopper.” So despite performance problems we’ve seen, promise Java tremendous: It make us significantly productive programmers. In ways—creating programs, working teams, building user interfaces communicate user, running programs different types machines, easily writing programs communicate across Internet—Java increases communication bandwidth people. I think results communication revolution may seen effects moving large quantities bits around. We shall see true revolution communicate easily: one-on-one, also groups planet. 1 However, I believe Python language comes closest exactly that. See www.Python.org. I’ve heard suggested next revolution formation kind global mind results enough people enough interconnectedness. Java may may tool foments revolution, least possibility made feel like I’m something meaningful attempting teach language. Java SE5 SE6 This edition book benefits greatly improvements made Java language Sun originally called JDK 1.5, later changed JDK5 J2SE5, finally dropped outdated “2” changed Java SE5. Many Java SE5 language changes designed improve experience programmer. As shall see, Java language designers completely succeed task, general made large steps right direction. One important goals edition completely absorb improvements Java SE5/6, introduce use throughout book. This means edition takes somewhat bold step “Java SE5/6-only,” much code book compile earlier versions Java; build system complain stop try. However, I think benefits worth risk. If somehow fettered earlier versions Java, I covered bases providing free downloads previous editions book via www.MindView.net. For various reasons, I decided provide current edition book free electronic form, prior editions. Java SE6 This book monumental, time-consuming project, published, Java SE6 (code-named mustang) appeared beta form. Although minor changes Java SE6 improved examples book, part focus Java SE6 affect content book; features primarily speed improvements library features outside purview text. The code book successfully tested release candidate Java SE6, I expect changes affect content book. If important changes time Java SE6 officially released, reflected book’s source code, downloadable www.MindView.net. The cover indicates book “Java SE5/6,” means “written Java SE5 significant changes version introduced language, equally applicable Java SE6.” The 4th edition The satisfaction new edition book getting things “right,” according I learned since last edition came out. Often insights nature saying “A learning experience get don’t get want,” opportunity fix something embarrassing simply tedious. Just often, creating next edition produces fascinating new ideas, embarrassment far outweighed delight discovery ability express ideas better form I previously achieved. There also challenge whispers back brain, making book something owners previous editions want buy. This presses improve, 2 Thinking Java Bruce Eckel rewrite reorganize everything I can, make book new valuable experience dedicated readers. Changes The CD-ROM traditionally packaged part book part edition. The essential part CD, Thinking C multimedia seminar (created MindView Chuck Allison), available downloadable Flash presentation. The goal seminar prepare familiar enough C syntax understand material presented book. Although two chapters book give decent introductory syntax coverage, may enough people without adequate background, Thinking C intended help people get necessary level. The Concurrency chapter (formerly called “Multithreading”) completely rewritten match major changes Java SE5 concurrency libraries, still gives basic foundation core ideas concurrency. Without core, it’s hard understand complex issues threading. I spent many months working this, immersed netherworld called “concurrency,” end chapter something provides basic foundation also ventures advanced territory. There new chapter every significant new Java SE5 language feature, new features woven modifications made existing material. Because continuing study design patterns, patterns introduced throughout book well. The book undergone significant reorganization. Much come teaching process together realization that, perhaps, perception “chapter” could stand rethought. I tended towards unconsidered belief topic “big enough” justify chapter. But especially teaching design patterns, I find seminar attendees best I introduce single pattern immediately exercise, even means I speak brief time (I discovered pace also enjoyable teacher). So version book I’ve tried break chapters topic, worry resulting length chapters. I think improvement. I also come realize importance code testing. Without built-in test framework tests run every time build system, way knowing code reliable not. To accomplish book, I created test framework display validate output program. (The framework written Python; find downloadable code book www.MindView.net.) Testing general covered supplement find http://MindView.net/Books/BetterJava, introduces I believe fundamental skills programmers basic toolkit. In addition, I’ve gone every single example book asked myself, “Why I way?” In cases I done modification improvement, make examples consistent within also demonstrate I consider best practices Java coding (at least, within limitations introductory text). Many existing examples significant redesign reimplementation. Examples longer made sense removed, new examples added. Readers made many, many wonderful comments first three editions book, naturally pleasant me. However, every then, someone complaints, reason one complaint comes periodically “The book big.” In mind faint damnation indeed “too many pages” Preface 3 gripe. (One reminded Emperor Austria’s complaint Mozart’s work: “Too many notes!” Not I way trying compare Mozart.) In addition, I assume complaint comes someone yet acquainted vastness Java language seen rest books subject. Despite this, one things I attempted edition trim portions become obsolete, least nonessential. In general, I’ve tried go everything, remove longer necessary, include changes, improve everything I could. I feel comfortable removing portions original material remains Web site (www.MindView.net), form freely downloadable 1st 3rd editions book, downloadable supplements book. For still can’t stand size book, I apologize. Believe not, I worked hard keep size down. Note cover design The cover Thinking Java inspired American Arts & Crafts Movement began near turn century reached zenith 1900 1920. It began England reaction machine production Industrial Revolution highly ornamental style Victorian era. Arts & Crafts emphasized spare design, forms nature seen art nouveau movement, hand-crafting, importance individual craftsperson, yet eschew use modern tools. There many echoes situation today: turn century, evolution raw beginnings computer revolution something refined meaningful, emphasis software craftsmanship rather manufacturing code. I see Java way: attempt elevate programmer away operating system mechanic toward “software craftsman.” Both author book/cover designer (who friends since childhood) find inspiration movement, furniture, lamps, pieces either original inspired period. The theme cover suggests collection box naturalist might use display insect specimens preserved. These insects objects placed within box objects. The box objects placed within “cover object,” illustrates fundamental concept aggregation object-oriented programming. Of course, programmer cannot help make association “bugs,” bugs captured presumably killed specimen jar, finally confined within small display box, imply Java’s ability find, display, subdue bugs (which truly one powerful attributes). In edition, I created watercolor painting see cover background. Acknowledgements First, thanks associates worked give seminars, provide consulting, develop teaching projects: Dave Bartlett, Bill Venners, Chuck Allison, Jeremy Meyer, Jamie King. I appreciate patience I continue try develop best model independent folks like us work together. Recently, doubt Internet, I become associated surprisingly large number people assist endeavors, usually working home offices. In past, I would pay pretty big office space accommodate folks, Net, FedEx, telephone, I’m able benefit help without extra costs. In attempts learn “play well 4 Thinking Java Bruce Eckel others,” helpful, I hope continue learning make work better efforts others. Paula Steuer invaluable taking haphazard business practices making sane (thanks prodding I don’t want something, Paula). Jonathan Wilcox, Esq., sifted corporate structure turned every possible rock might hide scorpions, frog-marched us process putting everything straight, legally. Thanks care persistence. Sharlynn Cobaugh made expert sound processing essential part creating multimedia training experiences, well tackling problems. Thanks perseverance faced intractable computer problems. The folks Amaio Prague helped several projects. Daniel Will-Harris original work-by-Internet inspiration, course fundamental graphic design solutions. Over years, conferences workshops, Gerald Weinberg become unofficial coach mentor, I thank him. Ervin Varga exceptionally helpful technical corrections 4th edition—although people helped various chapters examples, Ervin primary technical reviewer book, also took task rewriting solution guide 4th edition. Ervin found errors made improvements book invaluable additions text. His thoroughness attention detail amazing, he’s far away best technical reader I’ve ever had. Thanks, Ervin. My weblog Bill Venners’ www.Artima.com source assistance I’ve needed bounce ideas around. Thanks readers helped clarify concepts submitting comments, including James Watson, Howard Lovatt, Michael Barker, others, particular helped generics. Thanks Mark Welsh continuing assistance. Evan Cofsky continues supportive knowing top head arcane details setting maintaining Linux-based Web servers, keeping MindView server tuned secure. A special thanks new friend, coffee, generated nearly boundless enthusiasm project. Camp4 Coffee Crested Butte, Colorado, become standard hangout people come take MindView seminars, seminar breaks best catering I’ve ever had. Thanks buddy Al Smith creating making great place, interesting entertaining part Crested Butte experience. And Camp4 barristas cheerfully dole beverages. Thanks folks Prentice Hall continuing give I want, putting special requirements, going way make things run smoothly me. Certain tools proved invaluable development process I grateful creators every time I use these. Cygwin (www.cygwin.com) solved innumerable problems Windows can’t/won’t I become attached day (if I 15 years ago brain still hard-wired Gnu Emacs). IBM’s Eclipse (www.eclipse.org) truly wonderful contribution development community, I expect see great things continues evolve (how IBM become hip? I must missed memo). JetBrains IntelliJ Idea continues forge creative new paths development tools. I began using Enterprise Architect Sparxsystems book, rapidly become UML tool choice. Marco Hunsicker’s Jalopy code formatter (www.triemax.com) came handy numerous occasions, Marco helpful Preface 5 configuring particular needs. I’ve also found Slava Pestov’s JEdit plug-ins helpful times (www.jedit.org) it’s quite reasonable beginner’s editor seminars. And course, I don’t say enough everywhere else, I use Python (www.Python.org) constantly solve problems, brainchild buddy Guido Van Rossum gang goofy geniuses I spent great days sprinting (Tim Peters, I’ve framed mouse borrowed, officially named “TimBotMouse”). You guys need find healthier places eat lunch. (Also, thanks entire Python community, amazing bunch people.) Lots people sent corrections I indebted all, particular thanks go (for 1st edition): Kevin Raulerson (found tons great bugs), Bob Resendes (simply incredible), John Pinto, Joe Dante, Joe Sharp (all three fabulous), David Combs (many grammar clarification corrections), Dr. Robert Stephenson, John Cook, Franklin Chen, Zev Griner, David Karr, Leander A. Stroschein, Steve Clark, Charles A. Lee, Austin Maher, Dennis P. Roth, Roque Oliveira, Douglas Dunn, Dejan Ristic, Neil Galarneau, David B. Malkovsky, Steve Wilkinson, host others. Prof. Ir. Marc Meurrens put great deal effort publicize make electronic version 1st edition book available Europe. Thanks helped rewrite examples use Swing library (for 2nd edition), assistance: Jon Shvarts, Thomas Kirsch, Rahim Adatia, Rajesh Jain, Ravi Manthena, Banu Rajamani, Jens Brandt, Nitin Shivaram, Malcolm Davis, everyone expressed support. In 4th edition, Chris Grindstaff helpful development SWT section, Sean Neville wrote first draft Flex section me. Kraig Brockschmidt Gen Kiyooka smart technical people life become friends also influential unusual yoga practice forms spiritual enhancement, I find quite inspirational instructional. It’s much surprise understanding Delphi helped understand Java, since many concepts language design decisions common. My Delphi friends provided assistance helping gain insight marvelous programming environment. They Marco Cantu (another Italian—perhaps steeped Latin gives one aptitude programming languages?), Neil Rubenking (who used yoga/vegetarian/Zen thing discovered computers), course Zack Urlocker (the original Delphi product manager), long-time pal I’ve traveled world with. We’re indebted brilliance Anders Hejlsberg, continues toil away C# (which, you’ll learn book, major inspiration Java SE5). My friend Richard Hale Shaw’s insights support helpful (and Kim’s, too). Richard I spent many months giving seminars together trying work perfect learning experience attendees. The book design, cover design, cover photo created friend Daniel WillHarris, noted author designer (www.Will-Harris.com), used play rub-on letters junior high school awaited invention computers desktop publishing, complained mumbling algebra problems. However, I produced cameraready pages myself, typesetting errors mine. Microsoft® Word XP Windows used write book create camera-ready pages Adobe Acrobat; book created directly Acrobat PDF files. As tribute electronic age, I happened overseas I produced final versions 1st 2nd editions book—the 1st edition sent Cape Town, South Africa, 2nd edition posted Prague. 6 Thinking Java Bruce Eckel The 3rd 4th came Crested Butte, Colorado. The body typeface Georgia headlines Verdana. The cover typeface ITC Rennie Mackintosh. A special thanks teachers students (who teachers well). Molly cat often sat lap I worked edition, thus offered kind warm, furry support. The supporting cast friends includes, limited to: Patty Gast (Masseuse extraordinaire), Andrew Binstock, Steve Sinofsky, JD Hildebrandt, Tom Keffer, Brian McElhinney, Brinkley Barr, Bill Gates Midnight Engineering Magazine, Larry Constantine Lucy Lockwood, Gene Wang, Dave Mayer, David Intersimone, Chris Laura Strand, Almquists, Brad Jerbic, Marilyn Cvitanic, Mark Mabry, Robbins families, Moelter families (and McMillans), Michael Wilk, Dave Stoner, Cranstons, Larry Fogg, Mike Sequeira, Gary Entsminger, Kevin Sonda Donovan, Joe Lordi, Dave Brenda Bartlett, Patti Gast, Blake, Annette & Jade, Rentschlers, Sudeks, Dick, Patty, Lee Eckel, Lynn Todd, families. And course, Mom Dad. Preface 7 Introduction “He gave man speech, speech created thought, Which measure Universe”—Prometheus Unbound, Shelley Human beings ... much mercy particular language become medium expression society. It quite illusion imagine one adjusts reality essentially without use language language merely incidental means solving specific problems communication reflection. The fact matter “real world” large extent unconsciously built language habits group. The Status Linguistics Science, 1929, Edward Sapir Like human language, Java provides way express concepts. If successful, medium expression significantly easier flexible alternatives problems grow larger complex. You can’t look Java collection features—some features make sense isolation. You use sum parts thinking design, simply coding. And understand Java way, must understand problems language programming general. This book discusses programming problems, problems, approach Java taken solve them. Thus, set features I explain chapter based way I see particular type problem solved language. In way I hope move you, little time, point Java mindset becomes native tongue. Throughout, I’ll taking attitude want build model head allows develop deep understanding language; encounter puzzle, you’ll feed model deduce answer. Prerequisites This book assumes programming familiarity: You understand program collection statements, idea subroutine/function/macro, control statements “if” looping constructs “while,” etc. However, might learned many places, programming macro language working tool like Perl. As long you’ve programmed point feel comfortable basic ideas programming, you’ll able work book. Of course, book easier C programmers C++ programmers, don’t count you’re experienced languages—however, come willing work hard. Also, Thinking C multimedia seminar download www.MindView.net bring speed fundamentals necessary learn Java. However, I introducing concepts object-oriented programming (OOP) Java’s basic control mechanisms. Although references may made C C++ language features, intended insider comments, instead help programmers put Java perspective languages, which, all, Java descended. I attempt make references simple explain anything I think non-C/C++ programmer would familiar with. Learning Java At time first book, Using C++ (Osborne/McGraw-Hill, 1989), came out, I began teaching language. Teaching programming ideas become profession; I’ve seen nodding heads, blank faces, puzzled expressions audiences world since 1987. As I began giving in-house training smaller groups people, I discovered something exercises. Even people smiling nodding confused many issues. I found out, creating chairing C++ track Software Development Conference number years (and later creating chairing Java track), I speakers tended give typical audience many topics quickly. So eventually, variety audience level way I presented material, I would end losing portion audience. Maybe it’s asking much, I one people resistant traditional lecturing (and people, I believe, resistance results boredom), I wanted try keep everyone speed. For time, I creating number different presentations fairly short order. Thus, I ended learning experiment iteration (a technique also works well program design). Eventually, I developed course using everything I learned teaching experience. My company, MindView, Inc., gives public in-house Thinking Java seminar; main introductory seminar provides foundation advanced seminars. You find details www.MindView.net. (The introductory seminar also available Hands-On Java CD ROM. Information available Web site.) The feedback I get seminar helps change refocus material I think works well teaching medium. But book isn’t seminar notes; I tried pack much information I could within pages, structured draw next subject. More anything, book designed serve solitary reader struggling new programming language. Goals Like previous book, Thinking C++, book designed one thing mind: way people learn language. When I think chapter book, I think terms makes good lesson seminar. Seminar audience feedback helped understand difficult parts needed illumination. In areas I got ambitious included many features once, I came know—through process presenting material— include lot new features, need explain all, easily compounds student’s confusion. Each chapter tries teach single feature, small group associated features, without relying concepts haven’t introduced yet. That way digest piece context current knowledge moving on. My goals book to: 1. Present material one simple step time easily digest idea moving on. Carefully sequence presentation features you’re exposed topic see use. Of course, isn’t always possible; situations, brief introductory description given. 2. Use examples simple short possible. This sometimes prevents tackling “real world” problems, I’ve found beginners usually happier understand every detail example rather impressed 10 Thinking Java Bruce Eckel scope problem solves. Also, there’s severe limit amount code absorbed classroom situation. For I doubt receive criticism using “toy examples,” I’m willing accept favor producing something pedagogically useful. 3. Give I think important understand language, rather everything I know. I believe information importance hierarchy, facts 95 percent programmers never need know—details confuse people increase perception complexity language. To take example C, memorize operator precedence table (I never did), write clever code. But need think it, also confuse reader/maintainer code. So forget precedence, use parentheses things aren’t clear. 4. Keep section focused enough lecture time—and time exercise periods—is small. Not keep audience’s minds active involved hands-on seminar, gives reader greater sense accomplishment. 5. Provide solid foundation understand issues well enough move difficult coursework books. Teaching book The original edition book evolved one-week seminar was, Java infancy, enough time cover language. As Java grew continued encompass features libraries, I stubbornly tried teach one week. At one point, customer asked teach “just fundamentals,” I discovered trying cram everything single week become painful seminarians. Java longer “simple” language could taught week. That experience realization drove much reorganization book, designed support two-week seminar two-term college course. The introductory portion ends Error Handling Exceptions chapter, may also want supplement introduction JDBC, Servlets JSPs. This provides foundation course, core Hands-On Java CD ROM. The remainder book comprises intermediatelevel course, material covered Intermediate Thinking Java CD ROM. Both CD ROMs sale www.MindView.net. Contact Prentice-Hall www.prenhallprofessional.com information professor support materials book. JDK HTML documentation The Java language libraries Sun Microsystems (a free download http://java.sun.com) come documentation electronic form, readable using Web browser. Many books published Java duplicated documentation. So either already download it, unless necessary, book repeat documentation, it’s usually much faster find class descriptions Web browser look book (and online documentation probably upto-date). You’ll simply referred “the JDK documentation.” This book provide extra descriptions classes it’s necessary supplement documentation understand particular example. Introduction 11 Exercises I’ve discovered simple exercises exceptionally useful complete student’s understanding seminar, you’ll find set end chapter. Most exercises designed easy enough finished reasonable amount time classroom situation instructor observes, making sure students absorbing material. Some challenging, none present major challenges. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Foundations Java Another bonus edition free multimedia seminar download www.MindView.net. This Thinking C seminar gives introduction C syntax, operators, functions Java syntax based upon. In previous editions book Foundations Java CD packaged book, seminar may freely downloaded. I originally commissioned Chuck Allison create Thinking C standalone product, decided include 2nd edition Thinking C++ 2nd 3rd editions Thinking Java consistent experience people come seminars without adequate background basic C syntax. The thinking apparently goes “I’m smart programmer I don’t want learn C, rather C++ Java, I’ll skip C go directly C++/Java.” After arriving seminar, slowly dawns folks prerequisite understanding C syntax good reason. Technologies changed, made sense rework Thinking C downloadable Flash presentation rather including CD. By providing seminar online, I ensure everyone begin adequate preparation. The Thinking C seminar also allows book appeal wider audience. Even though Operators Controlling Execution chapters cover fundamental parts Java come C, online seminar gentler introduction, assumes even less student’s programming background book. Source code All source code book available copyrighted freeware, distributed single package, visiting Web site www.MindView.net. To make sure get current version, official code distribution site. You may distribute code classroom educational situations. The primary goal copyright ensure source code properly cited, prevent republishing code print media without permission. (As long source cited, using examples book media generally problem.) In source-code file find reference following copyright notice: //:! Copyright.txt This computer source code Copyright ©2006 MindView, Inc. All Rights Reserved. 12 Thinking Java Bruce Eckel Permission use, copy, modify, distribute computer source code (Source Code) documentation without fee without written agreement purposes set forth hereby granted, provided copyright notice, paragraph following five numbered paragraphs appear copies. 1. Permission granted compile Source Code include compiled code, executable format only, personal commercial software programs. 2. Permission granted use Source Code without modification classroom situations, including presentation materials, provided book "Thinking Java" cited origin. 3. Permission incorporate Source Code printed media may obtained contacting: MindView, Inc. 5343 Valle Vista La Mesa, California 91941 Wayne@MindView.net 4. The Source Code documentation copyrighted MindView, Inc. The Source code provided without express implied warranty kind, including implied warranty merchantability, fitness particular purpose non-infringement. MindView, Inc. warrant operation program includes Source Code uninterrupted error-free. MindView, Inc. makes representation suitability Source Code software includes Source Code purpose. The entire risk quality performance program includes Source Code user Source Code. The user understands Source Code developed research instructional purposes advised rely exclusively reason Source Code program includes Source Code. Should Source Code resulting software prove defective, user assumes cost necessary servicing, repair, correction. 5. IN NO EVENT SHALL MINDVIEW, INC., OR ITS PUBLISHER BE LIABLE TO ANY PARTY UNDER ANY LEGAL THEORY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS, OR FOR PERSONAL INJURIES, ARISING OUT OF THE USE OF THIS SOURCE CODE AND ITS DOCUMENTATION, OR ARISING OUT OF THE INABILITY TO USE ANY RESULTING PROGRAM, EVEN IF MINDVIEW, INC., OR ITS PUBLISHER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. MINDVIEW, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOURCE CODE AND DOCUMENTATION PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, WITHOUT ANY ACCOMPANYING SERVICES FROM MINDVIEW, INC., AND MINDVIEW, INC. HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. Please note MindView, Inc. maintains Web site sole distribution point electronic copies Source Code, http://www.MindView.net (and official mirror sites), freely available terms stated above. If think you’ve found error Source Code, please submit correction using feedback system find http://www.MindView.net. ///:~ You may use code projects classroom (including presentation materials) long copyright notice appears source file retained. Introduction 13 Coding standards In text book, identifiers (methods, variables, class names) set bold. Most keywords also set bold, except keywords used much bolding become tedious, “class.” I use particular coding style examples book. As much possible, follows style Sun uses virtually code find site (see http://java.sun.com/docs/codeconv/index.html), seems supported Java development environments. If you’ve read works, you’ll also notice Sun’s coding style coincides mine—this pleases me, although I nothing (that I know of) it. The subject formatting style good hours hot debate, I’ll say I’m trying dictate correct style via examples; I motivation using style I do. Because Java free-form programming language, continue use whatever style you’re comfortable with. One solution coding style issue use tool like Jalopy (www.triemax.com), assisted developing book, change formatting suits you. The code files printed book tested automated system, work without compiler errors. This book focuses tested Java SE5/6. If need learn earlier releases language covered edition, 1st 3rd editions book freely downloadable www.MindView.net. Errors No matter many tools writer uses detect errors, always creep often leap page fresh reader. If discover anything believe error, please use link find book www.MindView.net submit error along suggested correction. Your help appreciated. 14 Thinking Java Bruce Eckel Introduction Objects “We cut nature up, organize concepts, ascribe significances do, largely parties agreement holds throughout speech community codified patterns language … cannot talk except subscribing organization classification data agreement decrees.” Benjamin Lee Whorf (1897-1941) The genesis computer revolution machine. The genesis programming languages thus tends look like machine. But computers much machines mind amplification tools (“bicycles mind,” Steve Jobs fond saying) different kind expressive medium. As result, tools beginning look less like machines like parts minds, also like forms expression writing, painting, sculpture, animation, filmmaking. Object-oriented programming (OOP) part movement toward using computer expressive medium. This chapter introduce basic concepts OOP, including overview development methods. This chapter, book, assumes programming experience, although necessarily C. If think need preparation programming tackling book, work Thinking C multimedia seminar, downloadable www.MindView.net. This chapter background supplementary material. Many people feel comfortable wading object-oriented programming without understanding big picture first. Thus, many concepts introduced give solid overview OOP. However, people may get big picture concepts they’ve seen mechanics first; people may become bogged lost without code get hands on. If you’re part latter group eager get specifics language, feel free jump past chapter—skipping point prevent writing programs learning language. However, want come back eventually fill knowledge understand objects important design them. The progress abstraction All programming languages provide abstractions. It argued complexity problems you’re able solve directly related kind quality abstraction. By “kind” I mean, “What abstracting?” Assembly language small abstraction underlying machine. Many so-called “imperative” languages followed (such FORTRAN, BASIC, C) abstractions assembly language. These languages big improvements assembly language, primary abstraction still requires think terms structure computer rather structure problem trying solve. The programmer must establish association machine model (in “solution space,” place you’re implementing solution, computer) model problem actually solved (in “problem space,” place problem exists, business). The effort required perform mapping, fact extrinsic programming language, produces programs difficult write expensive maintain, side effect created entire “programming methods” industry. The alternative modeling machine model problem you’re trying solve. Early languages LISP APL chose particular views world (“All problems ultimately lists” “All problems algorithmic,” respectively). Prolog casts problems chains decisions. Languages created constraint-based programming programming exclusively manipulating graphical symbols. (The latter proved restrictive.) Each approaches may good solution particular class problem they’re designed solve, step outside domain become awkward. The object-oriented approach goes step providing tools programmer represent elements problem space. This representation general enough programmer constrained particular type problem. We refer elements problem space representations solution space “objects.” (You also need objects don’t problem-space analogs.) The idea program allowed adapt lingo problem adding new types objects, read code describing solution, you’re reading words also express problem. This flexible powerful language abstraction we’ve before. 1 Thus, OOP allows describe problem terms problem, rather terms computer solution run. There’s still connection back computer: Each object looks quite bit like little computer—it state, operations ask perform. However, doesn’t seem like bad analogy objects real world—they characteristics behaviors. Alan Kay summarized five basic characteristics Smalltalk, first successful objectoriented language one languages upon Java based. These characteristics represent pure approach object-oriented programming: 1. Everything object. Think object fancy variable; stores data, “make requests” object, asking perform operations itself. In theory, take conceptual component problem you’re trying solve (dogs, buildings, services, etc.) represent object program. 2. A program bunch objects telling sending messages. To make request object, “send message” object. More concretely, think message request call method belongs particular object. 3. Each object memory made objects. Put another way, create new kind object making package containing existing objects. Thus, build complexity program hiding behind simplicity objects. 4. Every object type. Using parlance, object instance class, “class” synonymous “type.” The important distinguishing characteristic class “What messages send it?” 5. All objects particular type receive messages. This actually loaded statement, see later. Because object type “circle” also object type “shape,” circle guaranteed accept shape messages. This 1 Some language designers decided object-oriented programming adequate easily solve programming problems, advocate combination various approaches multiparadigm programming languages. See Multiparadigm Programming Leda Timothy Budd (Addison-Wesley, 1995). 16 Thinking Java Bruce Eckel means write code talks shapes automatically handle anything fits description shape. This substitutability one powerful concepts OOP. Booch offers even succinct description object: An object state, behavior identity. This means object internal data (which gives state), methods (to produce behavior), object uniquely distinguished every object—to put concrete sense, object unique address memory. 2 An object interface Aristotle probably first begin careful study concept type; spoke “the class fishes class birds.” The idea objects, unique, also part class objects characteristics behaviors common used directly first object-oriented language, Simula-67, fundamental keyword class introduces new type program. Simula, name implies, created developing simulations classic “bank teller problem.” In this, numerous tellers, customers, accounts, transactions, units money—a lot “objects.” Objects identical except state program’s execution grouped together “classes objects,” that’s keyword class came from. Creating abstract data types (classes) fundamental concept object-oriented programming. Abstract data types work almost exactly like built-in types: You create variables type (called objects instances object-oriented parlance) manipulate variables (called sending messages requests; send message object figures it). The members (elements) class share commonality: Every account balance, every teller accept deposit, etc. At time, member state: Each account different balance, teller name. Thus, tellers, customers, accounts, transactions, etc., represented unique entity computer program. This entity object, object belongs particular class defines characteristics behaviors. So, although really object-oriented programming create new data types, virtually object-oriented programming languages use “class” keyword. When see word “type” think “class” vice versa. 3 Since class describes set objects identical characteristics (data elements) behaviors (functionality), class really data type floating point number, example, also set characteristics behaviors. The difference programmer defines class fit problem rather forced use existing data type designed represent unit storage machine. You extend programming language adding new data types specific needs. The programming system welcomes new classes gives care type checking gives built-in types. The object-oriented approach limited building simulations. Whether agree program simulation system you’re designing, use OOP techniques easily reduce large set problems simple solution. 2 This actually bit restrictive, since objects conceivably exist different machines address spaces, also stored disk. In cases, identity object must determined something memory address. 3 Some people make distinction, stating type determines interface class particular implementation interface. Introduction Objects 17 Once class established, make many objects class like, manipulate objects elements exist problem trying solve. Indeed, one challenges object-oriented programming create one-toone mapping elements problem space objects solution space. But get object useful work you? There needs way make request object something, complete transaction, draw something screen, turn switch. And object satisfy certain requests. The requests make object defined interface, type determines interface. A simple example might representation light bulb: Light lt = new Light(); lt.on(); The interface determines requests make particular object. However, must code somewhere satisfy request. This, along hidden data, comprises implementation. From procedural programming standpoint, it’s complicated. A type method associated possible request, make particular request object, method called. This process usually summarized saying “send message” (make request) object, object figures message (it executes code). Here, name type/class Light, name particular Light object lt, requests make Light object turn on, turn off, make brighter, make dimmer. You create Light object defining “reference” (lt) object calling new request new object type. To send message object, state name object connect message request period (dot). From standpoint user predefined class, that’s pretty much programming objects. The preceding diagram follows format Unified Modeling Language (UML). Each class represented box, type name top portion box, data members care describe middle portion box, methods (the functions belong object, receive messages send object) bottom portion box. Often, name class public methods shown UML design diagrams, middle portion shown, case. If you’re interested class name, bottom portion doesn’t need shown, either. An object provides services While you’re trying develop understand program design, one best ways think objects “service providers.” Your program provide services user, accomplish using services offered objects. Your goal 18 Thinking Java Bruce Eckel produce (or even better, locate existing code libraries) set objects provide ideal services solve problem. A way start ask, “If I could magically pull hat, objects would solve problem right away?” For example, suppose creating bookkeeping program. You might imagine objects contain pre-defined bookkeeping input screens, another set objects perform bookkeeping calculations, object handles printing checks invoices different kinds printers. Maybe objects already exist, ones don’t, would look like? What services would objects provide, objects would need fulfill obligations? If keep this, eventually reach point say either, “That object seems simple enough sit write” “I’m sure object must exist already.” This reasonable way decompose problem set objects. Thinking object service provider additional benefit: It helps improve cohesiveness object. High cohesion fundamental quality software design: It means various aspects software component (such object, although could also apply method library objects) “fit together” well. One problem people designing objects cramming much functionality one object. For example, check printing module, may decide need object knows formatting printing. You’ll probably discover much one object, need three objects. One object might catalog possible check layouts, queried information print check. One object set objects generic printing interface knows different kinds printers (but nothing bookkeeping—this one candidate buying rather writing yourself). And third object could use services two accomplish task. Thus, object cohesive set services offers. In good object-oriented design, object one thing well, doesn’t try much. This allows discovery objects might purchased (the printer interface object), also produces new objects might reused somewhere else (the catalog check layouts). Treating objects service providers great simplifying tool. This useful design process, also someone else trying understand code reuse object. If see value object based service provides, makes much easier fit design. The hidden implementation It helpful break playing field class creators (those create new data types) client programmers 4 (the class consumers use data types applications). The goal client programmer collect toolbox full classes use rapid application development. The goal class creator build class exposes what’s necessary client programmer keeps everything else hidden. Why? Because it’s hidden, client programmer can’t access it, means class creator change hidden portion without worrying impact anyone else. The hidden portion usually represents tender insides object could easily corrupted careless uninformed client programmer, hiding implementation reduces program bugs. In relationship it’s important boundaries respected parties involved. When create library, establish relationship client programmer, also programmer, one putting together application using library, possibly build bigger library. If members class available everyone, client programmer anything class there’s way enforce rules. Even though might really prefer client programmer directly 4 I’m indebted friend Scott Meyers term. Introduction Objects 19 manipulate members class, without access control there’s way prevent it. Everything’s naked world. So first reason access control keep client programmers’ hands portions shouldn’t touch—parts necessary internal operation data type part interface users need order solve particular problems. This actually service client programmers easily see what’s important ignore. The second reason access control allow library designer change internal workings class without worrying affect client programmer. For example, might implement particular class simple fashion ease development, later discover need rewrite order make run faster. If interface implementation clearly separated protected, accomplish easily. Java uses three explicit keywords set boundaries class: public, private, protected. These access specifiers determine use definitions follow. public means following element available everyone. The private keyword, hand, means one access element except you, creator type, inside methods type. private brick wall client programmer. Someone tries access private member get compile-time error. The protected keyword acts like private, exception inheriting class access protected members, private members. Inheritance introduced shortly. Java also “default” access, comes play don’t use one aforementioned specifiers. This usually called package access classes access members classes package (library component), outside package members appear private. Reusing implementation Once class created tested, (ideally) represent useful unit code. It turns reusability nearly easy achieve many would hope; takes experience insight produce reusable object design. But design, begs reused. Code reuse one greatest advantages object-oriented programming languages provide. The simplest way reuse class use object class directly, also place object class inside new class. We call “creating member object.” Your new class made number type objects, combination need achieve functionality desired new class. Because composing new class existing classes, concept called composition (if composition happens dynamically, it’s usually called aggregation). Composition often referred “has-a” relationship, “A car engine.” 20 Thinking Java Bruce Eckel (This UML diagram indicates composition filled diamond, states one car. I typically use simpler form: line, without diamond, indicate association. 5 ) Composition comes great deal flexibility. The member objects new class typically private, making inaccessible client programmers using class. This allows change members without disturbing existing client code. You also change member objects run time, dynamically change behavior program. Inheritance, described next, flexibility since compiler must place compile-time restrictions classes created inheritance. Because inheritance important object-oriented programming, often highly emphasized, new programmer get idea inheritance used everywhere. This result awkward overly complicated designs. Instead, first look composition creating new classes, since simpler flexible. If take approach, designs cleaner. Once you’ve experience, reasonably obvious need inheritance. Inheritance By itself, idea object convenient tool. It allows package data functionality together concept, represent appropriate problem-space idea rather forced use idioms underlying machine. These concepts expressed fundamental units programming language using class keyword. It seems pity, however, go trouble create class forced create brand new one might similar functionality. It’s nicer take existing class, clone it, make additions modifications clone. This effectively get inheritance, exception original class (called base class superclass parent class) changed, modified “clone” (called derived class inherited class subclass child class) also reflects changes. (The arrow UML diagram points derived class base class. As see, commonly one derived class.) A type describe constraints set objects; also relationship types. Two types characteristics behaviors common, one type may contain characteristics another may also handle messages (or handle differently). Inheritance expresses similarity types using concept base types derived types. A base type contains characteristics behaviors shared among types derived it. You create base type 5 This usually enough detail diagrams, don’t need get specific whether you’re using aggregation composition. Introduction Objects 21 represent core ideas objects system. From base type, derive types express different ways core realized. For example, trash-recycling machine sorts pieces trash. The base type “trash”, piece trash weight, value, on, shredded, melted, decomposed. From this, specific types trash derived may additional characteristics (a bottle color) behaviors (an aluminum may crushed, steel magnetic). In addition, behaviors may different (the value paper depends type condition). Using inheritance, build type hierarchy expresses problem you’re trying solve terms types. A second example classic “shape” example, perhaps used computer-aided design system game simulation. The base type “shape,” shape size, color, position, on. Each shape drawn, erased, moved, colored, etc. From this, specific types shapes derived (inherited)—circle, square, triangle, on—each may additional characteristics behaviors. Certain shapes flipped, example. Some behaviors may different, want calculate area shape. The type hierarchy embodies similarities differences shapes. Casting solution terms problem useful don’t need lot intermediate models get description problem description solution. With objects, type hierarchy primary model, go directly description system real world description system code. Indeed, one difficulties people object-oriented design it’s simple get beginning end. A mind trained look complex solutions initially stumped simplicity. When inherit existing type, create new type. This new type contains members existing type (although private ones hidden away inaccessible), importantly duplicates interface base class. That is, messages send objects base class also send objects derived class. Since know type class messages send it, means derived class type base class. In previous example, “A circle shape.” This type equivalence via inheritance one fundamental gateways understanding meaning object-oriented programming. Since base class derived class fundamental interface, must implementation go along interface. That is, must code execute object receives particular message. If simply inherit class don’t 22 Thinking Java Bruce Eckel anything else, methods base-class interface come right along derived class. That means objects derived class type, also behavior, isn’t particularly interesting. You two ways differentiate new derived class original base class. The first quite straightforward: You simply add brand new methods derived class. These new methods part base-class interface. This means base class simply didn’t much wanted to, added methods. This simple primitive use inheritance is, times, perfect solution problem. However, look closely possibility base class might also need additional methods. This process discovery iteration design happens regularly object-oriented programming. Although inheritance may sometimes imply (especially Java, keyword inheritance extends) going add new methods interface, that’s necessarily true. The second important way differentiate new class change behavior existing base-class method. This referred overriding method. Introduction Objects 23 To override method, simply create new definition method derived class. You’re saying, “I’m using interface method here, I want something different new type.” Is-a vs. is-like-a relationships There’s certain debate occur inheritance: Should inheritance override baseclass methods (and add new methods aren’t base class)? This would mean derived class exactly type base class since exactly interface. As result, exactly substitute object derived class object base class. This thought pure substitution, it’s often referred substitution principle. In sense, ideal way treat inheritance. We often refer relationship base class derived classes case is-a relationship, say, “A circle shape.” A test inheritance determine whether state is-a relationship classes make sense. There times must add new interface elements derived type, thus extending interface. The new type still substituted base type, substitution isn’t perfect new methods accessible base type. This described islike-a relationship (my term). The new type interface old type also contains methods, can’t really say it’s exactly same. For example, consider air conditioner. Suppose house wired controls cooling; is, interface allows control cooling. Imagine air conditioner breaks replace heat pump, heat cool. The heat pump is-like-an air conditioner, more. Because control system house designed control cooling, restricted communication cooling part new object. The interface new object extended, existing system doesn’t know anything except original interface. 24 Thinking Java Bruce Eckel Of course, see design becomes clear base class “cooling system” general enough, renamed “temperature control system” also include heating—at point substitution principle work. However, diagram example happen design real world. When see substitution principle it’s easy feel like approach (pure substitution) way things, fact nice design works way. But you’ll find times it’s equally clear must add new methods interface derived class. With inspection cases reasonably obvious. Interchangeable objects polymorphism When dealing type hierarchies, often want treat object specific type is, instead base type. This allows write code doesn’t depend specific types. In shape example, methods manipulate generic shapes, unconcerned whether they’re circles, squares, triangles, shape hasn’t even defined yet. All shapes drawn, erased, moved, methods simply send message shape object; don’t worry object copes message. Such code unaffected addition new types, adding new types common way extend object-oriented program handle new situations. For example, derive new subtype shape called pentagon without modifying methods deal generic shapes. This ability easily extend design deriving new subtypes one essential ways encapsulate change. This greatly improves designs reducing cost software maintenance. There’s problem, however, attempting treat derived-type objects generic base types (circles shapes, bicycles vehicles, cormorants birds, etc.). If method going tell generic shape draw itself, generic vehicle steer, generic bird move, compiler cannot know compile time precisely piece code executed. That’s whole point—when message sent, programmer doesn’t want know piece code executed; draw method applied equally circle, square, triangle, object execute proper code depending specific type. If don’t know piece code executed, add new subtype, code executes different without requiring changes method Introduction Objects 25 calls it. Therefore, compiler cannot know precisely piece code executed, do? For example, following diagram BirdController object works generic Bird objects know exact type are. This convenient BirdController’s perspective doesn’t write special code determine exact type Bird it’s working Bird’s behavior. So happen that, move( ) called ignoring specific type Bird, right behavior occur (a Goose walks, flies, swims, Penguin walks swims)? The answer primary twist object-oriented programming: The compiler cannot make function call traditional sense. The function call generated non-OOP compiler causes called early binding, term may heard you’ve never thought way. It means compiler generates call specific function name, runtime system resolves call absolute address code executed. In OOP, program cannot determine address code run time, scheme necessary message sent generic object. To solve problem, object-oriented languages use concept late binding. When send message object, code called isn’t determined run time. The compiler ensure method exists performs type checking arguments return value, doesn’t know exact code execute. To perform late binding, Java uses special bit code lieu absolute call. This code calculates address method body, using information stored object (this process covered great detail Polymorphism chapter). Thus, object behave differently according contents special bit code. When send message object, object actually figure message. In languages must explicitly state want method flexibility latebinding properties (C++ uses virtual keyword this). In languages, default, methods dynamically bound. In Java, dynamic binding default behavior don’t need remember add extra keywords order get polymorphism. Consider shape example. The family classes (all based uniform interface) diagrammed earlier chapter. To demonstrate polymorphism, want write single piece code ignores specific details type talks base class. That code decoupled type-specific information thus simpler write easier understand. And, new type—a Hexagon, example—is added inheritance, code write work well new type Shape existing types. Thus, program extensible. 26 Thinking Java Bruce Eckel If write method Java (as soon learn do): void doSomething(Shape shape) { shape.erase(); // ... shape.draw(); } This method speaks Shape, independent specific type object it’s drawing erasing. If part program uses doSomething( ) method: Circle circle = new Circle(); Triangle triangle = new Triangle(); Line line= new Line(); doSomething(circle); doSomething(triangle); doSomething(line); The calls doSomething( ) automatically work correctly, regardless exact type object. This rather amazing trick. Consider line: doSomething(circle); What’s happening Circle passed method that’s expecting Shape. Since Circle Shape treated one doSomething( ). That is, message doSomething( ) send Shape, Circle accept. So completely safe logical thing do. We call process treating derived type though base type upcasting. The name cast used sense casting mold comes way inheritance diagram typically arranged, base type top derived classes fanning downward. Thus, casting base type moving inheritance diagram: “upcasting.” An object-oriented program contains upcasting somewhere, that’s decouple knowing exact type you’re working with. Look code doSomething( ): shape.erase(); // ... shape.draw(); Introduction Objects 27 Notice doesn’t say, “If you’re Circle, this, you’re Square, that, etc.” If write kind code, checks possible types Shape actually be, it’s messy need change every time add new kind Shape. Here, say, “You’re shape, I know erase( ) draw( ) yourself, it, take care details correctly.” What’s impressive code doSomething( ) that, somehow, right thing happens. Calling draw( ) Circle causes different code executed calling draw( ) Square Line, draw( ) message sent anonymous Shape, correct behavior occurs based actual type Shape. This amazing because, mentioned earlier, Java compiler compiling code doSomething( ), cannot know exactly types dealing with. So ordinarily, you’d expect end calling version erase( ) draw( ) base class Shape, specific Circle, Square, Line. And yet right thing happens polymorphism. The compiler runtime system handle details; need know right happen, importantly, design it. When send message object, object right thing, even upcasting involved. The singly rooted hierarchy One issues OOP become especially prominent since introduction C++ whether classes ultimately inherited single base class. In Java (as virtually OOP languages except C++) answer yes, name ultimate base class simply Object. It turns benefits singly rooted hierarchy many. All objects singly rooted hierarchy interface common, ultimately fundamental type. The alternative (provided C++) don’t know everything basic type. From backward-compatibility standpoint fits model C better thought less restrictive, want full-on objectoriented programming must build hierarchy provide convenience that’s built OOP languages. And new class library acquire, incompatible interface used. It requires effort (and possibly multiple inheritance) work new interface design. Is extra “flexibility” C++ worth it? If need it—if large investment C—it’s quite valuable. If you’re starting scratch, alternatives Java often productive. All objects singly rooted hierarchy guaranteed certain functionality. You know perform certain basic operations every object system. All objects easily created heap, argument passing greatly simplified. A singly rooted hierarchy makes much easier implement garbage collector, one fundamental improvements Java C++. And since information type object guaranteed objects, you’ll never end object whose type cannot determine. This especially important system-level operations, exception handling, allow greater flexibility programming. Containers In general, don’t know many objects you’re going need solve particular problem, long last. You also don’t know store objects. How know much space create information isn’t known run time? 28 Thinking Java Bruce Eckel The solution problems object-oriented design seems flippant: You create another type object. The new type object solves particular problem holds references objects. Of course, thing array, available languages. But new object, generally called container (also called collection, Java library uses term different sense book use “container”), expand whenever necessary accommodate everything place inside it. So don’t need know many objects you’re going hold container. Just create container object let take care details. Fortunately, good OOP language comes set containers part package. In C++, it’s part Standard C++ Library often called Standard Template Library (STL). Smalltalk complete set containers. Java also numerous containers standard library. In libraries, one two generic containers considered good enough needs, others (Java, example) library different types containers different needs: several different kinds List classes (to hold sequences), Maps (also known associative arrays, associate objects objects), Sets (to hold one type object), components queues, trees, stacks, etc. From design standpoint, really want container manipulated solve problem. If single type container satisfied needs, there’d reason different kinds. There two reasons need choice containers. First, containers provide different types interfaces external behavior. A stack different interface behavior queue, different set list. One might provide flexible solution problem other. Second, different containers different efficiencies certain operations. For example, two basic types List: ArrayList LinkedList. Both simple sequences identical interfaces external behaviors. But certain operations significantly different costs. Randomly accessing elements ArrayList constant-time operation; takes amount time regardless element select. However, LinkedList expensive move list randomly select element, takes longer find element farther list. On hand, want insert element middle sequence, it’s cheaper LinkedList ArrayList. These operations different efficiencies depending underlying structure sequence. You might start building program LinkedList and, tuning performance, change ArrayList. Because abstraction via interface List, change one minimal impact code. Parameterized types (generics) Before Java SE5, containers held one universal type Java: Object. The singly rooted hierarchy means everything Object, container holds Objects hold anything. 6 This made containers easy reuse. To use container, simply add object references later ask back. But, since container held Objects, added object reference container upcast Object, thus losing character. When fetching back, got Object reference, reference type put in. So turn back something specific type object put container? Here, cast used again, time you’re casting inheritance hierarchy general type. Instead, cast hierarchy specific type. This manner casting called downcasting. With upcasting, know, example, Circle type Shape it’s safe upcast, don’t know Object necessarily 6 They hold primitives, Java SE5 autoboxing makes restriction almost non-issue. This discussed detail later book. Introduction Objects 29 Circle Shape it’s hardly safe downcast unless know exactly you’re dealing with. It’s completely dangerous, however, downcast wrong thing you’ll get runtime error called exception, described shortly. When fetch object references container, though, must way remember exactly perform proper downcast. Downcasting runtime checks require extra time running program extra effort programmer. Wouldn’t make sense somehow create container knows types holds, eliminating need downcast possible mistake? The solution called parameterized type mechanism. A parameterized type class compiler automatically customize work particular types. For example, parameterized container, compiler could customize container would accept Shapes fetch Shapes. One big changes Java SE5 addition parameterized types, called generics Java. You’ll recognize use generics angle brackets types inside; example, ArrayList holds Shape created like this: ArrayList<Shape> shapes = new ArrayList<Shape>(); There also changes many standard library components order take advantage generics. As see, generics impact much code book. Object creation & lifetime One critical issue working objects way created destroyed. Each object requires resources, notably memory, order exist. When object longer needed must cleaned resources released reuse. In simple programming situations question object cleaned doesn’t seem challenging: You create object, use long it’s needed, destroyed. However, it’s hard encounter situations complex. Suppose, example, designing system manage air traffic airport. (The model might also work managing crates warehouse, video rental system, kennel boarding pets.) At first seems simple: Make container hold airplanes, create new airplane place container airplane enters air-trafficcontrol zone. For cleanup, simply clean appropriate airplane object plane leaves zone. But perhaps system record data planes; perhaps data doesn’t require immediate attention main controller function. Maybe it’s record flight plans small planes leave airport. So second container small planes, whenever create plane object also put second container it’s small plane. Then background process performs operations objects container idle moments. Now problem difficult: How possibly know destroy objects? When you’re done object, part system might be. This problem arise number situations, programming systems (such C++) must explicitly delete object you’re done become quite complex. 30 Thinking Java Bruce Eckel Where data object lifetime object controlled? C++ takes approach control efficiency important issue, gives programmer choice. For maximum runtime speed, storage lifetime determined program written, placing objects stack (these sometimes called automatic scoped variables) static storage area. This places priority speed storage allocation release, control valuable situations. However, sacrifice flexibility must know exact quantity, lifetime, type objects you’re writing program. If trying solve general problem computer-aided design, warehouse management, air-traffic control, restrictive. The second approach create objects dynamically pool memory called heap. In approach, don’t know run time many objects need, lifetime is, exact type is. Those determined spur moment program running. If need new object, simply make heap point need it. Because storage managed dynamically, run time, amount time required allocate storage heap noticeably longer time create storage stack. Creating storage stack often single assembly instruction move stack pointer another move back up. The time create heap storage depends design storage mechanism. The dynamic approach makes generally logical assumption objects tend complicated, extra overhead finding storage releasing storage important impact creation object. In addition, greater flexibility essential solve general programming problem. Java uses dynamic memory allocation, exclusively. 7 Every time want create object, use new operator build dynamic instance object. There’s another issue, however, that’s lifetime object. With languages allow objects created stack, compiler determines long object lasts automatically destroy it. However, create heap compiler knowledge lifetime. In language like C++, must determine programmatically destroy object, lead memory leaks don’t correctly (and common problem C++ programs). Java provides feature called garbage collector automatically discovers object longer use destroys it. A garbage collector much convenient reduces number issues must track code must write. More importantly, garbage collector provides much higher level insurance insidious problem memory leaks, brought many C++ project knees. With Java, garbage collector designed take care problem releasing memory (although doesn’t include aspects cleaning object). The garbage collector “knows” object longer use, automatically releases memory object. This, combined fact objects inherited single root class Object create objects one way—on heap—makes process programming Java much simpler programming C++. You far fewer decisions make hurdles overcome. Exception handling: dealing errors Ever since beginning programming languages, error handling particularly difficult issue. Because it’s hard design good error-handling scheme, many languages simply ignore issue, passing problem library designers come 7 Primitive types, you’ll learn later, special case. Introduction Objects 31 halfway measures work many situations easily circumvented, generally ignoring them. A major problem error-handling schemes rely programmer vigilance following agreed-upon convention enforced language. If programmer vigilant—often case hurry—these schemes easily forgotten. Exception handling wires error handling directly programming language sometimes even operating system. An exception object “thrown” site error “caught” appropriate exception handler designed handle particular type error. It’s exception handling different, parallel path execution taken things go wrong. And uses separate execution path, doesn’t need interfere normally executing code. This tends make code simpler write aren’t constantly forced check errors. In addition, thrown exception unlike error value that’s returned method flag that’s set method order indicate error condition—these ignored. An exception cannot ignored, it’s guaranteed dealt point. Finally, exceptions provide way reliably recover bad situation. Instead exiting program, often able set things right restore execution, produces much robust programs. Java’s exception handling stands among programming languages, Java, exception handling wired beginning you’re forced use it. It single acceptable way report errors. If don’t write code properly handle exceptions, you’ll get compile-time error message. This guaranteed consistency sometimes make error handling much easier. It’s worth noting exception handling isn’t object-oriented feature, although objectoriented languages exception normally represented object. Exception handling existed object-oriented languages. Concurrent programming A fundamental concept computer programming idea handling one task time. Many programming problems require program stop it’s doing, deal problem, return main process. The solution approached many ways. Initially, programmers low-level knowledge machine wrote interrupt service routines, suspension main process initiated hardware interrupt. Although worked well, difficult non-portable, made moving program new type machine slow expensive. Sometimes, interrupts necessary handling time-critical tasks, there’s large class problems you’re simply trying partition problem separately running pieces (tasks) whole program responsive. Within program, separately running pieces called threads, general concept called concurrency. A common example concurrency user interface. By using tasks, user press button get quick response rather forced wait program finishes current task. Ordinarily, tasks way allocate time single processor. But operating system supports multiple processors, task assigned different processor, truly run parallel. One convenient features concurrency language level programmer doesn’t need worry whether many processors one. The program logically divided tasks, machine one processor, program runs faster, without special adjustments. All makes concurrency sound pretty simple. There catch: shared resources. If one task running that’s expecting access resource, 32 Thinking Java Bruce Eckel problem. For example, two processes can’t simultaneously send information printer. To solve problem, resources shared, printer, must locked used. So task locks resource, completes task, releases lock someone else use resource. Java’s concurrency built language, Java SE5 added significant additional library support. Java Internet If Java is, fact, yet another computer programming language, may question important promoted revolutionary step computer programming. The answer isn’t immediately obvious you’re coming traditional programming perspective. Although Java useful solving traditional standalone programming problems, also important solves programming problems World Wide Web. What Web? The Web seem bit mystery first, talk “surfing,” “presence,” “home pages.” It’s helpful step back see really is, must understand client/server systems, another aspect computing that’s full confusing issues. Client/server computing The primary idea client/server system central repository information— kind data, usually database—that want distribute demand set people machines. A key client/server concept repository information centrally located changed changes propagate information consumers. Taken together, information repository, software distributes information, machine(s) information software reside called “the server.” The software resides consumer machine, communicates server, fetches information, processes it, displays consumer machine called client. The basic concept client/server computing, then, complicated. The problems arise single server trying serve many clients once. Generally, database management system involved, designer “balances” layout data tables optimal use. In addition, systems often allow client insert new information server. This means must ensure one client’s new data doesn’t walk another client’s new data, data isn’t lost process adding database (this called transaction processing). As client software changes, must built, debugged, installed client machines, turns complicated expensive might think. It’s especially problematic support multiple types computers operating systems. Finally, there’s all-important performance issue: You might hundreds clients making requests server moment, small delay critical. To minimize latency, programmers work hard offload processing tasks, often client machine, sometimes machines server site, using so-called middleware. (Middleware also used improve maintainability.) The simple idea distributing information many layers complexity whole problem seem hopelessly enigmatic. And yet it’s crucial: Client/server computing accounts roughly half programming activities. It’s responsible everything taking orders credit-card transactions distribution kind data—stock market, scientific, government, name it. What we’ve come past Introduction Objects 33 individual solutions individual problems, inventing new solution time. These hard create hard use, user learn new interface one. The entire client/server problem needed solved big way. The Web giant server The Web actually one giant client/server system. It’s bit worse that, since servers clients coexisting single network once. You don’t need know that, care connecting interacting one server time (even though might hopping around world search correct server). Initially simple one-way process. You made request server handed file, machine’s browser software (i.e., client) would interpret formatting onto local machine. But short order people began wanting deliver pages server. They wanted full client/server capability client could feed information back server, example, database lookups server, add new information server, place order (which requires special security measures). These changes we’ve seeing development Web. The Web browser big step forward: concept one piece information displayed type computer without change. However, original browsers still rather primitive rapidly bogged demands placed them. They weren’t particularly interactive, tended clog server Internet whenever needed something required programming send information back server processed. It could take many seconds minutes find misspelled something request. Since browser viewer couldn’t perform even simplest computing tasks. (On hand, safe, couldn’t execute programs local machine might contain bugs viruses.) To solve problem, different approaches taken. To begin with, graphics standards enhanced allow better animation video within browsers. The remainder problem solved incorporating ability run programs client end, browser. This called client-side programming. Client-side programming The Web’s initial server-browser design provided interactive content, interactivity completely provided server. The server produced static pages client browser, would simply interpret display them. Basic HyperText Markup Language (HTML) contains simple mechanisms data gathering: text-entry boxes, check boxes, radio boxes, lists dropdown lists, well button could programmed reset data form “submit” data form back server. This submission passes Common Gateway Interface (CGI) provided Web servers. The text within submission tells CGI it. The common action run program located server directory that’s typically called “cgi-bin.” (If watch address window top browser push button Web page, sometimes see “cgi-bin” within gobbledygook there.) These programs written languages. Perl common choice designed text manipulation interpreted, installed server regardless processor operating system. However, Python (www.Python.org) making inroads greater power simplicity. Many powerful Web sites today built strictly CGI, fact nearly anything CGI. However, Web sites built CGI programs rapidly become overly complicated maintain, also problem response time. The response CGI program depends much data must sent, well load server Internet. (On top this, starting CGI program tends slow.) The initial 34 Thinking Java Bruce Eckel designers Web foresee rapidly bandwidth would exhausted kinds applications people developed. For example, sort dynamic graphing nearly impossible perform consistency Graphics Interchange Format (GIF) file must created moved server client version graph. In addition, you’ve doubt experienced process data validation Web input form. You press submit button page; data shipped back server; server starts CGI program discovers error, formats HTML page informing error, sends page back you; must back page try again. Not slow, it’s inelegant. The solution client-side programming. Most desktop computers run Web browsers powerful engines capable vast work, original static HTML approach sitting there, idly waiting server dish next page. Client-side programming means Web browser harnessed whatever work can, result user much speedier interactive experience Web site. The problem discussions client-side programming aren’t different discussions programming general. The parameters almost same, platform different; Web browser like limited operating system. In end, must still program, accounts dizzying array problems solutions produced client-side programming. The rest section provides overview issues approaches client-side programming. Plug-ins One significant steps forward client-side programming development plug-in. This way programmer add new functionality browser downloading piece code plugs appropriate spot browser. It tells browser, “From perform new activity.” (You need download plug-in once.) Some fast powerful behavior added browsers via plug-ins, writing plug-in trivial task, isn’t something you’d want part process building particular site. The value plug-in client-side programming allows expert programmer develop extensions add extensions browser without permission browser manufacturer. Thus, plug-ins provide “back door” allows creation new client-side programming languages (although languages implemented plug-ins). Scripting languages Plug-ins resulted development browser scripting languages. With scripting language, embed source code client-side program directly HTML page, plug-in interprets language automatically activated HTML page displayed. Scripting languages tend reasonably easy understand and, simply text part HTML page, load quickly part single server hit required procure page. The trade-off code exposed everyone see (and steal). Generally, however, aren’t amazingly sophisticated things scripting languages, much hardship. One scripting language expect Web browser support without plug-in JavaScript (this passing resemblance Java you’ll climb additional learning curve use it. It named way grab Java’s marketing momentum). Unfortunately, Web browsers originally implemented JavaScript different way Web browsers, even versions themselves. The standardization JavaScript form ECMAScript helped, taken long time various browsers catch (and didn’t help Microsoft pushing agenda form VBScript, also vague similarities JavaScript). In general, must program kind least-common-denominator form JavaScript Introduction Objects 35 order able run browsers. Dealing errors debugging JavaScript described mess. As proof difficulty, recently anyone created truly complex piece JavaScript (Google, GMail), required excessive dedication expertise. This points scripting languages used inside Web browsers really intended solve specific types problems, primarily creation richer interactive graphical user interfaces (GUIs). However, scripting language might solve 80 percent problems encountered client-side programming. Your problems might well fit completely within 80 percent, since scripting languages allow easier faster development, probably consider scripting language looking involved solution Java programming. Java If scripting language solve 80 percent client-side programming problems, 20 percent—the “really hard stuff”? Java popular solution this. Not powerful programming language built secure, cross-platform, international, Java continually extended provide language features libraries elegantly handle problems difficult traditional programming languages, concurrency, database access, network programming, distributed computing. Java allows client-side programming via applet Java Web Start. An applet mini-program run Web browser. The applet downloaded automatically part Web page (just as, example, graphic automatically downloaded). When applet activated, executes program. This part beauty—it provides way automatically distribute client software server time user needs client software, sooner. The user gets latest version client software without fail without difficult reinstallation. Because way Java designed, programmer needs create single program, program automatically works computers browsers built-in Java interpreters. (This safely includes vast majority machines.) Since Java full-fledged programming language, much work possible client making requests server. For example, won’t need send request form across Internet discover you’ve gotten date parameter wrong, client computer quickly work plotting data instead waiting server make plot ship graphic image back you. Not get immediate win speed responsiveness, general network traffic load servers reduced, preventing entire Internet slowing down. Alternatives To honest, Java applets particularly lived initial fanfare. When Java first appeared, everyone seemed excited applets, would finally allow serious client-side programmability, increase responsiveness decrease bandwidth requirements Internet-based applications. People envisioned vast possibilities. Indeed, find clever applets Web. But overwhelming move applets never happened. The biggest problem probably 10 MB download necessary install Java Runtime Environment (JRE) scary average user. The fact Microsoft chose include JRE Internet Explorer may sealed fate. In event, Java applets didn’t happen large scale. Nonetheless, applets Java Web Start applications still valuable situations. Anytime control user machines, example within corporation, 36 Thinking Java Bruce Eckel reasonable distribute update client applications using technologies, save considerable time, effort, money, especially need frequent updates. In Graphical User Interfaces chapter, look one promising new technology, Macromedia’s Flex, allows create Flash-based applet-equivalents. Because Flash Player available upwards 98 percent Web browsers (including Windows, Linux Mac) considered accepted standard. Installing upgrading Flash Player quick easy. The ActionScript language based ECMAScript reasonably familiar, Flex allows program without worrying browser specifics—thus far attractive JavaScript. For client-side programming, alternative worth considering. .NET C# For while, main competitor Java applets Microsoft’s ActiveX, although required client running Windows. Since then, Microsoft produced full competitor Java form .NET platform C# programming language. The .NET platform roughly Java Virtual Machine (JVM; software platform Java programs execute) Java libraries, C# bears unmistakable similarities Java. This certainly best work Microsoft done arena programming languages programming environments. Of course, considerable advantage able see worked well didn’t work well Java, build upon that, build have. This first time since inception Java real competition. As result, Java designers Sun taken hard look C# programmers might want move it, responded making fundamental improvements Java Java SE5. Currently, main vulnerability important question concerning .NET whether Microsoft allow completely ported platforms. They claim there’s problem this, Mono project (www.go-mono.com) partial implementation .NET working Linux, implementation complete Microsoft decided squash part it, .NET cross-platform solution still risky bet. Internet vs. intranet The Web general solution client/server problem, makes sense use technology solve subset problem, particular classic client/server problem within company. With traditional client/server approaches problem multiple types client computers, well difficulty installing new client software, handily solved Web browsers client-side programming. When Web technology used information network restricted particular company, referred intranet. Intranets provide much greater security Internet, since physically control access servers within company. In terms training, seems people understand general concept browser it’s much easier deal differences way pages applets look, learning curve new kinds systems seems reduced. The security problem brings us one divisions seems automatically forming world client-side programming. If program running Internet, don’t know platform working under, want extra careful don’t disseminate buggy code. You need something cross-platform secure, like scripting language Java. If you’re running intranet, might different set constraints. It’s uncommon machines could Intel/Windows platforms. On intranet, you’re responsible quality code repair bugs they’re discovered. In Introduction Objects 37 addition, might already body legacy code you’ve using traditional client/server approach, whereby must physically install client programs every time upgrade. The time wasted installing upgrades compelling reason move browsers, upgrades invisible automatic (Java Web Start also solution problem). If involved intranet, sensible approach take shortest path allows use existing code base, rather trying recode programs new language. When faced bewildering array solutions client-side programming problem, best plan attack cost-benefit analysis. Consider constraints problem would shortest path solution. Since client-side programming still programming, it’s always good idea take fastest development approach particular situation. This aggressive stance prepare inevitable encounters problems program development. Server-side programming This whole discussion ignored issue server-side programming, arguably Java greatest success. What happens make request server? Most time request simply “Send file.” Your browser interprets file appropriate fashion: HTML page, graphic image, Java applet, script program, etc. A complicated request server generally involves database transaction. A common scenario involves request complex database search, server formats HTML page sends result. (Of course, client intelligence via Java scripting language, raw data sent formatted client end, faster less load server.) Or might want register name database join group place order, involve changes database. These database requests must processed via code server side, generally referred server-side programming. Traditionally, server-side programming performed using Perl, Python, C++, language create CGI programs, sophisticated systems since appeared. These include Java-based Web servers allow perform server-side programming Java writing called servlets. Servlets offspring, JSPs, two compelling reasons companies develop Web sites moving Java, especially eliminate problems dealing differently abled browsers. Server-side programming topics covered Thinking Enterprise Java www.MindView.net. Despite talk Java Internet, general-purpose programming language solve kinds problems solve languages. Here, Java’s strength portability, also programmability, robustness, large, standard library numerous third-party libraries available continue developed. Summary You know procedural program looks like: data definitions function calls. To find meaning program, must work it, looking function calls low-level concepts create model mind. This reason need intermediate representations designing procedural programs—by themselves, programs tend confusing terms expression oriented toward computer problem you’re solving. Because OOP adds many new concepts top find procedural language, natural assumption may resulting Java program far 38 Thinking Java Bruce Eckel complicated equivalent procedural program. Here, you’ll pleasantly surprised: A well-written Java program generally far simpler much easier understand procedural program. What you’ll see definitions objects represent concepts problem space (rather issues computer representation) messages sent objects represent activities space. One delights objectoriented programming that, well-designed program, it’s easy understand code reading it. Usually, there’s lot less code well, many problems solved reusing existing library code. OOP Java may everyone. It’s important evaluate needs decide whether Java optimally satisfy needs, might better another programming system (including one you’re currently using). If know needs specialized foreseeable future specific constraints may satisfied Java, owe investigate alternatives (in particular, I recommend looking Python; see www.Python.org). If still choose Java language, you’ll least understand options clear vision took direction. Introduction Objects 39 Everything Is Object “If spoke different language, would perceive somewhat different world.” Ludwig Wittgenstein (1889-1951) Although based C++, Java “pure” object-oriented language. Both C++ Java hybrid languages, Java designers felt hybridization important C++. A hybrid language allows multiple programming styles; reason C++ hybrid support backward compatibility C language. Because C++ superset C language, includes many language’s undesirable features, make aspects C++ overly complicated. The Java language assumes want object-oriented programming. This means begin must shift mindset object-oriented world (unless it’s already there). The benefit initial effort ability program language simpler learn use many OOP languages. In chapter you’ll see basic components Java program learn (almost) everything Java object. You manipulate objects references Each programming language means manipulating elements memory. Sometimes programmer must constantly aware type manipulation going on. Are manipulating element directly, dealing kind indirect representation (a pointer C C++) must treated special syntax? All simplified Java. You treat everything object, using single consistent syntax. Although treat everything object, identifier manipulate actually “reference” object. 1 You might imagine television (the object) remote control (the reference). As long you’re holding reference, connection television, someone says, “Change channel” “Lower volume,” you’re manipulating reference, turn modifies object. If want move around 1 This flashpoint. There say, “Clearly, it’s pointer,” presumes underlying implementation. Also, Java references much akin C++ references pointers syntax. In 1st edition book, I chose invent new term, “handle,” C++ references Java references important differences. I coming C++ want confuse C++ programmers I assumed would largest audience Java. In 2nd edition, I decided “reference” commonly used term, anyone changing C++ would lot cope terminology references, might well jump feet. However, people disagree even term “reference.” I read one book “completely wrong say Java supports pass reference,” Java object identifiers (according author) actually “object references.” And (he goes on) everything actually pass value. So you’re passing reference, you’re “passing object reference value.” One could argue precision convoluted explanations, I think approach simplifies understanding concept without hurting anything (well, language lawyers may claim I’m lying you, I’ll say I’m providing appropriate abstraction). room still control television, take remote/reference you, television. Also, remote control stand own, television. That is, reference doesn’t mean there’s necessarily object connected it. So want hold word sentence, create String reference: String s; But you’ve created reference, object. If decided send message point, you’ll get error isn’t actually attached anything (there’s television). A safer practice, then, always initialize reference create it: String = "asdf"; However, uses special Java feature: Strings initialized quoted text. Normally, must use general type initialization objects. You must create objects When create reference, want connect new object. You so, general, new operator. The keyword new says, “Make new one objects.” So preceding example, say: String = new String("asdf"); Not mean “Make new String,” also gives information make String supplying initial character string. Of course, Java comes plethora ready-made types addition String. What’s important create types. In fact, creating new types fundamental activity Java programming, it’s you’ll learning rest book. Where storage lives It’s useful visualize aspects things laid program running— particular memory arranged. There five different places store data: 1. Registers. This fastest storage exists place different storage: inside processor. However, number registers severely limited, registers allocated needed. You don’t direct control, see evidence programs registers even exist (C & C++, hand, allow suggest register allocation compiler). 2. The stack. This lives general random-access memory (RAM) area, direct support processor via stack pointer. The stack pointer moved create new memory moved release memory. This extremely fast efficient way allocate storage, second registers. The Java system must know, creating program, exact lifetime items stored stack. This constraint places limits flexibility programs, Java storage exists stack—in particular, object references—Java objects placed stack. 42 Thinking Java Bruce Eckel 3. The heap. This general-purpose pool memory (also RAM area) Java objects live. The nice thing heap that, unlike stack, compiler doesn’t need know long storage must stay heap. Thus, there’s great deal flexibility using storage heap. Whenever need object, simply write code create using new, storage allocated heap code executed. Of course there’s price pay flexibility: It may take time allocate clean heap storage stack storage (if even could create objects stack Java, C++). 4. Constant storage. Constant values often placed directly program code, safe since never change. Sometimes constants cordoned optionally placed read-only memory (ROM), embedded systems. 2 5. Non-RAM storage. If data lives completely outside program, exist program running, outside control program. The two primary examples streamed objects, objects turned streams bytes, generally sent another machine, persistent objects, objects placed disk hold state even program terminated. The trick types storage turning objects something exist medium, yet resurrected regular RAMbased object necessary. Java provides support lightweight persistence, mechanisms JDBC Hibernate provide sophisticated support storing retrieving object information databases. Special case: primitive types One group types, you’ll use quite often programming, gets special treatment. You think “primitive” types. The reason special treatment create object new—especially small, simple variable—isn’t efficient, new places objects heap. For types Java falls back approach taken C C++. That is, instead creating variable using new, “automatic” variable created reference. The variable holds value directly, it’s placed stack, it’s much efficient. Java determines size primitive type. These sizes don’t change one machine architecture another languages. This size invariance one reason Java programs portable programs languages. Primitive type boolean Size — Minimum Maximum Wrapper type — — Boolean char 16 bits Unicode 0 Unicode 216- 1 Character byte 8 bits -128 +127 Byte 16 bits -215 +215-1 Short 32 bits -231 +231-1 Integer long 64 bits -263 +263-1 Long float 32 bits IEEE754 IEEE754 Float double 64 bits IEEE754 IEEE754 Double — — Void short int void — 2 An example string pool. All literal strings string-valued constant expressions interned automatically put special static storage. Everything Is Object 43 All numeric types signed, don’t look unsigned types. The size boolean type explicitly specified; defined able take literal values true false. The “wrapper” classes primitive data types allow make non-primitive object heap represent primitive type. For example: char c = ‘x’; Character ch = new Character(c); Or could also use: Character ch = new Character(‘x’); Java SE5 autoboxing automatically convert primitive wrapper type: Character ch = ‘x’; back: char c = ch; The reasons wrapping primitives shown later chapter. High-precision numbers Java includes two classes performing high-precision arithmetic: BigInteger BigDecimal. Although approximately fit category “wrapper” classes, neither one primitive analogue. Both classes methods provide analogues operations perform primitive types. That is, anything BigInteger BigDecimal int float, it’s must use method calls instead operators. Also, since there’s involved, operations slower. You’re exchanging speed accuracy. BigInteger supports arbitrary-precision integers. This means accurately represent integral values size without losing information operations. BigDecimal arbitrary-precision fixed-point numbers; use accurate monetary calculations, example. Consult JDK documentation details constructors methods call two classes. Arrays Java Virtually programming languages support kind arrays. Using arrays C C++ perilous arrays blocks memory. If program accesses array outside memory block uses memory initialization (common programming errors), unpredictable results. One primary goals Java safety, many problems plague programmers C C++ repeated Java. A Java array guaranteed initialized cannot 44 Thinking Java Bruce Eckel accessed outside range. The range checking comes price small amount memory overhead array well verifying index run time, assumption safety increased productivity worth expense (and Java sometimes optimize operations). When create array objects, really creating array references, references automatically initialized special value keyword: null. When Java sees null, recognizes reference question isn’t pointing object. You must assign object reference use it, try use reference that’s still null, problem reported run time. Thus, typical array errors prevented Java. You also create array primitives. Again, compiler guarantees initialization zeroes memory array. Arrays covered detail later chapters. You never need destroy object In programming languages, concept lifetime variable occupies significant portion programming effort. How long variable last? If supposed destroy it, you? Confusion variable lifetimes lead lot bugs, section shows Java greatly simplifies issue cleanup work you. Scoping Most procedural languages concept scope. This determines visibility lifetime names defined within scope. In C, C++, Java, scope determined placement curly braces {}. So example: { { int x = 12; // Only x available int q = 96; // Both x & q available } } // Only x available // q "out scope" A variable defined within scope available end scope. Any text ‘//’ end line comment. Indentation makes Java code easier read. Since Java free-form language, extra spaces, tabs, carriage returns affect resulting program. You cannot following, even though legal C C++: { int x = 12; { Everything Is Object 45 } int x = 96; // Illegal } The compiler announce variable x already defined. Thus C C++ ability “hide” variable larger scope allowed, Java designers thought led confusing programs. Scope objects Java objects lifetimes primitives. When create Java object using new, hangs around past end scope. Thus use: { String = new String("a string"); } // End scope reference vanishes end scope. However, String object pointing still occupying memory. In bit code, way access object end scope, reference scope. In later chapters you’ll see reference object passed around duplicated course program. It turns objects created new stay around long want them, whole slew C++ programming problems simply vanish Java. In C++ must make sure objects stay around long need them, must also destroy objects you’re done them. That brings interesting question. If Java leaves objects lying around, keeps filling memory halting program? This exactly kind problem would occur C++. This bit magic happens. Java garbage collector, looks objects created new figures ones referenced anymore. Then releases memory objects, memory used new objects. This means never need worry reclaiming memory yourself. You simply create objects, longer need them, go away themselves. This eliminates certain class programming problem: so-called “memory leak,” programmer forgets release memory. Creating new data types: class If everything object, determines particular class object looks behaves? Put another way, establishes type object? You might expect keyword called “type,” certainly would made sense. Historically, however, objectoriented languages used keyword class mean “I’m tell new type object looks like.” The class keyword (which common usually boldfaced throughout book) followed name new type. For example: class ATypeName { /* Class body goes */ } This introduces new type, although class body consists comment (the stars slashes inside, discussed later chapter), much it. However, create object type using new: ATypeName = new ATypeName(); 46 Thinking Java Bruce Eckel But cannot tell much anything (that is, cannot send interesting messages) define methods it. Fields methods When define class (and Java define classes, make objects classes, send messages objects), put two types elements class: fields (sometimes called data members), methods (sometimes called member functions). A field object type talk via reference, primitive type. If reference object, must initialize reference connect actual object (using new, seen earlier). Each object keeps storage fields; ordinary fields shared among objects. Here example class fields: class DataOnly { int i; double d; boolean b; } This class doesn’t anything except hold data. But create object like this: DataOnly data = new DataOnly(); You assign values fields, must first know refer member object. This accomplished stating name object reference, followed period (dot), followed name member inside object: objectReference.member For example: data.i = 47; data.d = 1.1; data.b = false; It also possible object might contain objects contain data you’d like modify. For this, keep “connecting dots.” For example: myPlane.leftTank.capacity = 100; The DataOnly class cannot much anything except hold data, methods. To understand work, must first understand arguments return values, described shortly. Default values primitive members When primitive data type member class, guaranteed get default value initialize it: Everything Is Object Primitive type Default boolean false char ‘\u0000’ (null) 47 Primitive type Default byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d The default values Java guarantees variable used member class. This ensures member variables primitive types always initialized (something C++ doesn’t do), reducing source bugs. However, initial value may correct even legal program writing. It’s best always explicitly initialize variables. This guarantee doesn’t apply local variables—those fields class. Thus, within method definition have: int x; Then x get arbitrary value (as C C++); automatically initialized zero. You responsible assigning appropriate value use x. If forget, Java definitely improves C++: You get compile-time error telling variable might initialized. (Many C++ compilers warn uninitialized variables, Java errors.) Methods, arguments, return values In many languages (like C C++), term function used describe named subroutine. The term commonly used Java method, “a way something.” If want, continue thinking terms functions. It’s really syntactic difference, book follows common Java usage term “method.” Methods Java determine messages object receive. The fundamental parts method name, arguments, return type, body. Here basic form: ReturnType methodName( /* Argument list */ ) { /* Method body */ } The return type describes value comes back method call it. The argument list gives types names information want pass method. The method name argument list (which called signature method) uniquely identify method. Methods Java created part class. A method called object, 3 object must able perform method call. If try call wrong method object, you’ll get error message compile time. You call method object naming object followed period (dot), followed name method argument list, like this: 3 static methods, you’ll learn soon, called class, without object. 48 Thinking Java Bruce Eckel objectName.methodName(arg1, arg2, arg3); For example, suppose method f( ) takes arguments returns value type int. Then, object called f( ) called, say this: int x = a.f(); The type return value must compatible type x. This act calling method commonly referred sending message object. In preceding example, message f( ) object a. Object-oriented programming often summarized simply “sending messages objects.” The argument list The method argument list specifies information pass method. As might guess, information—like everything else Java—takes form objects. So, must specify argument list types objects pass name use one. As situation Java seem handing objects around, actually passing references.4 The type reference must correct, however. If argument supposed String, must pass String compiler give error. Consider method takes String argument. Here definition, must placed within class definition compiled: int storage(String s) { return s.length() * 2; } This method tells many bytes required hold information particular String. (The size char String 16 bits, two bytes, support Unicode characters.) The argument type String called s. Once passed method, treat like object. (You send messages it.) Here, length( ) method called, one methods Strings; returns number characters string. You also see use return keyword, two things. First, means “Leave method, I’m done.” Second, method produces value, value placed right return statement. In case, return value produced evaluating expression s.length( ) * 2. You return type want, don’t want return anything all, indicating method returns void. Here examples: boolean flag() { return true; } double naturalLogBase() { return 2.718; } void nothing() { return; } void nothing2() {} When return type void, return keyword used exit method, therefore unnecessary reach end method. You return method point, you’ve given non-void return type, compiler force (with error messages) return appropriate type value regardless return. At point, look like program bunch objects methods take objects arguments send messages objects. That indeed much Everything Is Object 49 goes on, following chapter you’ll learn detailed low-level work making decisions within method. For chapter, sending messages suffice. Building Java program There several issues must understand seeing first Java program. Name visibility A problem programming language control names. If use name one module program, another programmer uses name another module, distinguish one name another prevent two names “clashing”? In C particular problem program often unmanageable sea names. C++ classes (on Java classes based) nest functions within classes cannot clash function names nested within classes. However, C++ still allows global data global functions, clashing still possible. To solve problem, C++ introduced namespaces using additional keywords. Java able avoid taking fresh approach. To produce unambiguous name library, Java creators want use Internet domain name reverse since domain names guaranteed unique. Since domain name MindView.net, utility library foibles would named net.mindview.utility.foibles. After reversed domain name, dots intended represent subdirectories. In Java 1.0 Java 1.1 domain extensions com, edu, org, net, etc., capitalized convention, library would appear: NET.mindview.utility.foibles. Partway development Java 2, however, discovered caused problems, entire package name lowercase. This mechanism means files automatically live namespaces, class within file must unique identifier—the language prevents name clashes you. Using components Whenever want use predefined class program, compiler must know locate it. Of course, class might already exist source-code file it’s called from. In case, simply use class—even class doesn’t get defined later file (Java eliminates so-called “forward referencing” problem). What class exists file? You might think compiler smart enough simply go find it, problem. Imagine want use class particular name, one definition class exists (presumably different definitions). Or worse, imagine you’re writing program, you’re building add new class library conflicts name existing class. To solve problem, must eliminate potential ambiguities. This accomplished telling Java compiler exactly classes want using import keyword. import tells compiler bring package, library classes. (In languages, library could consist functions data well classes, remember code Java must written inside class.) 50 Thinking Java Bruce Eckel Most time you’ll using components standard Java libraries come compiler. With these, don’t need worry long, reversed domain names; say, example: import java.util.ArrayList; tell compiler want use Java’s ArrayList class. However, util contains number classes, might want use several without declaring explicitly. This easily accomplished using ‘*’ indicate wild card: import java.util.*; It common import collection classes manner import classes individually. The static keyword Ordinarily, create class describing objects class look behave. You don’t actually get object create one using new, point storage allocated methods become available. There two situations approach sufficient. One want single piece storage particular field, regardless many objects class created, even objects created. The need method isn’t associated particular object class. That is, need method call even objects created. You achieve effects static keyword. When say something static, means particular field method tied particular object instance class. So even you’ve never created object class call static method access static field. With ordinary, non-static fields methods, must create object use object access field method, since non-static fields methods must know particular object working with. 4 Some object-oriented languages use terms class data class methods, meaning data methods exist class whole, particular objects class. Sometimes Java literature uses terms too. To make field method static, simply place keyword definition. For example, following produces static field initializes it: class StaticTest { static int = 47; } Now even make two StaticTest objects, still one piece storage StaticTest.i. Both objects share i. Consider: StaticTest st1 = new StaticTest(); StaticTest st2 = new StaticTest(); 4 Of course, since static methods don’t need objects created used, cannot directly access non-static members methods simply calling members without referring named object (since nonstatic members methods must tied particular object). Everything Is Object 51 At point, st1.i st2.i value 47 since refer piece memory. There two ways refer static variable. As preceding example indicates, name via object, saying, example, st2.i. You also refer directly class name, something cannot non-static member. StaticTest.i++; The ++ operator adds one variable. At point, st1.i st2.i value 48. Using class name preferred way refer static variable. Not emphasize variable’s static nature, cases gives compiler better opportunities optimization. Similar logic applies static methods. You refer static method either object method, special additional syntax ClassName.method( ). You define static method similar way: class Incrementable { static void increment() { StaticTest.i++; } } You see Incrementable method increment( ) increments static data using ++ operator. You call increment( ) typical way, object: Incrementable sf = new Incrementable(); sf.increment(); Or, increment( ) static method, call directly class: Incrementable.increment(); Although static, applied field, definitely changes way data created (one class versus non-static one object), applied method it’s dramatic. An important use static methods allow call method without creating object. This essential, see, defining main( ) method entry point running application. Your first Java program Finally, here’s first complete program. It starts printing string, date, using Date class Java standard library. // HelloDate.java import java.util.*; public class HelloDate { public static void main(String[] args) { System.out.println("Hello, it’s: "); System.out.println(new Date()); } } 52 Thinking Java Bruce Eckel At beginning program file, must place necessary import statements bring extra classes you’ll need code file. Note I say “extra”. That’s there’s certain library classes automatically brought every Java file: java.lang. Start Web browser look documentation Sun. (If haven’t downloaded JDK documentation http://java.sun.com, now. 5 Note documentation doesn’t come packed JDK; must separate download get it.) If look list packages, you’ll see different class libraries come Java. Select java.lang. This bring list classes part library. Since java.lang implicitly included every Java code file, classes automatically available. There’s Date class listed java.lang, means must import another library use that. If don’t know library particular class is, want see classes, select “Tree” Java documentation. Now find every single class comes Java. Then use browser’s “find” function find Date. When you’ll see listed java.util.Date, lets know it’s util library must import java.util.* order use Date. If go back beginning, select java.lang System, you’ll see System class several fields, select out, you’ll discover it’s static PrintStream object. Since it’s static, don’t need create anything new. The object always there, use it. What object determined type: PrintStream. Conveniently, PrintStream shown description hyperlink, click that, you’ll see list methods call PrintStream. There quite few, covered later book. For we’re interested println( ), effect means “Print I’m giving console end newline.” Thus, Java program write write something like this: System.out.println("A String things"); whenever want display information console. The name class name file. When you’re creating standalone program one, one classes file must name file. (The compiler complains don’t this.) That class must contain method called main( ) signature return type: public static void main(String[] args) { The public keyword means method available outside world (described detail Access Control chapter). The argument main( ) array String objects. The args won’t used program, Java compiler insists hold arguments command line. The line prints date quite interesting: System.out.println(new Date()); The argument Date object created send value (which automatically converted String) println( ). As soon statement finished, Date unnecessary, garbage collector come along get anytime. We don’t need worry cleaning up. 5 The Java compiler documentation Sun tend change regularly, best place get directly Sun. By downloading yourself, get recent version. Everything Is Object 53 When look JDK documentation http://java.sun.com, see System many methods allow produce interesting effects (one Java’s powerful assets large set standard libraries). For example: //: object/ShowProperties.java public class ShowProperties { public static void main(String[] args) { System.getProperties().list(System.out); System.out.println(System.getProperty("user.name")); System.out.println( System.getProperty("java.library.path")); } } ///:~ The first line main( ) displays “properties” system running program, gives environment information. The list( ) method sends results argument, System.out. You see later book send results elsewhere, file, example. You also ask specific property—in case, user name java.library.path. (The unusual comments beginning end explained little later.) Compiling running To compile run program, programs book, must first Java programming environment. There number third-party development environments, book I assume using Java Developer’s Kit (JDK) Sun, free. If using another development system, 6 need look documentation system determine compile run programs. Get Internet go http://java.sun.com. There find information links lead process downloading installing JDK particular platform. Once JDK installed, you’ve set computer’s path information find javac java, download unpack source code book (you find www.MindView.net). This create subdirectory chapter book. Move subdirectory named objects type: javac HelloDate.java This command produce response. If get kind error message, means haven’t installed JDK properly need investigate problems. On hand, get command prompt back, type: java HelloDate you’ll get message date output. This process use compile run programs book. However, see source code book also file called build.xml chapter, contains “Ant” commands automatically building files 6 IBM’s “jikes” compiler common alternative, significantly faster Sun’s javac (although you’re building groups files using Ant, there’s much difference). There also open-source projects create Java compilers, runtime environments, libraries. 54 Thinking Java Bruce Eckel chapter. Buildfiles Ant (including download it) described fully supplement find http://MindView.net/Books/BetterJava, Ant installed (from http://jakarta.apache.org/ant) type ‘ant’ command prompt compile run programs chapter. If haven’t installed Ant yet, type javac java commands hand. Comments embedded documentation There two types comments Java. The first traditional C-style comment inherited C++. These comments begin /* continue, possibly across many lines, */. Note many programmers begin line continued comment *, you’ll often see: /* This comment * continues * across lines */ Remember, however, everything inside /* */ ignored, there’s difference saying: /* This comment continues across lines */ The second form comment comes C++. It single-line comment, starts // continues end line. This type comment convenient commonly used it’s easy. You don’t need hunt keyboard find / * (instead, press key twice), don’t need close comment. So often see: // This one-line comment Comment documentation Possibly biggest problem documenting code maintaining documentation. If documentation code separate, becomes tedious change documentation every time change code. The solution seems simple: Link code documentation. The easiest way put everything file. To complete picture, however, need special comment syntax mark documentation tool extract comments put useful form. This Java done. The tool extract comments called Javadoc, part JDK installation. It uses technology Java compiler look special comment tags put programs. It extracts information marked tags, also pulls class name method name adjoins comment. This way get away minimal amount work generate decent program documentation. The output Javadoc HTML file view Web browser. Thus, Javadoc allows create maintain single source file automatically generate useful documentation. Because Javadoc, straightforward standard creating documentation, expect even demand documentation Java libraries. Everything Is Object 55 In addition, write Javadoc handlers, called doclets, want perform special operations information processed Javadoc (to produce output different format, example). Doclets introduced supplement http://MindView.net/Books/BetterJava. What follows introduction overview basics Javadoc. A thorough description found JDK documentation. When unpack documentation, look “tooldocs” subdirectory (or follow “tooldocs” link). Syntax All Javadoc commands occur within /** comments. The comments end */ usual. There two primary ways use Javadoc: Embed HTML use “doc tags.” Standalone doc tags commands start ‘@’ placed beginning comment line. (A leading ‘*’, however, ignored.) Inline doc tags appear anywhere within Javadoc comment also start ‘@’ surrounded curly braces. There three “types” comment documentation, correspond element comment precedes: class, field, method. That is, class comment appears right definition class, field comment appears right front definition field, method comment appears right front definition method. As simple example: //: object/Documentation1.java /** A class comment */ public class Documentation1 { /** A field comment */ public int i; /** A method comment */ public void f() {} } ///:~ Note Javadoc process comment documentation public protected members. Comments private package-access members (see Access Control chapter) ignored, you’ll see output. (However, use -private flag include private members well.) This makes sense, since public protected members available outside file, client programmer’s perspective. The output preceding code HTML file standard format rest Java documentation, users comfortable format easily navigate classes. It’s worth entering preceding code, sending Javadoc, viewing resulting HTML file see results. Embedded HTML Javadoc passes HTML commands generated HTML document. This allows full use HTML; however, primary motive let format code, as: //: object/Documentation2.java /** * <pre> * System.out.println(new Date()); * </pre> */ ///:~ You also use HTML would Web document format regular text descriptions: 56 Thinking Java Bruce Eckel //: object/Documentation3.java /** * You <em>even</em> insert list: * <ol> * <li> Item one * <li> Item two * <li> Item three * </ol> */ ///:~ Note within documentation comment, asterisks beginning line thrown away Javadoc, along leading spaces. Javadoc reformats everything conforms standard documentation appearance. Don’t use headings <h1> <hr> embedded HTML, Javadoc inserts headings interfere them. All types comment documentation—class, field, method—can support embedded HTML. Some example tags Here Javadoc tags available code documentation. Before trying anything serious using Javadoc, consult Javadoc reference JDK documentation learn different ways use Javadoc. @see This tag allows refer documentation classes. Javadoc generate HTML @see tags hyperlinked documentation. The forms are: @see classname @see fully-qualified-classname @see fully-qualified-classname#method-name Each one adds hyperlinked “See Also” entry generated documentation. Javadoc check hyperlinks give make sure valid. {@link package.class#member label} Very similar @see, except used inline uses label hyperlink text rather “See Also.” {@docRoot} Produces relative path documentation root directory. Useful explicit hyperlinking pages documentation tree. {@inheritDoc} Inherits documentation nearest base class class current doc comment. Everything Is Object 57 @version This form: @version version-information version-information significant information see fit include. When - version flag placed Javadoc command line, version information called specially generated HTML documentation. @author This form: @author author-information author-information is, presumably, name, could also include email address appropriate information. When -author flag placed Javadoc command line, author information called specially generated HTML documentation. You multiple author tags list authors, must placed consecutively. All author information lumped together single paragraph generated HTML. @since This tag allows indicate version code began using particular feature. You’ll see appearing HTML Java documentation indicate version JDK used. @param This used method documentation, form: @param parameter-name description parameter-name identifier method parameter list, description text continue subsequent lines. The description considered finished new documentation tag encountered. You number these, presumably one parameter. @return This used method documentation, looks like this: @return description description gives meaning return value. It continue subsequent lines. 58 Thinking Java Bruce Eckel @throws Exceptions demonstrated Error Handling Exceptions chapter. Briefly, objects “thrown” method method fails. Although one exception object emerge call method, particular method might produce number different types exceptions, need descriptions. So form exception tag is: @throws fully-qualified-class-name description fully-qualified-class-name gives unambiguous name exception class that’s defined somewhere, description (which continue subsequent lines) tells particular type exception emerge method call. @deprecated This used indicate features superseded improved feature. The deprecated tag suggestion longer use particular feature, since sometime future likely removed. A method marked @deprecated causes compiler issue warning used. In Java SE5, @deprecated Javadoc tag superseded @Deprecated annotation (you’ll learn Annotations chapter). Documentation example Here first Java program again, time documentation comments added: //: object/HelloDate.java import java.util.*; /** The first Thinking Java example program. * Displays string today’s date. * @author Bruce Eckel * @author www.MindView.net * @version 4.0 */ public class HelloDate { /** Entry point class & application. * @param args array string arguments * @throws exceptions No exceptions thrown */ public static void main(String[] args) { System.out.println("Hello, it’s: "); System.out.println(new Date()); } } /* Output: (55% match) Hello, it’s: Wed Oct 05 14:39:36 MDT 2005 *///:~ The first line file uses technique putting ‘//:’ special marker comment line containing source file name. That line contains path information file (object indicates chapter) followed file name. The last line also finishes comment, one (‘///:~’) indicates end source code listing, allows automatically updated text book checked compiler executed. Everything Is Object 59 The /* Output: tag indicates beginning output generated file. In form, automatically tested verify accuracy. In case, (55% match) indicates testing system output fairly different one run next expect 55 percent correlation output shown here. Most examples book produce output contain output commented form, see output know correct. Coding style The style described Code Conventions Java Programming Language 7 capitalize first letter class name. If class name consists several words, run together (that is, don’t use underscores separate names), first letter embedded word capitalized, as: class AllTheColorsOfTheRainbow { // ... This sometimes called “camel-casing.” For almost everything else—methods, fields (member variables), object reference names—the accepted style classes except first letter identifier lowercase. For example: class AllTheColorsOfTheRainbow { int anIntegerRepresentingColors; void changeTheHueOfTheColor(int newHue) { // ... } // ... } The user must also type long names, merciful. The Java code see Sun libraries also follows placement open-and-close curly braces see used book. Summary The goal chapter enough Java understand write simple program. You’ve also gotten overview language basic ideas. However, examples far form “Do this, that, something else.” The next two chapters introduce basic operators used Java programming, show control flow program. Exercises Normally, exercises distributed throughout chapters, chapter learning write basic programs exercises delayed end. The number parentheses exercise number indicator difficult exercise is, ranking 1-10. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. 7 http://java.sun.com/docs/codeconv/index.html. To preserve space book seminar presentations, guidelines could followed, you’ll see style I use matches Java standard much possible. 60 Thinking Java Bruce Eckel Exercise 1: (2) Create class containing int char initialized, print values verify Java performs default initialization. Exercise 2: (1) Following HelloDate.java example chapter, create “hello, world” program simply displays statement. You need single method class (the “main” one gets executed program starts). Remember make static include argument list, even though don’t use argument list. Compile program javac run using java. If using different development environment JDK, learn compile run programs environment. Exercise 3: (1) Find code fragments involving ATypeName turn program compiles runs. Exercise 4: (1) Turn DataOnly code fragments program compiles runs. Exercise 5: (1) Modify previous exercise values data DataOnly assigned printed main( ). Exercise 6: (2) Write program includes calls storage( ) method defined code fragment chapter. Exercise 7: (1) Turn Incrementable code fragments working program. Exercise 8: (3) Write program demonstrates that, matter many objects create particular class, one instance particular static field class. Exercise 9: (2) Write program demonstrates autoboxing works primitive types wrappers. Exercise 10: (2) Write program prints three arguments taken command line. To this, you’ll need index command-line array Strings. Exercise 11: (1) Turn AllTheColorsOfTheRainbow example program compiles runs. Exercise 12: (2) Find code second version HelloDate.java, simple comment documentation example. Execute Javadoc file view results Web browser. Exercise 13: (1) Run Documentation1.java, Documentation2.java, Documentation3.java Javadoc. Verify resulting documentation Web browser. Exercise 14: (1) Add HTML list items documentation previous exercise. Exercise 15: (1) Take program Exercise 2 add comment documentation it. Extract comment documentation HTML file using Javadoc view Web browser. Everything Is Object 61 Exercise 16: (1) In Initialization & Cleanup chapter, locate Overloading.java example add Javadoc documentation. Extract comment documentation HTML file using Javadoc view Web browser. 62 Thinking Java Bruce Eckel Operators At lowest level, data Java manipulated using operators. Because Java inherited C++, operators familiar C C++ programmers. Java also added improvements simplifications. If you’re familiar C C++ syntax, skim chapter next, looking places Java different languages. However, find floundering bit two chapters, make sure go multimedia seminar Thinking C, freely downloadable www.MindView.net. It contains audio lectures, slides, exercises, solutions specifically designed bring speed fundamentals necessary learn Java. Simpler print statements In previous chapter, introduced Java print statement: System.out.println("Rather lot type"); You may observe lot type (and thus many redundant tendon hits), also rather noisy read. Most languages Java taken much simpler approach commonly used statement. The Access Control chapter introduces concept static import added Java SE5, creates tiny library simplify writing print statements. However, don’t need know details order begin using library. We rewrite program last chapter using new library: //: operators/HelloDate.java import java.util.*; import static net.mindview.util.Print.*; public class HelloDate { public static void main(String[] args) { print("Hello, it’s: "); print(new Date()); } } /* Output: (55% match) Hello, it’s: Wed Oct 05 14:39:05 MDT 2005 *///:~ The results much cleaner. Notice insertion static keyword second import statement. In order use library, must download book’s code package www.MindView.net one mirrors. Unzip code tree add root directory code tree computer’s CLASSPATH environment variable. (You’ll eventually get full introduction classpath, might well get used struggling early. Alas, one common battles Java.) Although use net.mindview.util.Print nicely simplifies code, justifiable everywhere. If small number print statements program, I forego import write full System.out.println( ). Exercise 1: (1) Write program uses “short” normal form print statement. Using Java operators An operator takes one arguments produces new value. The arguments different form ordinary method calls, effect same. Addition unary plus (+), subtraction unary minus (-), multiplication (*), division (/), assignment (=) work much programming language. All operators produce value operands. In addition, operators change value operand. This called side effect. The common use operators modify operands generate side effect, keep mind value produced available use, operators without side effects. Almost operators work primitives. The exceptions ‘=‘, ‘==‘ ‘!=‘, work objects (and point confusion objects). In addition, String class supports ‘+’ ‘+=‘. Precedence Operator precedence defines expression evaluates several operators present. Java specific rules determine order evaluation. The easiest one remember multiplication division happen addition subtraction. Programmers often forget precedence rules, use parentheses make order evaluation explicit. For example, look statements (1) (2): //: operators/Precedence.java public class Precedence { public static void main(String[] args) { int x = 1, = 2, z = 3; int = x + - 2/2 + z; // (1) int b = x + (y - 2)/(2 + z); // (2) System.out.println("a = " + + " b = " + b); } } /* Output: = 5 b = 1 *///:~ These statements look roughly same, output see different meanings depend use parentheses. Notice System.out.println( ) statement involves ‘+’ operator. In context, ‘+’ means “string concatenation” and, necessary, “string conversion.” When compiler sees String followed ‘+’ followed non-String, attempts convert nonString String. As see output, successfully converts int String b. 64 Thinking Java Bruce Eckel Assignment Assignment performed operator =. It means “Take value right-hand side (often called rvalue) copy left-hand side (often called lvalue)”. An rvalue constant, variable, expression produces value, lvalue must distinct, named variable. (That is, must physical space store value.) For instance, assign constant value variable: = 4; cannot assign anything constant value—it cannot lvalue. (You can’t say 4 = a;.) Assignment primitives quite straightforward. Since primitive holds actual value reference object, assign primitives, copy contents one place another. For example, say = b primitives, contents b copied a. If go modify a, b naturally unaffected modification. As programmer, expect situations. When assign objects, however, things change. Whenever manipulate object, you’re manipulating reference, assign “from one object another,” you’re actually copying reference one place another. This means say c = objects, end c pointing object that, originally, pointed to. Here’s example demonstrates behavior: //: operators/Assignment.java // Assignment objects bit tricky. import static net.mindview.util.Print.*; class Tank { int level; } public class Assignment { public static void main(String[] args) { Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 9; t2.level = 47; print("1: t1.level: " + t1.level + ", t2.level: " + t2.level); t1 = t2; print("2: t1.level: " + t1.level + ", t2.level: " + t2.level); t1.level = 27; print("3: t1.level: " + t1.level + ", t2.level: " + t2.level); } } /* Output: 1: t1.level: 9, t2.level: 47 2: t1.level: 47, t2.level: 47 3: t1.level: 27, t2.level: 27 *///:~ The Tank class simple, two instances (t1 t2) created within main( ). The level field within Tank given different value, t2 assigned t1, t1 changed. In many programming languages expect t1 t2 independent times, you’ve assigned reference, changing t1 object appears change t2 object well! This t1 t2 contain reference, Operators 65 pointing object. (The original reference t1, pointed object holding value 9, overwritten assignment effectively lost; object cleaned garbage collector.) This phenomenon often called aliasing, it’s fundamental way Java works objects. But don’t want aliasing occur case? You could forego assignment say: t1.level = t2.level; This retains two separate objects instead discarding one tying t1 t2 object. You’ll soon realize manipulating fields within objects messy goes good object-oriented design principles. This nontrivial topic, keep mind assignment objects add surprises. Exercise 2: (1) Create class containing float use demonstrate aliasing. Aliasing method calls Aliasing also occur pass object method: //: operators/PassObject.java // Passing objects methods may // you’re used to. import static net.mindview.util.Print.*; class Letter { char c; } public class PassObject { static void f(Letter y) { y.c = ‘z’; } public static void main(String[] args) { Letter x = new Letter(); x.c = ‘a’; print("1: x.c: " + x.c); f(x); print("2: x.c: " + x.c); } } /* Output: 1: x.c: 2: x.c: z *///:~ In many programming languages, method f( ) would appear making copy argument Letter inside scope method. But reference passed, line y.c = ‘z’; actually changing object outside f( ). Aliasing solution complex issue covered one online supplements book. However, aware point watch pitfalls. 66 Thinking Java Bruce Eckel Exercise 3: (1) Create class containing float use demonstrate aliasing method calls. Mathematical operators The basic mathematical operators ones available programming languages: addition (+), subtraction (-), division (/), multiplication (*) modulus (%, produces remainder integer division). Integer division truncates, rather rounds, result. Java also uses shorthand notation C/C++ performs operation assignment time. This denoted operator followed equal sign, consistent operators language (whenever makes sense). For example, add 4 variable x assign result x, use: x += 4. This example shows use mathematical operators: //: operators/MathOps.java // Demonstrates mathematical operators. import java.util.*; import static net.mindview.util.Print.*; public class MathOps { public static void main(String[] args) { // Create seeded random number generator: Random rand = new Random(47); int i, j, k; // Choose value 1 100: j = rand.nextInt(100) + 1; print("j : " + j); k = rand.nextInt(100) + 1; print("k : " + k); = j + k; print("j + k : " + i); = j - k; print("j - k : " + i); = k / j; print("k / j : " + i); = k * j; print("k * j : " + i); = k % j; print("k % j : " + i); j %= k; print("j %= k : " + j); // Floating-point number tests: float u, v, w; // Applies doubles, v = rand.nextFloat(); print("v : " + v); w = rand.nextFloat(); print("w : " + w); u = v + w; print("v + w : " + u); u = v - w; print("v - w : " + u); u = v * w; print("v * w : " + u); u = v / w; print("v / w : " + u); // The following also works char, // byte, short, int, long, double: Operators 67 u += v; print("u u -= v; print("u u *= v; print("u u /= v; print("u += v : " + u); -= v : " + u); *= v : " + u); /= v : " + u); } } /* Output: j : 59 k : 56 j + k : 115 j - k : 3 k / j : 0 k * j : 3304 k % j : 56 j %= k : 3 v : 0.5309454 w : 0.0534122 v + w : 0.5843576 v - w : 0.47753322 v * w : 0.028358962 v / w : 9.940527 u += v : 10.471473 u -= v : 9.940527 u *= v : 5.2778773 u /= v : 9.940527 *///:~ To generate numbers, program first creates Random object. If create Random object arguments, Java uses current time seed random number generator, thus produce different output execution program. However, examples book, important output shown end examples consistent possible, output verified external tools. By providing seed (an initialization value random number generator always produce sequence particular seed value) creating Random object, random numbers generated time program executed, output verifiable. 1 To generate varying output, feel free remove seed examples book. The program generates number different types random numbers Random object simply calling methods nextInt( ) nextFloat( ) (you also call nextLong( ) nextDouble( )). The argument nextInt( ) sets upper bound generated number. The lower bound zero, don’t want possibility divide-by-zero, result offset one. Exercise 4: (2) Write program calculates velocity using constant distance constant time. Unary minus plus operators The unary minus (-) unary plus (+) operators binary minus plus. The compiler figures use intended way write expression. For instance, statement 1 The number 47 considered “magic number” college I attended, stuck. 68 Thinking Java Bruce Eckel x = -a; obvious meaning. The compiler able figure out: x = * -b; reader might get confused, sometimes clearer say: x = * (-b); Unary minus inverts sign data. Unary plus provides symmetry unary minus, although doesn’t effect. Auto increment decrement Java, like C, number shortcuts. Shortcuts make code much easier type, either easier harder read. Two nicer shortcuts increment decrement operators (often referred auto-increment auto-decrement operators). The decrement operator -- means “decrease one unit.” The increment operator ++ means “increase one unit.” If int, example, expression ++a equivalent (a = + 1). Increment decrement operators modify variable, also produce value variable result. There two versions type operator, often called prefix postfix versions. Preincrement means ++ operator appears variable, post-increment means ++ operator appears variable. Similarly, pre-decrement means -operator appears variable, post-decrement means -- operator appears variable. For pre-increment pre-decrement (i.e., ++a --a), operation performed value produced. For post-increment post-decrement (i.e., a++ a--), value produced, operation performed. As example: //: operators/AutoInc.java // Demonstrates ++ -- operators. import static net.mindview.util.Print.*; public class AutoInc { public static void main(String[] args) { int = 1; print("i : " + i); print("++i : " + ++i); // Pre-increment print("i++ : " + i++); // Post-increment print("i : " + i); print("--i : " + --i); // Pre-decrement print("i-- : " + i--); // Post-decrement print("i : " + i); } } /* Output: : 1 ++i : 2 i++ : 2 : 3 --i : 2 i-- : 2 : 1 *///:~ Operators 69 You see prefix form, get value operation performed, postfix form, get value operation performed. These operators, involving assignment, side effects— change operand rather using value. The increment operator one explanation name C++, implying “one step beyond C.” In early Java speech, Bill Joy (one Java creators), said “Java=C++--” (C plus plus minus minus), suggesting Java C++ unnecessary hard parts removed, therefore much simpler language. As progress book, you’ll see many parts simpler, yet ways Java isn’t much easier C++. Relational operators Relational operators generate boolean result. They evaluate relationship values operands. A relational expression produces true relationship true, false relationship untrue. The relational operators less (<), greater (>), less equal (<=), greater equal (>=), equivalent (==) equivalent (!=). Equivalence nonequivalence work primitives, comparisons won’t work type boolean. Because boolean values true false, “greater than” “less than” doesn’t make sense. Testing object equivalence The relational operators == != also work objects, meaning often confuses first-time Java programmer. Here’s example: //: operators/Equivalence.java public class Equivalence { public static void main(String[] args) { Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.println(n1 == n2); System.out.println(n1 != n2); } } /* Output: false true *///:~ The statement System.out.println(n1 == n2) print result boolean comparison within it. Surely output “true” “false,” since Integer objects same. But contents objects same, references same. The operators == != compare object references, output actually “false” “true.” Naturally, surprises people first. What want compare actual contents object equivalence? You must use special method equals( ) exists objects (not primitives, work fine == !=). Here’s it’s used: //: operators/EqualsMethod.java public class EqualsMethod { public static void main(String[] args) { Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.println(n1.equals(n2)); 70 Thinking Java Bruce Eckel } } /* Output: true *///:~ The result expect. Ah, it’s simple that. If create class, like this: //: operators/EqualsMethod2.java // Default equals() compare contents. class Value { int i; } public class EqualsMethod2 { public static void main(String[] args) { Value v1 = new Value(); Value v2 = new Value(); v1.i = v2.i = 100; System.out.println(v1.equals(v2)); } } /* Output: false *///:~ things confusing again: The result false. This default behavior equals( ) compare references. So unless override equals( ) new class won’t get desired behavior. Unfortunately, won’t learn overriding Reusing Classes chapter proper way define equals( ) Containers Depth chapter, aware way equals( ) behaves might save grief meantime. Most Java library classes implement equals( ) compares contents objects instead references. Exercise 5: (2) Create class called Dog containing two Strings: name says. In main( ), create two dog objects names “spot” (who says, “Ruff!”) “scruffy” (who says, “Wurf!”). Then display names say. Exercise 6: (3) Following Exercise 5, create new Dog reference assign spot’s object. Test comparison using == equals( ) references. Logical operators Each logical operators AND (&&), OR (||) NOT (!) produces boolean value true false based logical relationship arguments. This example uses relational logical operators: //: operators/Bool.java // Relational logical operators. import java.util.*; import static net.mindview.util.Print.*; public class Bool { public static void main(String[] args) { Random rand = new Random(47); int = rand.nextInt(100); Operators 71 int j = rand.nextInt(100); print("i = " + i); print("j = " + j); print("i > j " + (i > j)); print("i < j " + (i < j)); print("i >= j " + (i >= j)); print("i <= j " + (i <= j)); print("i == j " + (i == j)); print("i != j " + (i != j)); // Treating int boolean legal Java: //! print("i && j " + (i && j)); //! print("i || j " + (i || j)); //! print("!i " + !i); print("(i < 10) && (j < 10) " + ((i < 10) && (j < 10)) ); print("(i < 10) || (j < 10) " + ((i < 10) || (j < 10)) ); } } /* Output: = 58 j = 55 > j true < j false >= j true <= j false == j false != j true (i < 10) && (j < 10) false (i < 10) || (j < 10) false *///:~ You apply AND, OR, NOT boolean values only. You can’t use non-boolean boolean logical expression C C++. You see failed attempts commented ‘//!’ (this comment syntax enables automatic removal comments facilitate testing). The subsequent expressions, however, produce boolean values using relational comparisons, use logical operations results. Note boolean value automatically converted appropriate text form used String expected. You replace definition int preceding program primitive data type except boolean. Be aware, however, comparison floating point numbers strict. A number tiniest fraction different another number still “not equal.” A number tiniest bit zero still nonzero. Exercise 7: (3) Write program simulates coin-flipping. Short-circuiting When dealing logical operators, run phenomenon called “short-circuiting.” This means expression evaluated truth falsehood entire expression unambiguously determined. As result, latter parts logical expression might evaluated. Here’s example demonstrates short-circuiting: //: operators/ShortCircuit.java // Demonstrates short-circuiting behavior // logical operators. import static net.mindview.util.Print.*; 72 Thinking Java Bruce Eckel public class ShortCircuit { static boolean test1(int val) { print("test1(" + val + ")"); print("result: " + (val < 1)); return val < 1; } static boolean test2(int val) { print("test2(" + val + ")"); print("result: " + (val < 2)); return val < 2; } static boolean test3(int val) { print("test3(" + val + ")"); print("result: " + (val < 3)); return val < 3; } public static void main(String[] args) { boolean b = test1(0) && test2(2) && test3(2); print("expression " + b); } } /* Output: test1(0) result: true test2(2) result: false expression false *///:~ Each test performs comparison argument returns true false. It also prints information show it’s called. The tests used expression: test1(0) && test2(2) && test3(2) You might naturally think three tests would executed, output shows otherwise. The first test produced true result, expression evaluation continues. However, second test produced false result. Since means whole expression must false, continue evaluating rest expression? It might expensive. The reason shortcircuiting, fact, get potential performance increase parts logical expression need evaluated. Literals Ordinarily, insert literal value program, compiler knows exactly type make it. Sometimes, however, type ambiguous. When happens, must guide compiler adding extra information form characters associated literal value. The following code shows characters: //: operators/Literals.java import static net.mindview.util.Print.*; public class Literals { public static void main(String[] args) { int i1 = 0x2f; // Hexadecimal (lowercase) print("i1: " + Integer.toBinaryString(i1)); int i2 = 0X2F; // Hexadecimal (uppercase) print("i2: " + Integer.toBinaryString(i2)); int i3 = 0177; // Octal (leading zero) print("i3: " + Integer.toBinaryString(i3)); char c = 0xffff; // max char hex value Operators 73 print("c: " + Integer.toBinaryString(c)); byte b = 0x7f; // max byte hex value print("b: " + Integer.toBinaryString(b)); short = 0x7fff; // max short hex value print("s: " + Integer.toBinaryString(s)); long n1 = 200L; // long suffix long n2 = 200l; // long suffix (but confusing) long n3 = 200; float f1 = 1; float f2 = 1F; // float suffix float f3 = 1f; // float suffix double d1 = 1d; // double suffix double d2 = 1D; // double suffix // (Hex Octal also work long) } } /* Output: i1: 101111 i2: 101111 i3: 1111111 c: 1111111111111111 b: 1111111 s: 111111111111111 *///:~ A trailing character literal value establishes type. Uppercase lowercase L means long (however, using lowercase l confusing look like number one). Uppercase lowercase F means float. Uppercase lowercase D means double. Hexadecimal (base 16), works integral data types, denoted leading 0x 0X followed 0-9 a-f either uppercase lowercase. If try initialize variable value bigger hold (regardless numerical form value), compiler give error message. Notice preceding code maximum possible hexadecimal values char, byte, short. If exceed these, compiler automatically make value int tell need narrowing cast assignment (casts defined later chapter). You’ll know you’ve stepped line. Octal (base 8) denoted leading zero number digits 0-7. There literal representation binary numbers C, C++, Java. However, working hexadecimal octal notation, it’s useful display binary form results. This easily accomplished static toBinaryString( ) methods Integer Long classes. Notice passing smaller types Integer.toBinaryString( ), type automatically converted int. Exercise 8: (2) Show hex octal notations work long values. Use Long.toBinaryString( ) display results. Exponential notation Exponents use notation I’ve always found rather dismaying: //: operators/Exponents.java // "e" means "10 power." public class Exponents { public static void main(String[] args) { // Uppercase lowercase ‘e’ same: float expFloat = 1.39e-43f; expFloat = 1.39E-43f; 74 Thinking Java Bruce Eckel System.out.println(expFloat); double expDouble = 47e47d; // ‘d’ optional double expDouble2 = 47e47; // Automatically double System.out.println(expDouble); } } /* Output: 1.39E-43 4.7E48 *///:~ In science engineering, ‘e’ refers base natural logarithms, approximately 2.718. (A precise double value available Java Math.E.) This used exponentiation expressions 1.39 x e-43, means 1.39 x 2.718-43. However, FORTRAN programming language invented, decided e would mean “ten power”, odd decision FORTRAN designed science engineering, one would think designers would sensitive introducing ambiguity. 2 At rate, custom followed C, C++ Java. So you’re used thinking terms e base natural logarithms, must mental translation see expression 1.39 e-43f Java; means 1.39 x 10-43. Note don’t need use trailing character compiler figure appropriate type. With long n3 = 200; there’s ambiguity, L 200 would superfluous. However, float f4 = 1e-43f; // 10 power compiler normally takes exponential numbers doubles, without trailing f, give error telling must use cast convert double float. Exercise 9: (1) Display largest smallest numbers float double exponential notation. Bitwise operators The bitwise operators allow manipulate individual bits integral primitive data type. Bitwise operators perform Boolean algebra corresponding bits two arguments produce result. The bitwise operators come C’s low-level orientation, often manipulate hardware directly must set bits hardware registers. Java originally designed embedded TV set-top boxes, low-level orientation still made sense. However, probably won’t use bitwise operators much. 2 John Kirkham writes, “I started computing 1962 using FORTRAN II IBM 1620. At time, throughout 1960s 1970s, FORTRAN uppercase language. This probably started many early input devices old teletype units used 5 bit Baudot code, lowercase capability. The ‘E’ exponential notation also always uppercase never confused natural logarithm base ‘e’, always lowercase. The ‘E’ simply stood exponential, base number system used—usually 10. At time octal also widely used programmers. Although I never saw used, I seen octal number exponential notation I would considered base 8. The first time I remember seeing exponential using lowercase ‘e’ late 1970s I also found confusing. The problem arose lowercase crept FORTRAN, beginning. We actually functions use really wanted use natural logarithm base, uppercase.” Operators 75 The bitwise AND operator (&) produces one output bit input bits one; otherwise, produces zero. The bitwise OR operator (|) produces one output bit either input bit one produces zero input bits zero. The bitwise EXCLUSIVE OR, XOR (^), produces one output bit one input bit one, both. The bitwise NOT (~, also called ones complement operator) unary operator; takes one argument. (All bitwise operators binary operators.) Bitwise NOT produces opposite input bit—a one input bit zero, zero input bit one. The bitwise operators logical operators use characters, helpful mnemonic device help remember meanings: Because bits “small”, one character bitwise operators. Bitwise operators combined = sign unite operation assignment: &=, |= ^= legitimate. (Since ~ unary operator, cannot combined = sign.) The boolean type treated one-bit value, somewhat different. You perform bitwise AND, OR, XOR, can’t perform bitwise NOT (presumably prevent confusion logical NOT). For booleans, bitwise operators effect logical operators except short circuit. Also, bitwise operations booleans include XOR logical operator included list “logical” operators. You cannot use booleans shift expressions, described next. Exercise 10: (3) Write program two constant values, one alternating binary ones zeroes, zero least-significant digit, second, also alternating, one least-significant digit (hint: It’s easiest use hexadecimal constants this). Take two values combine possible ways using bitwise operators, display results using Integer.toBinaryString( ). Shift operators The shift operators also manipulate bits. They used solely primitive, integral types. The left-shift operator (<<) produces operand left operator shifted left number bits specified right operator (inserting zeroes lower-order bits). The signed right-shift operator (>>) produces operand left operator shifted right number bits specified right operator. The signed right shift >> uses sign extension: If value positive, zeroes inserted higher-order bits; value negative, ones inserted higher-order bits. Java also added unsigned right shift >>>, uses zero extension: Regardless sign, zeroes inserted higher-order bits. This operator exist C C++. If shift char, byte, short, promoted int shift takes place, result int. Only five low-order bits right-hand side used. This prevents shifting number bits int. If you’re operating long, you’ll get long result. Only six low-order bits right-hand side used, can’t shift number bits long. Shifts combined equal sign (<<= >>= >>>=). The lvalue replaced lvalue shifted rvalue. There problem, however, unsigned right shift combined assignment. If use byte short, don’t get correct results. Instead, promoted int right shifted, truncated assigned back variables, get -1 cases. The following example demonstrates this: 76 Thinking Java Bruce Eckel //: operators/URShift.java // Test unsigned right shift. import static net.mindview.util.Print.*; public class URShift { public static void main(String[] args) { int = -1; print(Integer.toBinaryString(i)); >>>= 10; print(Integer.toBinaryString(i)); long l = -1; print(Long.toBinaryString(l)); l >>>= 10; print(Long.toBinaryString(l)); short = -1; print(Integer.toBinaryString(s)); >>>= 10; print(Integer.toBinaryString(s)); byte b = -1; print(Integer.toBinaryString(b)); b >>>= 10; print(Integer.toBinaryString(b)); b = -1; print(Integer.toBinaryString(b)); print(Integer.toBinaryString(b>>>10)); } } /* Output: 11111111111111111111111111111111 1111111111111111111111 1111111111111111111111111111111111111111111111111111111111111111 111111111111111111111111111111111111111111111111111111 11111111111111111111111111111111 11111111111111111111111111111111 11111111111111111111111111111111 11111111111111111111111111111111 11111111111111111111111111111111 1111111111111111111111 *///:~ In last shift, resulting value assigned back b, printed directly, correct behavior occurs. Here’s example demonstrates use operators involving bits: //: operators/BitManipulation.java // Using bitwise operators. import java.util.*; import static net.mindview.util.Print.*; public class BitManipulation { public static void main(String[] args) { Random rand = new Random(47); int = rand.nextInt(); int j = rand.nextInt(); printBinaryInt("-1", -1); printBinaryInt("+1", +1); int maxpos = 2147483647; printBinaryInt("maxpos", maxpos); int maxneg = -2147483648; printBinaryInt("maxneg", maxneg); printBinaryInt("i", i); printBinaryInt("~i", ~i); Operators 77 printBinaryInt("-i", -i); printBinaryInt("j", j); printBinaryInt("i & j", & j); printBinaryInt("i | j", | j); printBinaryInt("i ^ j", ^ j); printBinaryInt("i << 5", << 5); printBinaryInt("i >> 5", >> 5); printBinaryInt("(~i) >> 5", (~i) >> 5); printBinaryInt("i >>> 5", >>> 5); printBinaryInt("(~i) >>> 5", (~i) >>> 5); long l = rand.nextLong(); long = rand.nextLong(); printBinaryLong("-1L", -1L); printBinaryLong("+1L", +1L); long = 9223372036854775807L; printBinaryLong("maxpos", ll); long lln = -9223372036854775808L; printBinaryLong("maxneg", lln); printBinaryLong("l", l); printBinaryLong("~l", ~l); printBinaryLong("-l", -l); printBinaryLong("m", m); printBinaryLong("l & m", l & m); printBinaryLong("l | m", l | m); printBinaryLong("l ^ m", l ^ m); printBinaryLong("l << 5", l << 5); printBinaryLong("l >> 5", l >> 5); printBinaryLong("(~l) >> 5", (~l) >> 5); printBinaryLong("l >>> 5", l >>> 5); printBinaryLong("(~l) >>> 5", (~l) >>> 5); } static void printBinaryInt(String s, int i) { print(s + ", int: " + + ", binary:\n " + Integer.toBinaryString(i)); } static void printBinaryLong(String s, long l) { print(s + ", long: " + l + ", binary:\n " + Long.toBinaryString(l)); } } /* Output: -1, int: -1, binary: 11111111111111111111111111111111 +1, int: 1, binary: 1 maxpos, int: 2147483647, binary: 1111111111111111111111111111111 maxneg, int: -2147483648, binary: 10000000000000000000000000000000 i, int: -1172028779, binary: 10111010001001000100001010010101 ~i, int: 1172028778, binary: 1000101110110111011110101101010 -i, int: 1172028779, binary: 1000101110110111011110101101011 j, int: 1717241110, binary: 1100110010110110000010100010110 & j, int: 570425364, binary: 100010000000000000000000010100 | j, int: -25213033, binary: 11111110011111110100011110010111 ^ j, int: -595638397, binary: 11011100011111110100011110000011 78 Thinking Java Bruce Eckel << 5, int: 1149784736, binary: 1000100100010000101001010100000 >> 5, int: -36625900, binary: 11111101110100010010001000010100 (~i) >> 5, int: 36625899, binary: 10001011101101110111101011 >>> 5, int: 97591828, binary: 101110100010010001000010100 (~i) >>> 5, int: 36625899, binary: 10001011101101110111101011 ... *///:~ The two methods end, printBinaryInt( ) printBinaryLong( ), take int long, respectively, print binary format along descriptive string. As well demonstrating effect bitwise operators int long, example also shows minimum, maximum, +1, -1 values int long see look like. Note high bit represents sign: 0 means positive 1 means negative. The output int portion displayed above. The binary representation numbers referred signed twos complement. Exercise 11: (3) Start number binary one significant position (hint: Use hexadecimal constant). Using signed right-shift operator, right shift way binary positions, time displaying result using Integer.toBinaryString( ). Exercise 12: (3) Start number binary ones. Left shift it, use unsigned right-shift operator right shift binary positions, time displaying result using Integer.toBinaryString( ). Exercise 13: (1) Write method displays char values binary form. Demonstrate using several different characters. Ternary if-else operator The ternary operator, also called conditional operator, unusual three operands. It truly operator produces value, unlike ordinary if-else statement you’ll see next section chapter. The expression form: boolean-exp ? value0 : value1 If boolean-exp evaluates true, value0 evaluated, result becomes value produced operator. If boolean-exp false, value1 evaluated result becomes value produced operator. Of course, could use ordinary if-else statement (described later), ternary operator much terser. Although C (where operator originated) prides terse language, ternary operator might introduced partly efficiency, somewhat wary using everyday basis—it’s easy produce unreadable code. The conditional operator different if-else produces value. Here’s example comparing two: //: operators/TernaryIfElse.java Operators 79 import static net.mindview.util.Print.*; public class TernaryIfElse { static int ternary(int i) { return < 10 ? * 100 : * 10; } static int standardIfElse(int i) { if(i < 10) return * 100; else return * 10; } public static void main(String[] args) { print(ternary(9)); print(ternary(10)); print(standardIfElse(9)); print(standardIfElse(10)); } } /* Output: 900 100 900 100 *///:~ You see code ternary( ) compact you’d need write without ternary operator, standardIfElse( ). However, standardIfElse( ) easier understand, doesn’t require lot typing. So sure ponder reasons choosing ternary operator—it’s generally warranted you’re setting variable one two values. String operator + += There’s one special usage operator Java: The + += operators used concatenate strings, you’ve already seen. It seems natural use operators even though doesn’t fit traditional way used. This capability seemed like good idea C++, operator overloading added C++ allow C++ programmer add meanings almost operator. Unfortunately, operator overloading combined restrictions C++ turns fairly complicated feature programmers design classes. Although operator overloading would much simpler implement Java C++ (as demonstrated C# language, straightforward operator overloading), feature still considered complex, Java programmers cannot implement overloaded operators like C++ C# programmers can. The use String operators interesting behavior. If expression begins String, operands follow must Strings (remember compiler automatically turns double-quoted sequence characters String): //: operators/StringOperators.java import static net.mindview.util.Print.*; public class StringOperators { public static void main(String[] args) { int x = 0, = 1, z = 2; String = "x, y, z "; print(s + x + + z); print(x + " " + s); // Converts x String 80 Thinking Java Bruce Eckel += "(summed) = "; // Concatenation operator print(s + (x + + z)); print("" + x); // Shorthand Integer.toString() } } /* Output: x, y, z 012 0 x, y, z x, y, z (summed) = 3 0 *///:~ Note output first print statement ‘o12’ instead ‘3’, you’d get summing integers. This Java compiler converts x, y, z String representations concatenates strings, instead adding together first. The second print statement converts leading variable String, string conversion depend comes first. Finally, see use += operator append string s, use parentheses control order evaluation expression ints actually summed displayed. Notice last example main( ): sometimes see empty String followed + primitive way perform conversion without calling cumbersome explicit method (Integer.toString( ), case). Common pitfalls using operators One pitfalls using operators attempting leave parentheses even least bit uncertain expression evaluate. This still true Java. An extremely common error C C++ looks like this: while(x = y) { // .... } The programmer clearly trying test equivalence (==) rather assignment. In C C++ result assignment always true nonzero, you’ll probably get infinite loop. In Java, result expression boolean, compiler expects boolean won’t convert int, conveniently give compile-time error catch problem ever try run program. So pitfall never happens Java. (The time won’t get compiletime error x boolean, case x = legal expression, preceding example, probably error.) A similar problem C C++ using bitwise AND OR instead logical versions. Bitwise AND OR use one characters (& |) logical AND OR use two (&& ||). Just = ==, it’s easy type one character instead two. In Java, compiler prevents this, won’t let cavalierly use one type doesn’t belong. Casting operators The word cast used sense “casting mold.” Java automatically change one type data another appropriate. For instance, assign integral value floating point variable, compiler automatically convert int float. Casting Operators 81 allows make type conversion explicit, force wouldn’t normally happen. To perform cast, put desired data type inside parentheses left value. You see following example: //: operators/Casting.java public class Casting { public static void main(String[] args) { int = 200; long lng = (long)i; lng = i; // "Widening," cast really required long lng2 = (long)200; lng2 = 200; // A "narrowing conversion": = (int)lng2; // Cast required } } ///:~ As see, it’s possible perform cast numeric value well variable. Notice introduce superfluous casts; example, compiler automatically promote int value long necessary. However, allowed use superfluous casts make point clarify code. In situations, cast may essential get code compile. In C C++, casting cause headaches. In Java, casting safe, exception perform so-called narrowing conversion (that is, go data type hold information one doesn’t hold much), run risk losing information. Here compiler forces use cast, effect saying, “This dangerous thing do—if want anyway must make cast explicit.” With widening conversion explicit cast needed, new type hold information old type information ever lost. Java allows cast primitive type primitive type, except boolean, doesn’t allow casting all. Class types allow casting. To convert one other, must special methods. (You’ll find later book objects cast within family types; Oak cast Tree vice versa, foreign type Rock.) Truncation rounding When performing narrowing conversions, must pay attention issues truncation rounding. For example, cast floating point value integral value, Java do? For example, value 29.7 cast int, resulting value 30 29? The answer seen example: //: operators/CastingNumbers.java // What happens cast float // double integral value? import static net.mindview.util.Print.*; public class CastingNumbers { public static void main(String[] args) { double = 0.7, = 0.4; float fabove = 0.7f, fbelow = 0.4f; print("(int)above: " + (int)above); print("(int)below: " + (int)below); print("(int)fabove: " + (int)fabove); 82 Thinking Java Bruce Eckel print("(int)fbelow: " + (int)fbelow); } } /* Output: (int)above: 0 (int)below: 0 (int)fabove: 0 (int)fbelow: 0 *///:~ So answer casting float double integral value always truncates number. If instead want result rounded, use round( ) methods java.lang.Math: //: operators/RoundingNumbers.java // Rounding floats doubles. import static net.mindview.util.Print.*; public class RoundingNumbers { public static void main(String[] args) { double = 0.7, = 0.4; float fabove = 0.7f, fbelow = 0.4f; print("Math.round(above): " + Math.round(above)); print("Math.round(below): " + Math.round(below)); print("Math.round(fabove): " + Math.round(fabove)); print("Math.round(fbelow): " + Math.round(fbelow)); } } /* Output: Math.round(above): 1 Math.round(below): 0 Math.round(fabove): 1 Math.round(fbelow): 0 *///:~ Since round( ) part java.lang, don’t need extra import use it. Promotion You’ll discover perform mathematical bitwise operations primitive data types smaller int (that is, char, byte, short), values promoted int performing operations, resulting value type int. So want assign back smaller type, must use cast. (And, since you’re assigning back smaller type, might losing information.) In general, largest data type expression one determines size result expression; multiply float double, result double; add int long, result long. Java “sizeof” In C C++, sizeof( ) operator tells number bytes allocated data items. The compelling reason sizeof( ) C C++ portability. Different data types might different sizes different machines, programmer must discover big types performing operations sensitive size. For example, one computer might store integers 32 bits, whereas another might store integers 16 bits. Programs could store larger values integers first machine. As might imagine, portability huge headache C C++ programmers. Operators 83 Java need sizeof( ) operator purpose, data types size machines. You need think portability level—it designed language. A compendium operators The following example shows primitive data types used particular operators. Basically, example repeated over, using different primitive data types. The file compile without error lines fail commented //!. //: operators/AllOps.java // Tests operators primitive data types // show ones accepted Java compiler. public class AllOps { // To accept results boolean test: void f(boolean b) {} void boolTest(boolean x, boolean y) { // Arithmetic operators: //! x = x * y; //! x = x / y; //! x = x % y; //! x = x + y; //! x = x - y; //! x++; //! x--; //! x = +y; //! x = -y; // Relational logical: //! f(x > y); //! f(x >= y); //! f(x < y); //! f(x <= y); f(x == y); f(x != y); f(!y); x = x && y; x = x || y; // Bitwise operators: //! x = ~y; x = x & y; x = x | y; x = x ^ y; //! x = x << 1; //! x = x >> 1; //! x = x >>> 1; // Compound assignment: //! x += y; //! x -= y; //! x *= y; //! x /= y; //! x %= y; //! x <<= 1; //! x >>= 1; //! x >>>= 1; x &= y; x ^= y; x |= y; // Casting: 84 Thinking Java Bruce Eckel //! //! //! //! //! //! //! char c = (char)x; byte b = (byte)x; short = (short)x; int = (int)x; long l = (long)x; float f = (float)x; double = (double)x; } void charTest(char x, char y) { // Arithmetic operators: x = (char)(x * y); x = (char)(x / y); x = (char)(x % y); x = (char)(x + y); x = (char)(x - y); x++; x--; x = (char)+y; x = (char)-y; // Relational logical: f(x > y); f(x >= y); f(x < y); f(x <= y); f(x == y); f(x != y); //! f(!x); //! f(x && y); //! f(x || y); // Bitwise operators: x= (char)~y; x = (char)(x & y); x = (char)(x | y); x = (char)(x ^ y); x = (char)(x << 1); x = (char)(x >> 1); x = (char)(x >>> 1); // Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; x <<= 1; x >>= 1; x >>>= 1; x &= y; x ^= y; x |= y; // Casting: //! boolean bl = (boolean)x; byte b = (byte)x; short = (short)x; int = (int)x; long l = (long)x; float f = (float)x; double = (double)x; } void byteTest(byte x, byte y) { // Arithmetic operators: x = (byte)(x* y); x = (byte)(x / y); x = (byte)(x % y); Operators 85 x = (byte)(x + y); x = (byte)(x - y); x++; x--; x = (byte)+ y; x = (byte)- y; // Relational logical: f(x > y); f(x >= y); f(x < y); f(x <= y); f(x == y); f(x != y); //! f(!x); //! f(x && y); //! f(x || y); // Bitwise operators: x = (byte)~y; x = (byte)(x & y); x = (byte)(x | y); x = (byte)(x ^ y); x = (byte)(x << 1); x = (byte)(x >> 1); x = (byte)(x >>> 1); // Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; x <<= 1; x >>= 1; x >>>= 1; x &= y; x ^= y; x |= y; // Casting: //! boolean bl = (boolean)x; char c = (char)x; short = (short)x; int = (int)x; long l = (long)x; float f = (float)x; double = (double)x; } void shortTest(short x, short y) { // Arithmetic operators: x = (short)(x * y); x = (short)(x / y); x = (short)(x % y); x = (short)(x + y); x = (short)(x - y); x++; x--; x = (short)+y; x = (short)-y; // Relational logical: f(x > y); f(x >= y); f(x < y); f(x <= y); f(x == y); f(x != y); 86 Thinking Java Bruce Eckel //! f(!x); //! f(x && y); //! f(x || y); // Bitwise operators: x = (short)~y; x = (short)(x & y); x = (short)(x | y); x = (short)(x ^ y); x = (short)(x << 1); x = (short)(x >> 1); x = (short)(x >>> 1); // Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; x <<= 1; x >>= 1; x >>>= 1; x &= y; x ^= y; x |= y; // Casting: //! boolean bl = (boolean)x; char c = (char)x; byte b = (byte)x; int = (int)x; long l = (long)x; float f = (float)x; double = (double)x; } void intTest(int x, int y) { // Arithmetic operators: x = x * y; x = x / y; x = x % y; x = x + y; x = x - y; x++; x--; x = +y; x = -y; // Relational logical: f(x > y); f(x >= y); f(x < y); f(x <= y); f(x == y); f(x != y); //! f(!x); //! f(x && y); //! f(x || y); // Bitwise operators: x = ~y; x = x & y; x = x | y; x = x ^ y; x = x << 1; x = x >> 1; x = x >>> 1; // Compound assignment: x += y; Operators 87 x -= y; x *= y; x /= y; x %= y; x <<= 1; x >>= 1; x >>>= 1; x &= y; x ^= y; x |= y; // Casting: //! boolean bl = (boolean)x; char c = (char)x; byte b = (byte)x; short = (short)x; long l = (long)x; float f = (float)x; double = (double)x; } void longTest(long x, long y) { // Arithmetic operators: x = x * y; x = x / y; x = x % y; x = x + y; x = x - y; x++; x--; x = +y; x = -y; // Relational logical: f(x > y); f(x >= y); f(x < y); f(x <= y); f(x == y); f(x != y); //! f(!x); //! f(x && y); //! f(x || y); // Bitwise operators: x = ~y; x = x & y; x = x | y; x = x ^ y; x = x << 1; x = x >> 1; x = x >>> 1; // Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; x <<= 1; x >>= 1; x >>>= 1; x &= y; x ^= y; x |= y; // Casting: //! boolean bl = (boolean)x; char c = (char)x; 88 Thinking Java Bruce Eckel byte b = (byte)x; short = (short)x; int = (int)x; float f = (float)x; double = (double)x; } void floatTest(float x, float y) { // Arithmetic operators: x = x * y; x = x / y; x = x % y; x = x + y; x = x - y; x++; x--; x = +y; x = -y; // Relational logical: f(x > y); f(x >= y); f(x < y); f(x <= y); f(x == y); f(x != y); //! f(!x); //! f(x && y); //! f(x || y); // Bitwise operators: //! x = ~y; //! x = x & y; //! x = x | y; //! x = x ^ y; //! x = x << 1; //! x = x >> 1; //! x = x >>> 1; // Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; //! x <<= 1; //! x >>= 1; //! x >>>= 1; //! x &= y; //! x ^= y; //! x |= y; // Casting: //! boolean bl = (boolean)x; char c = (char)x; byte b = (byte)x; short = (short)x; int = (int)x; long l = (long)x; double = (double)x; } void doubleTest(double x, double y) { // Arithmetic operators: x = x * y; x = x / y; x = x % y; x = x + y; x = x - y; Operators 89 x++; x--; x = +y; x = -y; // Relational logical: f(x > y); f(x >= y); f(x < y); f(x <= y); f(x == y); f(x != y); //! f(!x); //! f(x && y); //! f(x || y); // Bitwise operators: //! x = ~y; //! x = x & y; //! x = x | y; //! x = x ^ y; //! x = x << 1; //! x = x >> 1; //! x = x >>> 1; // Compound assignment: x += y; x -= y; x *= y; x /= y; x %= y; //! x <<= 1; //! x >>= 1; //! x >>>= 1; //! x &= y; //! x ^= y; //! x |= y; // Casting: //! boolean bl = (boolean)x; char c = (char)x; byte b = (byte)x; short = (short)x; int = (int)x; long l = (long)x; float f = (float)x; } } ///:~ Note boolean quite limited. You assign values true false, test truth falsehood, cannot add booleans perform type operation them. In char, byte, short, see effect promotion arithmetic operators. Each arithmetic operation types produces int result, must explicitly cast back original type (a narrowing conversion might lose information) assign back type. With int values, however, need cast, everything already int. Don’t lulled thinking everything safe, though. If multiply two ints big enough, you’ll overflow result. The following example demonstrates this: //: operators/Overflow.java // Surprise! Java lets overflow. public class Overflow { public static void main(String[] args) { 90 Thinking Java Bruce Eckel int big = Integer.MAX_VALUE; System.out.println("big = " + big); int bigger = big * 4; System.out.println("bigger = " + bigger); } } /* Output: big = 2147483647 bigger = -4 *///:~ You get errors warnings compiler, exceptions run time. Java good, it’s good. Compound assignments require casts char, byte, short, even though performing promotions results direct arithmetic operations. On hand, lack cast certainly simplifies code. You see that, exception boolean, primitive type cast primitive type. Again, must aware effect narrowing conversion casting smaller type; otherwise, might unknowingly lose information cast. Exercise 14: (3) Write method takes two String arguments uses boolean comparisons compare two Strings print results. For == !=, also perform equals( ) test. In main( ), call method different String objects. Summary If you’ve experience languages use C-like syntax, see operators Java similar virtually learning curve. If found chapter challenging, make sure view multimedia presentation Thinking C, available www.MindView.net. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Operators 91 Controlling Execution Like sentient creature, program must manipulate world make choices execution. In Java make choices execution control statements. Java uses C’s execution control statements, you’ve programmed C C++, see familiar. Most procedural programming languages kind control statements, often overlap among languages. In Java, keywords include if-else, while, do-while, for, return, break, selection statement called switch. Java not, however, support much-maligned goto (which still expedient way solve certain types problems). You still goto-like jump, much constrained typical goto. true false All conditional statements use truth falsehood conditional expression determine execution path. An example conditional expression == b. This uses conditional operator == see value equivalent value b. The expression returns true false. Any relational operators you’ve seen previous chapter used produce conditional statement. Note Java doesn’t allow use number boolean, even though it’s allowed C C++ (where truth nonzero falsehood zero). If want use non-boolean boolean test, if(a), must first convert boolean value using conditional expression, if(a != 0). if-else The if-else statement basic way control program flow. The else optional, use two forms: if(Boolean-expression) statement if(Boolean-expression) statement else statement The Boolean-expression must produce boolean result. The statement either simple statement terminated semicolon, compound statement, group simple statements enclosed braces. Whenever word “statement” used, always implies statement simple compound. As example if-else, test( ) method tell whether guess above, below, equivalent target number: //: control/IfElse.java import static net.mindview.util.Print.*; public class IfElse { static int result = 0; static void test(int testval, int target) { if(testval > target) result = +1; else if(testval < target) result = -1; else result = 0; // Match } public static void main(String[] args) { test(10, 5); print(result); test(5, 10); print(result); test(5, 5); print(result); } } /* Output: 1 -1 0 *///:~ In middle test( ), you’ll also see “else if,” new keyword else followed new statement. Although Java, like C C++ it, “free-form” language, conventional indent body control flow statement reader easily determine begins ends. Iteration Looping controlled while, do-while for, sometimes classified iteration statements. A statement repeats controlling Boolean-expression evaluates false. The form loop is: while(Boolean-expression) statement The Boolean-expression evaluated beginning loop iteration statement. Here’s simple example generates random numbers particular condition met: //: control/WhileTest.java // Demonstrates loop. public class WhileTest { static boolean condition() { boolean result = Math.random() < 0.99; System.out.print(result + ", "); return result; } public static void main(String[] args) { while(condition()) System.out.println("Inside ‘while’"); System.out.println("Exited ‘while’"); } } /* (Execute see output) *///:~ 94 Thinking Java Bruce Eckel The condition( ) method uses static method random( ) Math library, generates double value 0 1. (It includes 0, 1.) The result value comes comparison operator <, produces boolean result. If print boolean value, automatically get appropriate string “true” “false.” The conditional expression says: “repeat statements body long condition( ) returns true.” do-while The form do-while statement while(Boolean-expression); The sole difference do-while statement do-while always executes least once, even expression evaluates false first time. In while, conditional false first time statement never executes. In practice, dowhile less common while. A loop perhaps commonly used form iteration. This loop performs initialization first iteration. Then performs conditional testing and, end iteration, form “stepping.” The form loop is: for(initialization; Boolean-expression; step) statement Any expressions initialization, Boolean-expression step empty. The expression tested iteration, soon evaluates false, execution continue line following statement. At end loop, step executes. loops usually used “counting” tasks: //: control/ListCharacters.java // Demonstrates "for" loop listing // lowercase ASCII letters. public class ListCharacters { public static void main(String[] args) { for(char c = 0; c < 128; c++) if(Character.isLowerCase(c)) System.out.println("value: " + (int)c + " character: " + c); } } /* Output: value: 97 character: value: 98 character: b value: 99 character: c value: 100 character: value: 101 character: e value: 102 character: f value: 103 character: g value: 104 character: h value: 105 character: value: 106 character: j ... Controlling Execution 95 *///:~ Note variable c defined point used, inside control expression loop, rather beginning main( ). The scope c statement controlled for. This program also uses java.lang.Character “wrapper” class, wraps primitive char type object, also provides utilities. Here, static isLowerCase( ) method used detect whether character question lowercase letter. Traditional procedural languages like C require variables defined beginning block compiler creates block, allocate space variables. In Java C++, spread variable declarations throughout block, defining point need them. This allows natural coding style makes code easier understand. Exercise 1: (1) Write program prints values 1 100. Exercise 2: (2) Write program generates 25 random int values. For value, use if-else statement classify greater than, less than, equal second randomly generated value. Exercise 3: (1) Modify Exercise 2 code surrounded “infinite” loop. It run interrupt keyboard (typically pressing ControlC). Exercise 4: (3) Write program uses two nested loops modulus operator (%) detect print prime numbers (integral numbers evenly divisible numbers except 1). Exercise 5: (4) Repeat Exercise 10 previous chapter, using ternary operator bitwise test display ones zeroes, instead Integer.toBinaryString( ). The comma operator Earlier chapter I stated comma operator (not comma separator, used separate definitions method arguments) one use Java: control expression loop. In initialization step portions control expression, number statements separated commas, statements evaluated sequentially. Using comma operator, define multiple variables within statement, must type: //: control/CommaOperator.java public class CommaOperator { public static void main(String[] args) { for(int = 1, j = + 10; < 5; i++, j = * 2) { System.out.println("i = " + + " j = " + j); } } } /* Output: = 1 j = 11 = 2 j = 4 96 Thinking Java Bruce Eckel = 3 j = 6 = 4 j = 8 *///:~ The int definition statement covers j. The initialization portion number definitions one type. The ability define variables control expression limited loop. You cannot use approach selection iteration statements. You see initialization step portions, statements evaluated sequential order. Foreach syntax Java SE5 introduces new succinct syntax, use arrays containers (you’ll learn Arrays Containers Depth chapter). This often called foreach syntax, means don’t create int count sequence items—the foreach produces item you, automatically. For example, suppose array float you’d like select element array: //: control/ForEachFloat.java import java.util.*; public class ForEachFloat { public static void main(String[] args) { Random rand = new Random(47); float f[] = new float[10]; for(int = 0; < 10; i++) f[i] = rand.nextFloat(); for(float x : f) System.out.println(x); } } /* Output: 0.72711575 0.39982635 0.5309454 0.0534122 0.16020656 0.57799757 0.18847865 0.4170137 0.51660204 0.73734957 *///:~ The array populated using old loop, must accessed index. You see foreach syntax line: for(float x : f) { This defines variable x type float sequentially assigns element f x. Any method returns array candidate use foreach. For example, String class method toCharArray( ) returns array char, easily iterate characters string: Controlling Execution 97 //: control/ForEachString.java public class ForEachString { public static void main(String[] args) { for(char c : "An African Swallow".toCharArray() ) System.out.print(c + " "); } } /* Output: A n A f r c n S w l l w *///:~ As you’ll see Holding Your Objects chapter, foreach also work object Iterable. Many statements involve stepping sequence integral values, like this: for(int = 0; < 100; i++) For these, foreach syntax won’t work unless want create array int first. To simplify task, I’ve created method called range( ) net.mindview.util.Range automatically generates appropriate array. My intent range( ) used static import: //: control/ForEachInt.java import static net.mindview.util.Range.*; import static net.mindview.util.Print.*; public class ForEachInt { public static void main(String[] args) { for(int : range(10)) // 0..9 printnb(i + " "); print(); for(int : range(5, 10)) // 5..9 printnb(i + " "); print(); for(int : range(5, 20, 3)) // 5..20 step 3 printnb(i + " "); print(); } } /* Output: 0 1 2 3 4 5 6 7 8 9 5 6 7 8 9 5 8 11 14 17 *///:~ The range( ) method overloaded, means method name used different argument lists (you’ll learn overloading soon). The first overloaded form range( ) starts zero produces values including top end range. The second form starts first value goes one less second, third form step value increases value. range( ) simple version what’s called generator, you’ll see later book. Note although range( ) allows use foreach syntax places, thus arguably increases readability, little less efficient, tuning performance may want use profiler, tool measures performance code. You’ll note use printnb( ) addition print( ). The printnb( ) method emit newline, allows output line pieces. 98 Thinking Java Bruce Eckel The foreach syntax saves time typing code. More importantly, far easier read says trying (get element array) rather giving details (“I’m creating index I use select array elements.”). The foreach syntax used whenever possible book. return Several keywords represent unconditional branching, simply means branch happens without test. These include return, break, continue, way jump labeled statement similar goto languages. The return keyword two purposes: It specifies value method return (if doesn’t void return value) causes current method exit, returning value. The preceding test( ) method rewritten take advantage this: //: control/IfElse2.java import static net.mindview.util.Print.*; public class IfElse2 { static int test(int testval, int target) { if(testval > target) return +1; else if(testval < target) return -1; else return 0; // Match } public static void main(String[] args) { print(test(10, 5)); print(test(5, 10)); print(test(5, 5)); } } /* Output: 1 -1 0 *///:~ There’s need else, method continue executing return. If return statement method returns void, there’s implicit return end method, it’s always necessary include return statement. However, method states return anything void, must ensure every code path return value. Exercise 6: (2) Modify two test( ) methods previous two programs take two extra arguments, begin end, testval tested see within range (and including) begin end. break continue You also control flow loop inside body iteration statements using break continue. break quits loop without executing rest statements loop. continue stops execution current iteration goes back beginning loop begin next iteration. Controlling Execution 99 This program shows examples break continue within loops: //: control/BreakAndContinue.java // Demonstrates break continue keywords. import static net.mindview.util.Range.*; public class BreakAndContinue { public static void main(String[] args) { for(int = 0; < 100; i++) { if(i == 74) break; // Out loop if(i % 9 != 0) continue; // Next iteration System.out.print(i + " "); } System.out.println(); // Using foreach: for(int : range(100)) { if(i == 74) break; // Out loop if(i % 9 != 0) continue; // Next iteration System.out.print(i + " "); } System.out.println(); int = 0; // An "infinite loop": while(true) { i++; int j = * 27; if(j == 1269) break; // Out loop if(i % 10 != 0) continue; // Top loop System.out.print(i + " "); } } } /* Output: 0 9 18 27 36 45 54 63 72 0 9 18 27 36 45 54 63 72 10 20 30 40 *///:~ In loop, value never gets 100 break statement breaks loop 74. Normally, you’d use break like didn’t know terminating condition going occur. The continue statement causes execution go back top iteration loop (thus incrementing i) whenever evenly divisible 9. When is, value printed. The second loop shows use foreach, produces results. Finally, see “infinite” loop would, theory, continue forever. However, inside loop break statement break loop. In addition, you’ll see continue statement moves control back top loop without completing anything continue statement. (Thus printing happens second loop value divisible 10.) In output, value 0 printed, 0 % 9 produces 0. A second form infinite loop for(;;). The compiler treats while(true) for(;;) way, whichever one use matter programming taste. Exercise 7: (1) Modify Exercise 1 program exits using break keyword value 99. Try using return instead. 100 Thinking Java Bruce Eckel The infamous “goto” The goto keyword present programming languages beginning. Indeed, goto genesis program control assembly language: “If condition A, jump here; otherwise, jump there.” If read assembly code ultimately generated virtually compiler, you’ll see program control contains many jumps (the Java compiler produces “assembly code,” code run Java Virtual Machine rather directly hardware CPU). A goto jump source-code level, that’s brought disrepute. If program always jump one point another, isn’t way reorganize code flow control jumpy? goto fell true disfavor publication famous “Goto considered harmful” paper Edsger Dijkstra, since gotobashing popular sport, advocates cast-out keyword scurrying cover. As typical situations like this, middle ground fruitful. The problem use goto, overuse goto; rare situations goto actually best way structure control flow. Although goto reserved word Java, used language; Java goto. However, something looks bit like jump tied break continue keywords. It’s jump rather way break iteration statement. The reason it’s often thrown discussions goto uses mechanism: label. A label identifier followed colon, like this: label1: The place label useful Java right iteration statement. And means right before—it good put statement label iteration. And sole reason put label iteration you’re going nest another iteration switch (which you’ll learn shortly) inside it. That’s break continue keywords normally interrupt current loop, used label, they’ll interrupt loops label exists: label1: outer-iteration { inner-iteration { //... break; // (1) //... continue; // (2) //... continue label1; // (3) //... break label1; // (4) } } In (1), break breaks inner iteration end outer iteration. In (2), continue moves back beginning inner iteration. But (3), continue label1 breaks inner iteration outer iteration, way back label1. Then fact continue iteration, starting outer iteration. In (4), break label1 also breaks way label1, reenter iteration. It actually break iterations. Controlling Execution 101 Here example using loops: //: control/LabeledFor.java // For loops "labeled break" "labeled continue." import static net.mindview.util.Print.*; public class LabeledFor { public static void main(String[] args) { int = 0; outer: // Can’t statements for(; true ;) { // infinite loop inner: // Can’t statements for(; < 10; i++) { print("i = " + i); if(i == 2) { print("continue"); continue; } if(i == 3) { print("break"); i++; // Otherwise never // gets incremented. break; } if(i == 7) { print("continue outer"); i++; // Otherwise never // gets incremented. continue outer; } if(i == 8) { print("break outer"); break outer; } for(int k = 0; k < 5; k++) { if(k == 3) { print("continue inner"); continue inner; } } } } // Can’t break continue labels } } /* Output: = 0 continue inner = 1 continue inner = 2 continue = 3 break = 4 continue inner = 5 continue inner = 6 continue inner = 7 continue outer = 8 break outer 102 Thinking Java Bruce Eckel *///:~ Note break breaks loop, increment expression doesn’t occur end pass loop. Since break skips increment expression, increment performed directly case == 3. The continue outer statement case == 7 also goes top loop also skips increment, incremented directly. If break outer statement, would way get outer loop within inner loop, since break break innermost loop. (The true continue.) Of course, cases breaking loop also exit method, simply use return. Here demonstration labeled break continue statements loops: //: control/LabeledWhile.java // While loops "labeled break" "labeled continue." import static net.mindview.util.Print.*; public class LabeledWhile { public static void main(String[] args) { int = 0; outer: while(true) { print("Outer loop"); while(true) { i++; print("i = " + i); if(i == 1) { print("continue"); continue; } if(i == 3) { print("continue outer"); continue outer; } if(i == 5) { print("break"); break; } if(i == 7) { print("break outer"); break outer; } } } } } /* Output: Outer loop = 1 continue = 2 = 3 continue outer Outer loop = 4 = 5 break Outer loop Controlling Execution 103 = 6 = 7 break outer *///:~ The rules hold true while: 1. A plain continue goes top innermost loop continues. 2. A labeled continue goes label reenters loop right label. 3. A break “drops bottom” loop. 4. A labeled break drops bottom end loop denoted label. It’s important remember reason use labels Java nested loops want break continue one nested level. In Dijkstra’s “Goto considered harmful” paper, specifically objected labels, goto. He observed number bugs seems increase number labels program, labels gotos make programs difficult analyze. Note Java labels don’t suffer problem, since constrained placement can’t used transfer control ad hoc manner. It’s also interesting note case language feature made useful restricting power statement. switch The switch sometimes called selection statement. The switch statement selects among pieces code based value integral expression. Its general form is: switch(integral-selector) { case integral-value1 : statement; case integral-value2 : statement; case integral-value3 : statement; case integral-value4 : statement; case integral-value5 : statement; // ... default: statement; } break; break; break; break; break; Integral-selector expression produces integral value. The switch compares result integral-selector integral-value. If finds match, corresponding statement (a single statement multiple statements; braces required) executes. If match occurs, default statement executes. You notice preceding definition case ends break, causes execution jump end switch body. This conventional way build switch statement, break optional. If missing, code following case statements executes break encountered. Although don’t usually want kind behavior, useful experienced programmer. Note last statement, following default, doesn’t break execution falls break would taken anyway. You could put break end default statement harm considered important style’s sake. The switch statement clean way implement multiway selection (i.e., selecting among number different execution paths), requires selector evaluates integral value, int char. If want use, example, string floating 104 Thinking Java Bruce Eckel point number selector, won’t work switch statement. For non-integral types, must use series statements. At end next chapter, you’ll see Java SE5’s new enum feature helps ease restriction, enums designed work nicely switch. Here’s example creates letters randomly determines whether they’re vowels consonants: //: control/VowelsAndConsonants.java // Demonstrates switch statement. import java.util.*; import static net.mindview.util.Print.*; public class VowelsAndConsonants { public static void main(String[] args) { Random rand = new Random(47); for(int = 0; < 100; i++) { int c = rand.nextInt(26) + ‘a’; printnb((char)c + ", " + c + ": "); switch(c) { case ‘a’: case ‘e’: case ‘i’: case ‘o’: case ‘u’: print("vowel"); break; case ‘y’: case ‘w’: print("Sometimes vowel"); break; default: print("consonant"); } } } } /* Output: y, 121: Sometimes vowel n, 110: consonant z, 122: consonant b, 98: consonant r, 114: consonant n, 110: consonant y, 121: Sometimes vowel g, 103: consonant c, 99: consonant f, 102: consonant o, 111: vowel w, 119: Sometimes vowel z, 122: consonant ... *///:~ Since Random.nextInt(26) generates value 0 26, need add offset ‘a’ produce lowercase letters. The single-quoted characters case statements also produce integral values used comparison. Notice cases “stacked” top provide multiple matches particular piece code. You also aware it’s essential put break statement end particular case; otherwise, control simply drop continue processing next case. Controlling Execution 105 In statement: int c = rand.nextInt(26) + ‘a’; Random.nextInt( ) produces random int value 0 25, added value ‘a’. This means ‘a’ automatically converted int perform addition. In order print c character, must cast char; otherwise, you’ll produce integral output. Exercise 8: (2) Create switch statement prints message case, put switch inside loop tries case. Put break case test it, remove breaks see happens. Exercise 9: (4) A Fibonacci sequence sequence numbers 1, 1, 2, 3, 5, 8, 13, 21, 34, on, number (from third on) sum previous two. Create method takes integer argument displays many Fibonacci numbers starting beginning, e.g., If run java Fibonacci 5 (where Fibonacci name class) output be: 1, 1, 2, 3, 5. Exercise 10: (5) A vampire number even number digits formed multiplying pair numbers containing half number digits result. The digits taken original number order. Pairs trailing zeroes allowed. Examples include: 1260 = 21 * 60 1827 = 21 * 87 2187 = 27 * 81 Write program finds 4-digit vampire numbers. (Suggested Dan Forhan.) Summary This chapter concludes study fundamental features appear programming languages: calculation, operator precedence, type casting, selection iteration. Now you’re ready begin taking steps move closer world object-oriented programming. The next chapter cover important issues initialization cleanup objects, followed subsequent chapter essential concept implementation hiding. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. 106 Thinking Java Bruce Eckel Initialization & Cleanup As computer revolution progresses, “unsafe” programming become one major culprits makes programming expensive. Two safety issues initialization cleanup. Many C bugs occur programmer forgets initialize variable. This especially true libraries users don’t know initialize library component, even must. Cleanup special problem it’s easy forget element you’re done it, since longer concerns you. Thus, resources used element retained easily end running resources (most notably, memory). C++ introduced concept constructor, special method automatically called object created. Java also adopted constructor, addition garbage collector automatically releases memory resources they’re longer used. This chapter examines issues initialization cleanup, support Java. Guaranteed initialization constructor You imagine creating method called initialize( ) every class write. The name hint called using object. Unfortunately, means user must remember call method. In Java, class designer guarantee initialization every object providing constructor. If class constructor, Java automatically calls constructor object created, users even get hands it. So initialization guaranteed. The next challenge name method. There two issues. The first name use could clash name might like use member class. The second compiler responsible calling constructor, must always know method call. The C++ solution seems easiest logical, it’s also used Java: The name constructor name class. It makes sense method called automatically initialization. Here’s simple class constructor: //: initialization/SimpleConstructor.java // Demonstration simple constructor. class Rock { Rock() { // This constructor System.out.print("Rock "); } } public class SimpleConstructor { public static void main(String[] args) { for(int = 0; < 10; i++) new Rock(); } } /* Output: Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock *///:~ Now, object created: new Rock(); storage allocated constructor called. It guaranteed object properly initialized get hands it. Note coding style making first letter methods lowercase apply constructors, since name constructor must match name class exactly. A constructor takes arguments called default constructor. The Java documents typically use term no-arg constructor, “default constructor” use many years Java appeared, I tend use that. But like method, constructor also arguments allow specify object created. The preceding example easily changed constructor takes argument: //: initialization/SimpleConstructor2.java // Constructors arguments. class Rock2 { Rock2(int i) { System.out.print("Rock " + + " "); } } public class SimpleConstructor2 { public static void main(String[] args) { for(int = 0; < 8; i++) new Rock2(i); } } /* Output: Rock 0 Rock 1 Rock 2 Rock 3 Rock 4 Rock 5 Rock 6 Rock 7 *///:~ Constructor arguments provide way provide parameters initialization object. For example, class Tree constructor takes single integer argument denoting height tree, create Tree object like this: Tree = new Tree(12); // 12-foot tree If Tree(int) constructor, compiler won’t let create Tree object way. Constructors eliminate large class problems make code easier read. In preceding code fragment, example, don’t see explicit call initialize( ) method conceptually separate creation. In Java, creation initialization unified concepts—you can’t one without other. The constructor unusual type method return value. This distinctly different void return value, method returns nothing still option make return something else. Constructors return nothing don’t option (the new expression return reference newly created object, constructor return value). If return value, could select own, compiler would somehow need know return value. 108 Thinking Java Bruce Eckel Exercise 1: (1) Create class containing uninitialized String reference. Demonstrate reference initialized Java null. Exercise 2: (2) Create class String field initialized point definition, another one initialized constructor. What difference two approaches? Method overloading One important features programming language use names. When create object, give name region storage. A method name action. You refer objects methods using names. Well-chosen names create system easier people understand change. It’s lot like writing prose—the goal communicate readers. A problem arises mapping concept nuance human language onto programming language. Often, word expresses number different meanings—it’s overloaded. This useful, especially comes trivial differences. You say, “Wash shirt,” “Wash car,” “Wash dog.” It would silly forced say, “shirtWash shirt,” “carWash car,” “dogWash dog” listener doesn’t need make distinction action performed. Most human languages redundant, even miss words, still determine meaning. You don’t need unique identifiers—you deduce meaning context. Most programming languages (C particular) require unique identifier method (often called functions languages). So could one function called print( ) printing integers another called print( ) printing floats—each function requires unique name. In Java (and C++), another factor forces overloading method names: constructor. Because constructor’s name predetermined name class, one constructor name. But want create object one way? For example, suppose build class initialize standard way reading information file. You need two constructors, default constructor one takes String argument, name file initialize object. Both constructors, must name—the name class. Thus, method overloading essential allow method name used different argument types. And although method overloading must constructors, it’s general convenience used method. Here’s example shows overloaded constructors overloaded methods: //: initialization/Overloading.java // Demonstration constructor // ordinary method overloading. import static net.mindview.util.Print.*; class Tree { int height; Tree() { print("Planting seedling"); height = 0; } Tree(int initialHeight) { height = initialHeight; print("Creating new Tree " + height + " feet tall"); Initialization & Cleanup 109 } } void info() { print("Tree " + height + " feet tall"); } void info(String s) { print(s + ": Tree " + height + " feet tall"); } public class Overloading { public static void main(String[] args) { for(int = 0; < 5; i++) { Tree = new Tree(i); t.info(); t.info("overloaded method"); } // Overloaded constructor: new Tree(); } } /* Output: Creating new Tree 0 feet tall Tree 0 feet tall overloaded method: Tree 0 feet tall Creating new Tree 1 feet tall Tree 1 feet tall overloaded method: Tree 1 feet tall Creating new Tree 2 feet tall Tree 2 feet tall overloaded method: Tree 2 feet tall Creating new Tree 3 feet tall Tree 3 feet tall overloaded method: Tree 3 feet tall Creating new Tree 4 feet tall Tree 4 feet tall overloaded method: Tree 4 feet tall Planting seedling *///:~ A Tree object created either seedling, argument, plant grown nursery, existing height. To support this, default constructor, one takes existing height. You might also want call info( ) method one way. For example, extra message want printed, use info(String), info( ) nothing say. It would seem strange give two separate names obviously concept. Fortunately, method overloading allows use name both. Distinguishing overloaded methods If methods name, Java know method mean? There’s simple rule: Each overloaded method must take unique list argument types. If think second, makes sense. How else could programmer tell difference two methods name, types arguments? Even differences ordering arguments sufficient distinguish two methods, although don’t normally want take approach produces difficult-tomaintain code: 110 Thinking Java Bruce Eckel //: initialization/OverloadingOrder.java // Overloading based order arguments. import static net.mindview.util.Print.*; public class OverloadingOrder { static void f(String s, int i) { print("String: " + + ", int: " + i); } static void f(int i, String s) { print("int: " + + ", String: " + s); } public static void main(String[] args) { f("String first", 11); f(99, "Int first"); } } /* Output: String: String first, int: 11 int: 99, String: Int first *///:~ The two f( ) methods identical arguments, order different, that’s makes distinct. Overloading primitives A primitive automatically promoted smaller type larger one, slightly confusing combination overloading. The following example demonstrates happens primitive handed overloaded method: //: initialization/PrimitiveOverloading.java // Promotion primitives overloading. import static net.mindview.util.Print.*; public void void void void void void void class PrimitiveOverloading { f1(char x) { printnb("f1(char) "); } f1(byte x) { printnb("f1(byte) "); } f1(short x) { printnb("f1(short) "); } f1(int x) { printnb("f1(int) "); } f1(long x) { printnb("f1(long) "); } f1(float x) { printnb("f1(float) "); } f1(double x) { printnb("f1(double) "); } void void void void void void f2(byte x) { printnb("f2(byte) "); } f2(short x) { printnb("f2(short) "); } f2(int x) { printnb("f2(int) "); } f2(long x) { printnb("f2(long) "); } f2(float x) { printnb("f2(float) "); } f2(double x) { printnb("f2(double) "); } void void void void void f3(short x) { printnb("f3(short) "); } f3(int x) { printnb("f3(int) "); } f3(long x) { printnb("f3(long) "); } f3(float x) { printnb("f3(float) "); } f3(double x) { printnb("f3(double) "); } void void void void f4(int x) { printnb("f4(int) "); } f4(long x) { printnb("f4(long) "); } f4(float x) { printnb("f4(float) "); } f4(double x) { printnb("f4(double) "); } void f5(long x) { printnb("f5(long) "); } Initialization & Cleanup 111 void f5(float x) { printnb("f5(float) "); } void f5(double x) { printnb("f5(double) "); } void f6(float x) { printnb("f6(float) "); } void f6(double x) { printnb("f6(double) "); } void f7(double x) { printnb("f7(double) "); } void testConstVal() { printnb("5: "); f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5); print(); } void testChar() { char x = ‘x’; printnb("char: "); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); } void testByte() { byte x = 0; printnb("byte: "); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); } void testShort() { short x = 0; printnb("short: "); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); } void testInt() { int x = 0; printnb("int: "); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); } void testLong() { long x = 0; printnb("long: "); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); } void testFloat() { float x = 0; printnb("float: "); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); } void testDouble() { double x = 0; printnb("double: "); f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x); print(); } public static void main(String[] args) { PrimitiveOverloading p = new PrimitiveOverloading(); p.testConstVal(); p.testChar(); p.testByte(); p.testShort(); p.testInt(); p.testLong(); p.testFloat(); p.testDouble(); } } /* Output: 5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double) 112 Thinking Java Bruce Eckel short: f1(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double) int: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double) long: f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double) float: f1(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double) double: f1(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double) *///:~ You see constant value 5 treated int, overloaded method available takes int, used. In cases, data type smaller argument method, data type promoted. char produces slightly different effect, since doesn’t find exact char match, promoted int. What happens argument bigger argument expected overloaded method? A modification preceding program gives answer: //: initialization/Demotion.java // Demotion primitives overloading. import static net.mindview.util.Print.*; public void void void void void void void class Demotion { f1(char x) { print("f1(char)"); } f1(byte x) { print("f1(byte)"); } f1(short x) { print("f1(short)"); } f1(int x) { print("f1(int)"); } f1(long x) { print("f1(long)"); } f1(float x) { print("f1(float)"); } f1(double x) { print("f1(double)"); } void void void void void void f2(char x) { print("f2(char)"); } f2(byte x) { print("f2(byte)"); } f2(short x) { print("f2(short)"); } f2(int x) { print("f2(int)"); } f2(long x) { print("f2(long)"); } f2(float x) { print("f2(float)"); } void void void void void f3(char x) { print("f3(char)"); } f3(byte x) { print("f3(byte)"); } f3(short x) { print("f3(short)"); } f3(int x) { print("f3(int)"); } f3(long x) { print("f3(long)"); } void void void void f4(char x) { print("f4(char)"); } f4(byte x) { print("f4(byte)"); } f4(short x) { print("f4(short)"); } f4(int x) { print("f4(int)"); } void f5(char x) { print("f5(char)"); } void f5(byte x) { print("f5(byte)"); } void f5(short x) { print("f5(short)"); } void f6(char x) { print("f6(char)"); } void f6(byte x) { print("f6(byte)"); } void f7(char x) { print("f7(char)"); } void testDouble() { double x = 0; print("double argument:"); f1(x);f2((float)x);f3((long)x);f4((int)x); Initialization & Cleanup 113 f5((short)x);f6((byte)x);f7((char)x); } public static void main(String[] args) { Demotion p = new Demotion(); p.testDouble(); } } /* Output: double argument: f1(double) f2(float) f3(long) f4(int) f5(short) f6(byte) f7(char) *///:~ Here, methods take narrower primitive values. If argument wider, must perform narrowing conversion cast. If don’t this, compiler issue error message. Overloading return values It common wonder, “Why class names method argument lists? Why distinguish methods based return values?” For example, two methods, name arguments, easily distinguished other: void f() {} int f() { return 1; } This might work fine long compiler could unequivocally determine meaning context, int x = f( ). However, also call method ignore return value. This often referred calling method side effect, since don’t care return value, instead want effects method call. So call method way: f(); Java determine f( ) called? And could someone reading code see it? Because sort problem, cannot use return value types distinguish overloaded methods. Default constructors As mentioned previously, default constructor (a.k.a. “no-arg” constructor) one without arguments used create “default object.” If create class constructors, compiler automatically create default constructor you. For example: //: initialization/DefaultConstructor.java class Bird {} public class DefaultConstructor { public static void main(String[] args) { Bird b = new Bird(); // Default! 114 Thinking Java Bruce Eckel } } ///:~ The expression new Bird() creates new object calls default constructor, even though one explicitly defined. Without it, would method call build object. However, define constructors (with without arguments), compiler synthesize one you: //: initialization/NoSynthesis.java class Bird2 { Bird2(int i) {} Bird2(double d) {} } public class NoSynthesis { public static void main(String[] args) { //! Bird2 b = new Bird2(); // No default Bird2 b2 = new Bird2(1); Bird2 b3 = new Bird2(1.0); } } ///:~ If say: new Bird2() compiler complain cannot find constructor matches. When don’t put constructors, it’s compiler says, “You bound need constructor, let make one you.” But write constructor, compiler says, “You’ve written constructor know you’re doing; didn’t put default it’s meant leave out.” Exercise 3: (1) Create class default constructor (one takes arguments) prints message. Create object class. Exercise 4: (1) Add overloaded constructor previous exercise takes String argument prints along message. Exercise 5: (2) Create class called Dog overloaded bark( ) method. This method overloaded based various primitive data types, print different types barking, howling, etc., depending overloaded version called. Write main( ) calls different versions. Exercise 6: (1) Modify previous exercise two overloaded methods two arguments (of two different types), reversed order relative other. Verify works. Exercise 7: (1) Create class without constructor, create object class main( ) verify default constructor automatically synthesized. Initialization & Cleanup 115 The keyword If two objects type called b, might wonder call method peel( ) objects: //: initialization/BananaPeel.java class Banana { void peel(int i) { /* ... */ } } public class BananaPeel { public static void main(String[] args) { Banana = new Banana(), b = new Banana(); a.peel(1); b.peel(2); } } ///:~ If there’s one method called peel( ), method know whether it’s called object b? To allow write code convenient object-oriented syntax “send message object,” compiler undercover work you. There’s secret first argument passed method peel( ), argument reference object that’s manipulated. So two method calls become something like: Banana.peel(a, 1); Banana.peel(b, 2); This internal can’t write expressions get compiler accept them, gives idea what’s happening. Suppose you’re inside method you’d like get reference current object. Since reference passed secretly compiler, there’s identifier it. However, purpose there’s keyword: this. The keyword—which used inside non-static method—produces reference object method called for. You treat reference like object reference. Keep mind you’re calling method class within another method class, don’t need use this. You simply call method. The current reference automatically used method. Thus say: //: initialization/Apricot.java public class Apricot { void pick() { /* ... */ } void pit() { pick(); /* ... */ } } ///:~ Inside pit( ), could say this.pick( ) there’s need to. 1 The compiler automatically. The keyword used special cases need explicitly use reference current object. For example, it’s often used return statements want return reference current object: 1 Some people obsessively put front every method call field reference, arguing makes “clearer explicit.” Don’t it. There’s reason use high-level languages: They things us. If put it’s necessary, confuse annoy everyone reads code, since rest code they’ve read won’t use everywhere. People expect used necessary. Following consistent straightforward coding style saves time money. 116 Thinking Java Bruce Eckel //: initialization/Leaf.java // Simple use "this" keyword. public class Leaf { int = 0; Leaf increment() { i++; return this; } void print() { System.out.println("i = " + i); } public static void main(String[] args) { Leaf x = new Leaf(); x.increment().increment().increment().print(); } } /* Output: = 3 *///:~ Because increment( ) returns reference current object via keyword, multiple operations easily performed object. The keyword also useful passing current object another method: //: initialization/PassingThis.java class Person { public void eat(Apple apple) { Apple peeled = apple.getPeeled(); System.out.println("Yummy"); } } class Peeler { static Apple peel(Apple apple) { // ... remove peel return apple; // Peeled } } class Apple { Apple getPeeled() { return Peeler.peel(this); } } public class PassingThis { public static void main(String[] args) { new Person().eat(new Apple()); } } /* Output: Yummy *///:~ Apple needs call Peeler.peel( ), foreign utility method performs operation that, reason, needs external Apple (perhaps external method applied across many different classes, don’t want repeat code). To pass foreign method, must use this. Exercise 8: (1) Create class two methods. Within first method, call second method twice: first time without using this, second time using this—just see working; use form practice. Initialization & Cleanup 117 Calling constructors constructors When write several constructors class, times you’d like call one constructor another avoid duplicating code. You make call using keyword. Normally, say this, sense “this object” “the current object,” produces reference current object. In constructor, keyword takes different meaning give argument list. It makes explicit call constructor matches argument list. Thus straightforward way call constructors: //: initialization/Flower.java // Calling constructors "this" import static net.mindview.util.Print.*; public class Flower { int petalCount = 0; String = "initial value"; Flower(int petals) { petalCount = petals; print("Constructor w/ int arg only, petalCount= " + petalCount); } Flower(String ss) { print("Constructor w/ String arg only, = " + ss); = ss; } Flower(String s, int petals) { this(petals); //! this(s); // Can’t call two! this.s = s; // Another use "this" print("String & int args"); } Flower() { this("hi", 47); print("default constructor (no args)"); } void printPetalCount() { //! this(11); // Not inside non-constructor! print("petalCount = " + petalCount + " = "+ s); } public static void main(String[] args) { Flower x = new Flower(); x.printPetalCount(); } } /* Output: Constructor w/ int arg only, petalCount= 47 String & int args default constructor (no args) petalCount = 47 = hi *///:~ The constructor Flower(String s, int petals) shows that, call one constructor using this, cannot call two. In addition, constructor call must first thing do, you’ll get compiler error message. This example also shows another way you’ll see used. Since name argument name member data same, there’s ambiguity. You resolve 118 Thinking Java Bruce Eckel using this.s, say you’re referring member data. You’ll often see form used Java code, it’s used numerous places book. In printPetalCount( ) see compiler won’t let call constructor inside method constructor. Exercise 9: (1) Create class two (overloaded) constructors. Using this, call second constructor inside first one. The meaning static With keyword mind, fully understand means make method static. It means particular method. You cannot call non-static methods inside static methods 2 (although reverse possible), call static method class itself, without object. In fact, that’s primarily static method for. It’s you’re creating equivalent global method. However, global methods permitted Java, putting static method inside class allows access static methods static fields. Some people argue static methods object-oriented, since semantics global method; static method, don’t send message object, since there’s this. This probably fair argument, find using lot static methods, probably rethink strategy. However, statics pragmatic, times genuinely need them, whether “proper OOP” left theoreticians. Cleanup: finalization garbage collection Programmers know importance initialization, often forget importance cleanup. After all, needs clean int? But libraries, simply “letting go” object you’re done always safe. Of course, Java garbage collector reclaim memory objects longer used. Now consider unusual case: Suppose object allocates “special” memory without using new. The garbage collector knows release memory allocated new, won’t know release object’s “special” memory. To handle case, Java provides method called finalize( ) define class. Here’s it’s supposed work. When garbage collector ready release storage used object, first call finalize( ), next garbage-collection pass reclaim object’s memory. So choose use finalize( ), gives ability perform important cleanup time garbage collection. This potential programming pitfall programmers, especially C++ programmers, might initially mistake finalize( ) destructor C++, function always called object destroyed. It important distinguish C++ Java here, C++, objects always get destroyed (in bug-free program), whereas Java, objects always get garbage collected. Or, put another way: 1. Your objects might get garbage collected. 2 The one case possible occurs pass reference object static method (the static method could also create object). Then, via reference (which effectively this), call non-static methods access non-static fields. But typically, want something like this, you’ll make ordinary, non-static method. Initialization & Cleanup 119 2. Garbage collection destruction. If remember this, stay trouble. What means activity must performed longer need object, must perform activity yourself. Java destructor similar concept, must create ordinary method perform cleanup. For example, suppose process creating object, draws screen. If don’t explicitly erase image screen, might never get cleaned up. If put kind erasing functionality inside finalize( ), object garbage collected finalize( ) called (and there’s guarantee happen), image first removed screen, isn’t, image remain. You might find storage object never gets released program never nears point running storage. If program completes garbage collector never gets around releasing storage objects, storage returned operating system en masse program exits. This good thing, garbage collection overhead, never it, never incur expense. What finalize() for? So, use finalize( ) general-purpose cleanup method, good it? A third point remember is: 3. Garbage collection memory. That is, sole reason existence garbage collector recover memory program longer using. So activity associated garbage collection, notably finalize( ) method, must also memory deallocation. Does mean object contains objects, finalize( ) explicitly release objects? Well, no—the garbage collector takes care release object memory regardless object created. It turns need finalize( ) limited special cases object allocate storage way creating object. But, might observe, everything Java object, be? It would seem finalize( ) place possibility you’ll something Clike allocating memory using mechanism normal one Java. This happen primarily native methods, way call non-Java code Java. (Native methods covered Appendix B electronic 2nd edition book, available www.MindView.net.) C C++ languages currently supported native methods, since call subprograms languages, effectively call anything. Inside non-Java code, C’s malloc( ) family functions might called allocate storage, unless call free( ), storage released, causing memory leak. Of course, free( ) C C++ function, you’d need call native method inside finalize( ). After reading this, probably get idea won’t use finalize( ) much. 3 You’re correct; appropriate place normal cleanup occur. So normal cleanup performed? 3 Joshua Bloch goes section titled “avoid finalizers”: “Finalizers unpredictable, often dangerous, generally unnecessary.” Effective JavaTM Programming Language Guide, p. 20 (Addison-Wesley, 2001). 120 Thinking Java Bruce Eckel You must perform cleanup To clean object, user object must call cleanup method point cleanup desired. This sounds pretty straightforward, collides bit C++ concept destructor. In C++, objects destroyed. Or rather, objects destroyed. If C++ object created local (i.e., stack—not possible Java), destruction happens closing curly brace scope object created. If object created using new (like Java), destructor called programmer calls C++ operator delete (which doesn’t exist Java). If C++ programmer forgets call delete, destructor never called, memory leak, plus parts object never get cleaned up. This kind bug difficult track down, one compelling reasons move C++ Java. In contrast, Java doesn’t allow create local objects—you must always use new. But Java, there’s “delete” releasing object, garbage collector releases storage you. So simplistic standpoint, could say garbage collection, Java destructor. You’ll see book progresses, however, presence garbage collector remove need utility destructors. (And never call finalize( ) directly, that’s solution.) If want kind cleanup performed storage release, must still explicitly call appropriate method Java, equivalent C++ destructor without convenience. Remember neither garbage collection finalization guaranteed. If JVM isn’t close running memory, might waste time recovering memory garbage collection. The termination condition In general, can’t rely finalize( ) called, must create separate “cleanup” methods call explicitly. So appears finalize( ) useful obscure memory cleanup programmers never use. However, interesting use finalize( ) rely called every time. This verification termination condition 4 object. At point you’re longer interested object—when it’s ready cleaned up— object state whereby memory safely released. For example, object represents open file, file closed programmer object garbage collected. If portions object properly cleaned up, bug program difficult find. finalize( ) used eventually discover condition, even isn’t always called. If one finalizations happens reveal bug, discover problem, really care about. Here’s simple example might use it: //: initialization/TerminationCondition.java // Using finalize() detect object // hasn’t properly cleaned up. class Book { boolean checkedOut = false; Book(boolean checkOut) { checkedOut = checkOut; } 4 A term coined Bill Venners (www.Artima.com) seminar I giving together. Initialization & Cleanup 121 } void checkIn() { checkedOut = false; } protected void finalize() { if(checkedOut) System.out.println("Error: checked out"); // Normally, you’ll also this: // super.finalize(); // Call base-class version } public class TerminationCondition { public static void main(String[] args) { Book novel = new Book(true); // Proper cleanup: novel.checkIn(); // Drop reference, forget clean up: new Book(true); // Force garbage collection & finalization: System.gc(); } } /* Output: Error: checked *///:~ The termination condition Book objects supposed checked garbage collected, main( ), programmer error doesn’t check one books. Without finalize( ) verify termination condition, difficult bug find. Note System.gc( ) used force finalization. But even isn’t, it’s highly probable errant Book eventually discovered repeated executions program (assuming program allocates enough storage cause garbage collector execute). You generally assume base-class version finalize( ) also something important, call using super, see Book.finalize( ). In case, commented requires exception handling, haven’t covered yet. Exercise 10: (2) Create class finalize( ) method prints message. In main( ), create object class. Explain behavior program. Exercise 11: (4) Modify previous exercise finalize( ) always called. Exercise 12: (4) Create class called Tank filled emptied, termination condition must empty object cleaned up. Write finalize( ) verifies termination condition. In main( ), test possible scenarios occur Tank used. How garbage collector works If come programming language allocating objects heap expensive, may naturally assume Java’s scheme allocating everything (except primitives) heap also expensive. However, turns garbage collector significant impact increasing speed object creation. This might sound bit odd first—that storage release affects storage allocation—but it’s way JVMs work, 122 Thinking Java Bruce Eckel means allocating storage heap objects Java nearly fast creating storage stack languages. For example, think C++ heap yard object stakes piece turf. This real estate become abandoned sometime later must reused. In JVMs, Java heap quite different; it’s like conveyor belt moves forward every time allocate new object. This means object storage allocation remarkably rapid. The “heap pointer” simply moved forward virgin territory, it’s effectively C++’s stack allocation. (Of course, there’s little extra overhead bookkeeping, it’s nothing like searching storage.) You might observe heap isn’t fact conveyor belt, treat way, you’ll start paging memory—moving disk, appear memory actually do. Paging significantly impacts performance. Eventually, create enough objects, you’ll run memory. The trick garbage collector steps in, collects garbage compacts objects heap you’ve effectively moved “heap pointer” closer beginning conveyor belt farther away page fault. The garbage collector rearranges things makes possible high-speed, infinite-free-heap model used allocating storage. To understand garbage collection Java, it’s helpful learn garbage-collection schemes work systems. A simple slow garbage-collection technique called reference counting. This means object contains reference counter, every time reference attached object, reference count increased. Every time reference goes scope set null, reference count decreased. Thus, managing reference counts small constant overhead happens throughout lifetime program. The garbage collector moves entire list objects, finds one reference count zero releases storage (however, reference counting schemes often release object soon count goes zero). The one drawback objects circularly refer nonzero reference counts still garbage. Locating self-referential groups requires significant extra work garbage collector. Reference counting commonly used explain one kind garbage collection, doesn’t seem used JVM implementations. In faster schemes, garbage collection based reference counting. Instead, based idea non-dead object must ultimately traceable back reference lives either stack static storage. The chain might go several layers objects. Thus, start stack static storage area walk references, you’ll find live objects. For reference find, must trace object points follow references object, tracing objects point to, etc., you’ve moved entire Web originated reference stack static storage. Each object move must still alive. Note problem detached self-referential groups—these simply found, therefore automatically garbage. In approach described here, JVM uses adaptive garbage-collection scheme, live objects locates depends variant currently used. One variants stop-and-copy. This means that—for reasons become apparent—the program first stopped (this background collection scheme). Then, live object copied one heap another, leaving behind garbage. In addition, objects copied new heap, packed end-to-end, thus compacting new heap (and allowing new storage simply reeled end previously described). Of course, object moved one place another, references point object must changed. The reference goes heap static storage area object changed right away, references pointing object Initialization & Cleanup 123 encountered later “walk.” These fixed found (you could imagine table maps old addresses new ones). There two issues make so-called “copy collectors” inefficient. The first idea two heaps slosh memory back forth two separate heaps, maintaining twice much memory actually need. Some JVMs deal allocating heap chunks needed simply copying one chunk another. The second issue copying process itself. Once program becomes stable, might generating little garbage. Despite that, copy collector still copy memory one place another, wasteful. To prevent this, JVMs detect new garbage generated switch different scheme (this “adaptive” part). This scheme called mark-and-sweep, it’s earlier versions Sun’s JVM used time. For general use, mark-and-sweep fairly slow, know you’re generating little garbage, it’s fast. Mark-and-sweep follows logic starting stack static storage, tracing references find live objects. However, time finds live object, object marked setting flag it, object isn’t collected yet. Only marking process finished sweep occur. During sweep, dead objects released. However, copying happens, collector chooses compact fragmented heap, shuffling objects around. “Stop-and-copy” refers idea type garbage collection done background; instead, program stopped garbage collection occurs. In Sun literature you’ll find many references garbage collection low-priority background process, turns garbage collection implemented way earlier versions Sun JVM. Instead, Sun garbage collector stopped program memory got low. Mark-and-sweep also requires program stopped. As previously mentioned, JVM described memory allocated big blocks. If allocate large object, gets block. Strict stop-and-copy requires copying every live object source heap new heap free old one, translates lots memory. With blocks, garbage collection typically copy objects dead blocks collects. Each block generation count keep track whether it’s alive. In normal case, blocks created since last garbage collection compacted; blocks get generation count bumped referenced somewhere. This handles normal case lots short-lived temporary objects. Periodically, full sweep made—large objects still copied (they get generation count bumped), blocks containing small objects copied compacted. The JVM monitors efficiency garbage collection becomes waste time objects long-lived, switches mark-andsweep. Similarly, JVM keeps track successful mark-and-sweep is, heap starts become fragmented, switches back stop-and-copy. This “adaptive” part comes in, end mouthful: “Adaptive generational stop-and-copy mark-andsweep.” There number additional speedups possible JVM. An especially important one involves operation loader called just-in-time (JIT) compiler. A JIT compiler partially fully converts program native machine code doesn’t need interpreted JVM thus runs much faster. When class must loaded (typically, first time want create object class), .class file located, bytecodes class brought memory. At point, one approach simply JIT compile code, two drawbacks: It takes little time, which, compounded throughout life program, add up; increases size executable (bytecodes significantly compact expanded JIT code), might cause paging, definitely slows program. An alternative approach lazy evaluation, means code JIT compiled necessary. Thus, code 124 Thinking Java Bruce Eckel never gets executed might never JIT compiled. The Java HotSpot technologies recent JDKs take similar approach increasingly optimizing piece code time executed, code executed, faster gets. Member initialization Java goes way guarantee variables properly initialized used. In case method’s local variables, guarantee comes form compiletime error. So say: void f() { int i; i++; // Error -- initialized } you’ll get error message says might initialized. Of course, compiler could given default value, uninitialized local variable probably programmer error, default value would covered up. Forcing programmer provide initialization value likely catch bug. If primitive field class, however, things bit different. As saw Everything Is Object chapter, primitive field class guaranteed get initial value. Here’s program verifies this, shows values: //: initialization/InitialValues.java // Shows default initial values. import static net.mindview.util.Print.*; public class InitialValues { boolean t; char c; byte b; short s; int i; long l; float f; double d; InitialValues reference; void printInitialValues() { print("Data type Initial value"); print("boolean " + t); print("char [" + c + "]"); print("byte " + b); print("short " + s); print("int " + i); print("long " + l); print("float " + f); print("double " + d); print("reference " + reference); } public static void main(String[] args) { InitialValues iv = new InitialValues(); iv.printInitialValues(); /* You could also say: new InitialValues().printInitialValues(); */ } } /* Output: Data type Initial value Initialization & Cleanup 125 boolean char byte short int long float double reference *///:~ false [ ] 0 0 0 0 0.0 0.0 null You see even though values specified, automatically get initialized (the char value zero, prints space). So least there’s threat working uninitialized variables. When define object reference inside class without initializing new object, reference given special value null. Specifying initialization What happens want give variable initial value? One direct way simply assign value point define variable class. (Notice cannot C++, although C++ novices always try.) Here field definitions class InitialValues changed provide initial values: //: initialization/InitialValues2.java // Providing explicit initial values. public class InitialValues2 { boolean bool = true; char ch = ‘x’; byte b = 47; short = 0xff; int = 999; long lng = 1; float f = 3.14f; double = 3.14159; } ///:~ You also initialize non-primitive objects way. If Depth class, create variable initialize like so: //: initialization/Measurement.java class Depth {} public class Measurement { Depth = new Depth(); // ... } ///:~ If haven’t given initial value try use anyway, you’ll get runtime error called exception (covered Error Handling Exceptions chapter). You even call method provide initialization value: //: initialization/MethodInit.java public class MethodInit { int = f(); int f() { return 11; } 126 Thinking Java Bruce Eckel } ///:~ This method arguments, course, arguments cannot class members haven’t initialized yet. Thus, this: //: initialization/MethodInit2.java public class MethodInit2 { int = f(); int j = g(i); int f() { return 11; } int g(int n) { return n * 10; } } ///:~ But cannot this: //: initialization/MethodInit3.java public class MethodInit3 { //! int j = g(i); // Illegal forward reference int = f(); int f() { return 11; } int g(int n) { return n * 10; } } ///:~ This one place compiler, appropriately, complain forward referencing, since order initialization way program compiled. This approach initialization simple straightforward. It limitation every object type InitialValues get initialization values. Sometimes exactly need, times need flexibility. Constructor initialization The constructor used perform initialization, gives greater flexibility programming call methods perform actions run time determine initial values. There’s one thing keep mind, however: You aren’t precluding automatic initialization, happens constructor entered. So, example, say: //: initialization/Counter.java public class Counter { int i; Counter() { = 7; } // ... } ///:~ first initialized 0, 7. This true primitive types object references, including given explicit initialization point definition. For reason, compiler doesn’t try force initialize elements constructor particular place, used—initialization already guaranteed. Order initialization Within class, order initialization determined order variables defined within class. The variable definitions may scattered throughout Initialization & Cleanup 127 method definitions, variables initialized methods called—even constructor. For example: //: initialization/OrderOfInitialization.java // Demonstrates initialization order. import static net.mindview.util.Print.*; // When constructor called create // Window object, you’ll see message: class Window { Window(int marker) { print("Window(" + marker + ")"); } } class House { Window w1 = new Window(1); // Before constructor House() { // Show we’re constructor: print("House()"); w3 = new Window(33); // Reinitialize w3 } Window w2 = new Window(2); // After constructor void f() { print("f()"); } Window w3 = new Window(3); // At end } public class OrderOfInitialization { public static void main(String[] args) { House h = new House(); h.f(); // Shows construction done } } /* Output: Window(1) Window(2) Window(3) House() Window(33) f() *///:~ In House, definitions Window objects intentionally scattered prove they’ll get initialized constructor entered anything else happen. In addition, w3 reinitialized inside constructor. From output, see w3 reference gets initialized twice: constructor call. (The first object dropped, garbage collected later.) This might seem efficient first, guarantees proper initialization—what would happen overloaded constructor defined initialize w3 wasn’t “default” initialization w3 definition? static data initialization There’s single piece storage static, regardless many objects created. You can’t apply static keyword local variables, applies fields. If field static primitive don’t initialize it, gets standard initial value type. If it’s reference object, default initialization value null. If want place initialization point definition, looks nonstatics. 128 Thinking Java Bruce Eckel To see static storage gets initialized, here’s example: //: initialization/StaticInitialization.java // Specifying initial values class definition. import static net.mindview.util.Print.*; class Bowl { Bowl(int marker) { print("Bowl(" + marker + ")"); } void f1(int marker) { print("f1(" + marker + ")"); } } class Table { static Bowl bowl1 = new Bowl(1); Table() { print("Table()"); bowl2.f1(1); } void f2(int marker) { print("f2(" + marker + ")"); } static Bowl bowl2 = new Bowl(2); } class Cupboard { Bowl bowl3 = new Bowl(3); static Bowl bowl4 = new Bowl(4); Cupboard() { print("Cupboard()"); bowl4.f1(2); } void f3(int marker) { print("f3(" + marker + ")"); } static Bowl bowl5 = new Bowl(5); } public class StaticInitialization { public static void main(String[] args) { print("Creating new Cupboard() main"); new Cupboard(); print("Creating new Cupboard() main"); new Cupboard(); table.f2(1); cupboard.f3(1); } static Table table = new Table(); static Cupboard cupboard = new Cupboard(); } /* Output: Bowl(1) Bowl(2) Table() f1(1) Bowl(4) Bowl(5) Bowl(3) Cupboard() f1(2) Creating new Cupboard() main Bowl(3) Initialization & Cleanup 129 Cupboard() f1(2) Creating new Cupboard() main Bowl(3) Cupboard() f1(2) f2(1) f3(1) *///:~ Bowl allows view creation class, Table Cupboard static members Bowl scattered class definitions. Note Cupboard creates non-static Bowl bowl3 prior static definitions. From output, see static initialization occurs it’s necessary. If don’t create Table object never refer Table.bowl1 Table.bowl2, static Bowl bowl1 bowl2 never created. They initialized first Table object created (or first static access occurs). After that, static objects reinitialized. The order initialization statics first, haven’t already initialized previous object creation, non-static objects. You see evidence output. To execute main( ) (a static method), StaticInitialization class must loaded, static fields table cupboard initialized, causes classes loaded, since contain static Bowl objects, Bowl loaded. Thus, classes particular program get loaded main( ) starts. This usually case, typical programs won’t everything linked together statics example. To summarize process creating object, consider class called Dog: 1. Even though doesn’t explicitly use static keyword, constructor actually static method. So first time object type Dog created, first time static method static field class Dog accessed, Java interpreter must locate Dog.class, searching classpath. 2. As Dog.class loaded (creating Class object, you’ll learn later), static initializers run. Thus, static initialization takes place once, Class object loaded first time. 3. When create new Dog( ), construction process Dog object first allocates enough storage Dog object heap. 4. This storage wiped zero, automatically setting primitives Dog object default values (zero numbers equivalent boolean char) references null. 5. Any initializations occur point field definition executed. 6. Constructors executed. As shall see Reusing Classes chapter, might actually involve fair amount activity, especially inheritance involved. Explicit static initialization Java allows group static initializations inside special “static clause” (sometimes called static block) class. It looks like this: 130 Thinking Java Bruce Eckel //: initialization/Spoon.java public class Spoon { static int i; static { = 47; } } ///:~ It appears method, it’s static keyword followed block code. This code, like static initializations, executed once: first time make object class first time access static member class (even never make object class). For example: //: initialization/ExplicitStatic.java // Explicit static initialization "static" clause. import static net.mindview.util.Print.*; class Cup { Cup(int marker) { print("Cup(" + marker + ")"); } void f(int marker) { print("f(" + marker + ")"); } } class Cups { static Cup cup1; static Cup cup2; static { cup1 = new Cup(1); cup2 = new Cup(2); } Cups() { print("Cups()"); } } public class ExplicitStatic { public static void main(String[] args) { print("Inside main()"); Cups.cup1.f(99); // (1) } // static Cups cups1 = new Cups(); // (2) // static Cups cups2 = new Cups(); // (2) } /* Output: Inside main() Cup(1) Cup(2) f(99) *///:~ The static initializers Cups run either access static object cup1 occurs line marked (1), line (1) commented lines marked (2) uncommented. If (1) (2) commented out, static initialization Cups never occurs, see output. Also, doesn’t matter one lines marked (2) uncommented; static initialization occurs once. Exercise 13: (1) Verify statements previous paragraph. Initialization & Cleanup 131 Exercise 14: (1) Create class static String field initialized point definition, another one initialized static block. Add static method prints fields demonstrates initialized used. Non-static instance initialization Java provides similar syntax, called instance initialization, initializing non-static variables object. Here’s example: //: initialization/Mugs.java // Java "Instance Initialization." import static net.mindview.util.Print.*; class Mug { Mug(int marker) { print("Mug(" + marker + ")"); } void f(int marker) { print("f(" + marker + ")"); } } public class Mugs { Mug mug1; Mug mug2; { mug1 = new Mug(1); mug2 = new Mug(2); print("mug1 & mug2 initialized"); } Mugs() { print("Mugs()"); } Mugs(int i) { print("Mugs(int)"); } public static void main(String[] args) { print("Inside main()"); new Mugs(); print("new Mugs() completed"); new Mugs(1); print("new Mugs(1) completed"); } } /* Output: Inside main() Mug(1) Mug(2) mug1 & mug2 initialized Mugs() new Mugs() completed Mug(1) Mug(2) mug1 & mug2 initialized Mugs(int) new Mugs(1) completed *///:~ You see instance initialization clause: { 132 Thinking Java Bruce Eckel } mug1 = new Mug(1); mug2 = new Mug(2); print("mug1 & mug2 initialized"); looks exactly like static initialization clause except missing static keyword. This syntax necessary support initialization anonymous inner classes (see Inner Classes chapter), also allows guarantee certain operations occur regardless explicit constructor called. From output, see instance initialization clause executed either one constructors. Exercise 15: (1) Create class String initialized using instance initialization. Array initialization An array simply sequence either objects primitives type packaged together one identifier name. Arrays defined used squarebrackets indexing operator [ ]. To define array reference, simply follow type name empty square brackets: int[] a1; You also put square brackets identifier produce exactly meaning: int a1[]; This conforms expectations C C++ programmers. The former style, however, probably sensible syntax, since says type “an int array.” That style used book. The compiler doesn’t allow tell big array is. This brings us back issue “references.” All point reference array (you’ve allocated enough storage reference), there’s space allocated array object itself. To create storage array, must write initialization expression. For arrays, initialization appear anywhere code, also use special kind initialization expression must occur point array created. This special initialization set values surrounded curly braces. The storage allocation (the equivalent using new) taken care compiler case. For example: int[] a1 = { 1, 2, 3, 4, 5 }; So would ever define array reference without array? int[] a2; Well, it’s possible assign one array another Java, say: a2 = a1; What you’re really copying reference, demonstrated here: //: initialization/ArraysOfPrimitives.java import static net.mindview.util.Print.*; Initialization & Cleanup 133 public class ArraysOfPrimitives { public static void main(String[] args) { int[] a1 = { 1, 2, 3, 4, 5 }; int[] a2; a2 = a1; for(int = 0; < a2.length; i++) a2[i] = a2[i] + 1; for(int = 0; < a1.length; i++) print("a1[" + + "] = " + a1[i]); } } /* Output: a1[0] = 2 a1[1] = 3 a1[2] = 4 a1[3] = 5 a1[4] = 6 *///:~ You see a1 given initialization value a2 not; a2 assigned later—in case, another array. Since a2 a1 aliased array, changes made via a2 seen a1. All arrays intrinsic member (whether they’re arrays objects arrays primitives) query—but change—to tell many elements array. This member length. Since arrays Java, like C C++, start counting element zero, largest element index length - 1. If go bounds, C C++ quietly accept allow stomp memory, source many infamous bugs. However, Java protects problems causing runtime error (an exception) step bounds. 5 What don’t know many elements you’re going need array you’re writing program? You simply use new create elements array. Here, new works even though it’s creating array primitives (new won’t create non-array primitive): //: initialization/ArrayNew.java // Creating arrays new. import java.util.*; import static net.mindview.util.Print.*; public class ArrayNew { public static void main(String[] args) { int[] a; Random rand = new Random(47); = new int[rand.nextInt(20)]; print("length = " + a.length); print(Arrays.toString(a)); } } /* Output: length = 18 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] *///:~ The size array chosen random using Random.nextInt( ) method, produces value zero argument. Because randomness, it’s clear 5 Of course, checking every array access costs time code there’s way turn off, means array accesses might source inefficiency program occur critical juncture. For Internet security programmer productivity, Java designers saw worthwhile trade-off. Although may tempted write code think might make array accesses efficient, waste time automatic compile-time runtime optimizations speed array accesses. 134 Thinking Java Bruce Eckel array creation actually happening run time. In addition, output program shows array elements primitive types automatically initialized “empty” values. (For numerics char, zero, boolean, it’s false.) The Arrays.toString( ) method, part standard java.util library, produces printable version one-dimensional array. Of course, case array could also defined initialized statement: int[] = new int[rand.nextInt(20)]; This preferred way it, can. If create non-primitive array, create array references. Consider wrapper type Integer, class primitive: //: initialization/ArrayClassObj.java // Creating array nonprimitive objects. import java.util.*; import static net.mindview.util.Print.*; public class ArrayClassObj { public static void main(String[] args) { Random rand = new Random(47); Integer[] = new Integer[rand.nextInt(20)]; print("length = " + a.length); for(int = 0; < a.length; i++) a[i] = rand.nextInt(500); // Autoboxing print(Arrays.toString(a)); } } /* Output: (Sample) length = 18 [55, 193, 361, 461, 429, 368, 200, 22, 207, 288, 128, 51, 89, 309, 278, 498, 361, 20] *///:~ Here, even new called create array: Integer[] = new Integer[rand.nextInt(20)]; it’s array references, initialization complete reference initialized creating new Integer object (via autoboxing, case): a[i] = rand.nextInt(500); If forget create object, however, you’ll get exception run time try use empty array location. It’s also possible initialize arrays objects using curly brace-enclosed list. There two forms: //: initialization/ArrayInit.java // Array initialization. import java.util.*; public class ArrayInit { public static void main(String[] args) { Integer[] = { Initialization & Cleanup 135 new Integer(1), new Integer(2), 3, // Autoboxing }; Integer[] b = new Integer[]{ new Integer(1), new Integer(2), 3, // Autoboxing }; System.out.println(Arrays.toString(a)); System.out.println(Arrays.toString(b)); } } /* Output: [1, 2, 3] [1, 2, 3] *///:~ In cases, final comma list initializers optional. (This feature makes easier maintenance long lists.) Although first form useful, it’s limited used point array defined. You use second third forms anywhere, even inside method call. For example, could create array String objects pass main( ) another method, provide alternate command-line arguments main( ): //: initialization/DynamicArray.java // Array initialization. public class DynamicArray { public static void main(String[] args) { Other.main(new String[]{ "fiddle", "de", "dum" }); } } class Other { public static void main(String[] args) { for(String : args) System.out.print(s + " "); } } /* Output: fiddle de dum *///:~ The array created argument Other.main( ) created point method call, even provide alternate arguments time call. Exercise 16: (1) Create array String objects assign String element. Print array using loop. Exercise 17: (2) Create class constructor takes String argument. During construction, print argument. Create array object references class, don’t actually create objects assign array. When run program, notice whether initialization messages constructor calls printed. Exercise 18: (1) Complete previous exercise creating objects attach array references. 136 Thinking Java Bruce Eckel Variable argument lists The second form provides convenient syntax create call methods produce effect similar C’s variable argument lists (known “varargs” C). These include unknown quantities arguments well unknown types. Since classes ultimately inherited common root class Object (a subject learn book progresses), create method takes array Object call like this: //: initialization/VarArgs.java // Using array syntax create variable argument lists. class A {} public class VarArgs { static void printArray(Object[] args) { for(Object obj : args) System.out.print(obj + " "); System.out.println(); } public static void main(String[] args) { printArray(new Object[]{ new Integer(47), new Float(3.14), new Double(11.11) }); printArray(new Object[]{"one", "two", "three" }); printArray(new Object[]{new A(), new A(), new A()}); } } /* Output: (Sample) 47 3.14 11.11 one two three A@1a46e30 A@3e25a5 A@19821f *///:~ You see print( ) takes array Object, steps array using foreach syntax prints one. The standard Java library classes produce sensible output, objects classes created print class name, followed ‘@’ sign hexadecimal digits. Thus, default behavior (if don’t define toString( ) method class, described later book) print class name address object. You may see pre-Java SE5 code written like order produce variable argument lists. In Java SE5, however, long-requested feature finally added, use ellipses define variable argument list, see printArray( ): //: initialization/NewVarArgs.java // Using array syntax create variable argument lists. public class NewVarArgs { static void printArray(Object... args) { for(Object obj : args) System.out.print(obj + " "); System.out.println(); } public static void main(String[] args) { // Can take individual elements: printArray(new Integer(47), new Float(3.14), new Double(11.11)); printArray(47, 3.14F, 11.11); printArray("one", "two", "three"); printArray(new A(), new A(), new A()); // Or array: Initialization & Cleanup 137 printArray((Object[])new Integer[]{ 1, 2, 3, 4 }); printArray(); // Empty list OK } } /* Output: (75% match) 47 3.14 11.11 47 3.14 11.11 one two three A@1bab50a A@c3c749 A@150bd4d 1 2 3 4 *///:~ With varargs, longer explicitly write array syntax—the compiler actually fill specify varargs. You’re still getting array, print( ) able use foreach iterate array. However, it’s automatic conversion list elements array. Notice second-t0-last line program, array Integer (created using autoboxing) cast Object array (to remove compiler warning) passed printArray( ). Clearly, compiler sees already array performs conversion it. So group items pass list, already array accept variable argument list. The last line program shows it’s possible pass zero arguments vararg list. This helpful optional trailing arguments: //: initialization/OptionalTrailingArguments.java public class OptionalTrailingArguments { static void f(int required, String... trailing) { System.out.print("required: " + required + " "); for(String : trailing) System.out.print(s + " "); System.out.println(); } public static void main(String[] args) { f(1, "one"); f(2, "two", "three"); f(0); } } /* Output: required: 1 one required: 2 two three required: 0 *///:~ This also shows use varargs specified type Object. Here, varargs must String objects. It’s possible use type argument varargs, including primitive type. The following example also shows vararg list becomes array, there’s nothing list it’s array size zero: //: initialization/VarargType.java public class VarargType { static void f(Character... args) { System.out.print(args.getClass()); System.out.println(" length " + args.length); } static void g(int... args) { System.out.print(args.getClass()); System.out.println(" length " + args.length); } public static void main(String[] args) { 138 Thinking Java Bruce Eckel f(‘a’); f(); g(1); g(); System.out.println("int[]: " + new int[0].getClass()); } } /* Output: class [Ljava.lang.Character; length 1 class [Ljava.lang.Character; length 0 class [I length 1 class [I length 0 int[]: class [I *///:~ The getClass( ) method part Object, explored fully Type Information chapter. It produces class object, print class, see encoded string representing class type. The leading ‘[‘ indicates array type follows. The ‘I’ primitive int; double-check, I created array int last line printed type. This verifies using varargs depend autoboxing, actually uses primitive types. Varargs work harmony autoboxing, however. For example: //: initialization/AutoboxingVarargs.java public class AutoboxingVarargs { public static void f(Integer... args) { for(Integer : args) System.out.print(i + " "); System.out.println(); } public static void main(String[] args) { f(new Integer(1), new Integer(2)); f(4, 5, 6, 7, 8, 9); f(10, new Integer(11), 12); } } /* Output: 1 2 4 5 6 7 8 9 10 11 12 *///:~ Notice mix types together single argument list, autoboxing selectively promotes int arguments Integer. Varargs complicate process overloading, although seems safe enough first: //: initialization/OverloadingVarargs.java public class OverloadingVarargs { static void f(Character... args) { System.out.print("first"); for(Character c : args) System.out.print(" " + c); System.out.println(); } static void f(Integer... args) { System.out.print("second"); for(Integer : args) System.out.print(" " + i); System.out.println(); Initialization & Cleanup 139 } static void f(Long... args) { System.out.println("third"); } public static void main(String[] args) { f(‘a’, ‘b’, ‘c’); f(1); f(2, 1); f(0); f(0L); //! f(); // Won’t compile -- ambiguous } } /* Output: first b c second 1 second 2 1 second 0 third *///:~ In case, compiler using autoboxing match overloaded method, calls specifically matching method. But call f( ) without arguments, way knowing one call. Although error understandable, probably surprise client programmer. You might try solving problem adding non-vararg argument one methods: //: initialization/OverloadingVarargs2.java // {CompileTimeError} (Won’t compile) public class OverloadingVarargs2 { static void f(float i, Character... args) { System.out.println("first"); } static void f(Character... args) { System.out.print("second"); } public static void main(String[] args) { f(1, ‘a’); f(‘a’, ‘b’); } } ///:~ The {CompileTimeError} comment tag excludes file book’s Ant build. If compile hand you’ll see error message: reference f ambiguous, method f(float,java.lang.Character...) OverloadingVarargs2 method f(java.lang.Character...) OverloadingVarargs2 match If give methods non-vararg argument, works: //: initialization/OverloadingVarargs3.java public class OverloadingVarargs3 { static void f(float i, Character... args) { System.out.println("first"); } static void f(char c, Character... args) { 140 Thinking Java Bruce Eckel System.out.println("second"); } public static void main(String[] args) { f(1, ‘a’); f(‘a’, ‘b’); } } /* Output: first second *///:~ You generally use variable argument list one version overloaded method. Or consider all. Exercise 19: (2) Write method takes vararg String array. Verify pass either comma-separated list Strings String[] method. Exercise 20: (1) Create main( ) uses varargs instead ordinary main( ) syntax. Print elements resulting args array. Test various numbers command-line arguments. Enumerated types An apparently small addition Java SE5 enum keyword, makes life much easier need group together use set enumerated types. In past would created set constant integral values, naturally restrict set thus riskier difficult use. Enumerated types common enough need C, C++, number languages always them. Before Java SE5, Java programmers forced know lot quite careful wanted properly produce enum effect. Now Java enum, too, it’s much full-featured find C/C++. Here’s simple example: //: initialization/Spiciness.java public enum Spiciness { NOT, MILD, MEDIUM, HOT, FLAMING } ///:~ This creates enumerated type called Spiciness five named values. Because instances enumerated types constants, capital letters convention (if multiple words name, separated underscores). To use enum, create reference type assign instance: //: initialization/SimpleEnumUse.java public class SimpleEnumUse { public static void main(String[] args) { Spiciness howHot = Spiciness.MEDIUM; System.out.println(howHot); } } /* Output: MEDIUM *///:~ The compiler automatically adds useful features create enum. For example, creates toString( ) easily display name enum instance, print statement produced output. The compiler also creates ordinal( ) Initialization & Cleanup 141 method indicate declaration order particular enum constant, static values( ) method produces array values enum constants order declared: //: initialization/EnumOrder.java public class EnumOrder { public static void main(String[] args) { for(Spiciness : Spiciness.values()) System.out.println(s + ", ordinal " + s.ordinal()); } } /* Output: NOT, ordinal 0 MILD, ordinal 1 MEDIUM, ordinal 2 HOT, ordinal 3 FLAMING, ordinal 4 *///:~ Although enums appear new data type, keyword produces compiler behavior generating class enum, many ways treat enum class. In fact, enums classes methods. An especially nice feature way enums used inside switch statements: //: initialization/Burrito.java public class Burrito { Spiciness degree; public Burrito(Spiciness degree) { this.degree = degree;} public void describe() { System.out.print("This burrito "); switch(degree) { case NOT: System.out.println("not spicy all."); break; case MILD: case MEDIUM: System.out.println("a little hot."); break; case HOT: case FLAMING: default: System.out.println("maybe hot."); } } public static void main(String[] args) { Burrito plain = new Burrito(Spiciness.NOT), greenChile = new Burrito(Spiciness.MEDIUM), jalapeno = new Burrito(Spiciness.HOT); plain.describe(); greenChile.describe(); jalapeno.describe(); } } /* Output: This burrito spicy all. This burrito little hot. This burrito maybe hot. *///:~ Since switch intended select limited set possibilities, it’s ideal match enum. Notice enum names produce much clearer indication program means do. 142 Thinking Java Bruce Eckel In general use enum another way create data type, put results work. That’s point, don’t think hard them. Before introduction enum Java SE5, go lot effort make equivalent enumerated type safe use. This enough understand use basic enums, we’ll look deeply later book—they chapter: Enumerated Types. Exercise 21: (1) Create enum least-valuable six types paper currency. Loop values( ) print value ordinal( ). Exercise 22: (2) Write switch statement enum previous example. For case, output description particular currency. Summary This seemingly elaborate mechanism initialization, constructor, give strong hint critical importance placed initialization language. As Bjarne Stroustrup, inventor C++, designing language, one first observations made productivity C improper initialization variables causes significant portion programming problems. These kinds bugs hard find, similar issues apply improper cleanup. Because constructors allow guarantee proper initialization cleanup (the compiler allow object created without proper constructor calls), get complete control safety. In C++, destruction quite important objects created new must explicitly destroyed. In Java, garbage collector automatically releases memory objects, equivalent cleanup method Java isn’t necessary much time (but is, must yourself). In cases don’t need destructor-like behavior, Java’s garbage collector greatly simplifies programming adds much-needed safety managing memory. Some garbage collectors even clean resources like graphics file handles. However, garbage collector add runtime cost, expense difficult put perspective historical slowness Java interpreters. Although Java significant performance increases time, speed problem taken toll adoption language certain types programming problems. Because guarantee objects constructed, there’s actually constructor shown here. In particular, create new classes using either composition inheritance, guarantee construction also holds, additional syntax necessary support this. You’ll learn composition, inheritance, affect constructors future chapters. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Initialization & Cleanup 143 Access Control Access control (or implementation hiding) “not getting right first time.” All good writers—including write software—know piece work isn’t good it’s rewritten, often many times. If leave piece code drawer come back it, may see much better way it. This one prime motivations refactoring, rewrites working code order make readable, understandable, thus maintainable. 1 There tension, however, desire change improve code. There often consumers (client programmers) rely aspect code staying same. So want change it; want stay same. Thus primary consideration objectoriented design “separate things change things stay same.” This particularly important libraries. Consumers library must rely part use, know won’t need rewrite code new version library comes out. On flip side, library creator must freedom make modifications improvements certainty client code won’t affected changes. This achieved convention. For example, library programmer must agree remove existing methods modifying class library, since would break client programmer’s code. The reverse situation thornier, however. In case field, library creator know fields accessed client programmers? This also true methods part implementation class, meant used directly client programmer. What library creator wants rip old implementation put new one? Changing members might break client programmer’s code. Thus library creator strait jacket can’t change anything. To solve problem, Java provides access specifiers allow library creator say available client programmer not. The levels access control “most access” “least access” public, protected, package access (which keyword), private. From previous paragraph might think that, library designer, you’ll want keep everything “private” possible, expose methods want client programmer use. This exactly right, even though it’s often counterintuitive people program languages (especially C) used accessing everything without restriction. By end chapter convinced value access control Java. The concept library components control access components library complete, however. There’s still question components bundled together cohesive library unit. This controlled package keyword Java, access specifiers affected whether class package separate package. So begin chapter, you’ll learn library components placed packages. Then you’ll able understand complete meaning access specifiers. 1 See Refactoring: Improving Design Existing Code, Martin Fowler, et al. (Addison-Wesley, 1999). Occasionally someone argue refactoring, suggesting code works perfectly good it’s waste time refactor it. The problem way thinking lion’s share project’s time money initial writing code, maintaining it. Making code easier understand translates significant dollars. package: library unit A package contains group classes, organized together single namespace. For example, there’s utility library that’s part standard Java distribution, organized namespace java.util. One classes java.util called ArrayList. One way use ArrayList specify full name java.util.ArrayList. //: access/FullQualification.java public class FullQualification { public static void main(String[] args) { java.util.ArrayList list = new java.util.ArrayList(); } } ///:~ This rapidly becomes tedious, you’ll probably want use import keyword instead. If want import single class, name class import statement: //: access/SingleImport.java import java.util.ArrayList; public class SingleImport { public static void main(String[] args) { ArrayList list = new java.util.ArrayList(); } } ///:~ Now use ArrayList qualification. However, none classes java.util available. To import everything, simply use ‘*’ you’ve seeing rest examples book: import java.util.*; The reason importing provide mechanism manage namespaces. The names class members insulated other. A method f( ) inside class A clash f( ) signature class B. But class names? Suppose create Stack class installed machine already Stack class that’s written someone else? This potential clashing names it’s important complete control namespaces Java, create unique identifier combination class. Most examples thus far book existed single file designed local use, haven’t bothered package names. These examples actually packages: “unnamed” default package. This certainly option, simplicity’s sake approach used whenever possible throughout rest book. However, you’re planning create libraries programs friendly Java programs machine, must think preventing class name clashes. When create source-code file Java, it’s commonly called compilation unit (sometimes translation unit). Each compilation unit must name ending .java, inside compilation unit public class must name file (including capitalization, excluding .java file name extension). There one public class compilation unit; otherwise, compiler complain. If additional classes compilation unit, hidden world outside package they’re public, comprise “support” classes main public class. 146 Thinking Java Bruce Eckel Code organization When compile .java file, get output file class .java file. Each output file name class .java file, extension .class. Thus end quite .class files small number .java files. If you’ve programmed compiled language, might used compiler spitting intermediate form (usually “obj” file) packaged together others kind using linker (to create executable file) librarian (to create library). That’s Java works. A working program bunch .class files, packaged compressed Java ARchive (JAR) file (using Java’s jar archiver). The Java interpreter responsible finding, loading, interpreting 2 files. A library group class files. Each source file usually public class number non-public classes, there’s one public component source file. If want say components (each separate .java .class files) belong together, that’s package keyword comes in. If use package statement, must appear first non-comment file. When say: package access; you’re stating compilation unit part library named access. Put another way, you’re saying public class name within compilation unit umbrella name access, anyone wants use name must either fully specify name use import keyword combination access, using choices given previously. (Note convention Java package names use lowercase letters, even intermediate words.) For example, suppose name file MyClass.java. This means one one public class file, name class must MyClass (including capitalization): //: access/mypackage/MyClass.java package access.mypackage; public class MyClass { // ... } ///:~ Now, someone wants use MyClass or, matter, public classes access, must use import keyword make name names access available. The alternative give fully qualified name: //: access/QualifiedMyClass.java public class QualifiedMyClass { public static void main(String[] args) { access.mypackage.MyClass = new access.mypackage.MyClass(); } } ///:~ 2 There’s nothing Java forces use interpreter. There exist native-code Java compilers generate single executable file. Access Control 147 The import keyword make much cleaner: //: access/ImportedMyClass.java import access.mypackage.*; public class ImportedMyClass { public static void main(String[] args) { MyClass = new MyClass(); } } ///:~ It’s worth keeping mind package import keywords allow do, library designer, divide single global namespace won’t clashing names, matter many people get Internet start writing classes Java. Creating unique package names You might observe that, since package never really gets “packaged” single file, package made many .class files, things could get bit cluttered. To prevent this, logical thing place .class files particular package single directory; is, use hierarchical file structure operating system advantage. This one way Java references problem clutter; you’ll see way later jar utility introduced. Collecting package files single subdirectory solves two problems: creating unique package names, finding classes might buried directory structure someplace. This accomplished encoding path location .class file name package. By convention, first part package name reversed Internet domain name creator class. Since Internet domain names guaranteed unique, follow convention, package name unique you’ll never name clash. (That is, lose domain name someone else starts writing Java code path names did.) Of course, don’t domain name, must fabricate unlikely combination (such first last name) create unique package names. If you’ve decided start publishing Java code, it’s worth relatively small effort get domain name. The second part trick resolving package name directory machine, Java program runs needs load .class file, locate directory .class file resides. The Java interpreter proceeds follows. First, finds environment variable CLASSPATH 3 (set via operating system, sometimes installation program installs Java Java-based tool machine). CLASSPATH contains one directories used roots search .class files. Starting root, interpreter take package name replace dot slash generate path name CLASSPATH root (so package foo.bar.baz becomes foo\bar\baz foo/bar/baz possibly something else, depending operating system). This concatenated various entries CLASSPATH. That’s looks .class file name corresponding class you’re trying create. (It also searches standard directories relative Java interpreter resides.) To understand this, consider domain name, MindView.net. By reversing making lowercase, net.mindview establishes unique global name classes. (The com, edu, org, etc., extensions formerly capitalized Java packages, changed Java 2 entire package name lowercase.) I subdivide 3 When referring environment variable, capital letters used (CLASSPATH). 148 Thinking Java Bruce Eckel deciding I want create library named simple, I’ll end package name: package net.mindview.simple; Now package name used umbrella namespace following two files: //: net/mindview/simple/Vector.java // Creating package. package net.mindview.simple; public class Vector { public Vector() { System.out.println("net.mindview.simple.Vector"); } } ///:~ As mentioned before, package statement must first non-comment code file. The second file looks much same: //: net/mindview/simple/List.java // Creating package. package net.mindview.simple; public class List { public List() { System.out.println("net.mindview.simple.List"); } } ///:~ Both files placed subdirectory system: C:\DOC\JavaT\net\mindview\simple (Notice first comment line every file book establishes directory location file source-code tree—this used automatic code-extraction tool book.) If walk back path, see package name net.mindview.simple, first portion path? That’s taken care CLASSPATH environment variable, is, machine: CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT You see CLASSPATH contain number alternative search paths. There’s variation using JAR files, however. You must put actual name JAR file classpath, path it’s located. So JAR named grape.jar classpath would include: CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar Once classpath set properly, following file placed directory: //: access/LibTest.java // Uses library. import net.mindview.simple.*; Access Control 149 public class LibTest { public static void main(String[] args) { Vector v = new Vector(); List l = new List(); } } /* Output: net.mindview.simple.Vector net.mindview.simple.List *///:~ When compiler encounters import statement simple library, begins searching directories specified CLASSPATH, looking subdirectory net/mindview/simple, seeking compiled files appropriate names (Vector.class Vector, List.class List). Note classes desired methods Vector List must public. Setting CLASSPATH trial beginning Java users (it me, I started) Sun made JDK later versions Java bit smarter. You’ll find install it, even don’t set CLASSPATH, you’ll able compile run basic Java programs. To compile run source-code package book (available www.MindView.net), however, need add base directory book’s code tree CLASSPATH. Exercise 1: (1) Create class package. Create instance class outside package. Collisions What happens two libraries imported via ‘*’ include names? For example, suppose program this: import net.mindview.simple.*; import java.util.*; Since java.util.* also contains Vector class, causes potential collision. However, long don’t write code actually causes collision, everything OK—this good, otherwise might end lot typing prevent collisions would never happen. The collision occur try make Vector: Vector v = new Vector(); Which Vector class refer to? The compiler can’t know, reader can’t know either. So compiler complains forces explicit. If I want standard Java Vector, example, I must say: java.util.Vector v = new java.util.Vector(); Since (along CLASSPATH) completely specifies location Vector, there’s need import java.util.* statement unless I’m using something else java.util. Alternatively, use single-class import form prevent clashes—as long don’t use colliding names program (in case must fall back fully specifying names). 150 Thinking Java Bruce Eckel Exercise 2: (1) Take code fragments section turn program, verify collisions fact occur. A custom tool library With knowledge, create libraries tools reduce eliminate duplicate code. Consider, example, alias we’ve using System.out.println( ), reduce typing. This part class called Print end readable static import: //: net/mindview/util/Print.java // Print methods used without // qualifiers, using Java SE5 static imports: package net.mindview.util; import java.io.*; public class Print { // Print newline: public static void print(Object obj) { System.out.println(obj); } // Print newline itself: public static void print() { System.out.println(); } // Print line break: public static void printnb(Object obj) { System.out.print(obj); } // The new Java SE5 printf() (from C): public static PrintStream printf(String format, Object... args) { return System.out.printf(format, args); } } ///:~ You use printing shorthand print anything, either newline (print( )) without newline (printnb( )). You guess location file must directory starts one CLASSPATH locations, continues net/mindview. After compiling, static print( ) printnb( ) methods used anywhere system import static statement: //: access/PrintTest.java // Uses static printing methods Print.java. import static net.mindview.util.Print.*; public class PrintTest { public static void main(String[] args) { print("Available on!"); print(100); print(100L); print(3.14159); } } /* Output: Available on! 100 100 3.14159 Access Control 151 *///:~ A second component library range( ) methods, introduced Controlling Execution chapter, allow use foreach syntax simple integer sequences: //: net/mindview/util/Range.java // Array creation methods used without // qualifiers, using Java SE5 static imports: package net.mindview.util; public class Range { // Produce sequence [0..n) public static int[] range(int n) { int[] result = new int[n]; for(int = 0; < n; i++) result[i] = i; return result; } // Produce sequence [start..end) public static int[] range(int start, int end) { int sz = end - start; int[] result = new int[sz]; for(int = 0; < sz; i++) result[i] = start + i; return result; } // Produce sequence [start..end) incrementing step public static int[] range(int start, int end, int step) { int sz = (end - start)/step; int[] result = new int[sz]; for(int = 0; < sz; i++) result[i] = start + (i * step); return result; } } ///:~ From on, whenever come useful new utility, add library. You’ll see components added net.mindview.util library throughout book. Using imports change behavior A feature missing Java C’s conditional compilation, allows change switch get different behavior without changing code. The reason feature left Java probably often used C solve crossplatform issues: Different portions code compiled depending target platform. Since Java intended automatically cross-platform, feature necessary. However, valuable uses conditional compilation. A common use debugging code. The debugging features enabled development disabled shipping product. You accomplish changing package that’s imported order change code used program debug version production version. This technique used kind conditional code. Exercise 3: (2) Create two packages: debug debugoff, containing identical class debug( ) method. The first version displays String argument console, 152 Thinking Java Bruce Eckel second nothing. Use static import line import class test program, demonstrate conditional compilation effect. Package caveat It’s worth remembering anytime create package, implicitly specify directory structure give package name. The package must live directory indicated name, must directory searchable starting CLASSPATH. Experimenting package keyword bit frustrating first, unless adhere package-name directory-path rule, you’ll get lot mysterious runtime messages able find particular class, even class sitting directory. If get message like this, try commenting package statement, runs, you’ll know problem lies. Note compiled code often placed different directory source code, path compiled code must still found JVM using CLASSPATH. Java access specifiers The Java access specifiers public, protected, private placed front definition member class, whether it’s field method. Each access specifier controls access particular definition. If don’t provide access specifier, means “package access.” So one way another, everything kind access control. In following sections, you’ll learn various types access. Package access All examples chapter used access specifiers. The default access keyword, commonly referred package access (and sometimes “friendly”). It means classes current package access member, classes outside package, member appears private. Since compilation unit—a file—can belong single package, classes within single compilation unit automatically available via package access. Package access allows group related classes together package easily interact other. When put classes together package, thus granting mutual access package-access members, “own” code package. It makes sense code package access code own. You could say package access gives meaning reason grouping classes together package. In many languages way organize definitions files arbitrary, Java you’re compelled organize sensible fashion. In addition, you’ll probably want exclude classes shouldn’t access classes defined current package. The class controls code access members. Code another package can’t come around say, “Hi, I’m friend Bob’s!” expect shown protected, package-access, private members Bob. The way grant access member to: 1. Make member public. Then everybody, everywhere, access it. Access Control 153 2. Give member package access leaving access specifier, put classes package. Then classes package access member. 3. As you’ll see Reusing Classes chapter, inheritance introduced, inherited class access protected member well public member (but private members). It access package-access members two classes package. But don’t worry inheritance protected right now. 4. Provide “accessor/mutator” methods (also known “get/set” methods) read change value. This civilized approach terms OOP, fundamental JavaBeans, you’ll see Graphical User Interfaces chapter. public: interface access When use public keyword, means member declaration immediately follows public available everyone, particular client programmer uses library. Suppose define package dessert containing following compilation unit: //: access/dessert/Cookie.java // Creates library. package access.dessert; public class Cookie { public Cookie() { System.out.println("Cookie constructor"); } void bite() { System.out.println("bite"); } } ///:~ Remember, class file produced Cookie.java must reside subdirectory called dessert, directory access (indicating Access Control chapter book) must one CLASSPATH directories. Don’t make mistake thinking Java always look current directory one starting points searching. If don’t ‘.’ one paths CLASSPATH, Java won’t look there. Now create program uses Cookie: //: access/Dinner.java // Uses library. import access.dessert.*; public class Dinner { public static void main(String[] args) { Cookie x = new Cookie(); //! x.bite(); // Can’t access } } /* Output: Cookie constructor *///:~ create Cookie object, since constructor public class public. (We’ll look concept public class later.) However, bite( ) member inaccessible inside Dinner.java since bite( ) provides access within package dessert, compiler prevents using it. 154 Thinking Java Bruce Eckel The default package You might surprised discover following code compiles, even though would appear breaks rules: //: access/Cake.java // Accesses class separate compilation unit. class Cake { public static void main(String[] args) { Pie x = new Pie(); x.f(); } } /* Output: Pie.f() *///:~ In second file directory: //: access/Pie.java // The class. class Pie { void f() { System.out.println("Pie.f()"); } } ///:~ You might initially view completely foreign files, yet Cake able create Pie object call f( ) method. (Note must ‘.’ CLASSPATH order files compile.) You’d typically think Pie f( ) package access therefore available Cake. They package access—that part correct. The reason available Cake.java directory explicit package name. Java treats files like implicitly part “default package” directory, thus provide package access files directory. private: can’t touch that! The private keyword means one access member except class contains member, inside methods class. Other classes package cannot access private members, it’s you’re even insulating class yourself. On hand, it’s unlikely package might created several people collaborating together, private allows freely change member without concern affect another class package. The default package access often provides adequate amount hiding; remember, packageaccess member inaccessible client programmer using class. This nice, since default access one normally use (and one you’ll get forget add access control). Thus, you’ll typically think access members explicitly want make public client programmer, result, might initially think won’t use private keyword often, since it’s tolerable get away without it. However, turns consistent use private important, especially multithreading concerned. (As you’ll see Concurrency chapter.) Here’s example use private: //: access/IceCream.java // Demonstrates "private" keyword. Access Control 155 class Sundae { private Sundae() {} static Sundae makeASundae() { return new Sundae(); } } public class IceCream { public static void main(String[] args) { //! Sundae x = new Sundae(); Sundae x = Sundae.makeASundae(); } } ///:~ This shows example private comes handy: You might want control object created prevent someone directly accessing particular constructor (or them). In preceding example, cannot create Sundae object via constructor; instead, must call makeASundae( ) method you. 4 Any method you’re certain “helper” method class made private, ensure don’t accidentally use elsewhere package thus prohibit changing removing method. Making method private guarantees retain option. The true private field inside class. Unless must expose underlying implementation (which less likely might think), make fields private. However, reference object private inside class doesn’t mean object can’t public reference object. (See online supplements book learn aliasing issues.) protected: inheritance access Understanding protected access specifier requires jump ahead. First, aware don’t need understand section continue book inheritance (the Reusing Classes chapter). But completeness, brief description example using protected. The protected keyword deals concept called inheritance, takes existing class— refer base class—and adds new members class without touching existing class. You also change behavior existing members class. To inherit class, say new class extends existing class, like this: class Foo extends Bar { The rest class definition looks same. If create new package inherit class another package, members access public members original package. (Of course, perform inheritance package, manipulate members package access.) Sometimes creator base class would like take particular member grant access derived classes world general. That’s protected does. protected also gives package access—that is, classes package may access protected elements. 4 There’s another effect case: Since default constructor one defined, it’s private, prevent inheritance class. (A subject introduced later.) 156 Thinking Java Bruce Eckel If refer back file Cookie.java, following class cannot call package-access member bite( ): //: access/ChocolateChip.java // Can’t use package-access member another package. import access.dessert.*; public class ChocolateChip extends Cookie { public ChocolateChip() { System.out.println("ChocolateChip constructor"); } public void chomp() { //! bite(); // Can’t access bite } public static void main(String[] args) { ChocolateChip x = new ChocolateChip(); x.chomp(); } } /* Output: Cookie constructor ChocolateChip constructor *///:~ One interesting things inheritance method bite( ) exists class Cookie, also exists class inherited Cookie. But since bite( ) package access foreign package, it’s unavailable us one. Of course, could make public, everyone would access, maybe that’s want. If change class Cookie follows: //: access/cookie2/Cookie.java package access.cookie2; public class Cookie { public Cookie() { System.out.println("Cookie constructor"); } protected void bite() { System.out.println("bite"); } } ///:~ bite( ) becomes accessible anyone inheriting Cookie: //: access/ChocolateChip2.java import access.cookie2.*; public class ChocolateChip2 extends Cookie { public ChocolateChip2() { System.out.println("ChocolateChip2 constructor"); } public void chomp() { bite(); } // Protected method public static void main(String[] args) { ChocolateChip2 x = new ChocolateChip2(); x.chomp(); } } /* Output: Cookie constructor ChocolateChip2 constructor bite *///:~ Access Control 157 Note that, although bite( ) also package access, public. Exercise 4: (2) Show protected methods package access public. Exercise 5: (2) Create class public, private, protected, package-access fields method members. Create object class see kind compiler messages get try access class members. Be aware classes directory part “default” package. Exercise 6: (1) Create class protected data. Create second class file method manipulates protected data first class. Interface implementation Access control often referred implementation hiding. Wrapping data methods within classes combination implementation hiding often called encapsulation. 5 The result data type characteristics behaviors. Access control puts boundaries within data type two important reasons. The first establish client programmers can’t use. You build internal mechanisms structure without worrying client programmers accidentally treat internals part interface using. This feeds directly second reason, separate interface implementation. If structure used set programs, client programmers can’t anything send messages public interface, free change anything that’s public (e.g., package access, protected, private) without breaking client code. For clarity, might prefer style creating classes puts public members beginning, followed protected, package-access, private members. The advantage user class read top see first what’s important (the public members, accessed outside file), stop reading encounter non-public members, part internal implementation: //: access/OrganizedByAccess.java public class OrganizedByAccess { public void pub1() { /* ... */ } public void pub2() { /* ... */ } public void pub3() { /* ... */ } private void priv1() { /* ... */ } private void priv2() { /* ... */ } private void priv3() { /* ... */ } private int i; // ... } ///:~ This make partially easier read, interface implementation still mixed together. That is, still see source code—the implementation—because it’s right class. In addition, comment documentation supported Javadoc lessens importance code readability client programmer. Displaying interface consumer class really job class browser, tool whose job look available classes show (i.e., members 5 However, people often refer implementation hiding alone encapsulation. 158 Thinking Java Bruce Eckel available) useful fashion. In Java, viewing JDK documentation Web browser gives effect class browser. Class access In Java, access specifiers also used determine classes within library available users library. If want class available client programmer, use public keyword entire class definition. This controls whether client programmer even create object class. To control access class, specifier must appear keyword class. Thus say: public class Widget { Now name library access, client programmer access Widget saying import access.Widget; import access.*; However, there’s extra set constraints: 1. There one public class per compilation unit (file). The idea compilation unit single public interface represented public class. It many supporting package-access classes want. If one public class inside compilation unit, compiler give error message. 2. The name public class must exactly match name file containing compilation unit, including capitalization. So Widget, name file must Widget.java, widget.java WIDGET.java. Again, you’ll get compile-time error don’t agree. 3. It possible, though typical, compilation unit public class all. In case, name file whatever like (although naming arbitrarily confusing people reading maintaining code). What you’ve got class inside access you’re using accomplish tasks performed Widget public class access? You don’t want go bother creating documentation client programmer, think sometime later might want completely change things rip class altogether, substituting different one. To give flexibility, need ensure client programmers become dependent particular implementation details hidden inside access. To accomplish this, leave public keyword class, case package access. (That class used within package.) Exercise 7: (1) Create library according code fragments describing access Widget. Create Widget class part access package. When create package-access class, still makes sense make fields class private—you always make fields private possible—but it’s generally reasonable give methods access class (package access). Since package-access Access Control 159 class usually used within package, need make methods class public you’re forced to, cases, compiler tell you. Note class cannot private (that would make inaccessible anyone class) protected. 6 So two choices class access: package access public. If don’t want anyone else access class, make constructors private, thereby preventing anyone you, inside static member class, creating object class. Here’s example: //: access/Lunch.java // Demonstrates class access specifiers. Make class // effectively private private constructors: class Soup1 { private Soup1() {} // (1) Allow creation via static method: public static Soup1 makeSoup() { return new Soup1(); } } class Soup2 { private Soup2() {} // (2) Create static object return reference // upon request.(The "Singleton" pattern): private static Soup2 ps1 = new Soup2(); public static Soup2 access() { return ps1; } public void f() {} } // Only one public class allowed per file: public class Lunch { void testPrivate() { // Can’t this! Private constructor: //! Soup1 soup = new Soup1(); } void testStatic() { Soup1 soup = Soup1.makeSoup(); } void testSingleton() { Soup2.access().f(); } } ///:~ Up now, methods returning either void primitive type, definition: public static Soup1 makeSoup() { return new Soup1(); } might look little confusing first. The word Soup1 method name (makeSoup) tells method returns. So far book, usually void, means returns nothing. But also return reference object, happens here. This method returns reference object class Soup1. 6 Actually, inner class private protected, that’s special case. These introduced Inner Classes chapter. 160 Thinking Java Bruce Eckel The classes Soup1 Soup2 show prevent direct creation class making constructors private. Remember don’t explicitly create least one constructor, default constructor (a constructor arguments) created you. By writing default constructor, won’t created automatically. By making private, one create object class. But anyone use class? The preceding example shows two options. In Soup1, static method created creates new Soup1 returns reference it. This useful want extra operations Soup1 returning it, want keep count many Soup1 objects create (perhaps restrict population). Soup2 uses what’s called design pattern, covered Thinking Patterns (with Java) www.MindView.net. This particular pattern called Singleton, allows single object ever created. The object class Soup2 created static private member Soup2, there’s one one, can’t get except public method access( ). As previously mentioned, don’t put access specifier class access, defaults package access. This means object class created class package, outside package. (Remember, files within directory don’t explicit package declarations implicitly part default package directory.) However, static member class public, client programmer still access static member even though cannot create object class. Exercise 8: (4) Following form example Lunch.java, create class called ConnectionManager manages fixed array Connection objects. The client programmer must able explicitly create Connection objects, get via static method ConnectionManager. When ConnectionManager runs objects, returns null reference. Test classes main( ). Exercise 9: (2) Create following file access/local directory (presumably CLASSPATH): // access/local/PackagedClass.java package access.local; class PackagedClass { public PackagedClass() { System.out.println("Creating packaged class"); } } Then create following file directory access/local: // access/foreign/Foreign.java package access.foreign; import access.local.*; public class Foreign { public static void main(String[] args) { PackagedClass pc = new PackagedClass(); } } Explain compiler generates error. Would making Foreign class part access.local package change anything? Access Control 161 Summary In relationship it’s important boundaries respected parties involved. When create library, establish relationship user library—the client programmer—who another programmer, one using library build application bigger library. Without rules, client programmers anything want members class, even might prefer don’t directly manipulate members. Everything’s naked world. This chapter looked classes built form libraries: first, way group classes packaged within library, second, way class controls access members. It estimated C programming project begins break somewhere 50K 100K lines code C single namespace, names begin collide, causing extra management overhead. In Java, package keyword, package naming scheme, import keyword give complete control names, issue name collision easily avoided. There two reasons controlling access members. The first keep users’ hands portions shouldn’t touch. These pieces necessary internal operations class, part interface client programmer needs. So making methods fields private service client programmers, easily see what’s important ignore. It simplifies understanding class. The second important reason access control allow library designer change internal workings class without worrying affect client programmer. You might, example, build class one way first, discover restructuring code provide much greater speed. If interface implementation clearly separated protected, accomplish without forcing client programmers rewrite code. Access control ensures client programmer becomes dependent part underlying implementation class. When ability change underlying implementation, freedom improve design, also freedom make mistakes. No matter carefully plan design, you’ll make mistakes. Knowing it’s relatively safe make mistakes means you’ll experimental, you’ll learn quickly, you’ll finish project sooner. The public interface class user see, important part class get “right” analysis design. Even allows leeway change. If don’t get interface right first time, add methods, long don’t remove client programmers already used code. Notice access control focuses relationship—and kind communication—between library creator external clients library. There many situations case. For example, writing code yourself, working close quarters small team everything goes package. These situations different kind communication, rigid adherence access rules may optimal. Default (package) access may fine. 162 Thinking Java Bruce Eckel Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Access Control 163 Reusing Classes One compelling features Java code reuse. But revolutionary, you’ve got able lot copy code change it. That’s approach used procedural languages like C, hasn’t worked well. Like everything Java, solution revolves around class. You reuse code creating new classes, instead creating scratch, use existing classes someone already built debugged. The trick use classes without soiling existing code. In chapter you’ll see two ways accomplish this. The first quite straightforward: simply create objects existing class inside new class. This called composition, new class composed objects existing classes. You’re simply reusing functionality code, form. The second approach subtle. It creates new class type existing class. You literally take form existing class add code without modifying existing class. This technique called inheritance, compiler work. Inheritance one cornerstones object-oriented programming, additional implications explored Polymorphism chapter. It turns much syntax behavior similar composition inheritance (which makes sense ways making new types existing types). In chapter, you’ll learn code reuse mechanisms. Composition syntax Composition used quite frequently point book. You simply place object references inside new classes. For example, suppose you’d like object holds several String objects, couple primitives, object another class. For nonprimitive objects, put references inside new class, define primitives directly: //: reusing/SprinklerSystem.java // Composition code reuse. class WaterSource { private String s; WaterSource() { System.out.println("WaterSource()"); = "Constructed"; } public String toString() { return s; } } public class SprinklerSystem { private String valve1, valve2, valve3, valve4; private WaterSource source = new WaterSource(); private int i; private float f; public String toString() { return "valve1 = " + valve1 + " " + "valve2 = " + valve2 + " " + "valve3 = " + valve3 + " " + "valve4 = " + valve4 + "\n" + "i = " + + " " + "f = " + f + " " + "source = " + source; } public static void main(String[] args) { SprinklerSystem sprinklers = new SprinklerSystem(); System.out.println(sprinklers); } } /* Output: WaterSource() valve1 = null valve2 = null valve3 = null valve4 = null = 0 f = 0.0 source = Constructed *///: One methods defined classes special: toString( ). Every non-primitive object toString( ) method, it’s called special situations compiler wants String object. So expression SprinklerSystem.toString( ): "source = " + source; compiler sees trying add String object ("source = ") WaterSource. Because “add” String another String, says “I’ll turn source String calling toString( )!” After combine two Strings pass resulting String System.out.println( ) (or equivalently, book’s print() printnb( ) static methods). Any time want allow behavior class create, need write toString( ) method. Primitives fields class automatically initialized zero, noted Everything Is Object chapter. But object references initialized null, try call methods them, you’ll get exception-a runtime error. Conveniently, still print null reference without throwing exception. It makes sense compiler doesn’t create default object every reference, would incur unnecessary overhead many cases. If want references initialized, it: 1. At point objects defined. This means they’ll always initialized constructor called. 2. In constructor class. 3. Right actually need use object. This often called lazy initialization. It reduce overhead situations object creation expensive object doesn’t need created every time. 4. Using instance initialization. All four approaches shown here: //: reusing/Bath.java // Constructor initialization composition. import static net.mindview.util.Print.*; class Soap { private String s; 166 Thinking Java Bruce Eckel } Soap() { print("Soap()"); = "Constructed"; } public String toString() { return s; } public class Bath { private String // Initializing point definition: s1 = "Happy", s2 = "Happy", s3, s4; private Soap castille; private int i; private float toy; public Bath() { print("Inside Bath()"); s3 = "Joy"; toy = 3.14f; castille = new Soap(); } // Instance initialization: { = 47; } public String toString() { if(s4 == null) // Delayed initialization: s4 = "Joy"; return "s1 = " + s1 + "\n" + "s2 = " + s2 + "\n" + "s3 = " + s3 + "\n" + "s4 = " + s4 + "\n" + "i = " + + "\n" + "toy = " + toy + "\n" + "castille = " + castille; } public static void main(String[] args) { Bath b = new Bath(); print(b); } } /* Output: Inside Bath() Soap() s1 = Happy s2 = Happy s3 = Joy s4 = Joy = 47 toy = 3.14 castille = Constructed *///:~ Note Bath constructor, statement executed initializations take place. When don’t initialize point definition, there’s still guarantee you’ll perform initialization send message object reference—except inevitable run-time exception. When toString( ) called fills s4 fields properly initialized time used. Exercise 1: (2) Create simple class. Inside second class, define reference object first class. Use lazy initialization instantiate object. Reusing Classes 167 Inheritance syntax Inheritance integral part Java (and OOP languages). It turns you’re always inheritance create class, unless explicitly inherit class, implicitly inherit Java’s standard root class Object. The syntax composition obvious, perform inheritance there’s distinctly different form. When inherit, say “This new class like old class.” You state code opening brace class body, using keyword extends followed name base class. When this, automatically get fields methods base class. Here’s example: //: reusing/Detergent.java // Inheritance syntax & properties. import static net.mindview.util.Print.*; class Cleanser { private String = "Cleanser"; public void append(String a) { += a; } public void dilute() { append(" dilute()"); } public void apply() { append(" apply()"); } public void scrub() { append(" scrub()"); } public String toString() { return s; } public static void main(String[] args) { Cleanser x = new Cleanser(); x.dilute(); x.apply(); x.scrub(); print(x); } } public class Detergent extends Cleanser { // Change method: public void scrub() { append(" Detergent.scrub()"); super.scrub(); // Call base-class version } // Add methods interface: public void foam() { append(" foam()"); } // Test new class: public static void main(String[] args) { Detergent x = new Detergent(); x.dilute(); x.apply(); x.scrub(); x.foam(); print(x); print("Testing base class:"); Cleanser.main(args); } } /* Output: Cleanser dilute() apply() Detergent.scrub() scrub() foam() Testing base class: Cleanser dilute() apply() scrub() *///:~ This demonstrates number features. First, Cleanser append( ) method, Strings concatenated using += operator, one operators (along ‘+’) Java designers “overloaded” work Strings. 168 Thinking Java Bruce Eckel Second, Cleanser Detergent contain main( ) method. You create main( ) one classes; technique putting main() class allows easy testing class. And don’t need remove main() you’re finished; leave later testing. Even lot classes program, main( ) class invoked command line called. So case, say java Detergent, Detergent.main( ) called. But also say java Cleanser invoke Cleanser.main( ), even though Cleanser public class. Even class package access, public main() accessible. Here, see Detergent.main( ) calls Cleanser.main( ) explicitly, passing arguments command line (however, could pass String array). It’s important methods Cleanser public. Remember leave access specifier, member defaults package access, allows access package members. Thus, within package, anyone could use methods access specifier. Detergent would trouble, example. However, class package inherit Cleanser, could access public members. So allow inheritance, general rule make fields private methods public. (protected members also allow access derived classes; you’ll learn later.) Of course, particular cases must make adjustments, useful guideline. Cleanser set methods interface: append( ), dilute( ), apply( ), scrub( ), toString( ). Because Detergent derived Cleanser (via extends keyword), automatically gets methods interface, even though don’t see explicitly defined Detergent. You think inheritance, then, reusing class. As seen scrub( ), it’s possible take method that’s defined base class modify it. In case, might want call method base class inside new version. But inside scrub( ), cannot simply call scrub( ), since would produce recursive call, isn’t want. To solve problem, Java keyword super refers “superclass” current class inherits. Thus expression super.scrub( ) calls base-class version method scrub( ). When inheriting you’re restricted using methods base class. You also add new methods derived class exactly way put method class: Just define it. The method foam( ) example this. In Detergent.main( ) see Detergent object, call methods available Cleanser well Detergent (i.e., foam( )). Exercise 2: (2) Inherit new class class Detergent. Override scrub( ) add new method called sterilize( ). Initializing base class Since two classes involved—the base class derived class—instead one, bit confusing try imagine resulting object produced derived class. From outside, looks like new class interface base class maybe additional methods fields. But inheritance doesn’t copy interface base class. When create object derived class, contains within subobject base class. This subobject created object base class itself. It’s outside, subobject base class wrapped within derived-class object. Reusing Classes 169 Of course, it’s essential base-class subobject initialized correctly, there’s one way guarantee this: Perform initialization constructor calling baseclass constructor, appropriate knowledge privileges perform base-class initialization. Java automatically inserts calls base-class constructor derived-class constructor. The following example shows working three levels inheritance: //: reusing/Cartoon.java // Constructor calls inheritance. import static net.mindview.util.Print.*; class Art { Art() { print("Art constructor"); } } class Drawing extends Art { Drawing() { print("Drawing constructor"); } } public class Cartoon extends Drawing { public Cartoon() { print("Cartoon constructor"); } public static void main(String[] args) { Cartoon x = new Cartoon(); } } /* Output: Art constructor Drawing constructor Cartoon constructor *///:~ You see construction happens base “outward,” base class initialized derived-class constructors access it. Even don’t create constructor Cartoon( ), compiler synthesize default constructor calls base class constructor. Exercise 3: (2) Prove previous sentence. Exercise 4: (2) Prove base-class constructors (a) always called (b) called derived-class constructors. Exercise 5: (1) Create two classes, A B, default constructors (empty argument lists) announce themselves. Inherit new class called C A, create member class B inside C. Do create constructor C. Create object class C observe results. Constructors arguments The preceding example default constructors; is, don’t arguments. It’s easy compiler call there’s question arguments pass. If class doesn’t default arguments, want call base-class constructor argument, must explicitly write calls base-class constructor using super keyword appropriate argument list: //: reusing/Chess.java // Inheritance, constructors arguments. import static net.mindview.util.Print.*; class Game { Game(int i) { 170 Thinking Java Bruce Eckel } print("Game constructor"); } class BoardGame extends Game { BoardGame(int i) { super(i); print("BoardGame constructor"); } } public class Chess extends BoardGame { Chess() { super(11); print("Chess constructor"); } public static void main(String[] args) { Chess x = new Chess(); } } /* Output: Game constructor BoardGame constructor Chess constructor *///:~ If don’t call base-class constructor BoardGame( ), compiler complain can’t find constructor form Game( ). In addition, call base-class constructor must first thing derived-class constructor. (The compiler remind get wrong.) Exercise 6: (1) Using Chess.java, prove statements previous paragraph. Exercise 7: (1) Modify Exercise 5 A B constructors arguments instead default constructors. Write constructor C perform initialization within C’s constructor. Exercise 8: (1) Create base class non-default constructor, derived class default (no-arg) non-default constructor. In derived-class constructors, call base-class constructor. Exercise 9: (2) Create class called Root contains instance classes (that also create) named Component1, Component2, Component3. Derive class Stem Root also contains instance “component.” All classes default constructors print message class. Exercise 10: (1) Modify previous exercise class non-default constructors. Delegation A third relationship, directly supported Java, called delegation. This midway inheritance composition, place member object class you’re building (like composition), time expose methods member object new class (like inheritance). For example, spaceship needs control module: //: reusing/SpaceShipControls.java Reusing Classes 171 public class SpaceShipControls { void up(int velocity) {} void down(int velocity) {} void left(int velocity) {} void right(int velocity) {} void forward(int velocity) {} void back(int velocity) {} void turboBoost() {} } ///:~ One way build spaceship use inheritance: //: reusing/SpaceShip.java public class SpaceShip extends SpaceShipControls { private String name; public SpaceShip(String name) { this.name = name; } public String toString() { return name; } public static void main(String[] args) { SpaceShip protector = new SpaceShip("NSEA Protector"); protector.forward(100); } } ///:~ However, SpaceShip isn’t really “a type of” SpaceShipControls, even if, example, “tell” SpaceShip go forward( ). It’s accurate say SpaceShip contains SpaceShipControls, time methods SpaceShipControls exposed SpaceShip. Delegation solves dilemma: //: reusing/SpaceShipDelegation.java public class SpaceShipDelegation { private String name; private SpaceShipControls controls = new SpaceShipControls(); public SpaceShipDelegation(String name) { this.name = name; } // Delegated methods: public void back(int velocity) { controls.back(velocity); } public void down(int velocity) { controls.down(velocity); } public void forward(int velocity) { controls.forward(velocity); } public void left(int velocity) { controls.left(velocity); } public void right(int velocity) { controls.right(velocity); } public void turboBoost() { controls.turboBoost(); } public void up(int velocity) { controls.up(velocity); } public static void main(String[] args) { 172 Thinking Java Bruce Eckel SpaceShipDelegation protector = new SpaceShipDelegation("NSEA Protector"); protector.forward(100); } } ///:~ You see methods forwarded underlying controls object, interface thus inheritance. However, control delegation choose provide subset methods member object. Although Java language doesn’t support delegation, development tools often do. The example, instance, automatically generated using JetBrains Idea IDE. Exercise 11: (3) Modify Detergent.java uses delegation. Combining composition inheritance It common use composition inheritance together. The following example shows creation complex class, using inheritance composition, along necessary constructor initialization: //: reusing/PlaceSetting.java // Combining composition & inheritance. import static net.mindview.util.Print.*; class Plate { Plate(int i) { print("Plate constructor"); } } class DinnerPlate extends Plate { DinnerPlate(int i) { super(i); print("DinnerPlate constructor"); } } class Utensil { Utensil(int i) { print("Utensil constructor"); } } class Spoon extends Utensil { Spoon(int i) { super(i); print("Spoon constructor"); } } class Fork extends Utensil { Fork(int i) { super(i); print("Fork constructor"); } Reusing Classes 173 } class Knife extends Utensil { Knife(int i) { super(i); print("Knife constructor"); } } // A cultural way something: class Custom { Custom(int i) { print("Custom constructor"); } } public class PlaceSetting extends Custom { private Spoon sp; private Fork frk; private Knife kn; private DinnerPlate pl; public PlaceSetting(int i) { super(i + 1); sp = new Spoon(i + 2); frk = new Fork(i + 3); kn = new Knife(i + 4); pl = new DinnerPlate(i + 5); print("PlaceSetting constructor"); } public static void main(String[] args) { PlaceSetting x = new PlaceSetting(9); } } /* Output: Custom constructor Utensil constructor Spoon constructor Utensil constructor Fork constructor Utensil constructor Knife constructor Plate constructor DinnerPlate constructor PlaceSetting constructor *///:~ Although compiler forces initialize base classes, requires right beginning constructor, doesn’t watch make sure initialize member objects, must remember pay attention that. It’s rather amazing cleanly classes separated. You don’t even need source code methods order reuse code. At most, import package. (This true inheritance composition.) Guaranteeing proper cleanup Java doesn’t C++ concept destructor, method automatically called object destroyed. The reason probably Java, practice simply forget objects rather destroy them, allowing garbage collector reclaim memory necessary. 174 Thinking Java Bruce Eckel Often fine, times class might perform activities lifetime require cleanup. As mentioned Initialization & Cleanup chapter, can’t know garbage collector called, called. So want something cleaned class, must explicitly write special method it, make sure client programmer knows must call method. On top this—as described Error Handling Exceptions chapter—you must guard exception putting cleanup finally clause. Consider example computer-aided design system draws pictures screen: //: reusing/CADSystem.java // Ensuring proper cleanup. package reusing; import static net.mindview.util.Print.*; class Shape { Shape(int i) { print("Shape constructor"); } void dispose() { print("Shape dispose"); } } class Circle extends Shape { Circle(int i) { super(i); print("Drawing Circle"); } void dispose() { print("Erasing Circle"); super.dispose(); } } class Triangle extends Shape { Triangle(int i) { super(i); print("Drawing Triangle"); } void dispose() { print("Erasing Triangle"); super.dispose(); } } class Line extends Shape { private int start, end; Line(int start, int end) { super(start); this.start = start; this.end = end; print("Drawing Line: " + start + ", " + end); } void dispose() { print("Erasing Line: " + start + ", " + end); super.dispose(); } } public class CADSystem extends Shape { private Circle c; private Triangle t; private Line[] lines = new Line[3]; public CADSystem(int i) { super(i + 1); Reusing Classes 175 for(int j = 0; j < lines.length; j++) lines[j] = new Line(j, j*j); c = new Circle(1); = new Triangle(1); print("Combined constructor"); } public void dispose() { print("CADSystem.dispose()"); // The order cleanup reverse // order initialization: t.dispose(); c.dispose(); for(int = lines.length - 1; >= 0; i--) lines[i].dispose(); super.dispose(); } public static void main(String[] args) { CADSystem x = new CADSystem(47); try { // Code exception handling... } finally { x.dispose(); } } } /* Output: Shape constructor Shape constructor Drawing Line: 0, 0 Shape constructor Drawing Line: 1, 1 Shape constructor Drawing Line: 2, 4 Shape constructor Drawing Circle Shape constructor Drawing Triangle Combined constructor CADSystem.dispose() Erasing Triangle Shape dispose Erasing Circle Shape dispose Erasing Line: 2, 4 Shape dispose Erasing Line: 1, 1 Shape dispose Erasing Line: 0, 0 Shape dispose Shape dispose *///:~ Everything system kind Shape (which kind Object, since it’s implicitly inherited root class). Each class overrides Shape’s dispose( ) method addition calling base-class version method using super. The specific Shape classes—Circle, Triangle, Line—all constructors “draw,” although method called lifetime object could responsible something needs cleanup. Each class dispose( ) method restore non-memory things back way object existed. In main( ), see two keywords new, won’t explained Error Handling Exceptions chapter: try finally. The try keyword indicates block follows (delimited curly braces) guarded region, means given 176 Thinking Java Bruce Eckel special treatment. One special treatments code finally clause following guarded region always executed, matter try block exits. (With exception handling, it’s possible leave try block number non-ordinary ways.) Here, finally clause saying “always call dispose( ) x, matter happens.” Note cleanup method, must also pay attention calling order base-class member-object cleanup methods case one subobject depends another. In general, follow form imposed C++ compiler destructors: First perform cleanup work specific class, reverse order creation. (In general, requires base-class elements still viable.) Then call base-class cleanup method, demonstrated here. There many cases cleanup issue problem; let garbage collector work. But must explicitly, diligence attention required, there’s much rely comes garbage collection. The garbage collector might never called. If is, reclaim objects order wants. You can’t rely garbage collection anything memory reclamation. If want cleanup take place, make cleanup methods don’t use finalize( ). Exercise 12: (3) Add proper hierarchy dispose( ) methods classes Exercise 9. Name hiding If Java base class method name that’s overloaded several times, redefining method name derived class hide base-class versions (unlike C++). Thus overloading works regardless whether method defined level base class: //: reusing/Hide.java // Overloading base-class method name derived // class hide base-class versions. import static net.mindview.util.Print.*; class Homer { char doh(char c) { print("doh(char)"); return ‘d’; } float doh(float f) { print("doh(float)"); return 1.0f; } } class Milhouse {} class Bart extends Homer { void doh(Milhouse m) { print("doh(Milhouse)"); } } public class Hide { public static void main(String[] args) { Bart b = new Bart(); b.doh(1); b.doh(‘x’); b.doh(1.0f); Reusing Classes 177 b.doh(new Milhouse()); } } /* Output: doh(float) doh(char) doh(float) doh(Milhouse) *///:~ You see overloaded methods Homer available Bart, even though Bart introduces new overloaded method (in C++ would hide base-class methods). As you’ll see next chapter, it’s far common override methods name, using exactly signature return type base class. It confusing otherwise (which C++ disallows it—to prevent making probably mistake). Java SE5 added @Override annotation, keyword used were. When mean override method, choose add annotation compiler produce error message accidentally overload instead overriding. //: reusing/Lisa.java // {CompileTimeError} (Won’t compile) class Lisa extends Homer { @Override void doh(Milhouse m) { System.out.println("doh(Milhouse)"); } } ///:~ The {CompileTimeError} tag excludes file book’s Ant build, compile hand you’ll see error message: method override method superclass The @Override annotation thus prevent accidentally overloading don’t mean to. Exercise 13: (2) Create class method overloaded three times. Inherit new class, add new overloading method, show four methods available derived class. Choosing composition vs. inheritance Both composition inheritance allow place subobjects inside new class (composition explicitly this—with inheritance it’s implicit). You might wonder difference two, choose one other. Composition generally used want features existing class inside new class, interface. That is, embed object use implement features new class, user new class sees interface you’ve defined new class rather interface embedded object. For effect, embed private objects existing classes inside new class. Sometimes makes sense allow class user directly access composition new class; is, make member objects public. The member objects use 178 Thinking Java Bruce Eckel implementation hiding themselves, safe thing do. When user knows you’re assembling bunch parts, makes interface easier understand. A car object good example: //: reusing/Car.java // Composition public objects. class Engine { public void start() {} public void rev() {} public void stop() {} } class Wheel { public void inflate(int psi) {} } class Window { public void rollup() {} public void rolldown() {} } class Door { public Window window = new Window(); public void open() {} public void close() {} } public class Car { public Engine engine = new Engine(); public Wheel[] wheel = new Wheel[4]; public Door left = new Door(), right = new Door(); // 2-door public Car() { for(int = 0; < 4; i++) wheel[i] = new Wheel(); } public static void main(String[] args) { Car car = new Car(); car.left.window.rollup(); car.wheel[0].inflate(72); } } ///:~ Because case composition car part analysis problem (and simply part underlying design), making members public assists client programmer’s understanding use class requires less code complexity creator class. However, keep mind special case, general make fields private. When inherit, take existing class make special version it. In general, means you’re taking general-purpose class specializing particular need. With little thought, you’ll see would make sense compose car using vehicle object—a car doesn’t contain vehicle, vehicle. The is-a relationship expressed inheritance, has-a relationship expressed composition. Exercise 14: (1) In Car.java add service( ) method Engine call method main( ). Reusing Classes 179 protected Now you’ve introduced inheritance, keyword protected finally meaning. In ideal world, private keyword would enough. In real projects, times want make something hidden world large yet allow access members derived classes. The protected keyword nod pragmatism. It says “This private far class user concerned, available anyone inherits class anyone else package.” (In Java, protected also provides package access.) Although it’s possible create protected fields, best approach leave fields private; always preserve right change underlying implementation. You allow controlled access inheritors class protected methods: //: reusing/Orc.java // The protected keyword. import static net.mindview.util.Print.*; class Villain { private String name; protected void set(String nm) { name = nm; } public Villain(String name) { this.name = name; } public String toString() { return "I’m Villain name " + name; } } public class Orc extends Villain { private int orcNumber; public Orc(String name, int orcNumber) { super(name); this.orcNumber = orcNumber; } public void change(String name, int orcNumber) { set(name); // Available it’s protected this.orcNumber = orcNumber; } public String toString() { return "Orc " + orcNumber + ": " + super.toString(); } public static void main(String[] args) { Orc orc = new Orc("Limburger", 12); print(orc); orc.change("Bob", 19); print(orc); } } /* Output: Orc 12: I’m Villain name Limburger Orc 19: I’m Villain name Bob *///:~ You see change( ) access set( ) it’s protected. Also note way Orc’s toString( ) method defined terms base-class version toString( ). Exercise 15: (2) Create class inside package. Your class contain protected method. Outside package, try call protected method explain results. Now inherit class call protected method inside method derived class. 180 Thinking Java Bruce Eckel Upcasting The important aspect inheritance provides methods new class. It’s relationship expressed new class base class. This relationship summarized saying, “The new class type existing class.” This description fanciful way explaining inheritance—it’s supported directly language. As example, consider base class called Instrument represents musical instruments, derived class called Wind. Because inheritance means methods base class also available derived class, message send base class also sent derived class. If Instrument class play( ) method, Wind instruments. This means accurately say Wind object also type Instrument. The following example shows compiler supports notion: //: reusing/Wind.java // Inheritance & upcasting. class Instrument { public void play() {} static void tune(Instrument i) { // ... i.play(); } } // Wind objects instruments // interface: public class Wind extends Instrument { public static void main(String[] args) { Wind flute = new Wind(); Instrument.tune(flute); // Upcasting } } ///:~ What’s interesting example tune( ) method, accepts Instrument reference. However, Wind.main( ) tune( ) method called giving Wind reference. Given Java particular type checking, seems strange method accepts one type readily accept another type, realize Wind object also Instrument object, there’s method tune( ) could call Instrument isn’t also Wind. Inside tune( ), code works Instrument anything derived Instrument, act converting Wind reference Instrument reference called upcasting. Why “upcasting”? The term based way class inheritance diagrams traditionally drawn: root top page, growing downward. (Of course, draw diagrams way find helpful.) The inheritance diagram Wind.java then: Reusing Classes 181 Casting derived type base type moves inheritance diagram, it’s commonly referred upcasting. Upcasting always safe you’re going specific type general type. That is, derived class superset base class. It might contain methods base class, must contain least methods base class. The thing occur class interface upcast lose methods, gain them. This compiler allows upcasting without explicit casts special notation. You also perform reverse upcasting, called downcasting, involves dilemma examined next chapter, Type Information chapter. Composition vs. inheritance revisited In object-oriented programming, likely way you’ll create use code simply packaging data methods together class, using objects class. You’ll also use existing classes build new classes composition. Less frequently, you’ll use inheritance. So although inheritance gets lot emphasis learning OOP, doesn’t mean use everywhere possibly can. On contrary, use sparingly, it’s clear inheritance useful. One clearest ways determine whether use composition inheritance ask whether you’ll ever need upcast new class base class. If must upcast, inheritance necessary, don’t need upcast, look closely whether need inheritance. The Polymorphism chapter provides one compelling reasons upcasting, remember ask “Do I need upcast?” you’ll good tool deciding composition inheritance. Exercise 16: (2) Create class called Amphibian. From this, inherit class called Frog. Put appropriate methods base class. In main( ), create Frog upcast Amphibian demonstrate methods still work. Exercise 17: (1) Modify Exercise 16 Frog overrides method definitions base class (provides new definitions using method signatures). Note happens main( ). The final keyword Java’s final keyword slightly different meanings depending context, general says “This cannot changed.” You might want prevent changes two reasons: design efficiency. Because two reasons quite different, it’s possible misuse final keyword. The following sections discuss three places final used: data, methods, classes. 182 Thinking Java Bruce Eckel final data Many programming languages way tell compiler piece data “constant.” A constant useful two reasons: 1. It compile-time constant won’t ever change. 2. It value initialized run time don’t want changed. In case compile-time constant, compiler allowed “fold” constant value calculations it’s used; is, calculation performed compile time, eliminating run-time overhead. In Java, sorts constants must primitives expressed final keyword. A value must given time definition constant. A field static final one piece storage cannot changed. When final used object references rather primitives, meaning confusing. With primitive, final makes value constant, object reference, final makes reference constant. Once reference initialized object, never changed point another object. However, object modified; Java provide way make arbitrary object constant. (You can, however, write class objects effect constant.) This restriction includes arrays, also objects. Here’s example demonstrates final fields. Note convention, fields static final (that is, compile-time constants) capitalized use underscores separate words. //: reusing/FinalData.java // The effect final fields. import java.util.*; import static net.mindview.util.Print.*; class Value { int i; // Package access public Value(int i) { this.i = i; } } public class FinalData { private static Random rand = new Random(47); private String id; public FinalData(String id) { this.id = id; } // Can compile-time constants: private final int valueOne = 9; private static final int VALUE_TWO = 99; // Typical public constant: public static final int VALUE_THREE = 39; // Cannot compile-time constants: private final int i4 = rand.nextInt(20); static final int INT_5 = rand.nextInt(20); private Value v1 = new Value(11); private final Value v2 = new Value(22); private static final Value VAL_3 = new Value(33); // Arrays: private final int[] = { 1, 2, 3, 4, 5, 6 }; public String toString() { return id + ": " + "i4 = " + i4 + ", INT_5 = " + INT_5; } Reusing Classes 183 public static void main(String[] args) { FinalData fd1 = new FinalData("fd1"); //! fd1.valueOne++; // Error: can’t change value fd1.v2.i++; // Object isn’t constant! fd1.v1 = new Value(9); // OK -- final for(int = 0; < fd1.a.length; i++) fd1.a[i]++; // Object isn’t constant! //! fd1.v2 = new Value(0); // Error: Can’t //! fd1.VAL_3 = new Value(1); // change reference //! fd1.a = new int[3]; print(fd1); print("Creating new FinalData"); FinalData fd2 = new FinalData("fd2"); print(fd1); print(fd2); } } /* Output: fd1: i4 = 15, INT_5 = 18 Creating new FinalData fd1: i4 = 15, INT_5 = 18 fd2: i4 = 13, INT_5 = 18 *///:~ Since valueOne VALUE_TWO final primitives compile-time values, used compile-time constants different important way. VALUE_THREE typical way you’ll see constants defined: public they’re usable outside package, static emphasize there’s one, final say it’s constant. Note final static primitives constant initial values (that is, compile-time constants) named capitals convention, words separated underscores. (This like C constants, convention originated.) Just something final doesn’t mean value known compile time. This demonstrated initializing i4 INT_5 run time using randomly generated numbers. This portion example also shows difference making final value static non-static. This difference shows values initialized run time, since compile-time values treated compiler. (And presumably optimized existence.) The difference shown run program. Note values i4 fd1 fd2 unique, value INT_5 changed creating second FinalData object. That’s it’s static initialized upon loading time new object created. The variables v1 VAL_3 demonstrate meaning final reference. As see main( ), v2 final doesn’t mean can’t change value. Because it’s reference, final means cannot rebind v2 new object. You also see meaning holds true array, another kind reference. (There way I know make array references final.) Making references final seems less useful making primitives final. Exercise 18: (2) Create class static final field final field demonstrate difference two. Blank finals Java allows creation blank finals, fields declared final given initialization value. In cases, blank final must initialized used, compiler ensures this. However, blank finals provide much flexibility use final keyword since, example, final field inside class different object, yet retains immutable quality. Here’s example: 184 Thinking Java Bruce Eckel //: reusing/BlankFinal.java // "Blank" final fields. class Poppet { private int i; Poppet(int ii) { = ii; } } public class BlankFinal { private final int = 0; // Initialized final private final int j; // Blank final private final Poppet p; // Blank final reference // Blank finals MUST initialized constructor: public BlankFinal() { j = 1; // Initialize blank final p = new Poppet(1); // Initialize blank final reference } public BlankFinal(int x) { j = x; // Initialize blank final p = new Poppet(x); // Initialize blank final reference } public static void main(String[] args) { new BlankFinal(); new BlankFinal(47); } } ///:~ You’re forced perform assignments finals either expression point definition field every constructor. That way it’s guaranteed final field always initialized use. Exercise 19: (2) Create class blank final reference object. Perform initialization blank final inside constructors. Demonstrate guarantee final must initialized use, cannot changed initialized. final arguments Java allows make arguments final declaring argument list. This means inside method cannot change argument reference points to: //: reusing/FinalArguments.java // Using "final" method arguments. class Gizmo { public void spin() {} } public class FinalArguments { void with(final Gizmo g) { //! g = new Gizmo(); // Illegal -- g final } void without(Gizmo g) { g = new Gizmo(); // OK -- g final g.spin(); } // void f(final int i) { i++; } // Can’t change // You read final primitive: int g(final int i) { return + 1; } public static void main(String[] args) { FinalArguments bf = new FinalArguments(); Reusing Classes 185 bf.without(null); bf.with(null); } } ///:~ The methods f( ) g( ) show happens primitive arguments final: You read argument, can’t change it. This feature primarily used pass data anonymous inner classes, you’ll learn Inner Classes chapter. final methods There two reasons final methods. The first put “lock” method prevent inheriting class changing meaning. This done design reasons want make sure method’s behavior retained inheritance cannot overridden. The second reason final methods efficiency. In earlier implementations Java, made method final, allowed compiler turn calls method inline calls. When compiler saw final method call, could (at discretion) skip normal approach inserting code perform method call mechanism (push arguments stack, hop method code execute it, hop back clean stack arguments, deal return value) instead replace method call copy actual code method body. This eliminated overhead method call. Of course, method big, code begins bloat, probably wouldn’t see performance gains inlining, since improvements dwarfed amount time spent inside method. In recent version Java, virtual machine (in particular, hotspot technologies) detect situations optimize away extra indirection, longer necessary-in fact, generally discouraged-to use final try help optimizer. With Java SE5/6, let compiler JVM handle efficiency issues make method final want explicitly prevent overriding. 1 final private Any private methods class implicitly final. Because can’t access private method, can’t override it. You add final specifier private method, doesn’t give method extra meaning. This issue cause confusion, try override private method (which implicitly final), seems work, compiler doesn’t give error message: //: reusing/FinalOverridingIllusion.java // It looks like override // private private final method. import static net.mindview.util.Print.*; class WithFinals { // Identical "private" alone: private final void f() { print("WithFinals.f()"); } // Also automatically "final": private void g() { print("WithFinals.g()"); } } 1 Don’t fall prey urge prematurely optimize. If get system working it’s slow, it’s doubtful fix final keyword. http://MindView.net/Books/BetterJava information profiling, helpful speeding program. 186 Thinking Java Bruce Eckel class OverridingPrivate extends WithFinals { private final void f() { print("OverridingPrivate.f()"); } private void g() { print("OverridingPrivate.g()"); } } class OverridingPrivate2 extends OverridingPrivate { public final void f() { print("OverridingPrivate2.f()"); } public void g() { print("OverridingPrivate2.g()"); } } public class FinalOverridingIllusion { public static void main(String[] args) { OverridingPrivate2 op2 = new OverridingPrivate2(); op2.f(); op2.g(); // You upcast: OverridingPrivate op = op2; // But can’t call methods: //! op.f(); //! op.g(); // Same here: WithFinals wf = op2; //! wf.f(); //! wf.g(); } } /* Output: OverridingPrivate2.f() OverridingPrivate2.g() *///:~ “Overriding” occur something part base-class interface. That is, must able upcast object base type call method (the point become clear next chapter). If method private, isn’t part base-class interface. It code that’s hidden away inside class, happens name, create public, protected, package-access method name derived class, there’s connection method might happen name base class. You haven’t overridden method; you’ve created new method. Since private method unreachable effectively invisible, doesn’t factor anything except code organization class defined. Exercise 20: (1) Show @Override annotation solves problem section. Exercise 21: (1) Create class final method. Inherit class attempt overwrite method. final classes When say entire class final (by preceding definition final keyword), state don’t want inherit class allow anyone else so. In words, reason design class never need make changes, safety security reasons don’t want subclassing. Reusing Classes 187 //: reusing/Jurassic.java // Making entire class final. class SmallBrain {} final class Dinosaur { int = 7; int j = 1; SmallBrain x = new SmallBrain(); void f() {} } //! class Further extends Dinosaur {} // error: Cannot extend final class ‘Dinosaur’ public class Jurassic { public static void main(String[] args) { Dinosaur n = new Dinosaur(); n.f(); n.i = 40; n.j++; } } ///:~ Note fields final class final not, choose. The rules apply final fields regardless whether class defined final. However, prevents inheritance, methods final class implicitly final, since there’s way override them. You add final specifier method final class, doesn’t add meaning. Exercise 22: (1) Create final class attempt inherit it. final caution It seem sensible make method final you’re designing class. You might feel one could possibly want override methods. Sometimes true. But careful assumptions. In general, it’s difficult anticipate class reused, especially general-purpose class. If define method final, might prevent possibility reusing class inheritance programmer’s project simply couldn’t imagine used way. The standard Java library good example this. In particular, Java 1.0/1.1 Vector class commonly used might even useful if, name efficiency (which almost certainly illusion), methods hadn’t made final. It’s easily conceivable might want inherit override fundamentally useful class, designers somehow decided wasn’t appropriate. This ironic two reasons. First, Stack inherited Vector, says Stack Vector, isn’t really true logical standpoint. Nonetheless, it’s case Java designers inherited Vector. At point created Stack way, realized final methods restrictive. Second, many important methods Vector, addElement( ) elementAt( ), synchronized. As see Concurrency chapter, imposes significant performance overhead probably wipes gains provided final. This lends credence theory programmers consistently bad guessing optimizations occur. It’s bad clumsy design made standard library, everyone cope it. (Fortunately, modern Java 188 Thinking Java Bruce Eckel container library replaces Vector ArrayList, behaves much civilly. Unfortunately, there’s still new code written uses old container library.) It’s also interesting note Hashtable, another important Java 1.0/1.1 standard library class, final methods. As mentioned elsewhere book, it’s quite obvious classes designed completely different people others. (You’ll see method names Hashtable much briefer compared Vector, another piece evidence.) This precisely sort thing obvious consumers class library. When things inconsistent, makes work user—yet another paean value design code walkthroughs. (Note modern Java container library replaces Hashtable HashMap.) Initialization class loading In traditional languages, programs loaded part startup process. This followed initialization, program begins. The process initialization languages must carefully controlled order initialization statics doesn’t cause trouble. C++, example, problems one static expects another static valid second one initialized. Java doesn’t problem takes different approach loading. This one activities become easier, everything Java object. Remember compiled code class exists separate file. That file isn’t loaded code needed. In general, say “class code loaded point first use.” This usually first object class constructed, loading also occurs static field static method accessed. 2 The point first use also static initialization takes place. All static objects static code block initialized textual order (that is, order write class definition) point loading. The statics, course, initialized once. Initialization inheritance It’s helpful look whole initialization process, including inheritance, get full picture happens. Consider following example: //: reusing/Beetle.java // The full process initialization. import static net.mindview.util.Print.*; class Insect { private int = 9; protected int j; Insect() { print("i = " + + ", j = " + j); j = 39; } private static int x1 = printInit("static Insect.x1 initialized"); static int printInit(String s) { 2 The constructor also static method even though static keyword explicit. So precise, class first loaded one static members accessed. Reusing Classes 189 print(s); return 47; } } public class Beetle extends Insect { private int k = printInit("Beetle.k initialized"); public Beetle() { print("k = " + k); print("j = " + j); } private static int x2 = printInit("static Beetle.x2 initialized"); public static void main(String[] args) { print("Beetle constructor"); Beetle b = new Beetle(); } } /* Output: static Insect.x1 initialized static Beetle.x2 initialized Beetle constructor = 9, j = 0 Beetle.k initialized k = 47 j = 39 *///:~ The first thing happens run Java Beetle try access Beetle.main( ) (a static method), loader goes finds compiled code Beetle class (this happens file called Beetle.class). In process loading it, loader notices base class (that’s extends keyword says), loads. This happen whether you’re going make object base class. (Try commenting object creation prove yourself.) If base class base class, second base class would loaded, on. Next, static initialization root base class (in case, Insect) performed, next derived class, on. This important derived-class static initialization might depend base class member initialized properly. At point, necessary classes loaded object created. First, primitives object set default values object references set null—this happens one fell swoop setting memory object binary zero. Then base-class constructor called. In case call automatic, also specify base-class constructor call (as first operation Beetle( ) constructor) using super. The base class construction goes process order derived-class constructor. After base-class constructor completes, instance variables initialized textual order. Finally, rest body constructor executed. Exercise 23: (2) Prove class loading takes place once. Prove loading may caused either creation first instance class access static member. Exercise 24: (2) In Beetle.java, inherit specific type beetle class Beetle, following format existing classes. Trace explain output. 190 Thinking Java Bruce Eckel Summary Both inheritance composition allow create new type existing types. Composition reuses existing types part underlying implementation new type, inheritance reuses interface. With Inheritance, derived class base-class interface, upcast base, critical polymorphism, you’ll see next chapter. Despite strong emphasis inheritance object-oriented programming, start design generally prefer composition (or possibly delegation) first cut use inheritance clearly necessary. Composition tends flexible. In addition, using added artifice inheritance member type, change exact type, thus behavior, member objects run time. Therefore, change behavior composed object run time. When designing system, goal find create set classes class specific use neither big (encompassing much functionality it’s unwieldy reuse) annoyingly small (you can’t use without adding functionality). If designs become complex, it’s often helpful add objects breaking existing ones smaller parts. When set design system, it’s important realize program development incremental process, like human learning. It relies experimentation; much analysis want, still won’t know answers set project. You’ll much success-and immediate feedback-if start “grow” project organic, evolutionary creature, rather constructing like glass-box skyscraper. Inheritance composition two fundamental tools object-oriented programming allow perform experiments. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Reusing Classes 191 Polymorphism ”I asked, ‘Pray, Mr. Babbage, put machine wrong figures, right answers come out?’ I able rightly apprehend kind confusion ideas could provoke question.” Charles Babbage (1791-1871) Polymorphism third essential feature object-oriented programming language, data abstraction inheritance. It provides another dimension separation interface implementation, decouple how. Polymorphism allows improved code organization readability well creation extensible programs “grown” original creation project, also new features desired. Encapsulation creates new data types combining characteristics behaviors. Implementation hiding separates interface implementation making details private. This sort mechanical organization makes ready sense someone procedural programming background. But polymorphism deals decoupling terms types. In last chapter, saw inheritance allows treatment object type base type. This ability critical allows many types (derived base type) treated one type, single piece code work different types equally. The polymorphic method call allows one type express distinction another, similar type, long they’re derived base type. This distinction expressed differences behavior methods call base class. In chapter, you’ll learn polymorphism (also called dynamic binding late binding run-time binding) starting basics, simple examples strip away everything polymorphic behavior program. Upcasting revisited In last chapter saw object used type object base type. Taking object reference treating reference base type called upcasting way inheritance trees drawn base class top. You also saw problem arise, embodied following example musical instruments. First, since several examples play Notes, create separate Note enumeration, package: //: polymorphism/music/Note.java // Notes play musical instruments. package polymorphism.music; public enum Note { MIDDLE_C, C_SHARP, B_FLAT; // Etc. } ///:~ enums introduced Initialization & Cleanup chapter. Here, Wind type Instrument; therefore, Wind inherited Instrument: //: polymorphism/music/Instrument.java package polymorphism.music; import static net.mindview.util.Print.*; class Instrument { public void play(Note n) { print("Instrument.play()"); } } ///:~ //: polymorphism/music/Wind.java package polymorphism.music; // Wind objects instruments // interface: public class Wind extends Instrument { // Redefine interface method: public void play(Note n) { System.out.println("Wind.play() " + n); } } ///:~ //: polymorphism/music/Music.java // Inheritance & upcasting. package polymorphism.music; public class Music { public static void tune(Instrument i) { // ... i.play(Note.MIDDLE_C); } public static void main(String[] args) { Wind flute = new Wind(); tune(flute); // Upcasting } } /* Output: Wind.play() MIDDLE_C *///:~ The method Music.tune( ) accepts Instrument reference, also anything derived Instrument. In main( ), see happening Wind reference passed tune( ), cast necessary. This acceptable—the interface Instrument must exist Wind, Wind inherited Instrument. Upcasting Wind Instrument may “narrow” interface, cannot make anything less full interface Instrument. Forgetting object type Music.java might seem strange you. Why anyone intentionally forget type object? This happens upcast, seems like could much straightforward tune( ) simply takes Wind reference argument. This brings essential point: If that, you’d need write new tune( ) every type Instrument system. Suppose follow reasoning add Stringed Brass instruments: //: polymorphism/music/Music2.java // Overloading instead upcasting. 194 Thinking Java Bruce Eckel package polymorphism.music; import static net.mindview.util.Print.*; class Stringed extends Instrument { public void play(Note n) { print("Stringed.play() " + n); } } class Brass extends Instrument { public void play(Note n) { print("Brass.play() " + n); } } public class Music2 { public static void tune(Wind i) { i.play(Note.MIDDLE_C); } public static void tune(Stringed i) { i.play(Note.MIDDLE_C); } public static void tune(Brass i) { i.play(Note.MIDDLE_C); } public static void main(String[] args) { Wind flute = new Wind(); Stringed violin = new Stringed(); Brass frenchHorn = new Brass(); tune(flute); // No upcasting tune(violin); tune(frenchHorn); } } /* Output: Wind.play() MIDDLE_C Stringed.play() MIDDLE_C Brass.play() MIDDLE_C *///:~ This works, there’s major drawback: must write type-specific methods new Instrument class add. This means programming first place, also means want add new method like tune( ) new type Instrument, you’ve got lot work do. Add fact compiler won’t give error messages forget overload one methods whole process working types becomes unmanageable. Wouldn’t much nicer could write single method takes base class argument, specific derived classes? That is, wouldn’t nice could forget derived classes, write code talk base class? That’s exactly polymorphism allows do. However, programmers come procedural programming background bit trouble way polymorphism works. Exercise 1: (2) Create Cycle class, subclasses Unicycle, Bicycle Tricycle. Demonstrate instance type upcast Cycle via ride( ) method. Polymorphism 195 The twist The difficulty Music.java seen running program. The output Wind.play( ). This clearly desired output, doesn’t seem make sense would work way. Look tune( ) method: public static void tune(Instrument i) { // ... i.play(Note.MIDDLE_C); } It receives Instrument reference. So compiler possibly know Instrument reference points Wind case Brass Stringed? The compiler can’t. To get deeper understanding issue, it’s helpful examine subject binding. Method-call binding Connecting method call method body called binding. When binding performed program run (by compiler linker, one), it’s called early binding. You might heard term never option procedural languages. C compilers one kind method call, that’s early binding. The confusing part preceding program revolves around early binding, compiler cannot know correct method call Instrument reference. The solution called late binding, means binding occurs run time, based type object. Late binding also called dynamic binding runtime binding. When language implements late binding, must mechanism determine type object run time call appropriate method. That is, compiler still doesn’t know object type, method-call mechanism finds calls correct method body. The late-binding mechanism varies language language, imagine sort type information must installed objects. All method binding Java uses late binding unless method static final (private methods implicitly final). This means ordinarily don’t need make decisions whether late binding occur—it happens automatically. Why would declare method final? As noted last chapter, prevents anyone overriding method. Perhaps important, effectively “turns off” dynamic binding, rather tells compiler dynamic binding isn’t necessary. This allows compiler generate slightly efficient code final method calls. However, cases won’t make overall performance difference program, it’s best use final design decision, attempt improve performance. Producing right behavior Once know method binding Java happens polymorphically via late binding, write code talk base class know derived-class cases work correctly using code. Or put another way, “send message object let object figure right thing do.” 196 Thinking Java Bruce Eckel The classic example OOP “shape” example. This commonly used easy visualize, unfortunately confuse novice programmers thinking OOP graphics programming, course case. The shape example base class called Shape various derived types: Circle, Square, Triangle, etc. The reason example works well it’s easy say “a circle type shape” understood. The inheritance diagram shows relationships: The upcast could occur statement simple as: Shape = new Circle(); Here, Circle object created, resulting reference immediately assigned Shape, would seem error (assigning one type another); yet it’s fine Circle Shape inheritance. So compiler agrees statement doesn’t issue error message. Suppose call one base-class methods (that overridden derived classes): s.draw(); Again, might expect Shape’s draw( ) called is, all, Shape reference—so could compiler know anything else? And yet proper Circle.draw( ) called late binding (polymorphism). The following example puts slightly different way. First, let’s create reusable library Shape types: //: polymorphism/shape/Shape.java package polymorphism.shape; public class Shape { public void draw() {} public void erase() {} } ///:~ //: polymorphism/shape/Circle.java package polymorphism.shape; import static net.mindview.util.Print.*; public class Circle extends Shape { Polymorphism 197 public void draw() { print("Circle.draw()"); } public void erase() { print("Circle.erase()"); } } ///:~ //: polymorphism/shape/Square.java package polymorphism.shape; import static net.mindview.util.Print.*; public class Square extends Shape { public void draw() { print("Square.draw()"); } public void erase() { print("Square.erase()"); } } ///:~ //: polymorphism/shape/Triangle.java package polymorphism.shape; import static net.mindview.util.Print.*; public class Triangle extends Shape { public void draw() { print("Triangle.draw()"); } public void erase() { print("Triangle.erase()"); } } ///:~ //: polymorphism/shape/RandomShapeGenerator.java // A "factory" randomly creates shapes. package polymorphism.shape; import java.util.*; public class RandomShapeGenerator { private Random rand = new Random(47); public Shape next() { switch(rand.nextInt(3)) { default: case 0: return new Circle(); case 1: return new Square(); case 2: return new Triangle(); } } } ///:~ //: polymorphism/Shapes.java // Polymorphism Java. import polymorphism.shape.*; public class Shapes { private static RandomShapeGenerator gen = new RandomShapeGenerator(); public static void main(String[] args) { Shape[] = new Shape[9]; // Fill array shapes: for(int = 0; < s.length; i++) s[i] = gen.next(); // Make polymorphic method calls: for(Shape shp : s) shp.draw(); } } /* Output: Triangle.draw() Triangle.draw() Square.draw() Triangle.draw() Square.draw() Triangle.draw() Square.draw() 198 Thinking Java Bruce Eckel Triangle.draw() Circle.draw() *///:~ The base class Shape establishes common interface anything inherited Shape— is, shapes drawn erased. The derived classes override definitions provide unique behavior specific type shape. RandomShapeGenerator kind “factory” produces reference randomlyselected Shape object time call next( ) method. Note upcasting happens return statements, takes reference Circle, Square, Triangle sends next( ) return type, Shape. So whenever call next( ), never get chance see specific type is, since always get back plain Shape reference. main( ) contains array Shape references filled calls RandomShapeGenerator.next( ). At point know Shapes, don’t know anything specific (and neither compiler). However, step array call draw( ) one, correct type-specific behavior magically occurs, see output run program. The point creating shapes randomly drive home understanding compiler special knowledge allows make correct calls compile time. All calls draw( ) must made dynamic binding. Exercise 2: (1) Add @Override annotation shapes example. Exercise 3: (1) Add new method base class Shapes.java prints message, don’t override derived classes. Explain happens. Now override one derived classes others, see happens. Finally, override derived classes. Exercise 4: (2) Add new type Shape Shapes.java verify main( ) polymorphism works new type old types. Exercise 5: (1) Starting Exercise 1, add wheels( ) method Cycle, returns number wheels. Modify ride( ) call wheels( ) verify polymorphism works. Extensibility Now let’s return musical instrument example. Because polymorphism, add many new types want system without changing tune( ) method. In well-designed OOP program, methods follow model tune( ) communicate base-class interface. Such program extensible add new functionality inheriting new data types common base class. The methods manipulate base-class interface need changed accommodate new classes. Consider happens take instrument example add methods base class number new classes. Here’s diagram: Polymorphism 199 All new classes work correctly old, unchanged tune( ) method. Even tune( ) separate file new methods added interface Instrument, tune( ) still work correctly, even without recompiling it. Here implementation diagram: //: polymorphism/music3/Music3.java // An extensible program. package polymorphism.music3; import polymorphism.music.Note; import static net.mindview.util.Print.*; class Instrument { void play(Note n) { print("Instrument.play() " + n); } String what() { return "Instrument"; } void adjust() { print("Adjusting Instrument"); } } class Wind extends Instrument { void play(Note n) { print("Wind.play() " + n); } String what() { return "Wind"; } void adjust() { print("Adjusting Wind"); } } class Percussion extends Instrument { void play(Note n) { print("Percussion.play() " + n); } String what() { return "Percussion"; } void adjust() { print("Adjusting Percussion"); } } class Stringed extends Instrument { 200 Thinking Java Bruce Eckel } void play(Note n) { print("Stringed.play() " + n); } String what() { return "Stringed"; } void adjust() { print("Adjusting Stringed"); } class Brass extends Wind { void play(Note n) { print("Brass.play() " + n); } void adjust() { print("Adjusting Brass"); } } class Woodwind extends Wind { void play(Note n) { print("Woodwind.play() " + n); } String what() { return "Woodwind"; } } public class Music3 { // Doesn’t care type, new types // added system still work right: public static void tune(Instrument i) { // ... i.play(Note.MIDDLE_C); } public static void tuneAll(Instrument[] e) { for(Instrument : e) tune(i); } public static void main(String[] args) { // Upcasting addition array: Instrument[] orchestra = { new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind() }; tuneAll(orchestra); } } /* Output: Wind.play() MIDDLE_C Percussion.play() MIDDLE_C Stringed.play() MIDDLE_C Brass.play() MIDDLE_C Woodwind.play() MIDDLE_C *///:~ The new methods what( ), returns String reference description class, adjust( ), provides way adjust instrument. In main( ), place something inside orchestra array, automatically upcast Instrument. You see tune( ) method blissfully ignorant code changes happened around it, yet works correctly. This exactly polymorphism supposed provide. Changes code don’t cause damage parts program affected. Put another way, polymorphism important technique programmer “separate things change things stay same.” Polymorphism 201 Exercise 6: (1) Change Music3.java what( ) becomes root Object method toString( ). Try printing Instrument objects using System.out.println( ) (without casting). Exercise 7: (2) Add new type Instrument Music3.java verify polymorphism works new type. Exercise 8: (2) Modify Music3.java randomly creates Instrument objects way Shapes.java does. Exercise 9: (3) Create inheritance hierarchy Rodent: Mouse, Gerbil, Hamster, etc. In base class, provide methods common Rodents, override derived classes perform different behaviors depending specific type Rodent. Create array Rodent, fill different specific types Rodents, call base-class methods see happens. Exercise 10: (3) Create base class two methods. In first method, call second method. Inherit class override second method. Create object derived class, upcast base type, call first method. Explain happens. Pitfall: “overriding” private methods Here’s something might innocently try do: //: polymorphism/PrivateOverride.java // Trying override private method. package polymorphism; import static net.mindview.util.Print.*; public class PrivateOverride { private void f() { print("private f()"); } public static void main(String[] args) { PrivateOverride po = new Derived(); po.f(); } } class Derived extends PrivateOverride { public void f() { print("public f()"); } } /* Output: private f() *///:~ You might reasonably expect output “public f( )”, private method automatically final, also hidden derived class. So Derived’s f( ) case brand new method; it’s even overloaded, since base-class version f( ) isn’t visible Derived. The result non-private methods may overridden, watch appearance overriding private methods, generates compiler warnings, doesn’t might expect. To clear, use different name private base-class method derived class. 202 Thinking Java Bruce Eckel Pitfall: fields static methods Once learn polymorphism, begin think everything happens polymorphically. However, ordinary method calls polymorphic. For example, access field directly, access resolved compile time, following example demonstrates: 1 //: polymorphism/FieldAccess.java // Direct field access determined compile time. class Super { public int field = 0; public int getField() { return field; } } class Sub extends Super { public int field = 1; public int getField() { return field; } public int getSuperField() { return super.field; } } public class FieldAccess { public static void main(String[] args) { Super sup = new Sub(); // Upcast System.out.println("sup.field = " + sup.field + ", sup.getField() = " + sup.getField()); Sub sub = new Sub(); System.out.println("sub.field = " + sub.field + ", sub.getField() = " + sub.getField() + ", sub.getSuperField() = " + sub.getSuperField()); } } /* Output: sup.field = 0, sup.getField() = 1 sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0 *///:~ When Sub object upcast Super reference, field accesses resolved compiler, thus polymorphic. In example, different storage allocated Super.field Sub.field. Thus, Sub actually contains two fields called field: one gets Super. However, Super version default produced refer field Sub; order get Super field must explicitly say super.field. Although seems like could confusing issue, practice virtually never comes up. For one thing, you’ll generally make fields private won’t access directly, side effects calling methods. In addition, probably won’t give name base-class field derived-class field, confusing. If method static, doesn’t behave polymorphically: //: polymorphism/StaticPolymorphism.java // Static methods polymorphic. class StaticSuper { public static String staticGet() { 1 Thanks Randy Nichols asking question. Polymorphism 203 } return "Base staticGet()"; } public String dynamicGet() { return "Base dynamicGet()"; } class StaticSub extends StaticSuper { public static String staticGet() { return "Derived staticGet()"; } public String dynamicGet() { return "Derived dynamicGet()"; } } public class StaticPolymorphism { public static void main(String[] args) { StaticSuper sup = new StaticSub(); // Upcast System.out.println(sup.staticGet()); System.out.println(sup.dynamicGet()); } } /* Output: Base staticGet() Derived dynamicGet() *///:~ static methods associated class, individual objects. Constructors polymorphism As usual, constructors different kinds methods. This also true polymorphism involved. Even though constructors polymorphic (they’re actually static methods, static declaration implicit), it’s important understand way constructors work complex hierarchies polymorphism. This understanding help avoid unpleasant entanglements. Order constructor calls The order constructor calls briefly discussed Initialization & Cleanup chapter Reusing Classes chapter, polymorphism introduced. A constructor base class always called construction process derived class, chaining inheritance hierarchy constructor every base class called. This makes sense constructor special job: see object built properly. A derived class access members only, base class (whose members typically private). Only base-class constructor proper knowledge access initialize elements. Therefore, it’s essential constructors get called; otherwise entire object wouldn’t constructed. That’s compiler enforces constructor call every portion derived class. It silently call default constructor don’t explicitly call base-class constructor derived-class constructor body. If default constructor, compiler complain. (In case class constructors, compiler automatically synthesize default constructor.) 204 Thinking Java Bruce Eckel Let’s take look example shows effects composition, inheritance, polymorphism order construction: //: polymorphism/Sandwich.java // Order constructor calls. package polymorphism; import static net.mindview.util.Print.*; class Meal { Meal() { print("Meal()"); } } class Bread { Bread() { print("Bread()"); } } class Cheese { Cheese() { print("Cheese()"); } } class Lettuce { Lettuce() { print("Lettuce()"); } } class Lunch extends Meal { Lunch() { print("Lunch()"); } } class PortableLunch extends Lunch { PortableLunch() { print("PortableLunch()");} } public class Sandwich extends PortableLunch { private Bread b = new Bread(); private Cheese c = new Cheese(); private Lettuce l = new Lettuce(); public Sandwich() { print("Sandwich()"); } public static void main(String[] args) { new Sandwich(); } } /* Output: Meal() Lunch() PortableLunch() Bread() Cheese() Lettuce() Sandwich() *///:~ This example creates complex class classes, class constructor announces itself. The important class Sandwich, reflects three levels inheritance (four, count implicit inheritance Object) three member objects. You see output Sandwich object created main( ). This means order constructor calls complex object follows: 1. The base-class constructor called. This step repeated recursively root hierarchy constructed first, followed next-derived class, etc., most-derived class reached. 2. Member initializers called order declaration. Polymorphism 205 3. The body derived-class constructor called. The order constructor calls important. When inherit, know base class access public protected members base class. This means must able assume members base class valid you’re derived class. In normal method, construction already taken place, members parts object built. Inside constructor, however, must able assume members use built. The way guarantee base-class constructor called first. Then you’re derived-class constructor, members access base class initialized. Knowing members valid inside constructor also reason that, whenever possible, initialize member objects (that is, objects placed class using composition) point definition class (e.g., b, c, l preceding example). If follow practice, help ensure base class members member objects current object initialized. Unfortunately, doesn’t handle every case, see next section. Exercise 11: (1) Add class Pickle Sandwich.java. Inheritance cleanup When using composition inheritance create new class, time won’t worry cleaning up; subobjects usually left garbage collector. If cleanup issues, must diligent create dispose( ) method (the name I chosen use here; may come something better) new class. And inheritance, must override dispose( ) derived class special cleanup must happen part garbage collection. When override dispose( ) inherited class, it’s important remember call base-class version dispose( ), since otherwise base-class cleanup happen. The following example demonstrates this: //: polymorphism/Frog.java // Cleanup inheritance. package polymorphism; import static net.mindview.util.Print.*; class Characteristic { private String s; Characteristic(String s) { this.s = s; print("Creating Characteristic " + s); } protected void dispose() { print("disposing Characteristic " + s); } } class Description { private String s; Description(String s) { this.s = s; print("Creating Description " + s); } protected void dispose() { print("disposing Description " + s); } } 206 Thinking Java Bruce Eckel class LivingCreature { private Characteristic p = new Characteristic("is alive"); private Description = new Description("Basic Living Creature"); LivingCreature() { print("LivingCreature()"); } protected void dispose() { print("LivingCreature dispose"); t.dispose(); p.dispose(); } } class Animal extends LivingCreature { private Characteristic p = new Characteristic("has heart"); private Description = new Description("Animal Vegetable"); Animal() { print("Animal()"); } protected void dispose() { print("Animal dispose"); t.dispose(); p.dispose(); super.dispose(); } } class Amphibian extends Animal { private Characteristic p = new Characteristic("can live water"); private Description = new Description("Both water land"); Amphibian() { print("Amphibian()"); } protected void dispose() { print("Amphibian dispose"); t.dispose(); p.dispose(); super.dispose(); } } public class Frog extends Amphibian { private Characteristic p = new Characteristic("Croaks"); private Description = new Description("Eats Bugs"); public Frog() { print("Frog()"); } protected void dispose() { print("Frog dispose"); t.dispose(); p.dispose(); super.dispose(); } public static void main(String[] args) { Frog frog = new Frog(); print("Bye!"); frog.dispose(); } } /* Output: Creating Characteristic alive Creating Description Basic Living Creature Polymorphism 207 LivingCreature() Creating Characteristic heart Creating Description Animal Vegetable Animal() Creating Characteristic live water Creating Description Both water land Amphibian() Creating Characteristic Croaks Creating Description Eats Bugs Frog() Bye! Frog dispose disposing Description Eats Bugs disposing Characteristic Croaks Amphibian dispose disposing Description Both water land disposing Characteristic live water Animal dispose disposing Description Animal Vegetable disposing Characteristic heart LivingCreature dispose disposing Description Basic Living Creature disposing Characteristic alive *///:~ Each class hierarchy also contains member objects types Characteristic Description, must also disposed. The order disposal reverse order initialization, case one subobject dependent another. For fields, means reverse order declaration (since fields initialized declaration order). For base classes (following form that’s used C++ destructors), perform derived-class cleanup first, base-class cleanup. That’s derived-class cleanup could call methods base class require base-class components alive, must destroy prematurely. From output see parts Frog object disposed reverse order creation. From example, see although don’t always need perform cleanup, do, process requires care awareness. Exercise 12: (3) Modify Exercise 9 demonstrates order initialization base classes derived classes. Now add member objects base derived classes show order initialization occurs construction. Also note example, Frog object “owns” member objects. It creates them, knows long live (as long Frog does), knows dispose( ) member objects. However, one member objects shared one objects, problem becomes complex cannot simply assume call dispose( ). In case, reference counting may necessary keep track number objects still accessing shared object. Here’s looks like: //: polymorphism/ReferenceCounting.java // Cleaning shared member objects. import static net.mindview.util.Print.*; class Shared { private int refcount = 0; private static long counter = 0; private final long id = counter++; public Shared() { print("Creating " + this); } 208 Thinking Java Bruce Eckel public void addRef() { refcount++; } protected void dispose() { if(--refcount == 0) print("Disposing " + this); } public String toString() { return "Shared " + id; } } class Composing { private Shared shared; private static long counter = 0; private final long id = counter++; public Composing(Shared shared) { print("Creating " + this); this.shared = shared; this.shared.addRef(); } protected void dispose() { print("disposing " + this); shared.dispose(); } public String toString() { return "Composing " + id; } } public class ReferenceCounting { public static void main(String[] args) { Shared shared = new Shared(); Composing[] composing = { new Composing(shared), new Composing(shared), new Composing(shared), new Composing(shared), new Composing(shared) }; for(Composing c : composing) c.dispose(); } } /* Output: Creating Shared 0 Creating Composing 0 Creating Composing 1 Creating Composing 2 Creating Composing 3 Creating Composing 4 disposing Composing 0 disposing Composing 1 disposing Composing 2 disposing Composing 3 disposing Composing 4 Disposing Shared 0 *///:~ The static long counter keeps track number instances Shared created, also provides value id. The type counter long rather int, prevent overflow (this good practice; overflowing counter likely happen examples book). The id final expect change value lifetime object. When attach shared object class, must remember call addRef( ), dispose( ) method keep track reference count decide actually perform cleanup. This technique requires extra diligence use, sharing objects require cleanup don’t much choice. Exercise 13: (3) Add finalize( ) method ReferenceCounting.java verify termination condition (see Initialization & Cleanup chapter). Polymorphism 209 Exercise 14: (4) Modify Exercise 12 one member objects shared object reference counting, demonstrate works properly. Behavior polymorphic methods inside constructors The hierarchy constructor calls brings interesting dilemma. What happens you’re inside constructor call dynamically-bound method object constructed? Inside ordinary method, dynamically-bound call resolved run time, object cannot know whether belongs class method class derived it. If call dynamically-bound method inside constructor, overridden definition method used. However, effect call rather unexpected overridden method called object fully constructed. This conceal difficult-to-find bugs. Conceptually, constructor’s job bring object existence (which hardly ordinary feat). Inside constructor, entire object might partially formed—you know base-class objects initialized. If constructor one step building object class that’s derived constructor’s class, derived parts yet initialized time current constructor called. A dynamically bound method call, however, reaches “outward” inheritance hierarchy. It calls method derived class. If inside constructor, call method might manipulate members haven’t initialized yet—a sure recipe disaster. You see problem following example: //: polymorphism/PolyConstructors.java // Constructors polymorphism // don’t produce might expect. import static net.mindview.util.Print.*; class Glyph { void draw() { print("Glyph.draw()"); } Glyph() { print("Glyph() draw()"); draw(); print("Glyph() draw()"); } } class RoundGlyph extends Glyph { private int radius = 1; RoundGlyph(int r) { radius = r; print("RoundGlyph.RoundGlyph(), radius = " + radius); } void draw() { print("RoundGlyph.draw(), radius = " + radius); } } public class PolyConstructors { public static void main(String[] args) { 210 Thinking Java Bruce Eckel new RoundGlyph(5); } } /* Output: Glyph() draw() RoundGlyph.draw(), radius = 0 Glyph() draw() RoundGlyph.RoundGlyph(), radius = 5 *///:~ Glyph. draw( ) designed overridden, happens RoundGlyph. But Glyph constructor calls method, call ends RoundGlyph.draw( ), would seem intent. But look output, see Glyph’s constructor calls draw( ), value radius isn’t even default initial value 1. It’s 0. This would probably result either dot nothing drawn screen, you’d left staring, trying figure program won’t work. The order initialization described earlier section isn’t quite complete, that’s key solving mystery. The actual process initialization is: 1. The storage allocated object initialized binary zero anything else happens. 2. The base-class constructors called described previously. At point, overridden draw( ) method called (yes, RoundGlyph constructor called), discovers radius value zero, due Step 1. 3. Member initializers called order declaration. 4. The body derived-class constructor called. There’s upside this, everything least initialized zero (or whatever zero means particular data type) left garbage. This includes object references embedded inside class via composition, become null. So forget initialize reference, you’ll get exception run time. Everything else gets zero, usually telltale value looking output. On hand, pretty horrified outcome program. You’ve done perfectly logical thing, yet behavior mysteriously wrong, complaints compiler. (C++ produces rational behavior situation.) Bugs like could easily buried take long time discover. As result, good guideline constructors is, “Do little possible set object good state, possibly avoid it, don’t call methods class.” The safe methods call inside constructor final base class. (This also applies private methods, automatically final.) These cannot overridden thus cannot produce kind surprise. You may always able follow guideline, it’s something strive towards. Exercise 15: (2) Add RectangularGlyph PolyConstructors.java demonstrate problem described section. Covariant return types Java SE5 adds covariant return types, means overridden method derived class return type derived type returned base-class method: //: polymorphism/CovariantReturn.java Polymorphism 211 class Grain { public String toString() { return "Grain"; } } class Wheat extends Grain { public String toString() { return "Wheat"; } } class Mill { Grain process() { return new Grain(); } } class WheatMill extends Mill { Wheat process() { return new Wheat(); } } public class CovariantReturn { public static void main(String[] args) { Mill = new Mill(); Grain g = m.process(); System.out.println(g); = new WheatMill(); g = m.process(); System.out.println(g); } } /* Output: Grain Wheat *///:~ The key difference Java SE5 earlier versions java earlier versions would force overridden version process( ) return Grain, rather Wheat, even though Wheat derived Grain thus still legitimate return type. Covariant return types allow specific Wheat return type. Designing inheritance Once learn polymorphism, seem everything ought inherited, polymorphism clever tool. This burden designs; fact, choose inheritance first you’re using existing class make new class, things become needlessly complicated. A better approach choose composition first, especially it’s obvious one use. Composition force design inheritance hierarchy. But composition also flexible since it’s possible dynamically choose type (and thus behavior) using composition, whereas inheritance requires exact type known compile time. The following example illustrates this: //: polymorphism/Transmogrify.java // Dynamically changing behavior object // via composition (the "State" design pattern). import static net.mindview.util.Print.*; class Actor { public void act() {} } class HappyActor extends Actor { public void act() { print("HappyActor"); } 212 Thinking Java Bruce Eckel } class SadActor extends Actor { public void act() { print("SadActor"); } } class Stage { private Actor actor = new HappyActor(); public void change() { actor = new SadActor(); } public void performPlay() { actor.act(); } } public class Transmogrify { public static void main(String[] args) { Stage stage = new Stage(); stage.performPlay(); stage.change(); stage.performPlay(); } } /* Output: HappyActor SadActor *///:~ A Stage object contains reference Actor, initialized HappyActor object. This means performPlay( ) produces particular behavior. But since reference rebound different object run time, reference SadActor object substituted actor, behavior produced performPlay( ) changes. Thus gain dynamic flexibility run time. (This also called State Pattern. See Thinking Patterns (with Java) www.MindView.com.) In contrast, can’t decide inherit differently run time; must completely determined compile time. A general guideline “Use inheritance express differences behavior, fields express variations state.” In preceding example, used; two different classes inherited express difference act( ) method, Stage uses composition allow state changed. In case, change state happens produce change behavior. Exercise 16: (3) Following example Transmogrify.java, create Starship class containing AlertStatus reference indicate three different states. Include methods change states. Substitution vs. extension It would seem cleanest way create inheritance hierarchy take “pure” approach. That is, methods established base class overridden derived class, seen diagram: Polymorphism 213 This called pure “is-a” relationship interface class establishes is. Inheritance guarantees derived class interface base class nothing less. If follow diagram, derived classes also base-class interface. This thought pure substitution, derived class objects perfectly substituted base class, never need know extra information subclasses you’re using them: That is, base class receive message send derived class two exactly interface. All need upcast derived class never look back see exact type object you’re dealing with. Everything handled polymorphism. When see way, seems like pure is-a relationship sensible way things, design indicates muddled thinking definition broken. This trap. As soon start thinking way, you’ll turn around discover extending interface (which, unfortunately, keyword extends seems encourage) perfect solution particular problem. This termed “is-like-a” relationship, derived class like base class—it fundamental interface—but features require additional methods implement: 214 Thinking Java Bruce Eckel While also useful sensible approach (depending situation), drawback. The extended part interface derived class available base class, upcast, can’t call new methods: If you’re upcasting case, won’t bother you, often you’ll get situation need rediscover exact type object access extended methods type. The following section shows done. Downcasting runtime type information Since lose specific type information via upcast (moving inheritance hierarchy), makes sense retrieve type information—that is, move back inheritance hierarchy—you use downcast. However, know upcast always safe base class cannot bigger interface derived class. Therefore, every message send base class interface guaranteed accepted. But downcast, don’t really know shape (for example) actually circle. It could instead triangle square type. To solve problem, must way guarantee downcast correct, won’t accidentally cast wrong type send message object can’t accept. This would quite unsafe. In languages (like C++) must perform special operation order get type-safe downcast, Java, every cast checked! So even though looks like you’re performing ordinary parenthesized cast, run time cast checked ensure fact type think is. If isn’t, get ClassCastException. This act checking Polymorphism 215 types run time called runtime type identification (RTTI). The following example demonstrates behavior RTTI: //: polymorphism/RTTI.java // Downcasting & Runtime type information (RTTI). // {ThrowsException} class Useful { public void f() {} public void g() {} } class MoreUseful extends Useful { public void f() {} public void g() {} public void u() {} public void v() {} public void w() {} } public class RTTI { public static void main(String[] args) { Useful[] x = { new Useful(), new MoreUseful() }; x[0].f(); x[1].g(); // Compile time: method found Useful: //! x[1].u(); ((MoreUseful)x[1]).u(); // Downcast/RTTI ((MoreUseful)x[0]).u(); // Exception thrown } } ///:~ As previous diagram, MoreUseful extends interface Useful. But since it’s inherited, also upcast Useful. You see happening initialization array x main( ). Since objects array class Useful, send f( ) g( ) methods both, try call u( ) (which exists MoreUseful), you’ll get compile-time error message. If want access extended interface MoreUseful object, try downcast. If it’s correct type, successful. Otherwise, you’ll get ClassCastException. You don’t need write special code exception, since indicates programmer error could happen anywhere program. The {ThrowsException} comment tag tells book’s build system expect program throw exception executes. There’s RTTI simple cast. For example, there’s way see type you’re dealing try downcast it. All Type Information chapter devoted study different aspects Java run-time type identification. Exercise 17: (2) Using Cycle hierarchy Exercise 1, add balance( ) method Unicycle Bicycle, Tricycle. Create instances three types upcast array Cycle. Try call balance( ) element array observe results. Downcast call balance( ) observe happens. 216 Thinking Java Bruce Eckel Summary Polymorphism means “different forms.” In object-oriented programming, interface base class, different forms using interface: different versions dynamically bound methods. You’ve seen chapter it’s impossible understand, even create, example polymorphism without using data abstraction inheritance. Polymorphism feature cannot viewed isolation (like switch statement can, example), instead works concert, part larger picture class relationships. To use polymorphism—and thus object-oriented techniques—effectively programs, must expand view programming include members messages individual class, also commonality among classes relationships other. Although requires significant effort, it’s worthy struggle. The results faster program development, better code organization, extensible programs, easier code maintenance. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Polymorphism 217 Interfaces Interfaces abstract classes provide structured way separate interface implementation. Such mechanisms common programming languages. C++, example, indirect support concepts. The fact language keywords exist Java indicates ideas considered important enough provide direct support. First, we’ll look abstract class, kind midway step ordinary class interface. Although first impulse create interface, abstract class important necessary tool building classes unimplemented methods. You can’t always use pure interface. Abstract classes methods In “instrument” examples previous chapter, methods base class Instrument always “dummy” methods. If methods ever called, you’ve done something wrong. That’s intent Instrument create common interface classes derived it. In examples, reason establish common interface expressed differently different subtype. It establishes basic form, say what’s common derived classes. Another way saying call Instrument abstract base class, simply abstract class. If abstract class like Instrument, objects specific class almost always meaning. You create abstract class want manipulate set classes common interface. Thus, Instrument meant express interface, particular implementation, creating Instrument object makes sense, you’ll probably want prevent user it. This accomplished making methods Instrument generate errors, delays information run time requires reliable exhaustive testing user’s part. It’s usually better catch problems compile time. Java provides mechanism called abstract method. 1 This method incomplete; declaration method body. Here syntax abstract method declaration. abstract void f( ); A class containing abstract methods called abstract class. If class contains one abstract methods, class must qualified abstract. (Otherwise, compiler gives error message.) If abstract class incomplete, compiler supposed someone tries make object class? It cannot safely create object abstract class, get 1 For C++ programmers, ist analogue C++’s pure virtual function. error message compiler. This way, compiler ensures purity abstract class, don’t need worry misusing it. If inherit abstract class want make objects new type, must provide method definitions abstract methods base class. If don’t (and may choose to), derived class also abstract, compiler force qualify class abstract keyword. It’s possible make class abstract without including abstract methods. This useful you’ve got class doesn’t make sense abstract methods, yet want prevent instances class. The Instrument class previous chapter easily turned abstract class. Only methods abstract, since making class abstract doesn’t force make methods abstract. Here’s looks like: Here’s orchestra example modified use abstract classes methods: //: interfaces/music4/Music4.java // Abstract classes methods. package interfaces.music4; import polymorphism.music.Note; import static net.mindview.util.Print.*; abstract class Instrument { private int i; // Storage allocated 220 Thinking Java Bruce Eckel } public abstract void play(Note n); public String what() { return "Instrument"; } public abstract void adjust(); class Wind extends Instrument { public void play(Note n) { print("Wind.play() " + n); } public String what() { return "Wind"; } public void adjust() {} } class Percussion extends Instrument { public void play(Note n) { print("Percussion.play() " + n); } public String what() { return "Percussion"; } public void adjust() {} } class Stringed extends Instrument { public void play(Note n) { print("Stringed.play() " + n); } public String what() { return "Stringed"; } public void adjust() {} } class Brass extends Wind { public void play(Note n) { print("Brass.play() " + n); } public void adjust() { print("Brass.adjust()"); } } class Woodwind extends Wind { public void play(Note n) { print("Woodwind.play() " + n); } public String what() { return "Woodwind"; } } public class Music4 { // Doesn’t care type, new types // added system still work right: static void tune(Instrument i) { // ... i.play(Note.MIDDLE_C); } static void tuneAll(Instrument[] e) { for(Instrument : e) tune(i); } public static void main(String[] args) { // Upcasting addition array: Instrument[] orchestra = { new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind() }; Interfaces 221 tuneAll(orchestra); } } /* Output: Wind.play() MIDDLE_C Percussion.play() MIDDLE_C Stringed.play() MIDDLE_C Brass.play() MIDDLE_C Woodwind.play() MIDDLE_C *///:~ You see there’s really change except base class. It’s helpful create abstract classes methods make abstractness class explicit, tell user compiler intended used. Abstract classes also useful refactoring tolls, since allow easily move common methods inheritance hierarchy. Exercise 1: (1) Modify Exercise 9 previous chapter Rodent abstract class. Make methods Rodent abstract whenever possible. Exercise 2: (1) Create class abstract without including abstract methods verify cannot create instances class. Exercise 3: (2) Create base class abstract print( ) method overridden derived class. The overridden version method prints value int variable defined derived class. At point definition variable, give nonzero value. In base-class constructor, call method. In main( ), create object derived type, call print( ) method. Explain results. Exercise 4: (3) Create abstract class methods. Derive class add method. Create static method takes reference base class, downcasts derived class, calls method. In main( ), demonstrate works. Now put abstract declaration method base class, thus eliminating need downcast. Interfaces The interface keyword takes concept abstractness one step further. The abstract keyword allows create one undefined methods class—you provide part interface without providing corresponding implementation. The implementation provided inheritors. The interface keyword produces completely abstract class, one provides implementation all. It allows creator determine method names, argument lists, return types, method bodies. An interface provides form, implementation. An interface says, "All classes implement particular interface look like this." Thus, code uses particular interface knows methods might called interface, that’s all. So interface used establish "protocol" classes. (Some object-oriented programming languages keyword called protocol thing.) However, interface abstract class taken extreme, since allows perform variation "multiple inheritance" creating class upcast one base type. 222 Thinking Java Bruce Eckel To create interface, use interface keyword instead class keyword. As class, add public keyword interface keyword (but interface defined file name). If leave public keyword, get package access, interface usable within package. An interface also contain fields, implicitly static final. To make class conforms particular interface (or group interfaces), use implements keyword, says, "The interface looks like, I’m going say works." Other that, looks like inheritance. The diagram instrument example shows this: You see Woodwind Brass classes you’ve implemented interface, implementation becomes ordinary class extended regular way. You choose explicitly declare methods interface public, public even don’t say it. So implement interface, methods interface must defined public. Otherwise, would default package access, you’d reducing accessibility method inheritance, allowed Java compiler. You see modified version Instrument example. Note every method interface strictly declaration, thing compiler allows. In addition, none methods Instrument declared public, they’re automatically public anyway: Interfaces 223 //: interfaces/music5/Music5.java // Interfaces. package interfaces.music5; import polymorphism.music.Note; import static net.mindview.util.Print.*; interface Instrument { // Compile-time constant: int VALUE = 5; // static & final // Cannot method definitions: void play(Note n); // Automatically public void adjust(); } class Wind implements Instrument { public void play(Note n) { print(this + ".play() " + n); } public String toString() { return "Wind"; } public void adjust() { print(this + ".adjust()"); } } class Percussion implements Instrument { public void play(Note n) { print(this + ".play() " + n); } public String toString() { return "Percussion"; } public void adjust() { print(this + ".adjust()"); } } class Stringed implements Instrument { public void play(Note n) { print(this + ".play() " + n); } public String toString() { return "Stringed"; } public void adjust() { print(this + ".adjust()"); } } class Brass extends Wind { public String toString() { return "Brass"; } } class Woodwind extends Wind { public String toString() { return "Woodwind"; } } public class Music5 { // Doesn’t care type, new types // added system still work right: static void tune(Instrument i) { // ... i.play(Note.MIDDLE_C); } static void tuneAll(Instrument[] e) { for(Instrument : e) tune(i); } public static void main(String[] args) { // Upcasting addition array: Instrument[] orchestra = { new Wind(), new Percussion(), new Stringed(), 224 Thinking Java Bruce Eckel new Brass(), new Woodwind() }; tuneAll(orchestra); } } /* Output: Wind.play() MIDDLE_C Percussion.play() MIDDLE_C Stringed.play() MIDDLE_C Brass.play() MIDDLE_C Woodwind.play() MIDDLE_C *///:~ One change made version example: The what( ) method changed toString( ), since method used. Since toString( ) part root class Object, doesn’t need appear interface. The rest code works same. Notice doesn’t matter upcasting "regular" class called Instrument, abstract class called Instrument, interface called Instrument. The behavior same. In fact, see tune( ) method isn’t evidence whether Instrument "regular" class, abstract class, interface. Exercise 5: (2) Create interface containing three methods, package. Implement interface different package. Exercise 6: (2) Prove methods interface automatically public. Exercise 7: (1) Change Exercise 9 Polymorphism chapter Rodent interface. Exercise 8: (2) In polymorphism.Sandwich.java, create interface called FastFoo (with appropriate methods) change Sandwic h also implements FastFood. Exercise 9: (3) Refactor Musics.java moving common methods Wind, Percussion Stringed abstract class. Exercise 10: (3) Modify Musics.java adding Playable interface. Move play( ) declaration Instrument Playable. Add Playable derived classes including implement list. Change tune( ) takes Playable instead Instrument. Complete decoupling Whenever method works class instead interface, limited using class subclasses. If would like apply method class isn’t hierarchy, you’re luck. An interface relaxes constraint considerably. As result, allows write reusable code. For example, suppose Processor class name( ) process( ) method takes input, modifies produces output. The base class extended create different types Processor. In case, Processor subtypes modify String objects (note return types covariant, argument types): //: interfaces/classprocessor/Apply.java Interfaces 225 package interfaces.classprocessor; import java.util.*; import static net.mindview.util.Print.*; class Processor { public String name() { return getClass().getSimpleName(); } Object process(Object input) { return input; } } class Upcase extends Processor { String process(Object input) { // Covariant return return ((String)input).toUpperCase(); } } class Downcase extends Processor { String process(Object input) { return ((String)input).toLowerCase(); } } class Splitter extends Processor { String process(Object input) { // The split() argument divides String pieces: return Arrays.toString(((String)input).split(" ")); } } public class Apply { public static void process(Processor p, Object s) { print("Using Processor " + p.name()); print(p.process(s)); } public static String = "Disagreement beliefs definition incorrect"; public static void main(String[] args) { process(new Upcase(), s); process(new Downcase(), s); process(new Splitter(), s); } } /* Output: Using Processor Upcase DISAGREEMENT WITH BELIEFS IS BY DEFINITION INCORRECT Using Processor Downcase disagreement beliefs definition incorrect Using Processor Splitter [Disagreement, with, beliefs, is, by, definition, incorrect] *///:~ The Apply.process( ) method takes kind Processor applies Object, prints results. Creating method behaves differently depending argument object pass called Strategy design pattern. The method contains fixed part algorithm performed, Strategy contains part varies. The Strategy object pass in, contains code executed. Here, Processor object Strategy, main( ) see three different Strategies applied String s. The split( ) method part String class. It takes String object splits using argument boundary, returns String[]. It used shorter way creating array String. 226 Thinking Java Bruce Eckel Now suppose discover set electronic filters seem like could fit Apply.process( ) method: //: interfaces/filters/Waveform.java package interfaces.filters; public class Waveform { private static long counter; private final long id = counter++; public String toString() { return "Waveform " + id; } } ///:~ //: interfaces/filters/Filter.java package interfaces.filters; public class Filter { public String name() { return getClass().getSimpleName(); } public Waveform process(Waveform input) { return input; } } ///:~ //: interfaces/filters/LowPass.java package interfaces.filters; public class LowPass extends Filter { double cutoff; public LowPass(double cutoff) { this.cutoff = cutoff; } public Waveform process(Waveform input) { return input; // Dummy processing } } ///:~ //: interfaces/filters/HighPass.java package interfaces.filters; public class HighPass extends Filter { double cutoff; public HighPass(double cutoff) { this.cutoff = cutoff; } public Waveform process(Waveform input) { return input; } } ///:~ //: interfaces/filters/BandPass.java package interfaces.filters; public class BandPass extends Filter { double lowCutoff, highCutoff; public BandPass(double lowCut, double highCut) { lowCutoff = lowCut; highCutoff = highCut; } public Waveform process(Waveform input) { return input; } } ///:~ Filter interface elements Processor, isn’t inherited Processor—because creator Filter class clue might want use Processor—you can’t use Filter Apply.process( ) method, even though would work fine. Basically, coupling Apply.process( ) Processor stronger needs be, prevents Apply.process( ) code reused ought be. Also notice inputs outputs Waveforms. Interfaces 227 If Processor interface, however, constraints loosened enough reuse Apply.process( ) takes interface. Here modified versions Processor Apply: //: interfaces/interfaceprocessor/Processor.java package interfaces.interfaceprocessor; public interface Processor { String name(); Object process(Object input); } ///:~ //: interfaces/interfaceprocessor/Apply.java package interfaces.interfaceprocessor; import static net.mindview.util.Print.*; public class Apply { public static void process(Processor p, Object s) { print("Using Processor " + p.name()); print(p.process(s)); } } ///:~ The first way reuse code client programmers write classes conform interface, like this: //: interfaces/interfaceprocessor/StringProcessor.java package interfaces.interfaceprocessor; import java.util.*; public abstract class StringProcessor implements Processor{ public String name() { return getClass().getSimpleName(); } public abstract String process(Object input); public static String = "If weighs duck, she’s made wood"; public static void main(String[] args) { Apply.process(new Upcase(), s); Apply.process(new Downcase(), s); Apply.process(new Splitter(), s); } } class Upcase extends StringProcessor { public String process(Object input) { // Covariant return return ((String)input).toUpperCase(); } } class Downcase extends StringProcessor { public String process(Object input) { return ((String)input).toLowerCase(); } } class Splitter extends StringProcessor { public String process(Object input) { return Arrays.toString(((String)input).split(" ")); } } /* Output: 228 Thinking Java Bruce Eckel Using Processor Upcase IF SHE WEIGHS THE SAME AS A DUCK, SHE’S MADE OF WOOD Using Processor Downcase weighs duck, she’s made wood Using Processor Splitter [If, she, weighs, the, same, as, a, duck,, she’s, made, of, wood] *///:~ However, often situation able modify classes want use. In case electronic filters, example, library discovered rather created. In cases, use Adapter design pattern. In Adapter, write code take interface produce interface need, like this: //: interfaces/interfaceprocessor/FilterProcessor.java package interfaces.interfaceprocessor; import interfaces.filters.*; class FilterAdapter implements Processor { Filter filter; public FilterAdapter(Filter filter) { this.filter = filter; } public String name() { return filter.name(); } public Waveform process(Object input) { return filter.process((Waveform)input); } } public class FilterProcessor { public static void main(String[] args) { Waveform w = new Waveform(); Apply.process(new FilterAdapter(new LowPass(1.0)), w); Apply.process(new FilterAdapter(new HighPass(2.0)), w); Apply.process( new FilterAdapter(new BandPass(3.0, 4.0)), w); } } /* Output: Using Processor LowPass Waveform 0 Using Processor HighPass Waveform 0 Using Processor BandPass Waveform 0 *///:~ In approach Adapter, FilterAdapter constructor takes interface have—Filter—and produces object Processor interface need. You may also notice delegation FilterAdapter class. Decoupling interface implementation allows interface applied multiple different implementations, thus code reusable. Exercise 11: (4) Create class method takes String argument produces result swaps pair characters argument. Adapt class works interfaceprocessor.Apply.process( ). Interfaces 229 “Multiple inheritance” Java Because interface implementation all—that is, storage associated interface—there’s nothing prevent many interfaces combined. This valuable times need say, "An x b c." In C++, act combining multiple class interfaces called multiple inheritance, carries rather sticky baggage class implementation. In Java, perform act, one classes implementation, C++ problems occur Java combining multiple interfaces: In derived class, aren’t forced base class either abstract "concrete" (one abstract methods). If inherit non-interface, inherit one. All rest base elements must interfaces. You place interface names implements keyword separate commas. You many interfaces want. You upcast interface, interface independent type. The following example shows concrete class combined several interfaces produce new class: //: interfaces/Adventure.java // Multiple interfaces. interface CanFight { void fight(); } interface CanSwim { void swim(); } interface CanFly { void fly(); } class ActionCharacter { public void fight() {} } class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly { public void swim() {} public void fly() {} } public class Adventure { public static void t(CanFight x) { x.fight(); } public static void u(CanSwim x) { x.swim(); } 230 Thinking Java Bruce Eckel public static void v(CanFly x) { x.fly(); } public static void w(ActionCharacter x) { x.fight(); } public static void main(String[] args) { Hero h = new Hero(); t(h); // Treat CanFight u(h); // Treat CanSwim v(h); // Treat CanFly w(h); // Treat ActionCharacter } } ///:~ You see Hero combines concrete class ActionCharacter interfaces CanFight, CanSwim, CanFly. When combine concrete class interfaces way, concrete class must come first, interfaces. (The compiler gives error otherwise.) The signature fight( ) interface CanFight class ActionCharacter, fight( ) provided definition Hero. You extend interface, you’ve got another interface. When want create object, definitions must first exist. Even though Hero explicitly provide definition fight( ), definition comes along ActionCharacter; thus, it’s possible create Hero objects. In class Adventure, see four methods take arguments various interfaces concrete class. When Hero object created, passed methods, means upcast interface turn. Because way interfaces designed Java, works without particular effort part programmer. Keep mind one core reasons interfaces shown preceding example: upcast one base type (and flexibility provides). However, second reason using interfaces using abstract base class: prevent client programmer making object class establish interface. This brings question: Should use interface abstract class? If it’s possible create base class without method definitions member variables, always prefer interfaces abstract classes. In fact, know something going base class, consider making interface (this subject revisited chapter summary). Exercise 12: (2) In Adventure.java, add interface called CanClimb, following form interfaces. Exercise 13: (2) Create interface, inherit two new interfaces interface. Multiply inherit third interface second two. 2 Extending interface inheritance You easily add new method declarations interface using inheritance, also combine several interfaces new interface inheritance. In cases get new interface, seen example: 2 This shows interfaces prevent "diamond problem" occurs C++ multiple inheritance. Interfaces 231 //: interfaces/HorrorShow.java // Extending interface inheritance. interface Monster { void menace(); } interface DangerousMonster extends Monster { void destroy(); } interface Lethal { void kill(); } class DragonZilla implements DangerousMonster { public void menace() {} public void destroy() {} } interface Vampire extends DangerousMonster, Lethal { void drinkBlood(); } class VeryBadVampire implements Vampire { public void menace() {} public void destroy() {} public void kill() {} public void drinkBlood() {} } public class HorrorShow { static void u(Monster b) { b.menace(); } static void v(DangerousMonster d) { d.menace(); d.destroy(); } static void w(Lethal l) { l.kill(); } public static void main(String[] args) { DangerousMonster barney = new DragonZilla(); u(barney); v(barney); Vampire vlad = new VeryBadVampire(); u(vlad); v(vlad); w(vlad); } } ///:~ DangerousMonster simple extension Monster produces new interface. This implemented DragonZilla. The syntax used Vampire works inheriting interfaces. Normally, use extends single class, extends refer multiple base interfaces building new interface. As see, interface names simply separated commas. Exercise 14: (2) Create three interfaces, two methods. Inherit new interface combines three, adding new method. Create class implementing new interface also inheriting concrete class. Now write four methods, 232 Thinking Java Bruce Eckel takes one four interfaces argument. In main( ), create object class pass methods. Exercise 15: (2) Modify previous exercise creating abstract class inheriting derived class. Name collisions combining Interfaces You encounter small pitfall implementing multiple interfaces. In preceding example, CanFight ActionCharacter identical void fight( ) methods. An identical method problem, method differs signature return type? Here’s example: //: interfaces/InterfaceCollision.java package interfaces; interface interface interface class C { I1 { void f(); } I2 { int f(int i); } I3 { int f(); } public int f() { return 1; } } class C2 implements I1, I2 { public void f() {} public int f(int i) { return 1; } // overloaded } class C3 extends C implements I2 { public int f(int i) { return 1; } // overloaded } class C4 extends C implements I3 { // Identical, problem: public int f() { return 1; } } // Methods differ return type: //! class C5 extends C implements I1 {} //! interface I4 extends I1, I3 {} ///:~ The difficulty occurs overriding, implementation, overloading get unpleasantly mixed together. Also, overloaded methods cannot differ return type. When last two lines uncommented, error messages say all: InterfaceCollision.java:23: f() C cannot implementf() It; attempting use incompatible return type found: int required: void InterfaceCollision.java:24: Interfaces I3 andh incompatible; define f(), different return type Using method names different interfaces intended combined generally causes confusion readability code, well. Strive avoid it. Interfaces 233 Adapting interface One compelling reasons interfaces allow multiple implementations interface. In simple cases form method accepts interface, leaving implement interface pass object method. Thus, common use interfaces aforementioned Strategy design pattern. You write method performs certain operations, method takes interface also specify. You’re basically saying, "You use method object like, long object conforms interface." This makes method flexible, general reusable. For example, constructor Java SE5 Scanner class (which you’ll learn Strings chapter) takes Readable interface. You’ll find Readable argument method Java standard library—it created solely Scanner, Scanner doesn’t constrain argument particular class. This way, Scanner made work types. If create new class want usable Scanner, make Readable, like this: //: interfaces/RandomWords.java // Implementing interface conform method. import java.nio.*; import java.util.*; public class RandomWords implements Readable { private static Random rand = new Random(47); private static final char[] capitals = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray(); private static final char[] lowers = "abcdefghijklmnopqrstuvwxyz".toCharArray(); private static final char[] vowels = "aeiou".toCharArray(); private int count; public RandomWords(int count) { this.count = count; } public int read(CharBuffer cb) { if(count-- == 0) return -1; // Indicates end input cb.append(capitals[rand.nextInt(capitals.length)]); for(int = 0; < 4; i++) { cb.append(vowels[rand.nextInt(vowels.length)]); cb.append(lowers[rand.nextInt(lowers.length)]); } cb.append(" "); return 10; // Number characters appended } public static void main(String[] args) { Scanner = new Scanner(new RandomWords(10)); while(s.hasNext()) System.out.println(s.next()); } } /* Output: Yazeruyac Fowenucor Goeazimom Raeuuacio Nuoadesiw Hageaikux Ruqicibui Numasetih Kuuuuozog 234 Thinking Java Bruce Eckel Waqizeyoy *///:~ The Readable interface requires implementation read( ) method. Inside read( ), add CharBuffer argument (there several ways this; see CharBuffer documentation), return -l input. Suppose class already implement Readable—how make work Scanner? Here’s example class produces random floating point numbers: //: interfaces/RandomDoubles.java import java.util.*; public class RandomDoubles { private static Random rand = new Random(47); public double next() { return rand.nextDouble(); } public static void main(String[] args) { RandomDoubles rd = new RandomDoubles(); for(int = 0; < 7; ++) System.out.print(rd.next() + " "); } } /* Output: 0.7271157860730044 0.5309454508634242 0.16020656493302599 0.18847866977771732 0.5166020801268457 0.2678662084200585 0.2613610344283964 *///:~ Because add interface onto existing class way, means method takes interface provides way class adapted work method. This power using interfaces instead classes. Exercise 16: (3) Create class produces sequence chars. Adapt class input Scanner object. Fields interfaces Because fields put interface automatically static final, interface convenient tool creating groups constant values. Before Java SE5, way produce effect enum C C++. So see pre-Java SE5 code like this: //: interfaces/Months.java // Using interfaces create groups constants. package interfaces; public interface Months { int JANUARY = 1, FEBRUARY = 2, MARCH = 3, APRIL = 4, MAY = 5, JUNE = 6, JULY = 7, AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10, NOVEMBER = 11, DECEMBER = 12; } ///:~ Notice Java style using uppercase letters (with underscores separate multiple words single identifier) static finals constant initializers. The fields interface automatically public, explicitly specified. Interfaces 235 With Java SE5, much powerful flexible enum keyword, rarely makes sense use interfaces constants anymore. However, probably run across old idiom many occasions reading legacy code (the supplements book www.MindView.net contain complete description pre-Java SE5 approach producing enumerated types using interfaces). You find details using enums Enumerated Types chapter. Exercise 17: (2) Prove fields interface implicitly static final. Initializing fields interfaces Fields defined interfaces cannot "blank finals," initialized nonconstant expressions. For example: //: interfaces/RandVals.java // Initializing interface fields // non-constant initializers. import java.util.*; public interface RandVals { Random RAND = new Random(47); int RANDOM_INT = RAND.nextInt(10); long RANDOM_LONG = RAND.nextLong() * 10; float RANDOM_FLOAT = RAND.nextLong() * 10; double RANDOM_DOUBLE = RAND.nextDouble() * 10; } ///:~ Since fields static, initialized class first loaded, happens fields accessed first time. Here’s simple test: //: interfaces/TestRandVals.java import static net.mindview.util.Print.*; public class TestRandVals { public static void main(String[] args) { print(RandVals.RANDOM_INT); print(RandVals.RANDOM_LONG); print(RandVals.RANDOM_FLOAT); print(RandVals.RANDOM_DOUBLE); } } /* Output: 8 -32032247016559954 -8.5939291E18 5.779976127815049 *///:~ The fields, course, part interface. The values stored static storage area interface. 236 Thinking Java Bruce Eckel Nesting interfaces Interfaces may nested within classes within interfaces. 3 This reveals number interesting features: //: interfaces/nesting/NestingInterfaces.java package interfaces.nesting; class A { interface B { void f(); } public class BImp implements B { public void f() {} } private class BImp2 implements B { public void f() {} } public interface C { void f(); } class CImp implements C { public void f() {} } private class CImp2 implements C { public void f() {} } private interface D { void f(); } private class DImp implements D { public void f() {} } public class DImp2 implements D { public void f() {} } public D getD() { return new DImp2(); } private D dRef; public void receiveD(D d) { dRef = d; dRef.f(); } } interface E { interface G { void f(); } // Redundant "public": public interface H { void f(); } void g(); // Cannot private within interface: //! private interface I {} } public class NestingInterfaces { 3 Thanks Martin Danner asking seminar. Interfaces 237 public class BImp implements A.B { public void f() {} } class CImp implements A.C { public void f() {} } // Cannot implement private interface except // within interface’s defining class: //! class DImp implements A.D { //! public void f() {} //! } class EImp implements E { public void g() {} } class EGImp implements E.G { public void f() {} } class EImp2 implements E { public void g() {} class EG implements E.G { public void f() {} } } public static void main(String[] args) { A = new A(); // Can’t access A.D: //! A.D ad = a.getD(); // Doesn’t return anything A.D: //! A.DImp2 di2 = a.getD(); // Cannot access member interface: //! a.getD().f(); // Only another A anything getD(): A a2 = new A(); a2.receiveD(a.getD()); } } ///:~ The syntax nesting interface within class reasonably obvious. Just like non-nested interfaces, public package-access visibility. As added twist, interfaces also private, seen A.D (the qualification syntax used nested interfaces nested classes). What good private nested interface? You might guess implemented private inner class DImp, A.DImp2 shows also implemented public class. However, A.DImp2 used itself. You allowed mention fact implements private interface D, implementing private interface way force definition methods interface without adding type information (that is, without allowing upcasting). The method getD( ) produces quandary concerning private interface: It’s public method returns reference private interface. What return value method? In main( ), see several attempts use return value, fail. The thing works return value handed object permission use it—in case, another A, via receiveD( ) method. Interface E shows interfaces nested within other. However, rules interfaces—in particular, interface elements must public—are strictly enforced here, interface nested within another interface automatically public cannot made private. 238 Thinking Java Bruce Eckel Nestinglnterfaces shows various ways nested interfaces implemented. In particular, notice implement interface, required implement interfaces nested within. Also, private interfaces cannot implemented outside defining classes. Initially, features may seem like added strictly syntactic consistency, I generally find know feature, often discover places useful. Interfaces factories An interface intended gateway multiple implementations, typical way produce objects fit interface Factory Method design pattern. Instead calling constructor directly, call creation method factory object produces implementation interface—this way, theory, code completely isolated implementation interface, thus making possible transparently swap one implementation another. Here’s demonstration showing structure Factory Method: //: interfaces/Factories.java import static net.mindview.util.Print.*; interface Service { void method1(); void method2(); } interface ServiceFactory { Service getService(); } class Implementation1 implements Service { Implementation1() {} // Package access public void method1() {print("Implementation1 method1");} public void method2() {print("Implementation1 method2");} } class Implementation1Factory implements ServiceFactory { public Service getService() { return new Implementation1(); } } class Implementation2 implements Service { Implementation2() {} // Package access public void method1() {print("Implementation2 method1");} public void method2() {print("Implementation2 method2");} } class Implementation2Factory implements ServiceFactory { public Service getService() { return new Implementation2(); } } public class Factories { public static void serviceConsumer(ServiceFactory fact) { Service = fact.getService(); s.method1(); s.method2(); Interfaces 239 } public static void main(String[] args) { serviceConsumer(new Implementation1Factory()); // Implementations completely interchangeable: serviceConsumer(new Implementation2Factory()); } } /* Output: Implementation1 method1 Implementation1 method2 Implementation2 method1 Implementation2 method2 *///:~ Without Factory Method, code would somewhere specify exact type Service created, could call appropriate constructor. Why would want add extra level indirection? One common reason create framework. Suppose creating system play games; example, play chess checkers board: //: interfaces/Games.java // A Game framework using Factory Methods. import static net.mindview.util.Print.*; interface Game { boolean move(); } interface GameFactory { Game getGame(); } class Checkers implements Game { private int moves = 0; private static final int MOVES = 3; public boolean move() { print("Checkers move " + moves); return ++moves != MOVES; } } class CheckersFactory implements GameFactory { public Game getGame() { return new Checkers(); } } class Chess implements Game { private int moves = 0; private static final int MOVES = 4; public boolean move() { print("Chess move " + moves); return ++moves != MOVES; } } class ChessFactory implements GameFactory { public Game getGame() { return new Chess(); } } public class Games { public static void playGame(GameFactory factory) { Game = factory.getGame(); while(s.move()) ; } public static void main(String[] args) { playGame(new CheckersFactory()); playGame(new ChessFactory()); 240 Thinking Java Bruce Eckel } } /* Output: Checkers move 0 Checkers move 1 Checkers move 2 Chess move 0 Chess move 1 Chess move 2 Chess move 3 *///:~ If Games class represents complex piece code, approach allows reuse code different types games. You imagine elaborate games benefit pattern. In next chapter, you’ll see elegant way implement factories using anonymous inner classes. Exercise 18: (2) Create Cycle interface, implementations Unicycle, Bicycle Tricycle. Create factories type Cycle, code uses factories. Exercise 19: (3) Create framework using Factory Methods performs coin tossing dice tossing. Summary It tempting decide interfaces good, therefore always choose interfaces concrete classes. Of course, almost anytime create class, could instead create interface factory. Many people fallen temptation, creating interfaces factories wherever it’s possible. The logic seems might need use different implementation, always add abstraction. It become kind premature design optimization. Any abstraction motivated real need. Interfaces something refactor necessary, rather installing extra level indirection everywhere, along extra complexity. That extra complexity significant, make someone work complexity realize you’ve added interfaces "just case" compelling reason—well, I see thing I begin question designs particular person done. An appropriate guideline prefer classes interfaces. Start classes, becomes clear interfaces necessary, refactor. Interfaces great tool, easily overused. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Interfaces 241 Inner Classes It’s possible place class definition within another class definition. This called inner class. The inner class valuable feature allows group classes logically belong together control visibility one within other. However, it’s important understand inner classes distinctly different composition. At first, inner classes look like simple code-hiding mechanism: You place classes inside classes. You’ll learn, however, inner class that—it knows communicate surrounding class—and kind code write inner classes elegant clear, although there’s certainly guarantee this. Initially, inner classes may seem odd, take time become comfortable using designs. The need inner classes isn’t always obvious, basic syntax semantics inner classes described, section "Why inner classes?" begin make clear benefits inner classes. After section, remainder chapter contains detailed explorations syntax inner classes. These features provided language completeness, might need use them, least first. So initial parts chapter might need now, leave detailed explorations reference material. Creating inner classes You create inner class you’d expect—by placing class definition inside surrounding class: //: innerclasses/Parcel1.java // Creating inner classes. public class Parcel1 { class Contents { private int = 11; public int value() { return i; } } class Destination { private String label; Destination(String whereTo) { label = whereTo; } String readLabel() { return label; } } // Using inner classes looks like // using class, within Parcel1: public void ship(String dest) { Contents c = new Contents(); Destination = new Destination(dest); System.out.println(d.readLabel()); } public static void main(String[] args) { Parcel1 p = new Parcel1(); p.ship("Tasmania"); } } /* Output: Tasmania *///:~ The inner classes used inside ship( ) look like ordinary classes. Here, practical difference names nested within Parceli. You’ll see isn’t difference. More typically, outer class method returns reference inner class, see to( ) contents( ) methods: //: innerclasses/Parcel2.java // Returning reference inner class. public class Parcel2 { class Contents { private int = 11; public int value() { return i; } } class Destination { private String label; Destination(String whereTo) { label = whereTo; } String readLabel() { return label; } } public Destination to(String s) { return new Destination(s); } public Contents contents() { return new Contents(); } public void ship(String dest) { Contents c = contents(); Destination = to(dest); System.out.println(d.readLabel()); } public static void main(String[] args) { Parcel2 p = new Parcel2(); p.ship("Tasmania"); Parcel2 q = new Parcel2(); // Defining references inner classes: Parcel2.Contents c = q.contents(); Parcel2.Destination = q.to("Borneo"); } } /* Output: Tasmania *///:~ If want make object inner class anywhere except within non-static method outer class, must specify type object OuterClassName.InnerClassName, seen main( ). Exercise 1: (1) Write class named Outer contains inner class named Inner. Add method Outer returns object type Inner. In main( ), create initialize reference Inner. The link outer class So far, appears inner classes name-hiding code organization scheme, helpful totally compelling. However, there’s another twist. When create 244 Thinking Java Bruce Eckel inner class, object inner class link enclosing object made it, access members enclosing object—without special qualifications. In addition, inner classes access rights elements enclosing class. 1 The following example demonstrates this: //: innerclasses/Sequence.java // Holds sequence Objects. interface Selector { boolean end(); Object current(); void next(); } public class Sequence { private Object[] items; private int next = 0; public Sequence(int size) { items = new Object[size]; } public void add(Object x) { if(next < items.length) items[next++] = x; } private class SequenceSelector implements Selector { private int = 0; public boolean end() { return == items.length; } public Object current() { return items[i]; } public void next() { if(i < items.length) i++; } } public Selector selector() { return new SequenceSelector(); } public static void main(String[] args) { Sequence sequence = new Sequence(10); for(int = 0; < 10; i++) sequence.add(Integer.toString(i)); Selector selector = sequence.selector(); while(!selector.end()) { System.out.print(selector.current() + " "); selector.next(); } } } /* Output: 0 1 2 3 4 5 6 7 8 9 *///:~ The Sequence simply fixed-sized array Object class wrapped around it. You call add( ) add new Object end sequence (if there’s room left). To fetch objects Sequence, there’s interface called Selector. This example Iterator design pattern shall learn later book. A Selector allows see you’re end( ), access current( ) Object, move next( ) Object Sequence. Because Selector interface, classes implement interface ways, methods take interface argument, order create general-purpose code. Here, SequenceSelector private class provides Selector functionality. In main( ), see creation Sequence, followed addition number String objects. Then, Selector produced call selector( ), used move Sequence select item. 1 This different design nested classes C++, simply namehiding mechanism. There link enclosing object implied permissions C++. Inner Classes 245 At first, creation SequenceSelector looks like another inner class. But examine closely. Note methods—end( ), current( ), next( )—refers items, reference isn’t part SequenceSelector, instead private field enclosing class. However, inner class access methods fields enclosing class owned them. This turns convenient, see preceding example. So inner class automatic access members enclosing class. How happen? The inner class secretly captures reference particular object enclosing class responsible creating it. Then, refer member enclosing class, reference used select member. Fortunately, compiler takes care details you, see object inner class created association object enclosing class (when, shall see, inner class non-static). Construction inner-class object requires reference object enclosing class, compiler complain cannot access reference. Most time occurs without intervention part programmer. Exercise 2: (1) Create class holds String, toString( ) method displays String. Add several instances new class Sequence object, display them. Exercise 3: (1) Modify Exercise 1 Outer private String field (initialized constructor), Inner toString( ) displays field. Create object type Inner display it. Using .this .new If need produce reference outer-class object, name outer class followed dot this. The resulting reference automatically correct type, known checked compile time, runtime overhead. Here’s example shows use .this: //: innerclasses/DotThis.java // Qualifying access outer-class object. public class DotThis { void f() { System.out.println("DotThis.f()"); } public class Inner { public DotThis outer() { return DotThis.this; // A plain "this" would Inner’s "this" } } public Inner inner() { return new Inner(); } public static void main(String[] args) { DotThis dt = new DotThis(); DotThis.Inner dti = dt.inner(); dti.outer().f(); } } /* Output: DotThis.f() *///:~ Sometimes want tell object create object one inner classes. To must provide reference outer-class object new expression, using .new syntax, like this: //: innerclasses/DotNew.java 246 Thinking Java Bruce Eckel // Creating inner class directly using .new syntax. public class DotNew { public class Inner {} public static void main(String[] args) { DotNew dn = new DotNew(); DotNew.Inner dni = dn.new Inner(); } } ///:~ To create object inner class directly, don’t follow form refer outer class name DotNew might expect, instead must use object outer class make object inner class, see above. This also resolves name scoping issues inner class, don’t say (indeed, can’t say) dn.new DotNew.Inner( ). It’s possible create object inner class unless already object outer class. This object inner class quietly connected object outer class made from. However, make nested class (a static inner class), doesn’t need reference outer-class object. Here, see use .new applied "Parcel" example: //: innerclasses/Parcel3.java // Using .new create instances inner classes. public class Parcel3 { class Contents { private int = 11; public int value() { return i; } } class Destination { private String label; Destination(String whereTo) { label = whereTo; } String readLabel() { return label; } } public static void main(String[] args) { Parcel3 p = new Parcel3(); // Must use instance outer class // create instance inner class: Parcel3.Contents c = p.new Contents(); Parcel3.Destination = p.new Destination("Tasmania"); } } ///:~ Exercise 4: (2) Add method class Sequence.SequenceSelector produces reference outer class Sequence. Exercise 5: (1) Create class inner class. In separate class, make instance inner class. Inner classes upcasting Inner classes really come start upcasting base class, particular interface. (The effect producing interface reference object implements essentially upcasting base class.) That’s inner class—the implementation interface—can unseen unavailable, Inner Classes 247 convenient hiding implementation. All get back reference base class interface. We create interfaces previous examples: //: innerclasses/Destination.java public interface Destination { String readLabel(); } ///:~ Now Contents Destination represent interfaces available client programmer. Remember interface automatically makes members public. When get reference base class interface, it’s possible can’t even find exact type, shown here: //: innerclasses/TestParcel.java class Parcel4 { private class PContents implements Contents { private int = 11; public int value() { return i; } } protected class PDestination implements Destination { private String label; private PDestination(String whereTo) { label = whereTo; } public String readLabel() { return label; } } public Destination destination(String s) { return new PDestination(s); } public Contents contents() { return new PContents(); } } public class TestParcel { public static void main(String[] args) { Parcel4 p = new Parcel4(); Contents c = p.contents(); Destination = p.destination("Tasmania"); // Illegal -- can’t access private class: //! Parcel4.PContents pc = p.new PContents(); } } ///:~ In Parcel4, something new added: The inner class PContents private, nothing Parcel4 access it. Normal (non-inner) classes cannot made private protected; may given public package access. PDestination protected, nothing Parcel4, classes package (since protected also gives package access), inheritors Parcel4 access PDestination. This means client programmer restricted knowledge access members. In fact, can’t even downcast private inner class (or protected inner class unless you’re inheritor), can’t access name, see class TestParcel. Thus, private inner class provides way class designer completely prevent type-coding dependencies completely hide details implementation. In addition, extension interface useless client programmer’s perspective since client programmer 248 Thinking Java Bruce Eckel cannot access additional methods aren’t part public interface. This also provides opportunity Java compiler generate efficient code. Exercise 6: (2) Create interface least one method, package. Create class separate package. Add protected inner class implements interface. In third package, inherit class and, inside method, return object protected inner class, upcasting interface return. Exercise 7: (2) Create class private field private method. Create inner class method modifies outer-class field calls outer-class method. In second outer-class method, create object inner class call method, show effect outer-class object. Exercise 8: (2) Determine whether outer class access private elements inner class. Inner classes methods scopes What you’ve seen far encompasses typical use inner classes. In general, code you’ll write read involving inner classes "plain" inner classes simple easy understand. However, syntax inner classes covers number other, obscure techniques. Inner classes created within method even arbitrary scope. There two reasons this: 1. As shown previously, you’re implementing interface kind create return reference. 2. You’re solving complicated problem want create class aid solution, don’t want publicly available. In following examples, previous code modified use: 1. A class defined within method 2. A class defined within scope inside method 3. An anonymous class implementing interface 4. An anonymous class extending class non-default constructor 5. An anonymous class performs field initialization 6. An anonymous class performs construction using instance initialization (anonymous inner classes cannot constructors) The first example shows creation entire class within scope method (instead scope another class). This called local inner class: //: innerclasses/Parcel5.java // Nesting class within method. public class Parcel5 { public Destination destination(String s) { class PDestination implements Destination { Inner Classes 249 private String label; private PDestination(String whereTo) { label = whereTo; } public String readLabel() { return label; } } return new PDestination(s); } public static void main(String[] args) { Parcel5 p = new Parcel5(); Destination = p.destination("Tasmania"); } } ///:~ The class PDestination part destination( ) rather part Parcels. Therefore, PDestination cannot accessed outside destination( ). Notice upcasting occurs return statementnothing comes destination( ) except reference Destination, base class. Of course, fact name class PDestination placed inside destination( ) doesn’t mean PDestination valid object destination( ) returns. You could use class identifier PDestination inner class inside class subdirectory without name clash. The next example shows nest inner class within arbitrary scope: //: innerclasses/Parcel6.java // Nesting class within scope. public class Parcel6 { private void internalTracking(boolean b) { if(b) { class TrackingSlip { private String id; TrackingSlip(String s) { id = s; } String getSlip() { return id; } } TrackingSlip ts = new TrackingSlip("slip"); String = ts.getSlip(); } // Can’t use here! Out scope: //! TrackingSlip ts = new TrackingSlip("x"); } public void track() { internalTracking(true); } public static void main(String[] args) { Parcel6 p = new Parcel6(); p.track(); } } ///:~ The class TrackingSlip nested inside scope statement. This mean class conditionally created—it gets compiled along everything else. However, it’s available outside scope defined. Other that, looks like ordinary class. Exercise 9: (1) Create interface least one method, implement interface defining inner class within method, returns reference interface. 250 Thinking Java Bruce Eckel Exercise 10: (1) Repeat previous exercise define inner class within scope within method. Exercise 11: (2) Create private inner class implements public interface. Write method returns reference instance private inner class, upcast interface. Show inner class completely hidden trying downcast it. Anonymous inner classes The next example looks little odd: //: innerclasses/Parcel7.java // Returning instance anonymous inner class. public class Parcel7 { public Contents contents() { return new Contents() { // Insert class definition private int = 11; public int value() { return i; } }; // Semicolon required case } public static void main(String[] args) { Parcel7 p = new Parcel7(); Contents c = p.contents(); } } ///:~ The contents( ) method combines creation return value definition class represents return value! In addition, class anonymous; name. To make matters bit worse, looks like you’re starting create Contents object, But then, get semicolon, say, "But wait, I think I’ll slip class definition." What strange syntax means "Create object anonymous class that’s inherited Contents." The reference returned new expression automatically upcast Contents reference. The anonymous inner-class syntax shorthand for: //: innerclasses/Parcel7b.java // Expanded version Parcel7.java public class Parcel7b { class MyContents implements Contents { private int = 11; public int value() { return i; } } public Contents contents() { return new MyContents(); } public static void main(String[] args) { Parcel7b p = new Parcel7b(); Contents c = p.contents(); } } ///:~ In anonymous inner class, Contents created using default constructor. The following code shows base class needs constructor argument: //: innerclasses/Parcel8.java // Calling base-class constructor. Inner Classes 251 public class Parcel8 { public Wrapping wrapping(int x) { // Base constructor call: return new Wrapping(x) { // Pass constructor argument. public int value() { return super.value() * 47; } }; // Semicolon required } public static void main(String[] args) { Parcel8 p = new Parcel8(); Wrapping w = p.wrapping(10); } } ///:~ That is, simply pass appropriate argument base-class constructor, seen x passed new Wrapping(x). Although it’s ordinary class implementation, Wrapping also used common "interface" derived classes: //: innerclasses/Wrapping.java public class Wrapping { private int i; public Wrapping(int x) { = x; } public int value() { return i; } } ///:~ You’ll notice Wrapping constructor requires argument, make things bit interesting. The semicolon end anonymous inner class doesn’t mark end class body. Instead, marks end expression happens contain anonymous class. Thus, it’s identical use semicolon everywhere else. You also perform initialization define fields anonymous class: //: innerclasses/Parcel9.java // An anonymous inner class performs // initialization. A briefer version Parcel5.java. public class Parcel9 { // Argument must final use inside // anonymous inner class: public Destination destination(final String dest) { return new Destination() { private String label = dest; public String readLabel() { return label; } }; } public static void main(String[] args) { Parcel9 p = new Parcel9(); Destination = p.destination("Tasmania"); } } ///:~ If you’re defining anonymous inner class want use object that’s defined outside anonymous inner class, compiler requires argument reference final, see argument destination( ). If forget, you’ll get compile-time error message. 252 Thinking Java Bruce Eckel As long you’re simply assigning field, approach example fine. But need perform constructor-like activity? You can’t named constructor anonymous class (since there’s name!), instance initialization, can, effect, create constructor anonymous inner class, like this: //: innerclasses/AnonymousConstructor.java // Creating constructor anonymous inner class. import static net.mindview.util.Print.*; abstract class Base { public Base(int i) { print("Base constructor, = " + i); } public abstract void f(); } public class AnonymousConstructor { public static Base getBase(int i) { return new Base(i) { { print("Inside instance initializer"); } public void f() { print("In anonymous f()"); } }; } public static void main(String[] args) { Base base = getBase(47); base.f(); } } /* Output: Base constructor, = 47 Inside instance initializer In anonymous f() *///:~ In case, variable final. While passed base constructor anonymous class, never directly used inside anonymous class. Here’s "parcel" theme instance initialization. Note arguments destination( ) must final since used within anonymous class: //: innerclasses/Parcel10.java // Using "instance initialization" perform // construction anonymous inner class. public class Parcel10 { public Destination destination(final String dest, final float price) { return new Destination() { private int cost; // Instance initialization object: { cost = Math.round(price); if(cost > 100) System.out.println("Over budget!"); } private String label = dest; public String readLabel() { return label; } }; } public static void main(String[] args) { Parcel10 p = new Parcel10(); Inner Classes 253 Destination = p.destination("Tasmania", 101.395F); } } /* Output: Over budget! *///:~ Inside instance initializer see code couldn’t executed part field initializer (that is, statement). So effect, instance initializer constructor anonymous inner class. Of course, it’s limited; can’t overload instance initializers, one constructors. Anonymous inner classes somewhat limited compared regular inheritance, either extend class implement interface, both. And implement interface, implement one. Exercise 12: (1) Repeat Exercise 7 using anonymous inner class. Exercise 13: (1) Repeat Exercise 9 using anonymous inner class. Exercise 14: (1) Modify interfaces/HorrorShow.java implement DangerousMonster Vampire using anonymous classes. Exercise 15: (2) Create class non-default constructor (one arguments) default constructor (no "no-arg" constructor). Create second class method returns reference object first class. Create object return making anonymous inner class inherits first class. Factory Method revisited Look much nicer interfaces/Factories.java example comes use anonymous inner classes: //: innerclasses/Factories.java import static net.mindview.util.Print.*; interface Service { void method1(); void method2(); } interface ServiceFactory { Service getService(); } class Implementation1 implements Service { private Implementation1() {} public void method1() {print("Implementation1 method1");} public void method2() {print("Implementation1 method2");} public static ServiceFactory factory = new ServiceFactory() { public Service getService() { return new Implementation1(); } }; } class Implementation2 implements Service { private Implementation2() {} 254 Thinking Java Bruce Eckel public void method1() {print("Implementation2 method1");} public void method2() {print("Implementation2 method2");} public static ServiceFactory factory = new ServiceFactory() { public Service getService() { return new Implementation2(); } }; } public class Factories { public static void serviceConsumer(ServiceFactory fact) { Service = fact.getService(); s.method1(); s.method2(); } public static void main(String[] args) { serviceConsumer(Implementation1.factory); // Implementations completely interchangeable: serviceConsumer(Implementation2.factory); } } /* Output: Implementation1 method1 Implementation1 method2 Implementation2 method1 Implementation2 method2 *///:~ Now constructors Implementation1 Implementation2 private, there’s need create named class factory. In addition, often need single factory object, created static field Service implementation. The resulting syntax meaningful, well. The interfaces/Games.java example also improved anonymous inner classes: //: innerclasses/Games.java // Using anonymous inner classes Game framework. import static net.mindview.util.Print.*; interface Game { boolean move(); } interface GameFactory { Game getGame(); } class Checkers implements Game { private Checkers() {} private int moves = 0; private static final int MOVES = 3; public boolean move() { print("Checkers move " + moves); return ++moves != MOVES; } public static GameFactory factory = new GameFactory() { public Game getGame() { return new Checkers(); } }; } class Chess implements Game { private Chess() {} private int moves = 0; private static final int MOVES = 4; public boolean move() { print("Chess move " + moves); return ++moves != MOVES; Inner Classes 255 } public static GameFactory factory = new GameFactory() { public Game getGame() { return new Chess(); } }; } public class Games { public static void playGame(GameFactory factory) { Game = factory.getGame(); while(s.move()) ; } public static void main(String[] args) { playGame(Checkers.factory); playGame(Chess.factory); } } /* Output: Checkers move 0 Checkers move 1 Checkers move 2 Chess move 0 Chess move 1 Chess move 2 Chess move 3 *///:~ Remember advice given end last chapter: Prefer classes interfaces. If design demands interface, you’ll know it. Otherwise, don’t put forced to. Exercise 16: (1) Modify solution Exercise 18 Interfaces chapter use anonymous inner classes. Exercise 17: (1) Modify solution Exercise 19 Interfaces chapter use anonymous inner classes. Nested classes If don’t need connection inner-class object outerclass object, make inner class static. This commonly called nested class. 2 To understand meaning static applied inner classes, must remember object ordinary inner class implicitly keeps reference object enclosing class created it. This true, however, say inner class static. A nested class means: 1. You don’t need outer-class object order create object nested class. 2. You can’t access non-static outer-class object object nested class. Nested classes different ordinary inner classes another way, well. Fields methods ordinary inner classes outer level class, ordinary inner classes cannot static data, static fields, nested classes. However, nested classes these: //: innerclasses/Parcel11.java // Nested classes (static inner classes). 2 256 Roughly similar nested classes C++, except classes cannot access private members Java. Thinking Java Bruce Eckel public class Parcel11 { private static class ParcelContents implements Contents { private int = 11; public int value() { return i; } } protected static class ParcelDestination implements Destination { private String label; private ParcelDestination(String whereTo) { label = whereTo; } public String readLabel() { return label; } // Nested classes contain static elements: public static void f() {} static int x = 10; static class AnotherLevel { public static void f() {} static int x = 10; } } public static Destination destination(String s) { return new ParcelDestination(s); } public static Contents contents() { return new ParcelContents(); } public static void main(String[] args) { Contents c = contents(); Destination = destination("Tasmania"); } } ///:~ In main( ), object Parcel11 necessary; instead, use normal syntax selecting static member call methods return references Contents Destination. As you’ve seen earlier chapter, ordinary (non-static) inner class, link outer-class object achieved special reference. A nested class special reference, makes analogous static method. Exercise 18: (1) Create class containing nested class. In main( ), create instance nested class. Exercise 19: (2) Create class containing inner class contains inner class. Repeat using nested classes. Note names .class files produced compiler. Classes inside interfaces Normally, can’t put code inside interface, nested class part interface. Any class put inside interface automatically public static. Since class static, doesn’t violate rules interfaces—the nested class placed inside namespace interface. You even implement surrounding interface inner class, like this: //: innerclasses/ClassInInterface.java // {main: ClassInInterface$Test} Inner Classes 257 public interface ClassInInterface { void howdy(); class Test implements ClassInInterface { public void howdy() { System.out.println("Howdy!"); } public static void main(String[] args) { new Test().howdy(); } } } /* Output: Howdy! *///:~ It’s convenient nest class inside interface want create common code used different implementations interface. Earlier book I suggested putting main( ) every class act test bed class. One drawback amount extra compiled code must carry around. If problem, use nested class hold test code: //: innerclasses/TestBed.java // Putting test code nested class. // {main: TestBed$Tester} public class TestBed { public void f() { System.out.println("f()"); } public static class Tester { public static void main(String[] args) { TestBed = new TestBed(); t.f(); } } } /* Output: f() *///:~ This generates separate class called TestBed$Tester (to run program, say Java TestBed$Tester, must escape ‘$’ Unix/Linux systems). You use class testing, don’t need include shipping product; simply delete TestBed$Tester.class packaging things up. Exercise 20: (1) Create interface containing nested class. Implement interface create instance nested class. Exercise 21: (2) Create interface contains nested class static method calls methods interface displays results. Implement interface pass instance implementation method. 258 Thinking Java Bruce Eckel Reaching outward multiply nested class It doesn’t matter deeply inner class may nested—it transparently access members classes nested within, seen here: 3 //: innerclasses/MultiNestingAccess.java // Nested classes access members // levels classes nested within. class MNA { private void f() {} class A { private void g() {} public class B { void h() { g(); f(); } } } } public class MultiNestingAccess { public static void main(String[] args) { MNA mna = new MNA(); MNA.A mnaa = mna.new A(); MNA.A.B mnaab = mnaa.new B(); mnaab.h(); } } ///:~ You see MNAAB, methods g( ) f( ) callable without qualification (despite fact private). This example also demonstrates syntax necessary create objects multiply nested inner classes create objects different class. The ".new" syntax produces correct scope, qualify class name constructor call. Why inner classes? At point you’ve seen lot syntax semantics describing way inner classes work, doesn’t answer question exist. Why Java designers go much trouble add fundamental language feature? Typically, inner class inherits class implements interface, code inner class manipulates outer-class object created within. So could say inner class provides kind window outer class. A question cuts heart inner classes this: If I need reference interface, don’t I make outer class implement interface? The answer "If that’s need, that’s it." So distinguishes inner class implementing interface outer class implementing interface? The answer can’t always convenience interfaces—sometimes you’re working implementations. So compelling reason inner classes is: 3 Thanks Martin Danner. Inner Classes 259 Each inner class independently inherit implementation. Thus, inner class limited whether outer class already inheriting implementation. Without ability inner classes provide inherit—in effect—from one concrete abstract class, design programming problems would intractable. So one way look inner class rest solution multiple-inheritance problem. Interfaces solve part problem, inner classes effectively allow "multiple implementation inheritance." That is, inner classes effectively allow inherit one non-interface. To see detail, consider situation two interfaces must somehow implemented within class. Because flexibility interfaces, two choices: single class inner class. //: innerclasses/MultiInterfaces.java // Two ways class implement multiple interfaces. package innerclasses; interface A {} interface B {} class X implements A, B {} class Y implements A { B makeB() { // Anonymous inner class: return new B() {}; } } public class MultiInterfaces { static void takesA(A a) {} static void takesB(B b) {} public static void main(String[] args) { X x = new X(); Y = new Y(); takesA(x); takesA(y); takesB(x); takesB(y.makeB()); } } ///:~ Of course, assumes structure code makes logical sense either way. However, you’ll ordinarily kind guidance nature problem whether use single class inner class. But without constraints, approach preceding example doesn’t really make much difference implementation standpoint. Both work. However, abstract concrete classes instead interfaces, suddenly limited using inner classes class must somehow implement others: //: innerclasses/MultiImplementation.java // With concrete abstract classes, inner // classes way produce effect // "multiple implementation inheritance." package innerclasses; class D {} 260 Thinking Java Bruce Eckel abstract class E {} class Z extends D { E makeE() { return new E() {}; } } public class MultiImplementation { static void takesD(D d) {} static void takesE(E e) {} public static void main(String[] args) { Z z = new Z(); takesD(z); takesE(z.makeE()); } } ///:~ If didn’t need solve "multiple implementation inheritance" problem, could conceivably code around everything else without need inner classes. But inner classes additional features: 1. The inner class multiple instances, state information independent information outer-class object. 2. In single outer class several inner classes, implements interface inherits class different way. An example shown shortly. 3. The point creation inner-class object tied creation outerclass object. 4. There potentially confusing "is-a" relationship inner class; it’s separate entity. As example, Sequence.java use inner classes, you’d say, "A Sequence Selector," you’d able one Selector existence particular Sequence. You easily second method, reverseSelector( ), produces Selector moves backward sequence. This kind flexibility available inner classes. Exercise 22: (2) Implement reverseSelector( ) Sequence.java. Exercise 23: (4) Create interface U three methods. Create class A method produces reference U building anonymous inner class. Create second class B contains array U. B one method accepts stores reference U array, second method sets reference array (specified method argument) null, third method moves array calls methods U. In main( ), create group A objects single B. Fill B U references produced A objects. Use B call back A objects. Remove U references B. Closures & callbacks A closure callable object retains information scope created. From definition, see inner class object-oriented closure, doesn’t contain piece information outer-class object ("the scope created"), automatically holds reference back whole outer-class object, permission manipulate members, even private ones. Inner Classes 261 One compelling arguments made include kind pointer mechanism Java allow callbacks. With callback, object given piece information allows call back originating object later point. This powerful concept, see later book. If callback implemented using pointer, however, must rely programmer behave properly misuse pointer. As you’ve seen now, Java tends careful that, pointers included language. The closure provided inner class good solution—more flexible far safer pointer. Here’s example: //: innerclasses/Callbacks.java // Using inner classes callbacks package innerclasses; import static net.mindview.util.Print.*; interface Incrementable { void increment(); } // Very simple implement interface: class Callee1 implements Incrementable { private int = 0; public void increment() { i++; print(i); } } class MyIncrement { public void increment() { print("Other operation"); } static void f(MyIncrement mi) { mi.increment(); } } // If class must implement increment() // way, must use inner class: class Callee2 extends MyIncrement { private int = 0; public void increment() { super.increment(); i++; print(i); } private class Closure implements Incrementable { public void increment() { // Specify outer-class method, otherwise // you’d get infinite recursion: Callee2.this.increment(); } } Incrementable getCallbackReference() { return new Closure(); } } class Caller { private Incrementable callbackReference; Caller(Incrementable cbh) { callbackReference = cbh; } void go() { callbackReference.increment(); } } public class Callbacks { 262 Thinking Java Bruce Eckel public static void main(String[] args) { Callee1 c1 = new Callee1(); Callee2 c2 = new Callee2(); MyIncrement.f(c2); Caller caller1 = new Caller(c1); Caller caller2 = new Caller(c2.getCallbackReference()); caller1.go(); caller1.go(); caller2.go(); caller2.go(); } } /* Output: Other operation 1 1 2 Other operation 2 Other operation 3 *///:~ This also shows distinction implementing interface outer class versus inner class. Callee1 clearly simpler solution terms code. Callee2 inherits Mylncrement, already different increment( ) method something unrelated one expected Incrementable interface. When Mylncrement inherited Callee2, increment( ) can’t overridden use Incrementable, you’re forced provide separate implementation using inner class. Also note create inner class, add modify interface outer class. Everything except getCallbackReference( ) Callee2 private. To allow connection outside world, interface Incrementable essential. Here see interfaces allow complete separation interface implementation. The inner class Closure implements Incrementable provide hook back Callee2— safe hook. Whoever gets Incrementable reference can, course, call increment( ) abilities (unlike pointer, would allow run wild). Caller takes Incrementable reference constructor (although capturing callback reference could happen time) then, sometime later, uses reference "call back" Callee class. The value callback flexibility; dynamically decide methods called run time. The benefit become evident Graphical User Interfaces chapter, callbacks used everywhere implement GUI functionality. Inner classes & control frameworks A concrete example use inner classes found something I refer control framework. An application framework class set classes that’s designed solve particular type problem. To apply application framework, typically inherit one classes override methods. The code write overridden methods customizes general solution provided application framework order solve specific problem. This example Template Method design pattern (see Inner Classes 263 Thinking Patterns (with Java) www.MindView.net). The Template Method contains basic structure algorithm, calls one overrideable methods complete action algorithm. A design pattern separates things change things stay same, case Template Method part stays same, overrideable methods things change. A control framework particular type application framework dominated need respond events. A system primarily responds events called event-driven system. A common problem application programming graphical user interface (GUI), almost entirely event-driven. As see Graphical User Interfaces chapter, Java Swing library control framework elegantly solves GUI problem heavily uses inner classes. To see inner classes allow simple creation use control frameworks, consider control framework whose job execute events whenever events "ready." Although "ready" could mean anything, case based clock time. What follows control framework contains specific information it’s controlling. That information supplied inheritance, action( ) portion algorithm implemented. First, interface describes control event. It’s abstract class instead actual interface default behavior perform control based time. Thus, implementation included here: //: innerclasses/controller/Event.java // The common methods control event. package innerclasses.controller; public abstract class Event { private long eventTime; protected final long delayTime; public Event(long delayTime) { this.delayTime = delayTime; start(); } public void start() { // Allows restarting eventTime = System.nanoTime() + delayTime; } public boolean ready() { return System.nanoTime() >= eventTime; } public abstract void action(); } ///:~ The constructor captures time (measured time creation object) want Event run, calls start( ), takes current time adds delay time produce time event occur. Rather included constructor, start( ) separate method. This way, restart timer event run out, Event object reused. For example, want repeating event, simply call start( ) inside action( ) method. ready( ) tells it’s time run action( ) method. Of course, ready( ) overridden derived class base Event something time. The following file contains actual control framework manages fires events. The Event objects held inside container object type List<Event> (pronounced "List Event"), you’ll learn Holding Your Objects chapter. For now, need know add( ) append Event end List, size( ) produces 264 Thinking Java Bruce Eckel number entries List, foreach syntax fetches successive Events List, remove( ) removes specified Event List. //: innerclasses/controller/Controller.java // The reusable framework control systems. package innerclasses.controller; import java.util.*; public class Controller { // A class java.util hold Event objects: private List<Event> eventList = new ArrayList<Event>(); public void addEvent(Event c) { eventList.add(c); } public void run() { while(eventList.size() > 0) // Make copy you’re modifying list // you’re selecting elements it: for(Event e : new ArrayList<Event>(eventList)) if(e.ready()) { System.out.println(e); e.action(); eventList.remove(e); } } } ///:~ The run( ) method loops copy eventList, hunting Event object that’s ready( ) run. For one finds ready( ), prints information using object’s toString( ) method, calls action( ) method, removes Event list. Note far design know nothing exactly Event does. And crux design—how "separates things change things stay same." Or, use term, "vector change" different actions various kinds Event objects, express different actions creating different Event subclasses. This inner classes come play. They allow two things: 1. The entire implementation control framework created single class, thereby encapsulating everything that’s unique implementation. Inner classes used express many different kinds action( ) necessary solve problem. 2. Inner classes keep implementation becoming awkward, since you’re able easily access members outer class. Without ability code might become unpleasant enough you’d end seeking alternative. Consider particular implementation control framework designed control greenhouse functions. 4 Each action entirely different: turning lights, water, thermostats off, ringing bells, restarting system. But control framework designed easily isolate different code. Inner classes allow multiple derived versions base class, Event, within single class. For type action, inherit new Event inner class, write control code action( ) implementation. As typical application framework, class GreenhouseControls inherited Controller: 4 For reason always pleasing problem solve; came earlier book C++ Inside & Out, Java allows elegant solution Inner Classes 265 //: innerclasses/GreenhouseControls.java // This produces specific application // control system, single class. Inner // classes allow encapsulate different // functionality type event. import innerclasses.controller.*; public class GreenhouseControls extends Controller { private boolean light = false; public class LightOn extends Event { public LightOn(long delayTime) { super(delayTime); } public void action() { // Put hardware control code // physically turn light. light = true; } public String toString() { return "Light on"; } } public class LightOff extends Event { public LightOff(long delayTime) { super(delayTime); } public void action() { // Put hardware control code // physically turn light. light = false; } public String toString() { return "Light off"; } } private boolean water = false; public class WaterOn extends Event { public WaterOn(long delayTime) { super(delayTime); } public void action() { // Put hardware control code here. water = true; } public String toString() { return "Greenhouse water on"; } } public class WaterOff extends Event { public WaterOff(long delayTime) { super(delayTime); } public void action() { // Put hardware control code here. water = false; } public String toString() { return "Greenhouse water off"; } } private String thermostat = "Day"; public class ThermostatNight extends Event { public ThermostatNight(long delayTime) { super(delayTime); } public void action() { // Put hardware control code here. thermostat = "Night"; } public String toString() { return "Thermostat night setting"; } } public class ThermostatDay extends Event { public ThermostatDay(long delayTime) { 266 Thinking Java Bruce Eckel super(delayTime); } public void action() { // Put hardware control code here. thermostat = "Day"; } public String toString() { return "Thermostat day setting"; } } // An example action() inserts // new one event list: public class Bell extends Event { public Bell(long delayTime) { super(delayTime); } public void action() { addEvent(new Bell(delayTime)); } public String toString() { return "Bing!"; } } public class Restart extends Event { private Event[] eventList; public Restart(long delayTime, Event[] eventList) { super(delayTime); this.eventList = eventList; for(Event e : eventList) addEvent(e); } public void action() { for(Event e : eventList) { e.start(); // Rerun event addEvent(e); } start(); // Rerun Event addEvent(this); } public String toString() { return "Restarting system"; } } public static class Terminate extends Event { public Terminate(long delayTime) { super(delayTime); } public void action() { System.exit(0); } public String toString() { return "Terminating"; } } } ///:~ Note light, water, thermostat belong outer class GreenhouseControls, yet inner classes access fields without qualification special permission. Also, action( ) methods usually involve sort hardware control. Most Event classes look similar, Bell Restart special. Bell rings adds new Bell object event list, ring later. Notice inner classes almost look like multiple inheritance: Bell Restart methods Event also appear methods outer class GreenhouseControls. Restart given array Event objects adds controller. Since Restart( ) another Event object, also add Restart object within Restart.action( ) system regularly restarts itself. Inner Classes 267 The following class configures system creating GreenhouseControls object adding various kinds Event objects. This example Command design pattern— object eventList request encapsulated object: //: innerclasses/GreenhouseController.java // Configure execute greenhouse system. // {Args: 5000} import innerclasses.controller.*; public class GreenhouseController { public static void main(String[] args) { GreenhouseControls gc = new GreenhouseControls(); // Instead hard-wiring, could parse // configuration information text file here: gc.addEvent(gc.new Bell(900)); Event[] eventList = { gc.new ThermostatNight(0), gc.new LightOn(200), gc.new LightOff(400), gc.new WaterOn(600), gc.new WaterOff(800), gc.new ThermostatDay(1400) }; gc.addEvent(gc.new Restart(2000, eventList)); if(args.length == 1) gc.addEvent( new GreenhouseControls.Terminate( new Integer(args[0]))); gc.run(); } } /* Output: Bing! Thermostat night setting Light Light Greenhouse water Greenhouse water Thermostat day setting Restarting system Terminating *///:~ This class initializes system, adds appropriate events. The Restart event repeatedly run, loads eventList GreenhouseControls object time. If provide command-line argument indicating milliseconds, terminate program many milliseconds (this used testing). Of course, it’s flexible read events file instead hardcoding them. An exercise I/O chapter asks modify example that. This example move toward appreciation value inner classes, especially used within control framework. However, Graphical User Interfaces chapter you’ll see elegantly inner classes used describe actions graphical user interface. By time finish chapter, fully convinced. Exercise 24: (2) In GreenhouseControls.java, add Event inner classes turn fans off. Configure GreenhouseController.java use new Event objects. 268 Thinking Java Bruce Eckel Exercise 25: (3) Inherit GreenhouseControls GreenhouseControls.java add Event inner classes turn water mist generators off. Write new version GreenhouseController.java use new Event objects. Inheriting inner classes Because inner-class constructor must attach reference enclosing class object, things slightly complicated inherit inner class. The problem "secret" reference enclosing class object must initialized, yet derived class there’s longer default object attach to. You must use special syntax make association explicit: //: innerclasses/InheritInner.java // Inheriting inner class. class WithInner { class Inner {} } public class InheritInner extends WithInner.Inner { //! InheritInner() {} // Won’t compile InheritInner(WithInner wi) { wi.super(); } public static void main(String[] args) { WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); } } ///:~ You see InheritInner extending inner class, outer one. But comes time create constructor, default one good, can’t pass reference enclosing object. In addition, must use syntax enclosingClassReference.super(); inside constructor. This provides necessary reference, program compile. Exercise 26: (2) Create class inner class non-default constructor (one takes arguments). Create second class inner class inherits first inner class. Can inner classes overridden? What happens create inner class, inherit enclosing class redefine inner class? That is, possible "override" entire inner class? This seems like would powerful concept, "overriding" inner class another method outer class doesn’t really anything: //: innerclasses/BigEgg.java // An inner class cannot overriden like method. import static net.mindview.util.Print.*; class Egg { private Yolk y; Inner Classes 269 } protected class Yolk { public Yolk() { print("Egg.Yolk()"); } } public Egg() { print("New Egg()"); = new Yolk(); } public class BigEgg extends Egg { public class Yolk { public Yolk() { print("BigEgg.Yolk()"); } } public static void main(String[] args) { new BigEgg(); } } /* Output: New Egg() Egg.Yolk() *///:~ The default constructor synthesized automatically compiler, calls baseclass default constructor. You might think since BigEgg created, "overridden" version Yolk would used, case, see output. This example shows isn’t extra inner-class magic going inherit outer class. The two inner classes completely separate entities, namespace. However, it’s still possible explicitly inherit inner class: //: innerclasses/BigEgg2.java // Proper inheritance inner class. import static net.mindview.util.Print.*; class Egg2 { protected class Yolk { public Yolk() { print("Egg2.Yolk()"); } public void f() { print("Egg2.Yolk.f()");} } private Yolk = new Yolk(); public Egg2() { print("New Egg2()"); } public void insertYolk(Yolk yy) { = yy; } public void g() { y.f(); } } public class BigEgg2 extends Egg2 { public class Yolk extends Egg2.Yolk { public Yolk() { print("BigEgg2.Yolk()"); } public void f() { print("BigEgg2.Yolk.f()"); } } public BigEgg2() { insertYolk(new Yolk()); } public static void main(String[] args) { Egg2 e2 = new BigEgg2(); e2.g(); } } /* Output: Egg2.Yolk() New Egg2() Egg2.Yolk() BigEgg2.Yolk() BigEgg2.Yolk.f() *///:~ 270 Thinking Java Bruce Eckel Now BigEgg2.Yolk explicitly extends Egg2.Yolk overrides methods. The method insertYolk( ) allows BigEgg2 upcast one Yolk objects reference Egg2, g( ) calls y.f( ), overridden version f( ) used. The second call Egg2.Yolk( ) base-class constructor call BigEgg2.Yolk constructor. You see overridden version f( ) used g( ) called. Local inner classes As noted earlier, inner classes also created inside code blocks, typically inside body method. A local inner class cannot access specifier isn’t part outer class, access final variables current code block members enclosing class. Here’s example comparing creation local inner class anonymous inner class: //: innerclasses/LocalInnerClass.java // Holds sequence Objects. import static net.mindview.util.Print.*; interface Counter { int next(); } public class LocalInnerClass { private int count = 0; Counter getCounter(final String name) { // A local inner class: class LocalCounter implements Counter { public LocalCounter() { // Local inner class constructor print("LocalCounter()"); } public int next() { printnb(name); // Access local final return count++; } } return new LocalCounter(); } // The thing anonymous inner class: Counter getCounter2(final String name) { return new Counter() { // Anonymous inner class cannot named // constructor, instance initializer: { print("Counter()"); } public int next() { printnb(name); // Access local final return count++; } }; } public static void main(String[] args) { LocalInnerClass lic = new LocalInnerClass(); Counter c1 = lic.getCounter("Local inner "), c2 = lic.getCounter2("Anonymous inner "); for(int = 0; < 5; i++) print(c1.next()); for(int = 0; < 5; i++) Inner Classes 271 print(c2.next()); } } /* Output: LocalCounter() Counter() Local inner 0 Local inner 1 Local inner 2 Local inner 3 Local inner 4 Anonymous inner 5 Anonymous inner 6 Anonymous inner 7 Anonymous inner 8 Anonymous inner 9 *///:~ Counter returns next value sequence. It implemented local class anonymous inner class, behaviors capabilities. Since name local inner class accessible outside method, justification using local inner class instead anonymous inner class need named constructor and/or overloaded constructor, since anonymous inner class use instance initialization. Another reason make local inner class rather anonymous inner class need make one object class. Inner-class identifiers Since every class produces .class file holds information create objects type (this information produces "meta-class" called Class object), might guess inner classes must also produce .class files contain information Class objects. The names files/classes strict formula: name enclosing class, followed ‘$’, followed name inner class. For example, .class files created LocalInnerClass.java include: Counter.class LocalInnerClass$l.class LocallnnerClassSlLocalCounter.class LocallnnerClass.class If inner classes anonymous, compiler simply starts generating numbers inner-class identifiers. If inner classes nested within inner classes, names simply appended ‘$’ outer-class identifier (s). Although scheme generating internal names simple straightforward, it’s also robust handles situations. 5 Since standard naming scheme Java, generated files automatically platform-independent. (Note Java compiler changing inner classes sorts ways order make work.) 5 On hand, ‘$’ meta-character Unix shell you’ll sometimes trouble listing .class files. This bit strange coming Sun, Unix-based company. My guess weren’t considering issue, instead thought you’d naturally focus source-code files. 272 Thinking Java Bruce Eckel Summary Interfaces inner classes sophisticated concepts you’ll find many OOP languages; example, there’s nothing like C++. Together, solve problem C++ attempts solve multiple inheritance (MI) feature. However, MI C++ turns rather difficult use, whereas Java interfaces inner classes are, comparison, much accessible. Although features reasonably straightforward, use features design issue, much polymorphism. Over time, you’ll become better recognizing situations use interface, inner class, both. But point book, least comfortable syntax semantics. As see language features use, you’ll eventually internalize them. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Inner Classes 273 Holding Your Objects It’s fairly simple program fixed quantity objects known lifetimes. In general, programs always creating new objects based criteria known run time. Before then, won’t know quantity even exact type objects need. To solve general programming problem, need create number objects, anytime, anywhere. So can’t rely creating named reference hold one objects: MyType aReference; since you’ll never know many you’ll actually need. Most languages provide way solve essential problem. Java several ways hold objects (or rather, references objects). The compiler-supported type array, discussed before. An array efficient way hold group objects, you’re pointed towards choice want hold group primitives. But array fixed size, general case, won’t know time you’re writing program many objects you’re going need, whether need sophisticated way store objects—so fixed-sized constraint array limiting. The java.util library reasonably complete set container classes solve problem, basic types List, Set, Queue, Map. These types objects also known collection classes, Java library uses name Collection refer particular subset library, I shall use inclusive term "container." Containers provide sophisticated ways hold objects, solve surprising number problems using tools. Among characteristics—Set, example, holds one object value, Map associative array lets associate objects objects—the Java container classes automatically resize themselves. So, unlike arrays, put number objects don’t need worry big make container you’re writing program. Even though don’t direct keyword support Java, 1 container classes fundamental tools significantly increase programming muscle. In chapter you’ll get basic working knowledge Java container library, emphasis typical usage. Here, we’ll focus containers you’ll use day-to-day programming. Later, Containers Depth chapter, you’ll learn rest containers details functionality use them. 1 A number languages, Perl, Python, Ruby, native support containers. Generics type-safe containers One problems using pre-Java SE5 containers compiler allowed insert incorrect type container. For example, consider container Apple objects, using basic workhorse container, ArrayList. For now, think ArrayList "an array automatically expands itself." Using ArrayList straightforward: Create one, insert objects using add( ), access get( ), using index—just array, without square brackets. 2 ArrayList also method size( ) let know many elements added, don’t inadvertently index end cause error (by throwing runtime exception; exceptions introduced chapter Error Handling Exceptions). In example, Apples Oranges placed container, pulled out. Normally, Java compiler give warning example use generics. Here, special Java SE5 annotation used suppress warning. Annotations start ‘@’ sign, take argument; one @SuppressWarnings argument indicates "unchecked" warnings suppressed: //: holding/ApplesAndOrangesWithoutGenerics.java // Simple container example (produces compiler warnings). // {ThrowsException} import java.util.*; class Apple { private static long counter; private final long id = counter++; public long id() { return id; } } class Orange {} public class ApplesAndOrangesWithoutGenerics { @SuppressWarnings("unchecked") public static void main(String[] args) { ArrayList apples = new ArrayList(); for(int = 0; < 3; i++) apples.add(new Apple()); // Not prevented adding Orange apples: apples.add(new Orange()); for(int = 0; < apples.size(); i++) ((Apple)apples.get(i)).id(); // Orange detected run time } } /* (Execute see output) *///:~ You’ll learn Java SE5 annotations Annotations chapter. The classes Apple Orange distinct; nothing common except Objects. (Remember don’t explicitly say class you’re inheriting from, automatically inherit Object.) Since ArrayList holds Objects, add Apple objects container using ArrayList method add( ), also add Orange objects without complaint either compile time run time. When go fetch think Apple objects using ArrayList method get( ), get back reference Object must cast Apple. Then need surround entire expression parentheses force evaluation cast calling 2 This place operator overloading would nice. C++ C# container classes produce cleaner syntax using operator overloading. 276 Thinking Java Bruce Eckel id( ) method Apple; otherwise, you’ll get syntax error. At run time, try cast Orange object Apple, you’ll get error form aforementioned exception. In Generics chapter, you’ll learn creating classes using Java generics complex. However, applying predefined generic classes usually straightforward. For example, define ArrayList intended hold Apple objects, say ArrayList<Apple> instead ArrayList. The angle brackets surround type parameters (there may one), specify type(s) held instance container. With generics, you’re prevented, compile time, putting wrong type object container. 3 Here’s example again, using generics: //: holding/ApplesAndOrangesWithGenerics.java import java.util.*; public class ApplesAndOrangesWithGenerics { public static void main(String[] args) { ArrayList<Apple> apples = new ArrayList<Apple>(); for(int = 0; < 3; i++) apples.add(new Apple()); // Compile-time error: // apples.add(new Orange()); for(int = 0; < apples.size(); i++) System.out.println(apples.get(i).id()); // Using foreach: for(Apple c : apples) System.out.println(c.id()); } } /* Output: 0 1 2 0 1 2 *///:~ Now compiler prevent putting Orange apples, becomes compile-time error rather runtime error. Also notice cast longer necessary fetching items back List. Since List knows type holds, cast call get( ). Thus, generics know compiler check type object put container, also get cleaner syntax using objects container. The example also shows that, need use index element, use foreach syntax select element List. You limited putting exact type object container specify type generic parameter. Upcasting works generics types: //: holding/GenericsAndUpcasting.java import java.util.*; class class class class GrannySmith extends Apple {} Gala extends Apple {} Fuji extends Apple {} Braeburn extends Apple {} public class GenericsAndUpcasting { public static void main(String[] args) { ArrayList<Apple> apples = new ArrayList<Apple>(); apples.add(new GrannySmith()); 3 At end Generics chapter, you’ll find discussion whether bad problem. However, Generics chapter also show Java generics useful type-safe containers. Holding Your Objects 277 apples.add(new Gala()); apples.add(new Fuji()); apples.add(new Braeburn()); for(Apple c : apples) System.out.println(c); } } /* Output: (Sample) GrannySmith@7d772e Gala@11b86e7 Fuji@35ce36 Braeburn@757aef *///:~ Thus, add subtype Apple container specified hold Apple objects. The output produced default toString( ) method Object, prints class name followed unsigned hexadecimal representation hash code object (generated hashCode( ) method). You’ll learn hash codes detail Containers Depth. Exercise 1: (2) Create new class called Gerbil int gerbilNumber that’s initialized constructor. Give method called hop( ) displays gerbil number is, it’s hopping. Create ArrayList add Gerbil objects List. Now use get( ) method move List call hop( ) Gerbil. Basic concepts The Java container library takes idea "holding objects" divides two distinct concepts, expressed basic interfaces library: 1. Collection: sequence individual elements one rules applied them. A List must hold elements way inserted, Set cannot duplicate elements, Queue produces elements order determined queuing discipline (usually order inserted). 2. Map: group key-value object pairs, allowing look value using key. An ArrayList allows look object using number, sense associates numbers objects. A map allows look object using another object. It’s also called associative array, associates objects objects, dictionary, look value object using key object like look definition using word. Maps powerful programming tools. Although it’s always possible, ideally you’ll write code talk interfaces, place you’ll specify precise type you’re using point creation. So create List like this: List<Apple> apples = new ArrayList<Apple>(); Notice ArrayList upcast List, contrast way handled previous examples. The intent using interface decide want change implementation, need change point creation, like this: List<Apple> apples = new LinkedList<Apple>(); Thus, you’ll typically make object concrete class, upcast corresponding interface, use interface throughout rest code. 278 Thinking Java Bruce Eckel This approach won’t always work, classes additional functionality. For example, LinkedList additional methods List interface, TreeMap methods Map interface. If need use methods, won’t able upcast general interface. The Collection interface generalizes idea sequence—a way holding group objects. Here’s simple example fills Collection (represented ArrayList) Integer objects prints element resulting container: //: holding/SimpleCollection.java import java.util.*; public class SimpleCollection { public static void main(String[] args) { Collection<Integer> c = new ArrayList<Integer>(); for(int = 0; < 10; i++) c.add(i); // Autoboxing for(Integer : c) System.out.print(i + ", "); } } /* Output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, *///:~ Since example uses Collection methods, object class inherited Collection would work, ArrayList basic type sequence. The name add( ) method suggests puts new element Collection. However, documentation carefully states add( ) "ensures Collection contains specified element." This allow meaning Set, adds element isn’t already there. With ArrayList, sort List, add( ) always means "put in," Lists don’t care duplicates. All Collections traversed using foreach syntax, shown here. Later chapter you’ll learn flexible concept called Iterator. Exercise 2: (1) Modify SimpleCollection.java use Set c. Exercise 3: (2) Modify innerclasses/Sequence.java add number elements it. Adding groups elements There utility methods Arrays Collections classes java.util add groups elements Collection. Arrays.asList( ) takes either array commaseparated list elements (using varargs) turns List object. Collections.addAll( ) takes Collection object either array comma-separated list adds elements Collection. Here’s example shows methods, well conventional addAll( ) method that’s part Collection types: //: holding/AddingGroups.java // Adding groups elements Collection objects. import java.util.*; public class AddingGroups { public static void main(String[] args) { Collection<Integer> collection = Holding Your Objects 279 new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5)); Integer[] moreInts = { 6, 7, 8, 9, 10 }; collection.addAll(Arrays.asList(moreInts)); // Runs significantly faster, can’t // construct Collection way: Collections.addAll(collection, 11, 12, 13, 14, 15); Collections.addAll(collection, moreInts); // Produces list "backed by" array: List<Integer> list = Arrays.asList(16, 17, 18, 19, 20); list.set(1, 99); // OK -- modify element // list.add(21); // Runtime error // underlying array cannot resized. } } ///:~ The constructor Collection accept another Collection uses initializing itself, use Arrays.asList( ) produce input constructor. However, Collections.addAll( ) runs much faster, it’s easy construct Collection elements call Collections.addAll( ), preferred approach. The Collection.addAll( ) member method take argument another Collection object, flexible Arrays.asList( ) Collections.addAll( ), use variable argument lists. It’s also possible use output Arrays.asList( ) directly, List, underlying representation case array, cannot resized. If try add( ) delete( ) elements list, would attempt change size array, you’ll get "Unsupported Operation" error run time. A limitation Arrays.asList( ) takes best guess resulting type List, doesn’t pay attention you’re assigning to. Sometimes cause problem: //: holding/AsListInference.java // Arrays.asList() makes best guess type. import java.util.*; class class class class class class Snow {} Powder extends Snow {} Light extends Powder {} Heavy extends Powder {} Crusty extends Snow {} Slush extends Snow {} public class AsListInference { public static void main(String[] args) { List<Snow> snow1 = Arrays.asList( new Crusty(), new Slush(), new Powder()); // // // // // // Won’t compile: List<Snow> snow2 = Arrays.asList( new Light(), new Heavy()); Compiler says: found : java.util.List<Powder> required: java.util.List<Snow> // Collections.addAll() doesn’t get confused: List<Snow> snow3 = new ArrayList<Snow>(); Collections.addAll(snow3, new Light(), new Heavy()); 280 Thinking Java Bruce Eckel // Give hint using // explicit type argument specification: List<Snow> snow4 = Arrays.<Snow>asList( new Light(), new Heavy()); } } ///:~ When trying create snow2, Arrays.asList( ) types Powder, creates List<Powder> rather List<Snow>, whereas Collections.addAll( ) works fine knows first argument target type is. As see creation snow4, it’s possible insert "hint" middle Arrays.asList( ), tell compiler actual target type resulting List type produced Arrays.asList( ). This called explicit type argument specification. Maps complex, you’ll see, Java standard library provide way automatically initialize them, except contents another Map. Printing containers You must use Arrays.toString( ) produce printable representation array, containers print nicely without help. Here’s example also introduces basic Java containers: //: holding/PrintingContainers.java // Containers print automatically. import java.util.*; import static net.mindview.util.Print.*; public class PrintingContainers { static Collection fill(Collection<String> collection) { collection.add("rat"); collection.add("cat"); collection.add("dog"); collection.add("dog"); return collection; } static Map fill(Map<String,String> map) { map.put("rat", "Fuzzy"); map.put("cat", "Rags"); map.put("dog", "Bosco"); map.put("dog", "Spot"); return map; } public static void main(String[] args) { print(fill(new ArrayList<String>())); print(fill(new LinkedList<String>())); print(fill(new HashSet<String>())); print(fill(new TreeSet<String>())); print(fill(new LinkedHashSet<String>())); print(fill(new HashMap<String,String>())); print(fill(new TreeMap<String,String>())); print(fill(new LinkedHashMap<String,String>())); } } /* Output: [rat, cat, dog, dog] [rat, cat, dog, dog] [dog, cat, rat] Holding Your Objects 281 [cat, dog, rat] [rat, cat, dog] {dog=Spot, cat=Rags, rat=Fuzzy} {cat=Rags, dog=Spot, rat=Fuzzy} {rat=Fuzzy, cat=Rags, dog=Spot} *///:~ This shows two primary categories Java container library. The distinction based number items held "slot" container. The Collection category holds one item slot. It includes List, holds group items specified sequence, Set, allows addition one identical item, Queue, allows insert objects one "end" container remove objects "end" (for purposes example, another way looking sequence shown). A Map holds two objects, key associated value, slot. In output, see default printing behavior (provided via container’s toString( ) method) produces reasonably readable results. A Collection printed surrounded square brackets, element separated comma. A Map surrounded curly braces, key value associated equal sign (keys left, values right). The first fill( ) method works types Collection, implements add( ) method include new elements. ArrayList LinkedList types List, see output hold elements order inserted. The difference two performance certain types operations, also LinkedList contains operations ArrayList. These explored fully later chapter. HashSet, TreeSet LinkedHashSet types Set. The output shows Set hold one identical item, also shows different Set implementations store elements differently. The HashSet stores elements using rather complex approach explored Containers Depth chapter—all need know point technique fastest way retrieve elements, result storage order seem nonsensical (often, care whether something member Set, order appears). If storage order important, use TreeSet, keeps objects ascending comparison order, LinkedHashSet, keeps objects order added. A Map (also called associative array) allows look object using key, like simple database. The associated object called value. If Map associates states capitals want know capital Ohio, look using "Ohio" key—almost indexing array. Because behavior, Map accepts one key. Map.put(key, value) adds value (the thing want) associates key (the thing look with). Map.get(key) produces value associated key. The example adds key-value pairs, perform lookups. That shown later. Notice don’t specify (or think about) size Map resizes automatically. Also, Maps know print themselves, showing association keys values. The order keys values held inside Map insertion order HashMap implementation uses fast algorithm controls order. 282 Thinking Java Bruce Eckel The example uses three basic flavors Map: HashMap, TreeMap LinkedHashMap. Like HashSet, HashMap provides fastest lookup technique, also doesn’t hold elements apparent order. A TreeMap keeps keys sorted ascending comparison order, LinkedHashMap keeps keys insertion order retaining lookup speed HashMap. Exercise 4: (3) Create generator class produces character names (as String objects) favorite movie (you use Snow White Star Wars fallback) time call next( ), loops around beginning character list runs names. Use generator fill array, ArrayList, LinkedList, HashSet, LinkedHashSet, TreeSet, print container. List Lists promise maintain elements particular sequence. The List interface adds number methods Collection allow insertion removal elements middle List. There two types List: • The basic ArrayList, excels randomly accessing elements, slower inserting removing elements middle List. • The LinkedList, provides optimal sequential access, inexpensive insertions deletions middle List. A LinkedList relatively slow random access, larger feature set ArrayList. The following example reaches forward book use library Type Information chapter importing typeinfo.pets. This library contains hierarchy Pet classes along tools randomly generate Pet objects. You don’t need know full details point, (1) there’s Pet class various subtypes Pet (2) static Pets.arrayList( ) method return ArrayList filled randomly selected Pet objects: //: holding/ListFeatures.java import typeinfo.pets.*; import java.util.*; import static net.mindview.util.Print.*; public class ListFeatures { public static void main(String[] args) { Random rand = new Random(47); List<Pet> pets = Pets.arrayList(7); print("1: " + pets); Hamster h = new Hamster(); pets.add(h); // Automatically resizes print("2: " + pets); print("3: " + pets.contains(h)); pets.remove(h); // Remove object Pet p = pets.get(2); print("4: " + p + " " + pets.indexOf(p)); Pet cymric = new Cymric(); print("5: " + pets.indexOf(cymric)); print("6: " + pets.remove(cymric)); // Must exact object: print("7: " + pets.remove(p)); print("8: " + pets); pets.add(3, new Mouse()); // Insert index Holding Your Objects 283 print("9: " + pets); List<Pet> sub = pets.subList(1, 4); print("subList: " + sub); print("10: " + pets.containsAll(sub)); Collections.sort(sub); // In-place sort print("sorted subList: " + sub); // Order important containsAll(): print("11: " + pets.containsAll(sub)); Collections.shuffle(sub, rand); // Mix print("shuffled subList: " + sub); print("12: " + pets.containsAll(sub)); List<Pet> copy = new ArrayList<Pet>(pets); sub = Arrays.asList(pets.get(1), pets.get(4)); print("sub: " + sub); copy.retainAll(sub); print("13: " + copy); copy = new ArrayList<Pet>(pets); // Get fresh copy copy.remove(2); // Remove index print("14: " + copy); copy.removeAll(sub); // Only removes exact objects print("15: " + copy); copy.set(1, new Mouse()); // Replace element print("16: " + copy); copy.addAll(2, sub); // Insert list middle print("17: " + copy); print("18: " + pets.isEmpty()); pets.clear(); // Remove elements print("19: " + pets); print("20: " + pets.isEmpty()); pets.addAll(Pets.arrayList(4)); print("21: " + pets); Object[] = pets.toArray(); print("22: " + o[3]); Pet[] pa = pets.toArray(new Pet[0]); print("23: " + pa[3].id()); } } /* Output: 1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug] 2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster] 3: true 4: Cymric 2 5: -1 6: false 7: true 8: [Rat, Manx, Mutt, Pug, Cymric, Pug] 9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug] subList: [Manx, Mutt, Mouse] 10: true sorted subList: [Manx, Mouse, Mutt] 11: true shuffled subList: [Mouse, Manx, Mutt] 12: true sub: [Mouse, Pug] 13: [Mouse, Pug] 14: [Rat, Mouse, Mutt, Pug, Cymric, Pug] 15: [Rat, Mutt, Cymric, Pug] 16: [Rat, Mouse, Cymric, Pug] 17: [Rat, Mouse, Mouse, Pug, Cymric, Pug] 18: false 19: [] 20: true 21: [Manx, Cymric, Rat, EgyptianMau] 22: EgyptianMau 284 Thinking Java Bruce Eckel 23: 14 *///:~ The print lines numbered output related source code. The first output line shows original List Pets. Unlike array, List allows add elements created, remove elements, resizes itself. That’s fundamental value: modifiable sequence. You see result adding Hamster output line 2—the object appended end list. You find whether object list using contains( ) method. If want remove object, pass object’s reference remove( ) method. Also, reference object, discover index number object located List using indexOf( ), see output line 4. When deciding whether element part List, discovering index element, removing element List reference, equals( ) method (part root class Object) used. Each Pet defined unique object, even though two Cymrics list, I create new Cymric object pass indexOf( ), result -1 (indicating wasn’t found), attempts remove( ) object return false. For classes, equals( ) may defined differently—Strings, example, equal contents two Strings identical. So prevent surprises, it’s important aware List behavior changes depending equals( ) behavior. In output lines 7 8, removing object exactly matches object List shown successful. It’s possible insert element middle List, see output line 9 code precedes it, brings issue: LinkedList, insertion removal middle list cheap operation (except for, case, actual random access middle list), ArrayList expensive operation. Does mean never insert elements middle ArrayList, switch LinkedList do? No, means aware issue, start many insertions middle ArrayList program starts slowing down, might look List implementation possible culprit (the best way discover bottleneck, see supplement http://MindView.net/Books/BetterJava, use profiler). Optimization tricky issue, best policy leave alone discover need worry (although understanding issues always good idea). The subList( ) method allows easily create slice larger list, naturally produces true result passed containsAll( ) larger list. It’s also interesting note order unimportant—you see output lines 11 12 calling intuitively named Collections.sort( ) Collections.shuffle( ) sub doesn’t affect outcome containsAll( ). subList( ) produces list backed original list. Therefore, changes returned list reflected original list, vice versa. The retainAll( ) method effectively "set intersection" operation, case keeping elements copy also sub. Again, resulting behavior depends equals( ) method. Output line 14 shows result removing element using index number, straightforward removing object reference since don’t worry equals( ) behavior using indexes. The removeAll( ) method also operates based equals( ) method. As name implies, removes objects List argument List. The set( ) method rather unfortunately named potential confusion Set class— Holding Your Objects 285 "replace" might better name here, replaces element index (the first argument) second argument. Output line 17 shows Lists, there’s overloaded addAll( ) method allows insert new list middle original list, instead appending end addAll( ) comes Collection. Output lines 18-20 show effect isEmpty( ) clear( ) methods. Output lines 22 23 show convert Collection array using toArray( ). This overloaded method; no-argument version returns array Object, pass array target type overloaded version, produce array type specified (assuming passes type checking). If argument array small hold objects List (as case here), Array( ) create new array appropriate size. Pet objects id( ) method, see called one objects resulting array. Exercise 5: (3) Modify ListFeatures.java uses Integers (remember autoboxing!) instead Pets, explain difference results. Exercise 6: (2) Modify ListFeatures.java uses Strings instead Pets, explain difference results. Exercise 7: (3) Create class, make initialized array objects class. Fill List array. Create subset List using subList( ), remove subset List. Iterator In container, must way insert elements fetch again. After all, that’s primary job container—to hold things. In List, add( ) one way insert elements, get( ) one way fetch elements. If want start thinking higher level, there’s drawback: You need program exact type container order use it. This might seem bad first, write code List, later discover would convenient apply code Set? Or suppose you’d like write, beginning, piece generalpurpose code doesn’t know care type container it’s working with, used different types containers without rewriting code? The concept Iterator (another design pattern) used achieve abstraction. An iterator object whose job move sequence select object sequence without client programmer knowing caring underlying structure sequence. In addition, iterator usually what’s called lightweight object: one that’s cheap create. For reason, you’ll often find seemingly strange constraints iterators; example, Java Iterator move one direction. There’s much Iterator except: 1. Ask Collection hand Iterator using method called iterator( ). That Iterator ready return first element sequence. 2. Get next object sequence next( ). 3. See objects sequence hasNext( ). 286 Thinking Java Bruce Eckel 4. Remove last element returned iterator remove( ). To see works, use Pets tools Type Information chapter: //: holding/SimpleIteration.java import typeinfo.pets.*; import java.util.*; public class SimpleIteration { public static void main(String[] args) { List<Pet> pets = Pets.arrayList(12); Iterator<Pet> = pets.iterator(); while(it.hasNext()) { Pet p = it.next(); System.out.print(p.id() + ":" + p + " "); } System.out.println(); // A simpler approach, possible: for(Pet p : pets) System.out.print(p.id() + ":" + p + " "); System.out.println(); // An Iterator also remove elements: = pets.iterator(); for(int = 0; < 6; i++) { it.next(); it.remove(); } System.out.println(pets); } } /* Output: 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster [Pug, Manx, Cymric, Rat, EgyptianMau, Hamster] *///:~ With Iterator, don’t need worry number elements container. That’s taken care hasNext( ) next( ). If you’re simply moving forward List trying modify List object itself, see foreach syntax succinct. An Iterator also remove last element produced next( ), means must call next( ) call remove( ). 4 This idea taking container objects passing perform operation one powerful seen throughout book. Now consider creation display( ) method container-agnostic: //: holding/CrossContainerIteration.java import typeinfo.pets.*; import java.util.*; public class CrossContainerIteration { 4 remove( ) so-called "optional" method (there methods), means Iterator implementations must implement it. This topic covered Containers Depth chapter. The standard Java library containers implement remove( ), however, don’t need worry chapter. Holding Your Objects 287 public static void display(Iterator<Pet> it) { while(it.hasNext()) { Pet p = it.next(); System.out.print(p.id() + ":" + p + " "); } System.out.println(); } public static void main(String[] args) { ArrayList<Pet> pets = Pets.arrayList(8); LinkedList<Pet> petsLL = new LinkedList<Pet>(pets); HashSet<Pet> petsHS = new HashSet<Pet>(pets); TreeSet<Pet> petsTS = new TreeSet<Pet>(pets); display(pets.iterator()); display(petsLL.iterator()); display(petsHS.iterator()); display(petsTS.iterator()); } } /* Output: 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat 5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat *///:~ Note display( ) contains information type sequence traversing, shows true power Iterator: ability separate operation traversing sequence underlying structure sequence. For reason, sometimes say iterators unify access containers. Exercise 8: (1) Modify Exercise l uses Iterator move List calling hop( ). Exercise 9: (4) Modify innerclasses/Sequence.java Sequence works Iterator instead Selector. Exercise 10: (2) Change Exercise 9 Polymorphism chapter use ArrayList hold Rodents Iterator move sequence Rodents. Exercise 11: (2) Write method uses Iterator step Collection print toString( ) object container. Fill different types Collections objects apply method container. ListIterator The ListIterator powerful subtype Iterator produced List classes. While Iterator move forward, ListIterator bidirectional. It also produce indexes next previous elements relative iterator pointing list, replace last element visited using set( ) method. You produce ListIterator points beginning List calling listIterator( ), also create ListIterator starts pointing index n list calling listIterator(n). Here’s example demonstrates abilities: //: holding/ListIteration.java import typeinfo.pets.*; import java.util.*; public class ListIteration { public static void main(String[] args) { 288 Thinking Java Bruce Eckel List<Pet> pets = Pets.arrayList(8); ListIterator<Pet> = pets.listIterator(); while(it.hasNext()) System.out.print(it.next() + ", " + it.nextIndex() + ", " + it.previousIndex() + "; "); System.out.println(); // Backwards: while(it.hasPrevious()) System.out.print(it.previous().id() + " "); System.out.println(); System.out.println(pets); = pets.listIterator(3); while(it.hasNext()) { it.next(); it.set(Pets.randomPet()); } System.out.println(pets); } } /* Output: Rat, 1, 0; Manx, 2, 5; Pug, 7, 6; Manx, 7 6 5 4 3 2 1 0 [Rat, Manx, Cymric, [Rat, Manx, Cymric, *///:~ 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 8, 7; Mutt, Pug, Cymric, Pug, Manx] Cymric, Rat, EgyptianMau, Hamster, EgyptianMau] The Pets.randomPet( ) method used replace Pet objects List location 3 onward. Exercise 12: (3) Create populate List<Integer>. Create second List<Integer> size first, use ListIterators read elements first List insert second reverse order. (You may want explore number different ways solve problem.) LinkedList The LinkedList also implements basic List interface like ArrayList does, performs certain operations (insertion removal middle List) efficiently ArrayList. Conversely, less efficient random-access operations. LinkedList also adds methods allow used stack, Queue doubleended queue (deque). Some methods aliases slight variations other, produce names familiar within context particular usage (Queue, particular). For example, getFirst( ) element( ) identical—they return head (first element) list without removing it, throw NoSuchElementException List empty. peek( ) slight variation two returns null list empty. removeFirst( ) remove( ) also identical—they remove return head list, throw NoSuchElementException empty list, poll( ) slight variation returns null list empty. addFirst( ) inserts element beginning list. offer( ) add( ) addLast( ). They add element tail (end) list. Holding Your Objects 289 removeLast( ) removes returns last element list. Here’s example shows basic similarity differences features. It doesn’t repeat behavior shown ListFeatures.java: //: holding/LinkedListFeatures.java import typeinfo.pets.*; import java.util.*; import static net.mindview.util.Print.*; public class LinkedListFeatures { public static void main(String[] args) { LinkedList<Pet> pets = new LinkedList<Pet>(Pets.arrayList(5)); print(pets); // Identical: print("pets.getFirst(): " + pets.getFirst()); print("pets.element(): " + pets.element()); // Only differs empty-list behavior: print("pets.peek(): " + pets.peek()); // Identical; remove return first element: print("pets.remove(): " + pets.remove()); print("pets.removeFirst(): " + pets.removeFirst()); // Only differs empty-list behavior: print("pets.poll(): " + pets.poll()); print(pets); pets.addFirst(new Rat()); print("After addFirst(): " + pets); pets.offer(Pets.randomPet()); print("After offer(): " + pets); pets.add(Pets.randomPet()); print("After add(): " + pets); pets.addLast(new Hamster()); print("After addLast(): " + pets); print("pets.removeLast(): " + pets.removeLast()); } } /* Output: [Rat, Manx, Cymric, Mutt, Pug] pets.getFirst(): Rat pets.element(): Rat pets.peek(): Rat pets.remove(): Rat pets.removeFirst(): Manx pets.poll(): Cymric [Mutt, Pug] After addFirst(): [Rat, Mutt, Pug] After offer(): [Rat, Mutt, Pug, Cymric] After add(): [Rat, Mutt, Pug, Cymric, Pug] After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster] pets.removeLast(): Hamster *///:~ The result Pets.arrayList( ) handed LinkedList constructor order populate it. If look Queue interface, you’ll see element( ), offer( ), peek( ), poll( ) remove( ) methods added LinkedList order could Queue implementation. Full examples Queues given later chapter. Exercise 13: (3) In innerclasses/GreenhouseController.java example, class Controller uses ArrayList. Change code use LinkedList instead, use Iterator cycle set events. 290 Thinking Java Bruce Eckel Exercise 14: (3) Create empty LinkedList<Integer>. Using Listlterator, add Integers List always inserting middle List. Stack A stack sometimes referred "last-in, first-out" (LIFO) container. It’s sometimes called pushdown stack, whatever "push" stack last first item "pop" stack. An often-used analogy cafeteria trays spring-loaded holder—the last ones go first ones come out. LinkedList methods directly implement stack functionality, also use LinkedList rather making stack class. However, stack class sometimes tell story better: //: net/mindview/util/Stack.java // Making stack LinkedList. package net.mindview.util; import java.util.LinkedList; public class Stack<T> { private LinkedList<T> storage = new LinkedList<T>(); public void push(T v) { storage.addFirst(v); } public T peek() { return storage.getFirst(); } public T pop() { return storage.removeFirst(); } public boolean empty() { return storage.isEmpty(); } public String toString() { return storage.toString(); } } ///:~ This introduces simplest possible example class definition using generics. The <T> class name tells compiler parameterized type, type parameter—the one substituted real type class used—is T. Basically, says, "We’re defining Stack holds objects type T." The Stack implemented using LinkedList, LinkedList also told holding type T. Notice push( ) takes object type T, peek( ) pop( ) return object type T. The peek( ) method provides top element without removing top stack, pop( ) removes returns top element. If want stack behavior, inheritance inappropriate would produce class rest LinkedList methods (you’ll see Containers Depth chapter mistake made Java l.o designers created java.util.Stack). Here’s simple demonstration new Stack class: //: holding/StackTest.java import net.mindview.util.*; public class StackTest { public static void main(String[] args) { Stack<String> stack = new Stack<String>(); for(String : "My dog fleas".split(" ")) stack.push(s); while(!stack.empty()) System.out.print(stack.pop() + " "); } } /* Output: fleas dog My *///:~ Holding Your Objects 291 If want use Stack class code, you’ll need fully specify package— change name class—when create one; otherwise, you’ll probably collide Stack java.util package. For example, import java.util.* example, must use package names order prevent collisions: //: holding/StackCollision.java import net.mindview.util.*; public class StackCollision { public static void main(String[] args) { net.mindview.util.Stack<String> stack = new net.mindview.util.Stack<String>(); for(String : "My dog fleas".split(" ")) stack.push(s); while(!stack.empty()) System.out.print(stack.pop() + " "); System.out.println(); java.util.Stack<String> stack2 = new java.util.Stack<String>(); for(String : "My dog fleas".split(" ")) stack2.push(s); while(!stack2.empty()) System.out.print(stack2.pop() + " "); } } /* Output: fleas dog My fleas dog My *///:~ The two Stack classes interface, common Stack interface java.util—probably original, poorly designed java.util.Stack class Java 1.0 co-opted name. Even though java.util.Stack exists, LinkedList produces better Stack net.mindview.util.Stack approach preferable. You also control selection "preferred" Stack implementation using explicit import: import net.mindview.util.Stack; Now reference Stack select net.mindview.util version, select java.util.Stack must use full qualification. Exercise 15: (4) Stacks often used evaluate expressions programming languages. Using net.mindview.util.Stack, evaluate following expression, where’+’ means "push following letter onto stack," and’-’ means "pop top stack print it": "+U+n+c—+e+r+t—+a-+i-+n+t+y—+ -+r+u—+l+e+s—" Set A Set refuses hold one instance object value. If try add one instance equivalent object, Set prevents duplication. The common use Set test membership, easily ask whether object Set. Because this, lookup typically important operation Set, you’ll usually choose HashSet implementation, optimized rapid lookup. Set interface Collection, isn’t extra functionality like two different types List. Instead, Set exactly Collection—it different behavior. (This ideal use inheritance polymorphism: express 292 Thinking Java Bruce Eckel different behavior.) A Set determines membership based "value" object, complex topic learn Containers Depth chapter. Here’s example uses HashSet Integer objects: //: holding/SetOfInteger.java import java.util.*; public class SetOfInteger { public static void main(String[] args) { Random rand = new Random(47); Set<Integer> intset = new HashSet<Integer>(); for(int = 0; < 10000; i++) intset.add(rand.nextInt(30)); System.out.println(intset); } } /* Output: [15, 8, 23, 16, 7, 22, 9, 21, 6, 1, 29, 14, 24, 4, 19, 26, 11, 18, 3, 12, 27, 17, 2, 13, 28, 20, 25, 10, 5, 0] *///:~ Ten thousand random numbers 29 added Set, imagine value many duplications. And yet see one instance appears result. You’ll also notice output discernible order. This HashSet uses hashing speed—hashing covered Containers Depth chapter. The order maintained HashSet different TreeSet LinkedHashSet, since implementation different way storing elements. TreeSet keeps elements sorted red-black tree data structure, whereas HashSet uses hashing function. LinkedHashSet also uses hashing lookup speed, appears maintain elements insertion order using linked list. If want results sorted, one approach use TreeSet instead HashSet: //: holding/SortedSetOfInteger.java import java.util.*; public class SortedSetOfInteger { public static void main(String[] args) { Random rand = new Random(47); SortedSet<Integer> intset = new TreeSet<Integer>(); for(int = 0; < 10000; i++) intset.add(rand.nextInt(30)); System.out.println(intset); } } /* Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29] *///:~ One common operations perform test set membership using contains( ), also operations remind Venn diagrams may taught elementary school: //: holding/SetOperations.java import java.util.*; import static net.mindview.util.Print.*; public class SetOperations { Holding Your Objects 293 public static void main(String[] args) { Set<String> set1 = new HashSet<String>(); Collections.addAll(set1, "A B C D E F G H I J K L".split(" ")); set1.add("M"); print("H: " + set1.contains("H")); print("N: " + set1.contains("N")); Set<String> set2 = new HashSet<String>(); Collections.addAll(set2, "H I J K L".split(" ")); print("set2 set1: " + set1.containsAll(set2)); set1.remove("H"); print("set1: " + set1); print("set2 set1: " + set1.containsAll(set2)); set1.removeAll(set2); print("set2 removed set1: " + set1); Collections.addAll(set1, "X Y Z".split(" ")); print("‘X Y Z’ added set1: " + set1); } } /* Output: H: true N: false set2 set1: true set1: [D, K, C, B, L, G, I, M, A, F, J, E] set2 set1: false set2 removed set1: [D, C, B, G, M, A, F, E] ‘X Y Z’ added set1: [Z, D, C, B, G, M, A, F, Y, X, E] *///:~ The method names self-explanatory, find JDK documentation. Producing list unique elements quite useful. For example, suppose you’d like list words file SetOperations.java, above. Using net.mindview.TextFile utility introduced later book, open read file Set: //: holding/UniqueWords.java import java.util.*; import net.mindview.util.*; public class UniqueWords { public static void main(String[] args) { Set<String> words = new TreeSet<String>( new TextFile("SetOperations.java", "\\W+")); System.out.println(words); } } /* Output: [A, B, C, Collections, D, E, F, G, H, HashSet, I, J, K, L, M, N, Output, Print, Set, SetOperations, String, X, Y, Z, add, addAll, added, args, class, contains, containsAll, false, from, holding, import, in, java, main, mindview, net, new, print, public, remove, removeAll, removed, set1, set2, split, static, to, true, util, void] *///:~ TextFile inherited List<String>. The TextFile constructor opens file breaks words according regular expression "\\W+", means "one letters" (regular expressions introduced Strings chapter). The result handed TreeSet constructor, adds contents List itself. Since TreeSet, result sorted. In case, sorting done lexicographically uppercase lowercase letters separate groups. If you’d like sort alphabetically, 294 Thinking Java Bruce Eckel pass String.CASE_INSENSITIVE_ORDER Comparator (a comparator object establishes order) TreeSet constructor: //: holding/UniqueWordsAlphabetic.java // Producing alphabetic listing. import java.util.*; import net.mindview.util.*; public class UniqueWordsAlphabetic { public static void main(String[] args) { Set<String> words = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); words.addAll( new TextFile("SetOperations.java", "\\W+")); System.out.println(words); } } /* Output: [A, add, addAll, added, args, B, C, class, Collections, contains, containsAll, D, E, F, false, from, G, H, HashSet, holding, I, import, in, J, java, K, L, M, main, mindview, N, net, new, Output, Print, public, remove, removeAll, removed, Set, set1, set2, SetOperations, split, static, String, to, true, util, void, X, Y, Z] *///:~ Comparators explored detail Arrays chapter. Exercise 16: (5) Create Set vowels. Working UniqueWords.Java, count display number vowels input word, also display total number vowels input file. Map The ability map objects objects immensely powerful way solve programming problems. For example, consider program examine randomness Java’s Random class. Ideally, Random would produce perfect distribution numbers, test need generate many random numbers count ones fall various ranges. A Map easily solves problem; case, key number produced Random, value number times number appears: //: holding/Statistics.java // Simple demonstration HashMap. import java.util.*; public class Statistics { public static void main(String[] args) { Random rand = new Random(47); Map<Integer,Integer> = new HashMap<Integer,Integer>(); for(int = 0; < 10000; i++) { // Produce number 0 20: int r = rand.nextInt(20); Integer freq = m.get(r); m.put(r, freq == null ? 1 : freq + 1); } System.out.println(m); } } /* Output: Holding Your Objects 295 {15=497, 4=481, 19=464, 8=468, 11=531, 16=533, 18=478, 3=508, 7=471, 12=521, 17=509, 2=489, 13=506, 9=549, 6=519, 1=502, 14=477, 10=513, 5=503, 0=481} *///:~ In main( ), autoboxing converts randomly generated int Integer reference used HashMap (you can’t use primitives containers). The get( ) method returns null key already container (which means first time number found). Otherwise, get( ) method produces associated Integer value key, incremented (again, autoboxing simplifies expression actually conversions Integer taking place). Here’s example allows use String description look Pet objects. It also shows test Map see contains key value containsKey( ) containsValue( ): //: holding/PetMap.java import typeinfo.pets.*; import java.util.*; import static net.mindview.util.Print.*; public class PetMap { public static void main(String[] args) { Map<String,Pet> petMap = new HashMap<String,Pet>(); petMap.put("My Cat", new Cat("Molly")); petMap.put("My Dog", new Dog("Ginger")); petMap.put("My Hamster", new Hamster("Bosco")); print(petMap); Pet dog = petMap.get("My Dog"); print(dog); print(petMap.containsKey("My Dog")); print(petMap.containsValue(dog)); } } /* Output: {My Cat=Cat Molly, My Hamster=Hamster Bosco, My Dog=Dog Ginger} Dog Ginger true true *///:~ Maps, like arrays Collections, easily expanded multiple dimensions; simply make Map whose values Maps (and values Maps containers, even Maps). Thus, it’s quite easy combine containers quickly produce powerful data structures. For example, suppose keeping track people multiple pets—all need Map<Person, List<Pet>>: //: holding/MapOfList.java package holding; import typeinfo.pets.*; import java.util.*; import static net.mindview.util.Print.*; public class MapOfList { public static Map<Person, List<? extends Pet>> petPeople = new HashMap<Person, List<? extends Pet>>(); static { petPeople.put(new Person("Dawn"), Arrays.asList(new Cymric("Molly"),new Mutt("Spot"))); petPeople.put(new Person("Kate"), Arrays.asList(new Cat("Shackleton"), new Cat("Elsie May"), new Dog("Margrett"))); 296 Thinking Java Bruce Eckel petPeople.put(new Person("Marilyn"), Arrays.asList( new Pug("Louie aka Louis Snorkelstein Dupree"), new Cat("Stanford aka Stinky el Negro"), new Cat("Pinkola"))); petPeople.put(new Person("Luke"), Arrays.asList(new Rat("Fuzzy"), new Rat("Fizzy"))); petPeople.put(new Person("Isaac"), Arrays.asList(new Rat("Freckly"))); } public static void main(String[] args) { print("People: " + petPeople.keySet()); print("Pets: " + petPeople.values()); for(Person person : petPeople.keySet()) { print(person + " has:"); for(Pet pet : petPeople.get(person)) print(" " + pet); } } } /* Output: People: [Person Luke, Person Marilyn, Person Isaac, Person Dawn, Person Kate] Pets: [[Rat Fuzzy, Rat Fizzy], [Pug Louie aka Louis Snorkelstein Dupree, Cat Stanford aka Stinky el Negro, Cat Pinkola], [Rat Freckly], [Cymric Molly, Mutt Spot], [Cat Shackleton, Cat Elsie May, Dog Margrett]] Person Luke has: Rat Fuzzy Rat Fizzy Person Marilyn has: Pug Louie aka Louis Snorkelstein Dupree Cat Stanford aka Stinky el Negro Cat Pinkola Person Isaac has: Rat Freckly Person Dawn has: Cymric Molly Mutt Spot Person Kate has: Cat Shackleton Cat Elsie May Dog Margrett *///:~ A Map return Set keys, Collection values, Set pairs. The keySet( ) method produces Set keys petPeople, used foreach statement iterate Map. Exercise 17: (2) Take Gerbil class Exercise 1 put Map instead, associating Gerbil’s name (e.g. "Fuzzy" "Spot") String (the key) Gerbil (the value) put table. Get Iterator keySet( ) use move Map, looking Gerbil key printing key telling Gerbil hop( ). Exercise 18: (3) Fill HashMap key-value pairs. Print results show ordering hash code. Extract pairs, sort key, place result LinkedHashMap. Show insertion order maintained. Exercise 19: (2) Repeat previous exercise HashSet LinkedHashSet. Holding Your Objects 297 Exercise 20: (3) Modify Exercise 16 keep count occurrence vowel. Exercise 21: (3) Using Map<String,Integer>, follow form UniqueWords.java create program counts occurrence words file. Sort results using Collections.sort( ) second argument String.CASE_INSENSITIVE_ORDER (to produce alphabetic sort), display result. Exercise 22: (5) Modify previous exercise uses class containing String count field store different word, Set objects maintain list words. Exercise 23: (4) Starting Statistics.java, create program runs test repeatedly looks see one number tends appear others results. Exercise 24: (2) Fill LinkedHashMap String keys objects choice. Now extract pairs, sort based keys, reinsert Map. Exercise 25: (3) Create Map<String,ArrayList<Integer>>. Use net.mindview.TextFile open text file read word time (use "\\W+" second argument TextFile constructor). Count words read in, word file, record ArrayList<Integer> word count associated word—this is, effect, location file word found. Exercise 26: (4) Take resulting Map previous exercise re-create order words appeared original file. Queue A queue typically “first-in, first-out" (FIFO) container. That is, put things one end pull other, order put order come out. Queues commonly used way reliably transfer objects one area program another. Queues especially important concurrent programming, see Concurrency chapter, safely transfer objects one task another. LinkedList methods support queue behavior implements Queue interface, LinkedList used Queue implementation. By upcasting LinkedList Queue, example uses Queuespecific methods Queue interface: //: holding/QueueDemo.java // Upcasting Queue LinkedList. import java.util.*; public class QueueDemo { public static void printQ(Queue queue) { while(queue.peek() != null) System.out.print(queue.remove() + " "); System.out.println(); } public static void main(String[] args) { Queue<Integer> queue = new LinkedList<Integer>(); Random rand = new Random(47); for(int = 0; < 10; i++) 298 Thinking Java Bruce Eckel queue.offer(rand.nextInt(i + 10)); printQ(queue); Queue<Character> qc = new LinkedList<Character>(); for(char c : "Brontosaurus".toCharArray()) qc.offer(c); printQ(qc); } } /* Output: 8 1 1 1 5 14 3 1 0 1 B r n u r u *///:~ offer( ) one Queue-specific methods; inserts element tail queue can, returns false. Both peek( ) element( ) return head queue without removing it, peek( ) returns null queue empty element( ) throws NoSuchElementException. Both poll( ) remove( ) remove return head queue, poll( ) returns null queue empty, remove( ) throws NoSuchElementException. Autoboxing automatically converts int result nextInt( ) Integer object required queue, char c Character object required qc. The Queue interface narrows access methods LinkedList appropriate methods available, thus less tempted use LinkedList methods (here, could actually cast queue back LinkedList, least discouraged so). Notice Queue-specific methods provide complete standalone functionality. That is, usable Queue without methods Collection, inherited. Exercise 27: (2) Write class called Command contains String method operation( ) displays String. Write second class method fills Queue Command objects returns it. Pass filled Queue method third class consumes objects Queue calls operation( ) methods. PriorityQueue First-in, first-out (FIFO) describes typical queuing discipline. A queuing discipline decides, given group elements queue, one goes next. First-in, firstout says next element one waiting longest. Apriority queue says element goes next one greatest need (the highest priority). For example, airport, customer might pulled queue plane leave. If build messaging system, messages important others, dealt sooner, regardless arrive. The PriorityQueue added Java SE5 provide automatic implementation behavior. When offer( ) object onto PriorityQueue, object sorted queue. 5 The default sorting uses natural order objects queue, modify order providing Comparator. The PriorityQueue ensures call peek( ), poll( ) remove( ), element get one highest priority. 5 This actually depends implementation. Priority queue algorithms typically sort insertion (maintaining heap), may also perform selection important element upon removal. The choice algorithm could important object priority change waiting queue. Holding Your Objects 299 It’s trivial make PriorityQueue works built-in types like Integer, String Character. In following example, first set values identical random values previous example, see emerge differently PriorityQueue: //: holding/PriorityQueueDemo.java import java.util.*; public class PriorityQueueDemo { public static void main(String[] args) { PriorityQueue<Integer> priorityQueue = new PriorityQueue<Integer>(); Random rand = new Random(47); for(int = 0; < 10; i++) priorityQueue.offer(rand.nextInt(i + 10)); QueueDemo.printQ(priorityQueue); List<Integer> ints = Arrays.asList(25, 22, 20, 18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25); priorityQueue = new PriorityQueue<Integer>(ints); QueueDemo.printQ(priorityQueue); priorityQueue = new PriorityQueue<Integer>( ints.size(), Collections.reverseOrder()); priorityQueue.addAll(ints); QueueDemo.printQ(priorityQueue); String fact = "EDUCATION SHOULD ESCHEW OBFUSCATION"; List<String> strings = Arrays.asList(fact.split("")); PriorityQueue<String> stringPQ = new PriorityQueue<String>(strings); QueueDemo.printQ(stringPQ); stringPQ = new PriorityQueue<String>( strings.size(), Collections.reverseOrder()); stringPQ.addAll(strings); QueueDemo.printQ(stringPQ); Set<Character> charSet = new HashSet<Character>(); for(char c : fact.toCharArray()) charSet.add(c); // Autoboxing PriorityQueue<Character> characterPQ = new PriorityQueue<Character>(charSet); QueueDemo.printQ(characterPQ); } } /* Output: 0 1 1 1 1 1 3 5 8 14 1 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25 25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1 A A B C C C D D E E E F H H I I L N N O O O O S S S T T U U U W W U U U T T S S S O O O O N N L I I H H F E E E D D C C C B A A A B C D E F H I L N O S T U W *///:~ You see duplicates allowed, lowest values highest priority (in case String, spaces also count values higher priority letters). To show change ordering providing Comparator object, third constructor call PriorityQueue<Integer> second call PriorityQueue<String> use reverse-order Comparator produced Collections.reverseOrder( ) (added Java SE5). The last section adds HashSet eliminate duplicate Characters, make things little interesting. 300 Thinking Java Bruce Eckel Integer, String Character work PriorityQueue classes already natural ordering built in. If want use class PriorityQueue, must include additional functionality produce natural ordering, provide Comparator. There’s sophisticated example demonstrates Containers Depth chapter. Exercise 28: (2) Fill PriorityQueue (using offer( )) Double values created using java.util.Random, remove elements using poll( ) display them. Exercise 29: (2) Create simple class inherits Object contains members, show cannot successfully add multiple elements class PriorityQueue. This issue fully explained Containers Depth chapter. Collection vs. Iterator Collection root interface describes common sequence containers. It might thought "incidental interface," one appeared commonality interfaces. In addition, java.utiLAbstractCollection class provides default implementation Collection, create new subtype AbstractCollection without unnecessary code duplication. One argument interface allows create generic code. By writing interface rather implementation, code applied types objects. 6 So I write method takes Collection, method applied type implements Collection—and allows new class choose implement Collection order used method. It’s interesting note, however, Standard C++ Library common base class containers—all commonality containers achieved iterators. In Java, might seem sensible follow C++ approach, express commonality containers using iterator rather Collection. However, two approaches bound together, since implementing Collection also means providing iterator( ) method: //: holding/InterfaceVsIterator.java import typeinfo.pets.*; import java.util.*; public class InterfaceVsIterator { public static void display(Iterator<Pet> it) { while(it.hasNext()) { Pet p = it.next(); System.out.print(p.id() + ":" + p + " "); } System.out.println(); } public static void display(Collection<Pet> pets) { for(Pet p : pets) System.out.print(p.id() + ":" + p + " "); System.out.println(); } public static void main(String[] args) { List<Pet> petList = Pets.arrayList(8); Set<Pet> petSet = new HashSet<Pet>(petList); Map<String,Pet> petMap = new LinkedHashMap<String,Pet>(); 6 Some people advocate automatic creation interface every possible combination methods class— sometimes every single class. I believe interface meaning mechanical duplication method combinations, I tend wait I see value added interface creating one. Holding Your Objects 301 String[] names = ("Ralph, Eric, Robin, Lacey, " + "Britney, Sam, Spot, Fluffy").split(", "); for(int = 0; < names.length; i++) petMap.put(names[i], petList.get(i)); display(petList); display(petSet); display(petList.iterator()); display(petSet.iterator()); System.out.println(petMap); System.out.println(petMap.keySet()); display(petMap.values()); display(petMap.values().iterator()); } } /* Output: 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat {Ralph=Rat, Eric=Manx, Robin=Cymric, Lacey=Mutt, Britney=Pug, Sam=Cymric, Spot=Pug, Fluffy=Manx} [Ralph, Eric, Robin, Lacey, Britney, Sam, Spot, Fluffy] 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx *///:~ Both versions display( ) work Map objects well subtypes Collection, Collection interface Iterator decouple display( ) methods knowing particular implementation underlying container. In case two approaches come even. In fact, Collection pulls ahead bit Iterable, implementation display(Collection) foreach construct used, makes code little cleaner. The use Iterator becomes compelling implement foreign class, one Collection, would difficult annoying make implement Collection interface. For example, create Collection implementation inheriting class holds Pet objects, must implement Collection methods, even don’t need use within display( ) method. Although easily accomplished inheriting AbstractCollection, you’re forced implement iterator( ) anyway, along size( ), order provide methods implemented AbstractCollection, used methods AbstractCollection: //: holding/CollectionSequence.java import typeinfo.pets.*; import java.util.*; public class CollectionSequence extends AbstractCollection<Pet> { private Pet[] pets = Pets.createArray(8); public int size() { return pets.length; } public Iterator<Pet> iterator() { return new Iterator<Pet>() { private int index = 0; public boolean hasNext() { return index < pets.length; } public Pet next() { return pets[index++]; } public void remove() { // Not implemented throw new UnsupportedOperationException(); } 302 Thinking Java Bruce Eckel }; } public static void main(String[] args) { CollectionSequence c = new CollectionSequence(); InterfaceVsIterator.display(c); InterfaceVsIterator.display(c.iterator()); } } /* Output: 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx *///:~ The remove( ) method "optional operation," learn Containers Depth chapter. Here, it’s necessary implement it, call it, throw exception. From example, see implement Collection, also implement iterator( ), implementing iterator( ) alone requires slightly less effort inheriting AbstractCoUection. However, class already inherits another class, cannot also inherit AbstractCollection. In case, implement Collection you’d implement methods interface. In case would much easier inherit add ability create iterator: //: holding/NonCollectionSequence.java import typeinfo.pets.*; import java.util.*; class PetSequence { protected Pet[] pets = Pets.createArray(8); } public class NonCollectionSequence extends PetSequence { public Iterator<Pet> iterator() { return new Iterator<Pet>() { private int index = 0; public boolean hasNext() { return index < pets.length; } public Pet next() { return pets[index++]; } public void remove() { // Not implemented throw new UnsupportedOperationException(); } }; } public static void main(String[] args) { NonCollectionSequence nc = new NonCollectionSequence(); InterfaceVsIterator.display(nc.iterator()); } } /* Output: 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx *///:~ Producing Iterator least-coupled way connecting sequence method consumes sequence, puts far fewer constraints sequence class implementing Collection. Exercise 30: (5) Modify CollectionSequence.java inherit AbstractCollection, instead implements Collection. Holding Your Objects 303 Foreach iterators So far, foreach syntax primarily used arrays, also works Collection object. You’ve actually seen examples using ArrayList, here’s general proof: //: holding/ForEachCollections.java // All collections work foreach. import java.util.*; public class ForEachCollections { public static void main(String[] args) { Collection<String> cs = new LinkedList<String>(); Collections.addAll(cs, "Take long way home".split(" ")); for(String : cs) System.out.print("‘" + + "‘ "); } } /* Output: ‘Take’ ‘the’ ‘long’ ‘way’ ‘home’ *///:~ Since cs Collection, code shows working foreach characteristic Collection objects. The reason works Java SE5 introduced new interface called Iterable contains iterator( ) method produce Iterator, Iterable interface foreach uses move sequence. So create class implements Iterable, use foreach statement: //: holding/IterableClass.java // Anything Iterable works foreach. import java.util.*; public class IterableClass implements Iterable<String> { protected String[] words = ("And " + "we know Earth banana-shaped.").split(" "); public Iterator<String> iterator() { return new Iterator<String>() { private int index = 0; public boolean hasNext() { return index < words.length; } public String next() { return words[index++]; } public void remove() { // Not implemented throw new UnsupportedOperationException(); } }; } public static void main(String[] args) { for(String : new IterableClass()) System.out.print(s + " "); } } /* Output: And know Earth banana-shaped. *///:~ 304 Thinking Java Bruce Eckel The iterator( ) method returns instance anonymous inner implementation Iterator<String> delivers word array. In main( ), see IterableClass indeed work foreach statement. In Java SE5, number classes made Iterable, primarily Collection classes (but Maps). For example, code displays operating system environment variables: //: holding/EnvironmentVariables.java import java.util.*; public class EnvironmentVariables { public static void main(String[] args) { for(Map.Entry entry: System.getenv().entrySet()) { System.out.println(entry.getKey() + ": " + entry.getValue()); } } } /* (Execute see output) *///:~ System.getenv( ) 7 returns Map, entrySet( ) produces Set Map.Entry elements, Set Iterable used foreach loop. A foreach statement works array anything Iterable, doesn’t mean array automatically Iterable, autoboxing takes place: //: holding/ArrayIsNotIterable.java import java.util.*; public class ArrayIsNotIterable { static <T> void test(Iterable<T> ib) { for(T : ib) System.out.print(t + " "); } public static void main(String[] args) { test(Arrays.asList(1, 2, 3)); String[] strings = { "A", "B", "C" }; // An array works foreach, it’s Iterable: //! test(strings); // You must explicitly convert Iterable: test(Arrays.asList(strings)); } } /* Output: 1 2 3 A B C *///:~ Trying pass array Iterable argument fails. There automatic conversion Iterable; must hand. Exercise 31: (3) Modify polymorphism/shape/RandomShapeGenerator.java make Iterable. You’ll need add constructor takes number elements want iterator produce stopping. Verify works. 7 This available Java SE5, thought tightly coupled operating system, thus violate "write once, run anywhere." The fact included suggests Java designers becoming pragmatic. Holding Your Objects 305 The Adapter Method idiom What existing class Iterable, you’d like add one new ways use class foreach statement? For example, suppose you’d like choose whether iterate list words either forward reverse direction. If simply inherit class override iterator( ) method, replace existing method don’t get choice. One solution I call Adapter Method idiom. The "Adapter" part comes design patterns, must provide particular interface satisfy foreach statement. When one interface need another one, writing adapter solves problem. Here, I want add ability produce reverse iterator default forward iterator, I can’t override. Instead, I add method produces Iterable object used foreach statement. As see here, allows us provide multiple ways use foreach: //: holding/AdapterMethodIdiom.java // The "Adapter Method" idiom allows use foreach // additional kinds Iterables. import java.util.*; class ReversibleArrayList<T> extends ArrayList<T> { public ReversibleArrayList(Collection<T> c) { super(c); } public Iterable<T> reversed() { return new Iterable<T>() { public Iterator<T> iterator() { return new Iterator<T>() { int current = size() - 1; public boolean hasNext() { return current > -1; } public T next() { return get(current--); } public void remove() { // Not implemented throw new UnsupportedOperationException(); } }; } }; } } public class AdapterMethodIdiom { public static void main(String[] args) { ReversibleArrayList<String> ral = new ReversibleArrayList<String>( Arrays.asList("To be".split(" "))); // Grabs ordinary iterator via iterator(): for(String : ral) System.out.print(s + " "); System.out.println(); // Hand Iterable choice for(String : ral.reversed()) System.out.print(s + " "); } } /* Output: To To *///:~ If simply put ral object foreach statement, get (default) forward iterator. But call reversed( ) object, produces different behavior. 306 Thinking Java Bruce Eckel Using approach, I add two adapter methods IterableClass.java example: //: holding/MultiIterableClass.java // Adding several Adapter Methods. import java.util.*; public class MultiIterableClass extends IterableClass { public Iterable<String> reversed() { return new Iterable<String>() { public Iterator<String> iterator() { return new Iterator<String>() { int current = words.length - 1; public boolean hasNext() { return current > -1; } public String next() { return words[current--]; } public void remove() { // Not implemented throw new UnsupportedOperationException(); } }; } }; } public Iterable<String> randomized() { return new Iterable<String>() { public Iterator<String> iterator() { List<String> shuffled = new ArrayList<String>(Arrays.asList(words)); Collections.shuffle(shuffled, new Random(47)); return shuffled.iterator(); } }; } public static void main(String[] args) { MultiIterableClass mic = new MultiIterableClass(); for(String : mic.reversed()) System.out.print(s + " "); System.out.println(); for(String : mic.randomized()) System.out.print(s + " "); System.out.println(); for(String : mic) System.out.print(s + " "); } } /* Output: banana-shaped. Earth know And banana-shaped. Earth And know And know Earth banana-shaped. *///:~ Notice second method, random( ), doesn’t create Iterator simply returns one shuffled List. You see output Collections.shuffle( ) method doesn’t affect original array, shuffles references shuffled. This true randomized( ) method wraps ArrayList around result Arrays.asList( ). If List produced Arrays.asList( ) shuffled directly, modify underlying array, see here: //: holding/ModifyingArraysAsList.java import java.util.*; public class ModifyingArraysAsList { public static void main(String[] args) { Holding Your Objects 307 Random rand = new Random(47); Integer[] ia = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; List<Integer> list1 = new ArrayList<Integer>(Arrays.asList(ia)); System.out.println("Before shuffling: " + list1); Collections.shuffle(list1, rand); System.out.println("After shuffling: " + list1); System.out.println("array: " + Arrays.toString(ia)); List<Integer> list2 = Arrays.asList(ia); System.out.println("Before shuffling: " + list2); Collections.shuffle(list2, rand); System.out.println("After shuffling: " + list2); System.out.println("array: " + Arrays.toString(ia)); } } /* Output: Before shuffling: [1, 2, 3, 4, 5, 6, 7, 8, 9, After shuffling: [4, 6, 3, 1, 8, 7, 2, 5, 10, array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Before shuffling: [1, 2, 3, 4, 5, 6, 7, 8, 9, After shuffling: [9, 1, 6, 3, 7, 2, 5, 10, 4, array: [9, 1, 6, 3, 7, 2, 5, 10, 4, 8] *///:~ 10] 9] 10] 8] In first case, output Arrays.asList( ) handed ArrayList( ) constructor, creates ArrayList references elements ia. Shuffling references doesn’t modify array. However, use result Arrays.asList(ia) directly, shuffling modifies order ia. It’s important aware Arrays.asList( ) produces List object uses underlying array physical implementation. If anything List modifies it, don’t want original array modified, make copy another container. Exercise 32: (2) Following example MultilterableClass, add reversed( ) randomized( ) methods NonCollectionSequence.java, well making NonCollectionSequence implement Iterable, show approaches work foreach statements. Summary Java provides number ways hold objects: 1. An array associates numerical indexes objects. It holds objects known type don’t cast result you’re looking object. It multidimensional, hold primitives. However, size cannot changed create it. 2. A Collection holds single elements, Map holds associated pairs. With Java generics, specify type object held containers, can’t put wrong type container don’t cast elements fetch container. Both Collections Maps automatically resize add elements. A container won’t hold primitives, autoboxing takes care translating primitives back forth wrapper types held container. 3. Like array, List also associates numerical indexes objects— thus, arrays Lists ordered containers. 308 Thinking Java Bruce Eckel 4. Use ArrayList you’re lot random accesses, LinkedList lot insertions removals middle list. 5. The behavior Queues stacks provided via LinkedList. 6. A Map way associate integral values, objects objects. HashMaps designed rapid access, whereas TreeMap keeps keys sorted order, thus fast HashMap. A LinkedHashMap keeps elements insertion order, provides rapid access hashing. 7. A Set accepts one type object. HashSets provide maximally fast lookups, whereas TreeSets keep elements sorted order. LinkedHashSets keep elements insertion order. 8. There’s need use legacy classes Vector, Hashtable, Stack new code. It’s helpful look simplified diagram Java containers (without abstract classes legacy components). This includes interfaces classes encounter regular basis. Simple Container Taxonomy You’ll see really four basic container components—Map, List, Set, Queue—and two three implementations one (the java.util.concurrent implementations Queue included diagram). The containers use often heavy black lines around them. The dotted boxes represent interfaces, solid boxes regular (concrete) classes. The dotted lines hollow arrows indicate particular class implementing interface. The solid arrows show class produce objects class arrow pointing to. For example, Collection produce Iterator, List produce ListIterator (as well ordinary Iterator, since List inherited Collection). Here’s example shows difference methods various classes. The actual code Generics chapter; I’m calling produce output. The output also shows interfaces implemented class interface: //: holding/ContainerMethods.java import net.mindview.util.*; Holding Your Objects 309 public class ContainerMethods { public static void main(String[] args) { ContainerMethodDifferences.main(args); } } /* Output: (Sample) Collection: [add, addAll, clear, contains, containsAll, equals, hashCode, isEmpty, iterator, remove, removeAll, retainAll, size, toArray] Interfaces Collection: [Iterable] Set extends Collection, adds: [] Interfaces Set: [Collection] HashSet extends Set, adds: [] Interfaces HashSet: [Set, Cloneable, Serializable] LinkedHashSet extends HashSet, adds: [] Interfaces LinkedHashSet: [Set, Cloneable, Serializable] TreeSet extends Set, adds: [pollLast, navigableHeadSet, descendingIterator, lower, headSet, ceiling, pollFirst, subSet, navigableTailSet, comparator, first, floor, last, navigableSubSet, higher, tailSet] Interfaces TreeSet: [NavigableSet, Cloneable, Serializable] List extends Collection, adds: [listIterator, indexOf, get, subList, set, lastIndexOf] Interfaces List: [Collection] ArrayList extends List, adds: [ensureCapacity, trimToSize] Interfaces ArrayList: [List, RandomAccess, Cloneable, Serializable] LinkedList extends List, adds: [pollLast, offer, descendingIterator, addFirst, peekLast, removeFirst, peekFirst, removeLast, getLast, pollFirst, pop, poll, addLast, removeFirstOccurrence, getFirst, element, peek, offerLast, push, offerFirst, removeLastOccurrence] Interfaces LinkedList: [List, Deque, Cloneable, Serializable] Queue extends Collection, adds: [offer, element, peek, poll] Interfaces Queue: [Collection] PriorityQueue extends Queue, adds: [comparator] Interfaces PriorityQueue: [Serializable] Map: [clear, containsKey, containsValue, entrySet, equals, get, hashCode, isEmpty, keySet, put, putAll, remove, size, values] HashMap extends Map, adds: [] Interfaces HashMap: [Map, Cloneable, Serializable] LinkedHashMap extends HashMap, adds: [] Interfaces LinkedHashMap: [Map] SortedMap extends Map, adds: [subMap, comparator, firstKey, lastKey, headMap, tailMap] Interfaces SortedMap: [Map] TreeMap extends Map, adds: [descendingEntrySet, subMap, pollLastEntry, lastKey, floorEntry, lastEntry, lowerKey, navigableHeadMap, navigableTailMap, descendingKeySet, tailMap, ceilingEntry, higherKey, pollFirstEntry, comparator, firstKey, floorKey, higherEntry, firstEntry, navigableSubMap, headMap, lowerEntry, ceilingKey] Interfaces TreeMap: [NavigableMap, Cloneable, Serializable] *///:~ You see Sets except TreeSet exactly interface Collection. List Collection differ significantly, although List requires methods Collection. On hand, methods Queue interface stand alone; Collection methods required create functioning Queue implementation. Finally, intersection Map Collection fact Map produce Collections using entrySet( ) values( ) methods. Notice tagging interface java.util.RandomAccess, attached ArrayList LinkedList. This provides information algorithms might want dynamically change behavior depending use particular List. 310 Thinking Java Bruce Eckel It’s true organization somewhat odd, object-oriented hierarchies go. However, learn containers java.util (in particular, Containers Depth chapter), you’ll see issues slightly odd inheritance structure. Container libraries always difficult design problems—solving problems involves satisfying set forces often oppose other. So prepared compromises there. Despite issues, Java containers fundamental tools use day-to-day basis make programs simpler, powerful, effective. It might take little get comfortable aspects library, I think you’ll find rapidly acquiring using classes library. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Holding Your Objects 311 Error Handling Exceptions The basic philosophy Java "badly formed code run." The ideal time catch error compile time, even try run program. However, errors detected compile time. The rest problems must handled run time formality allows originator error pass appropriate information recipient know handle difficulty properly. Improved error recovery one powerful ways increase robustness code. Error recovery fundamental concern every program write, it’s especially important Java, one primary goals create program components others use. To create robust system, component must robust. By providing consistent error-reporting model using exceptions, Java allows components reliably communicate problems client code. The goals exception handling Java simplify creation large, reliable programs using less code currently possible, confidence application doesn’t unhandled error. Exceptions terribly difficult learn, one features provide immediate significant benefits project. Because exception handling official way Java reports errors, enforced Java compiler, many examples written book without learning exception handling. This chapter introduces code need write properly handle exceptions, shows generate exceptions one methods gets trouble. Concepts C earlier languages often multiple error-handling schemes, generally established convention part programming language. Typically, returned special value set flag, recipient supposed look value flag determine something amiss. However, years passed, discovered programmers use library tend think invincible—as "Yes, errors might happen others, code." So, surprisingly, wouldn’t check error conditions (and sometimes error conditions silly check 1 ). If thorough enough check error every time called method, code could turn unreadable nightmare. Because programmers could still coax systems languages, resistant admitting truth: approach handling errors major limitation creating large, robust, maintainable programs. The solution take casual nature error handling enforce formality. This actually long history, implementations exception handling go back operating systems 1960s, even BASIC’S "on error goto." But C++ exception 1 The C programmer look return value printf( ) example this. handling based Ada, Java’s based primarily C++ (although looks like Object Pascal). The word "exception" meant sense "I take exception that." At point problem occurs, might know it, know can’t continue merrily; must stop, somebody, somewhere, must figure do. But don’t enough information current context fix problem. So hand problem higher context someone qualified make proper decision. The rather significant benefit exceptions tend reduce complexity error-handling code. Without exceptions, must check particular error deal multiple places program. With exceptions, longer need check errors point method call, since exception guarantee someone catches it. You need handle problem one place, so-called exception handler. This saves code, separates code describes want normal execution code executed things go awry. In general, reading, writing, debugging code becomes much clearer exceptions using old way error handling. Basic exceptions An exceptional condition problem prevents continuation current method scope. It’s important distinguish exceptional condition normal problem, enough information current context somehow cope difficulty. With exceptional condition, cannot continue processing don’t information necessary deal problem current context. All jump current context relegate problem higher context. This happens throw exception. Division simple example. If you’re divide zero, it’s worth checking condition. But mean denominator zero? Maybe know, context problem you’re trying solve particular method, deal zero denominator. But it’s unexpected value, can’t deal must throw exception rather continuing along execution path. When throw exception, several things happen. First, exception object created way Java object created: heap, new. Then current path execution (the one couldn’t continue) stopped reference exception object ejected current context. At point exception-handling mechanism takes begins look appropriate place continue executing program. This appropriate place exception handler, whose job recover problem program either try another tack continue. As simple example throwing exception, consider object reference called t. It’s possible might passed reference hasn’t initialized, might want check trying call method using object reference. You send information error larger context creating object representing information "throwing" current context. This called throwing exception. Here’s looks like: if(t == null) throw new NullPointerException(); This throws exception, allows you—in current context—to abdicate responsibility thinking issue further. It’s magically handled somewhere else. Precisely shown shortly. 314 Thinking Java Bruce Eckel Exceptions allow think everything transaction, exceptions guard transactions: "...the fundamental premise transactions needed exception handling distributed computations. Transactions computer equivalent contract law. If anything goes wrong, we’ll blow away whole computation." 2 You also think exceptions built-in undo system, (with care) various recovery points program. If part program fails, exception "undo" back known stable point program. One important aspects exceptions something bad happens, don’t allow program continue along ordinary path. This real problem languages like C C++; especially C, way force program stop going path problem occurred, possible ignore problems long time get completely inappropriate state. Exceptions allow (if nothing else) force program stop tell went wrong, (ideally) force program deal problem return stable state. Exception arguments As object Java, always create exceptions heap using new, allocates storage calls constructor. There two constructors standard exceptions: The first default constructor, second takes string argument place pertinent information exception: throw new NullPointerException("t = null"); This string later extracted using various methods, you’ll see. The keyword throw produces number interesting results. After creating exception object new, give resulting reference throw. The object is, effect, "returned" method, even though object type isn’t normally method designed return. A simplistic way think exception handling different kind return mechanism, although get trouble take analogy far. You also exit ordinary scopes throwing exception. In either case, exception object returned, method scope exits. Any similarity ordinary return method ends here, return someplace completely different return normal method call. (You end appropriate exception handler might far away—many levels call stack— exception thrown.) In addition, throw type Throwable, exception root class. Typically, you’ll throw different class exception different type error. The information error represented inside exception object implicitly name exception class, someone bigger context figure exception. (Often, information type exception, nothing meaningful stored within exception object.) Catching exception To see exception caught, must first understand concept guarded region. This section code might produce exceptions followed code handle exceptions. 2 Jim Gray, Turing Award winner team’s contributions transactions, interview www.acmqueue.org. Error Handling Exceptions 315 The try block If you’re inside method throw exception (or another method call within method throws exception), method exit process throwing. If don’t want throw exit method, set special block within method capture exception. This called try block "try" various method calls there. The try block ordinary scope preceded keyword try: try { // Code might generate exceptions } If checking errors carefully programming language didn’t support exception handling, you’d surround every method call setup error-testing code, even call method several times. With exception handling, put everything try block capture exceptions one place. This means code much easier write read goal code confused error checking. Exception handlers Of course, thrown exception must end someplace. This "place" exception handler, there’s one every exception type want catch. Exception handlers immediately follow try block denoted keyword catch: try { // Code might generate exceptions } catch(Type1 id1)|{ // Handle exceptions Type1 } catch(Type2 id2) { // Handle exceptions Type2 } catch(Type3 id3) { // Handle exceptions Type3 } // etc... Each catch clause (exception handler) like little method takes one one argument particular type. The identifier (id1, id2, on) used inside handler, like method argument. Sometimes never use identifier type exception gives enough information deal exception, identifier must still there. The handlers must appear directly try block. If exception thrown, exception-handling mechanism goes hunting first handler argument matches type exception. Then enters catch clause, exception considered handled. The search handlers stops catch clause finished. Only matching catch clause executes; it’s like switch statement need break case prevent remaining ones executing. Note within try block, number different method calls might generate exception, need one handler. 316 Thinking Java Bruce Eckel Termination vs. resumption There two basic models exception-handling theory. Java supportst termination, 3 assume error critical there’s way get back exception occurred. Whoever threw exception decided way salvage situation, don’t want come back. The alternative called resumption. It means exception handler expected something rectify situation, faulting method retried, presuming success second time. If want resumption, means still hope continue execution exception handled. If want resumption-like behavior Java, don’t throw exception encounter error. Instead, call method fixes problem. Alternatively, place try block inside loop keeps reentering try block result satisfactory. Historically, programmers using operating systems supported resumptive exception handling eventually ended using termination-like code skipping resumption. So although resumption sounds attractive first, isn’t quite useful practice. The dominant reason probably coupling results: A resumptive handler would need aware exception thrown, contain non-generic code specific throwing location. This makes code difficult write maintain, especially large systems exception generated many points. Creating exceptions You’re stuck using existing Java exceptions. The Java exception hierarchy can’t foresee errors might want report, create denote special problem library might encounter. To create exception class, must inherit existing exception class, preferably one close meaning new exception (although often possible). The trivial way create new type exception let compiler create default constructor you, requires almost code all: //: exceptions/InheritingExceptions.java // Creating exceptions. class SimpleException extends Exception {} public class InheritingExceptions { public void f() throws SimpleException { System.out.println("Throw SimpleException f()"); throw new SimpleException(); } public static void main(String[] args) { InheritingExceptions sed = new InheritingExceptions(); try { sed.f(); } catch(SimpleException e) { System.out.println("Caught it!"); } } } /* Output: Throw SimpleException f() 3 As languages, including C++, C#, Python, D, etc. Error Handling Exceptions 317 Caught it! *///:~ The compiler creates default constructor, automatically (and invisibly) calls baseclass default constructor. Of course, case don’t get SimpleException(String) constructor, practice isn’t used much. As you’ll see, important thing exception class name, time exception like one shown satisfactory. Here, result printed console, automatically captured tested book’s output-display system. However, may want send error output standard error stream writing System.err. This usually better place send error information System.out, may redirected. If send output System.err, redirected along System.out user likely notice it. You also create exception class constructor String argument: //: exceptions/FullConstructors.java class MyException extends Exception { public MyException() {} public MyException(String msg) { super(msg); } } public class FullConstructors { public static void f() throws MyException { System.out.println("Throwing MyException f()"); throw new MyException(); } public static void g() throws MyException { System.out.println("Throwing MyException g()"); throw new MyException("Originated g()"); } public static void main(String[] args) { try { f(); } catch(MyException e) { e.printStackTrace(System.out); } try { g(); } catch(MyException e) { e.printStackTrace(System.out); } } } /* Output: Throwing MyException f() MyException FullConstructors.f(FullConstructors.java:11) FullConstructors.main(FullConstructors.java:19) Throwing MyException g() MyException: Originated g() FullConstructors.g(FullConstructors.java:15) FullConstructors.main(FullConstructors.java:24) *///:~ The added code small: two constructors define way MyException created. In second constructor, base-class constructor String argument explicitly invoked using super keyword. In handlers, one Throwable (from Exception inherited) methods called: printStackTrace( ). As see output, produces information 318 Thinking Java Bruce Eckel sequence methods called get point exception happened. Here, information sent System.out, automatically captured displayed output. However, call default version: e.printStackTrace(); information goes standard error stream. Exercise 1: (2) Create class main( ) throws object class Exception inside try block. Give constructor Exception String argument. Catch exception inside catch clause print String argument. Add finally clause print message prove there. Exercise 2: (1) Define object reference initialize null. Try call method reference. Now wrap code try-catch clause catch exception. Exercise 3: (1) Write code generate catch ArraylndexOutOfBoundsException. Exercise 4: (2) Create exception class using extends keyword. Write constructor class takes String argument stores inside object String reference. Write method displays stored String. Create try-catch clause exercise new exception. Exercise 5: (3) Create resumption-like behavior using loop repeats exception longer thrown. Exceptions logging You may also want log output using java.util.logging facility. Although full details logging introduced supplement http://MindView.net/Books/BetterJava, basic logging straightforward enough used here. //: exceptions/LoggingExceptions.java // An exception reports Logger. import java.util.logging.*; import java.io.*; class LoggingException extends Exception { private static Logger logger = Logger.getLogger("LoggingException"); public LoggingException() { StringWriter trace = new StringWriter(); printStackTrace(new PrintWriter(trace)); logger.severe(trace.toString()); } } public class LoggingExceptions { public static void main(String[] args) { try { throw new LoggingException(); } catch(LoggingException e) { System.err.println("Caught " + e); } try { throw new LoggingException(); Error Handling Exceptions 319 } catch(LoggingException e) { System.err.println("Caught " + e); } } } /* Output: (85% match) Aug 30, 2005 4:02:31 PM LoggingException <init> SEVERE: LoggingException LoggingExceptions.main(LoggingExceptions.java:19) Caught LoggingException Aug 30, 2005 4:02:31 PM LoggingException <init> SEVERE: LoggingException LoggingExceptions.main(LoggingExceptions.java:24) Caught LoggingException *///:~ The static Logger.getLogger( ) method creates Logger object associated String argument (usually name package class errors about) sends output System.err. The easiest way write Logger call method associated level logging message; here, severe( ) used. To produce String logging message, we’d like stack trace exception thrown, printStackTrace( ) doesn’t produce String default. To get String, need use overloaded printStackTrace( ) takes java.io.PrintWriter object argument (all fully explained I/O chapter). If hand Print Writer constructor java.io.StringWriter object, output extracted String calling toString( ). Although approach used LoggingException convenient builds logging infrastructure exception itself, thus works automatically without client programmer intervention, it’s common catching logging someone else’s exception, must generate log message exception handler: //: exceptions/LoggingExceptions2.java // Logging caught exceptions. import java.util.logging.*; import java.io.*; public class LoggingExceptions2 { private static Logger logger = Logger.getLogger("LoggingExceptions2"); static void logException(Exception e) { StringWriter trace = new StringWriter(); e.printStackTrace(new PrintWriter(trace)); logger.severe(trace.toString()); } public static void main(String[] args) { try { throw new NullPointerException(); } catch(NullPointerException e) { logException(e); } } } /* Output: (90% match) Aug 30, 2005 4:07:54 PM LoggingExceptions2 logException SEVERE: java.lang.NullPointerException LoggingExceptions2.main(LoggingExceptions2.java:16) *///:~ The process creating exceptions taken further. You add extra constructors members: 320 Thinking Java Bruce Eckel //: exceptions/ExtraFeatures.java // Further embellishment exception classes. import static net.mindview.util.Print.*; class MyException2 extends Exception { private int x; public MyException2() {} public MyException2(String msg) { super(msg); } public MyException2(String msg, int x) { super(msg); this.x = x; } public int val() { return x; } public String getMessage() { return "Detail Message: "+ x + " "+ super.getMessage(); } } public class ExtraFeatures { public static void f() throws MyException2 { print("Throwing MyException2 f()"); throw new MyException2(); } public static void g() throws MyException2 { print("Throwing MyException2 g()"); throw new MyException2("Originated g()"); } public static void h() throws MyException2 { print("Throwing MyException2 h()"); throw new MyException2("Originated h()", 47); } public static void main(String[] args) { try { f(); } catch(MyException2 e) { e.printStackTrace(System.out); } try { g(); } catch(MyException2 e) { e.printStackTrace(System.out); } try { h(); } catch(MyException2 e) { e.printStackTrace(System.out); System.out.println("e.val() = " + e.val()); } } } /* Output: Throwing MyException2 f() MyException2: Detail Message: 0 null ExtraFeatures.f(ExtraFeatures.java:22) ExtraFeatures.main(ExtraFeatures.java:34) Throwing MyException2 g() MyException2: Detail Message: 0 Originated g() ExtraFeatures.g(ExtraFeatures.java:26) ExtraFeatures.main(ExtraFeatures.java:39) Throwing MyException2 h() MyException2: Detail Message: 47 Originated h() ExtraFeatures.h(ExtraFeatures.java:30) ExtraFeatures.main(ExtraFeatures.java:44) e.val() = 47 Error Handling Exceptions 321 *///:~ A field x added, along method reads value additional constructor sets it. In addition, Throwable.getMessage( ) overridden produce interesting detail message. getMessage( ) something like toString( ) exception classes. Since exception another kind object, continue process embellishing power exception classes. Keep mind, however, dressing-up might lost client programmers using packages, since might simply look exception thrown nothing more. (That’s way Java library exceptions used.) Exercise 6: (1) Create two exception classes, performs logging automatically. Demonstrate work. Exercise 7: (1) Modify Exercise 3 catch clause logs results. The exception specification In Java, you’re encouraged inform client programmer, calls method, exceptions might thrown method. This civilized, caller know exactly code write catch potential exceptions. Of course, source code available, client programmer could hunt look throw statements, library might come sources. To prevent problem, Java provides syntax (and forces use syntax) allow politely tell client programmer exceptions method throws, client programmer handle them. This exception specification it’s part method declaration, appearing argument list. The exception specification uses additional keyword, throws, followed list potential exception types. So method definition might look like this: void f() throws TooBig, TooSmall, DivZero { //... However, say void f() { //... means exceptions thrown method {except exceptions inherited RuntimeException, thrown anywhere without exception specifications—these described later). You can’t lie exception specification. If code within method causes exceptions, method doesn’t handle them, compiler detect tell must either handle exception indicate exception specification may thrown method. By enforcing exception specifications top bottom, Java guarantees certain level exception correctness ensured compile time. There one place lie: You claim throw exception really don’t. The compiler takes word it, forces users method treat really throw exception. This beneficial effect placeholder exception, actually start throwing exception later without requiring changes existing code. It’s also important creating abstract base classes interfaces whose derived classes implementations may need throw exceptions. 322 Thinking Java Bruce Eckel Exceptions checked enforced compile time called checked exceptions. Exercise 8: (1) Write class method throws exception type created Exercise 4. Try compiling without exception specification see compiler says. Add appropriate exception specification. Try class exception inside try-catch clause. Catching exception It possible create handler catches type exception. You catching base-class exception type Exception (there types base exceptions, Exception base that’s pertinent virtually programming activities): catch(Exception e) { System.out.println("Caught exception"); } This catch exception, use you’ll want put end list handlers avoid preempting exception handlers might otherwise follow it. Since Exception class base exception classes important programmer, don’t get much specific information exception, call methods come base type Throwable: String getMessage( ) String getLocalizedMessage( ) Gets detail message, message adjusted particular locale. String toString( ) Returns short description Throwable, including detail message one. void printStackTrace( ) voidprintStackTrace(PrintStream) voidprintStackTrace(java.io.PrintWriter) Prints Throwable Throwable’s call stack trace. The call stack shows sequence method calls brought point exception thrown. The first version prints standard error, second third print stream choice (in I/O chapter, you’ll understand two types streams). Throwable fillInStackTrace( ) Records information within Throwable object current state stack frames. Useful application rethrowing error exception (more shortly). In addition, get methods Throwable’s base type Object (everybody’s base type). The one might come handy exceptions getClass( ), returns object representing class object. You turn query Class object name getName( ), includes package information, getSimpleName( ), produces class name alone. Here’s example shows use basic Exception methods: //: exceptions/ExceptionMethods.java // Demonstrating Exception Methods. import static net.mindview.util.Print.*; Error Handling Exceptions 323 public class ExceptionMethods { public static void main(String[] args) { try { throw new Exception("My Exception"); } catch(Exception e) { print("Caught Exception"); print("getMessage():" + e.getMessage()); print("getLocalizedMessage():" + e.getLocalizedMessage()); print("toString():" + e); print("printStackTrace():"); e.printStackTrace(System.out); } } } /* Output: Caught Exception getMessage():My Exception getLocalizedMessage():My Exception toString():java.lang.Exception: My Exception printStackTrace(): java.lang.Exception: My Exception ExceptionMethods.main(ExceptionMethods.java:8) *///:~ You see methods provide successively information—each effectively superset previous one. Exercise 9: (2) Create three new types exceptions. Write class method throws three. In main( ), call method use single catch clause catch three types exceptions. The stack trace The information provided printStackTrace( ) also accessed directly using getStackTrace( ). This method returns array stack trace elements, representing one stack frame. Element zero top stack, last method invocation sequence (the point Throwable created thrown). The last element array bottom stack first method invocation sequence. This program provides simple demonstration: //: exceptions/WhoCalled.java // Programmatic access stack trace information. public class WhoCalled { static void f() { // Generate exception fill stack trace try { throw new Exception(); } catch (Exception e) { for(StackTraceElement ste : e.getStackTrace()) System.out.println(ste.getMethodName()); } } static void g() { f(); } static void h() { g(); } public static void main(String[] args) { f(); System.out.println("--------------------------------"); g(); System.out.println("--------------------------------"); 324 Thinking Java Bruce Eckel h(); } } /* Output: f main -------------------------------f g main -------------------------------f g h main *///:~ Here, print method name, also print entire StackTraceElement, contains additional information. Rethrowing exception Sometimes you’ll want rethrow exception caught, particularly use Exception catch exception. Since already reference current exception, simply rethrow reference: catch(Exception e) { System.out.println("An exception thrown"); throw e; } Rethrowing exception causes go exception handlers nexthigher context. Any catch clauses try block still ignored. In addition, everything exception object preserved, handler higher context catches specific exception type extract information object. If simply rethrow current exception, information print exception printStackTrace( ) pertain exception’s origin, place rethrow it. If want install new stack trace information, calling fillInStackTrace( ), returns Throwable object creates stuffing current stack information old exception object. Here’s looks like: //: exceptions/Rethrowing.java // Demonstrating fillInStackTrace() public class Rethrowing { public static void f() throws Exception { System.out.println("originating exception f()"); throw new Exception("thrown f()"); } public static void g() throws Exception { try { f(); } catch(Exception e) { System.out.println("Inside g(),e.printStackTrace()"); e.printStackTrace(System.out); throw e; } } public static void h() throws Exception { Error Handling Exceptions 325 try { f(); } catch(Exception e) { System.out.println("Inside h(),e.printStackTrace()"); e.printStackTrace(System.out); throw (Exception)e.fillInStackTrace(); } } public static void main(String[] args) { try { g(); } catch(Exception e) { System.out.println("main: printStackTrace()"); e.printStackTrace(System.out); } try { h(); } catch(Exception e) { System.out.println("main: printStackTrace()"); e.printStackTrace(System.out); } } } /* Output: originating exception f() Inside g(),e.printStackTrace() java.lang.Exception: thrown f() Rethrowing.f(Rethrowing.java:7) Rethrowing.g(Rethrowing.java:11) Rethrowing.main(Rethrowing.java:29) main: printStackTrace() java.lang.Exception: thrown f() Rethrowing.f(Rethrowing.java:7) Rethrowing.g(Rethrowing.java:11) Rethrowing.main(Rethrowing.java:29) originating exception f() Inside h(),e.printStackTrace() java.lang.Exception: thrown f() Rethrowing.f(Rethrowing.java:7) Rethrowing.h(Rethrowing.java:20) Rethrowing.main(Rethrowing.java:35) main: printStackTrace() java.lang.Exception: thrown f() Rethrowing.h(Rethrowing.java:24) Rethrowing.main(Rethrowing.java:35) *///:~ The line fillInStackTrace( ) called becomes new point origin exception. It’s also possible rethrow different exception one caught. If this, get similar effect use fillInStackTrace( )— information original site exception lost, you’re left information pertaining new throw: //: exceptions/RethrowNew.java // Rethrow different object one caught. class OneException extends Exception { public OneException(String s) { super(s); } } class TwoException extends Exception { 326 Thinking Java Bruce Eckel } public TwoException(String s) { super(s); } public class RethrowNew { public static void f() throws OneException { System.out.println("originating exception f()"); throw new OneException("thrown f()"); } public static void main(String[] args) { try { try { f(); } catch(OneException e) { System.out.println( "Caught inner try, e.printStackTrace()"); e.printStackTrace(System.out); throw new TwoException("from inner try"); } } catch(TwoException e) { System.out.println( "Caught outer try, e.printStackTrace()"); e.printStackTrace(System.out); } } } /* Output: originating exception f() Caught inner try, e.printStackTrace() OneException: thrown f() RethrowNew.f(RethrowNew.java:15) RethrowNew.main(RethrowNew.java:20) Caught outer try, e.printStackTrace() TwoException: inner try RethrowNew.main(RethrowNew.java:25) *///:~ The final exception knows came inner try block f( ). You never worry cleaning previous exception, exceptions matter. They’re heap-based objects created new, garbage collector automatically cleans up. Exception chaining Often want catch one exception throw another, still keep information originating exception—this called exception chaining. Prior JDK 1.4, programmers write code preserve original exception information, Throwable subclasses option take cause object constructor. The cause intended originating exception, passing maintain stack trace back origin, even though you’re creating throwing new exception. It’s interesting note Throwable subclasses provide cause argument constructor three fundamental exception classes Error (used JVM report system errors), Exception, RuntimeException. If want chain exception types, initCause( ) method rather constructor. Here’s example allows dynamically add fields DynamicFields object run time: //: exceptions/DynamicFields.java Error Handling Exceptions 327 // A Class dynamically adds fields itself. // Demonstrates exception chaining. import static net.mindview.util.Print.*; class DynamicFieldsException extends Exception {} public class DynamicFields { private Object[][] fields; public DynamicFields(int initialSize) { fields = new Object[initialSize][2]; for(int = 0; < initialSize; i++) fields[i] = new Object[] { null, null }; } public String toString() { StringBuilder result = new StringBuilder(); for(Object[] obj : fields) { result.append(obj[0]); result.append(": "); result.append(obj[1]); result.append("\n"); } return result.toString(); } private int hasField(String id) { for(int = 0; < fields.length; i++) if(id.equals(fields[i][0])) return i; return -1; } private int getFieldNumber(String id) throws NoSuchFieldException { int fieldNum = hasField(id); if(fieldNum == -1) throw new NoSuchFieldException(); return fieldNum; } private int makeField(String id) { for(int = 0; < fields.length; i++) if(fields[i][0] == null) { fields[i][0] = id; return i; } // No empty fields. Add one: Object[][] tmp = new Object[fields.length + 1][2]; for(int = 0; < fields.length; i++) tmp[i] = fields[i]; for(int = fields.length; < tmp.length; i++) tmp[i] = new Object[] { null, null }; fields = tmp; // Recursive call expanded fields: return makeField(id); } public Object getField(String id) throws NoSuchFieldException { return fields[getFieldNumber(id)][1]; } public Object setField(String id, Object value) throws DynamicFieldsException { if(value == null) { // Most exceptions don’t "cause" constructor. // In cases must use initCause(), // available Throwable subclasses. DynamicFieldsException dfe = 328 Thinking Java Bruce Eckel new DynamicFieldsException(); dfe.initCause(new NullPointerException()); throw dfe; } int fieldNumber = hasField(id); if(fieldNumber == -1) fieldNumber = makeField(id); Object result = null; try { result = getField(id); // Get old value } catch(NoSuchFieldException e) { // Use constructor takes "cause": throw new RuntimeException(e); } fields[fieldNumber][1] = value; return result; } public static void main(String[] args) { DynamicFields df = new DynamicFields(3); print(df); try { df.setField("d", "A value d"); df.setField("number", 47); df.setField("number2", 48); print(df); df.setField("d", "A new value d"); df.setField("number3", 11); print("df: " + df); print("df.getField(\"d\") : " + df.getField("d")); Object field = df.setField("d", null); // Exception } catch(NoSuchFieldException e) { e.printStackTrace(System.out); } catch(DynamicFieldsException e) { e.printStackTrace(System.out); } } } /* Output: null: null null: null null: null d: A value number: 47 number2: 48 df: d: A new value number: 47 number2: 48 number3: 11 df.getField("d") : A new value DynamicFieldsException DynamicFields.setField(DynamicFields.java:64) DynamicFields.main(DynamicFields.java:94) Caused by: java.lang.NullPointerException DynamicFields.setField(DynamicFields.java:66) ... 1 *///:~ Each DynamicFields object contains array Object-Object pairs. The first object field identifier (a String), second field value, type except unwrapped primitive. When create object, make educated guess many fields need. When call setField( ), either finds existing field Error Handling Exceptions 329 name creates new one, puts value. If runs space, adds new space creating array length one longer copying old elements in. If try put null value, throws DynamicFieldsException creating one using initCause( ) insert NullPointerException cause. As return value, setField( ) also fetches old value field location using getField( ), could throw NoSuchFieldException. If client programmer calls getField( ), responsible handling NoSuchFieldException, exception thrown inside setField( ), it’s programming error, NoSuchFieldException converted RuntimeException using constructor takes cause argument. You’ll notice toString( ) uses StringBuilder create result. You’ll learn StringBuilder Strings chapter, general you’ll want use whenever you’re writing toString( ) involves looping, case here. Exercise 10: (2) Create class two methods, f( ) g( ). In g( ), throw exception new type define. In f( ), call g( ), catch exception and, catch clause, throw different exception (of second type define). Test code main( ). Exercise 11: (1) Repeat previous exercise, inside catch clause, wrap g( )’s exception RuntimeException. Standard Java exceptions The Java class Throwable describes anything thrown exception. There two general types Throwable objects ("types = "inherited from"). Error represents compile-time system errors don’t worry catching (except special cases). Exception basic type thrown standard Java library class methods methods runtime accidents. So Java programmer’s base type interest usually Exception. The best way get overview exceptions browse JDK documentation. It’s worth get feel various exceptions, you’ll soon see isn’t anything special one exception next except name. Also, number exceptions Java keeps expanding; basically, it’s pointless print book. Any new library get third-party vendor probably exceptions well. The important thing understand concept exceptions. The basic idea name exception represents problem occurred, exception name intended relatively selfexplanatory. The exceptions defined java.lang; created support libraries util, net, io, see full class names inherited from. For example, I/O exceptions inherited java.io.IOException. Special case: RuntimeException The first example chapter if(t == null) throw new NullPointerException(); 330 Thinking Java Bruce Eckel It bit horrifying think must check null every reference passed method (since can’t know caller passed valid reference). Fortunately, don’t—this part standard runtime checking Java performs you, call made null reference, Java automatically throw NullPointerException. So bit code always superfluous, although may want perform checks order guard appearance NullPointerException. There’s whole group exception types category. They’re always thrown automatically Java don’t need include exception specifications. Conveniently enough, they’re grouped together putting single base class called RuntimeException, perfect example inheritance: It establishes family types characteristics behaviors common. Also, never need write exception specification saying method might throw RuntimeException (or type inherited RuntimeException), unchecked exceptions. Because indicate bugs, don’t usually catch RuntimeException—it’s dealt automatically. If forced check RuntimeExceptions, code could get messy. Even though don’t typically catch RuntimeExceptions, packages might choose throw RuntimeExceptions. What happens don’t catch exceptions? Since compiler doesn’t enforce exception specifications these, it’s quite plausible RuntimeException could percolate way main( ) method without caught. To see happens case, try following example: //: exceptions/NeverCaught.java // Ignoring RuntimeExceptions. // {ThrowsException} public class NeverCaught { static void f() { throw new RuntimeException("From f()"); } static void g() { f(); } public static void main(String[] args) { g(); } } ///:~ You already see RuntimeException (or anything inherited it) special case, since compiler doesn’t require exception specification types. The output reported System.err: Exception thread "main" Java.lang.RuntimeException: From f() NeverCaught.f(NeverCaught.Java:7) NeverCaught.g(NeverCaught.Java:10) NeverCaught.main(NeverCaught.Java:13) So answer is: If RuntimeException gets way main( ) without caught, printStackTrace( ) called exception program exits. Keep mind exceptions type RuntimeException (and subclasses) ignored coding, since compiler carefully enforces handling checked exceptions. The reasoning RuntimeException represents programming error, is: Error Handling Exceptions 331 1. An error cannot anticipate. For example, null reference outside control. 2. An error you, programmer, checked code (such ArraylndexOutOfBoundsException paid attention size array). An exception happens point #1 often becomes issue point #2. You see tremendous benefit exceptions case, since help debugging process. It’s interesting notice cannot classify Java exception handling single-purpose tool. Yes, designed handle pesky runtime errors occur forces outside code’s control, it’s also essential certain types programming bugs compiler cannot detect. Exercise 12: (3) Modify innerclasses/Sequence.java throws appropriate exception try put many elements. Performing cleanup finally There’s often piece code want execute whether exception thrown within try block. This usually pertains operation memory recovery (since that’s taken care garbage collector). To achieve effect, use finally clause 4 end exception handlers. The full picture exceptionhandling section thus: try { // The guarded region: Dangerous activities // might throw A, B, C } catch(A a1) { // Handler situation A } catch(B b1) { // Handler situation B } catch(C c1) { // Handler situation C } finally { // Activities happen every time } To demonstrate finally clause always runs, try program: //: exceptions/FinallyWorks.java // The finally clause always executed. class ThreeException extends Exception {} public class FinallyWorks { static int count = 0; public static void main(String[] args) { while(true) { try { 4 C++ exception handling finally clause relies destructors accomplish sort cleanup. 332 Thinking Java Bruce Eckel // Post-increment zero first time: if(count++ == 0) throw new ThreeException(); System.out.println("No exception"); } catch(ThreeException e) { System.out.println("ThreeException"); } finally { System.out.println("In finally clause"); if(count == 2) break; // "while" } } } } /* Output: ThreeException In finally clause No exception In finally clause *///:~ From output, see finally clause executed whether exception thrown. This program also gives hint deal fact exceptions Java allow resume back exception thrown, discussed earlier. If place try block loop, establish condition must met continue program. You also add static counter device allow loop try several different approaches giving up. This way build greater level robustness programs. What’s finally for? In language without garbage collection without automatic destructor calls, 5 finally important allows programmer guarantee release memory regardless happens try block. But Java garbage collection, releasing memory virtually never problem. Also, destructors call. So need use finally Java? The finally clause necessary need set something memory back original state. This kind cleanup like open file network connection, something you’ve drawn screen, even switch outside world, modeled following example: //: exceptions/Switch.java import static net.mindview.util.Print.*; public class Switch { private boolean state = false; public boolean read() { return state; } public void on() { state = true; print(this); } public void off() { state = false; print(this); } public String toString() { return state ? "on" : "off"; } } ///:~ //: exceptions/OnOffException1.java public class OnOffException1 extends Exception {} ///:~ 5 A destructor function that’s always called object becomes unused. You always know exactly destructor gets called. C++ automatic destructor calls, C# (which much like Java) way automatic destruction occur. Error Handling Exceptions 333 //: exceptions/OnOffException2.java public class OnOffException2 extends Exception {} ///:~ //: exceptions/OnOffSwitch.java // Why use finally? public class OnOffSwitch { private static Switch sw = new Switch(); public static void f() throws OnOffException1,OnOffException2 {} public static void main(String[] args) { try { sw.on(); // Code throw exceptions... f(); sw.off(); } catch(OnOffException1 e) { System.out.println("OnOffException1"); sw.off(); } catch(OnOffException2 e) { System.out.println("OnOffException2"); sw.off(); } } } /* Output: *///:~ The goal make sure switch main( ) completed, sw.off( ) placed end try block end exception handler. But it’s possible exception might thrown isn’t caught here, sw.off( ) would missed. However, finally place cleanup code try block one place: //: exceptions/WithFinally.java // Finally Guarantees cleanup. public class WithFinally { static Switch sw = new Switch(); public static void main(String[] args) { try { sw.on(); // Code throw exceptions... OnOffSwitch.f(); } catch(OnOffException1 e) { System.out.println("OnOffException1"); } catch(OnOffException2 e) { System.out.println("OnOffException2"); } finally { sw.off(); } } } /* Output: *///:~ Here sw.off( ) moved one place, it’s guaranteed run matter happens. 334 Thinking Java Bruce Eckel Even cases exception caught current set catch clauses, finally executed exception-handling mechanism continues search handler next higher level: //: exceptions/AlwaysFinally.java // Finally always executed. import static net.mindview.util.Print.*; class FourException extends Exception {} public class AlwaysFinally { public static void main(String[] args) { print("Entering first try block"); try { print("Entering second try block"); try { throw new FourException(); } finally { print("finally 2nd try block"); } } catch(FourException e) { System.out.println( "Caught FourException 1st try block"); } finally { System.out.println("finally 1st try block"); } } } /* Output: Entering first try block Entering second try block finally 2nd try block Caught FourException 1st try block finally 1st try block *///:~ The finally statement also executed situations break continue statements involved. Note that, along labeled break labeled continue, finally eliminates need goto statement Java. Exercise 13: (2) Modify Exercise 9 adding finally clause. Verify finally clause executed, even NullPointerException thrown. Exercise 14: (2) Show OnOffSwitch.java fail throwing RuntimeException inside try block. Exercise 15: (2) Show WithFinally.java doesn’t fail throwing RuntimeException inside try block. Using finally return Because finally clause always executed, it’s possible return multiple points within method still guarantee important cleanup performed: //: exceptions/MultipleReturns.java import static net.mindview.util.Print.*; public class MultipleReturns { public static void f(int i) { print("Initialization requires cleanup"); Error Handling Exceptions 335 try { print("Point 1"); if(i == 1) return; print("Point 2"); if(i == 2) return; print("Point 3"); if(i == 3) return; print("End"); return; } finally { print("Performing cleanup"); } } public static void main(String[] args) { for(int = 1; <= 4; i++) f(i); } } /* Output: Initialization requires cleanup Point 1 Performing cleanup Initialization requires cleanup Point 1 Point 2 Performing cleanup Initialization requires cleanup Point 1 Point 2 Point 3 Performing cleanup Initialization requires cleanup Point 1 Point 2 Point 3 End Performing cleanup *///:~ You see output doesn’t matter return inside finally class. Exercise 16: (2) Modify reusing/CADSystem.java demonstrate returning middle try-finally still perform proper cleanup. Exercise 17: (3) Modify polymorphism/Frog.java uses try-finally guarantee proper cleanup, show works even return middle try-finally. Pitfall: lost exception Unfortunately, there’s flaw Java’s exception implementation. Although exceptions indication crisis program never ignored, it’s possible exception simply lost. This happens particular configuration using finally clause: //: exceptions/LostMessage.java // How exception lost. class VeryImportantException extends Exception { public String toString() { 336 Thinking Java Bruce Eckel } return "A important exception!"; } class HoHumException extends Exception { public String toString() { return "A trivial exception"; } } public class LostMessage { void f() throws VeryImportantException { throw new VeryImportantException(); } void dispose() throws HoHumException { throw new HoHumException(); } public static void main(String[] args) { try { LostMessage lm = new LostMessage(); try { lm.f(); } finally { lm.dispose(); } } catch(Exception e) { System.out.println(e); } } } /* Output: A trivial exception *///:~ You see output there’s evidence VerylmportantException, simply replaced HoHumException finally clause. This rather serious pitfall, since means exception completely lost, far subtle difficult-to-detect fashion preceding example. In contrast, C++ treats situation second exception thrown first one handled dire programming error. Perhaps future version Java repair problem (on hand, typically wrap method throws exception, dispose( ) example above, inside try-catch clause). An even simpler way lose exception return inside finally clause: //: exceptions/ExceptionSilencer.java public class ExceptionSilencer { public static void main(String[] args) { try { throw new RuntimeException(); } finally { // Using ‘return’ inside finally block // silence thrown exception. return; } } } ///:~ If run program you’ll see produces output, even though exception thrown. Error Handling Exceptions 337 Exercise 18: (3) Add second level exception loss LostMessage.java HoHumException replaced third exception. Exercise 19: (2) Repair problem LostMessage.java guarding call finally clause. Exception restrictions When override method, throw exceptions specified base-class version method. This useful restriction, since means code works base class automatically work object derived base class (a fundamental OOP concept, course), including exceptions. This example demonstrates kinds restrictions imposed (at compile time) exceptions: //: exceptions/StormyInning.java // Overridden methods may throw exceptions // specified base-class versions, exceptions // derived base-class exceptions. class BaseballException extends Exception {} class Foul extends BaseballException {} class Strike extends BaseballException {} abstract class Inning { public Inning() throws BaseballException {} public void event() throws BaseballException { // Doesn’t actually throw anything } public abstract void atBat() throws Strike, Foul; public void walk() {} // Throws checked exceptions } class StormException extends Exception {} class RainedOut extends StormException {} class PopFoul extends Foul {} interface Storm { public void event() throws RainedOut; public void rainHard() throws RainedOut; } public class StormyInning extends Inning implements Storm { // OK add new exceptions constructors, // must deal base constructor exceptions: public StormyInning() throws RainedOut, BaseballException {} public StormyInning(String s) throws Foul, BaseballException {} // Regular methods must conform base class: //! void walk() throws PopFoul {} //Compile error // Interface CANNOT add exceptions existing // methods base class: //! public void event() throws RainedOut {} // If method doesn’t already exist // base class, exception OK: public void rainHard() throws RainedOut {} // You choose throw exceptions, 338 Thinking Java Bruce Eckel // even base version does: public void event() {} // Overridden methods throw inherited exceptions: public void atBat() throws PopFoul {} public static void main(String[] args) { try { StormyInning si = new StormyInning(); si.atBat(); } catch(PopFoul e) { System.out.println("Pop foul"); } catch(RainedOut e) { System.out.println("Rained out"); } catch(BaseballException e) { System.out.println("Generic baseball exception"); } // Strike thrown derived version. try { // What happens upcast? Inning = new StormyInning(); i.atBat(); // You must catch exceptions // base-class version method: } catch(Strike e) { System.out.println("Strike"); } catch(Foul e) { System.out.println("Foul"); } catch(RainedOut e) { System.out.println("Rained out"); } catch(BaseballException e) { System.out.println("Generic baseball exception"); } } } ///:~ In Inning, see constructor event( ) method say throw exception, never do. This legal allows force user catch exceptions might added overridden versions event( ). The idea holds abstract methods, seen atBat( ). The interface Storm interesting contains one method (event( )) defined Inning, one method isn’t. Both methods throw new type exception, RainedOut. When Stormylnning extends Inning implements Storm, you’ll see event( ) method Storm cannot change exception interface event( ) Inning. Again, makes sense otherwise you’d never know catching correct thing working base class. Of course, method described interface base class, rainHard( ), there’s problem throws exceptions. The restriction exceptions apply constructors. You see Stormylnning constructor throw anything wants, regardless base-class constructor throws. However, since base-class constructor must always called one way another (here, default constructor called automatically), derived-class constructor must declare base-class constructor exceptions exception specification. A derived-class constructor cannot catch exceptions thrown base-class constructor. The reason StormyInning.walk( ) compile throws exception, Inning.walk( ) not. If allowed, could write code called Inning.walk( ) didn’t handle exceptions, substituted object class derived Inning, exceptions would thrown Error Handling Exceptions 339 code would break. By forcing derived-class methods conform exception specifications base-class methods, substitutability objects maintained. The overridden event( ) method shows derived-class version method may choose throw exceptions, even base-class version does. Again, fine since doesn’t break code written assuming base-class version throws exceptions. Similar logic applies atBat( ), throws PopFoul, exception derived Foul thrown base-class version atBat( ). This way, write code works Inning calls atBat( ), must catch Foul exception. Since PopFoul derived Foul, exception handler also catch PopFoul. The last point interest main( ). Here, see you’re dealing exactly StormyInning object, compiler forces catch exceptions specific class, upcast base type, compiler (correctly) forces catch exceptions base type. All constraints produce much robust exceptionhandling code. 6 Although exception specifications enforced compiler inheritance, exception specifications part type method, comprises method name argument types. Therefore, cannot overload methods based exception specifications. In addition, exception specification exists baseclass version method doesn’t mean must exist derived-class version method. This quite different inheritance rules, method base class must also exist derived class. Put another way, "exception specification interface" particular method may narrow inheritance overriding, may widen—this precisely opposite rule class interface inheritance. Exercise 20: (3) Modify StormyInning.java adding UmpireArgument exception type methods throw exception. Test modified hierarchy. Constructors It’s important always ask, "If exception occurs, everything properly cleaned up?" Most time you’re fairly safe, constructors there’s problem. The constructor puts object safe starting state, might perform operation— opening filethat doesn’t get cleaned user finished object calls special cleanup method. If throw exception inside constructor, cleanup behaviors might occur properly. This means must especially diligent write constructor. You might think finally solution. But it’s quite simple, finally performs cleanup code every time. If constructor fails partway execution, might successfully created part object cleaned finally clause. In following example, class called InputFile created opens file allows read one line time. It uses classes FileReader BufferedReader Java standard I/O library discussed I/O chapter. These classes simple enough probably won’t trouble understanding basic use: //: exceptions/InputFile.java // Paying attention exceptions constructors. import java.io.*; 6 ISO C++ added similar constraints require derived-method exceptions as, derived from, exceptions thrown base-class method. This one case C++ actually able check exception specifications compile time. 340 Thinking Java Bruce Eckel public class InputFile { private BufferedReader in; public InputFile(String fname) throws Exception { try { = new BufferedReader(new FileReader(fname)); // Other code might throw exceptions } catch(FileNotFoundException e) { System.out.println("Could open " + fname); // Wasn’t open, don’t close throw e; } catch(Exception e) { // All exceptions must close try { in.close(); } catch(IOException e2) { System.out.println("in.close() unsuccessful"); } throw e; // Rethrow } finally { // Don’t close here!!! } } public String getLine() { String s; try { = in.readLine(); } catch(IOException e) { throw new RuntimeException("readLine() failed"); } return s; } public void dispose() { try { in.close(); System.out.println("dispose() successful"); } catch(IOException e2) { throw new RuntimeException("in.close() failed"); } } } ///:~ The constructor InputFile takes String argument, name file want open. Inside try block, creates FileReader using file name. A FileReader isn’t particularly useful use create BufferedReader. One benefits InputFile combines two actions. If FileReader constructor unsuccessful, throws FileNotFoundException. This one case don’t want close file, wasn’t successfully opened. Any catch clauses must close file opened time catch clauses entered. (Of course, gets trickier one method throw FileNotFoundException. In case, you’ll usually break things several try blocks.) The close( ) method might throw exception tried caught even though it’s within block another catch clause—it’s another pair curly braces Java compiler. After performing local operations, exception rethrown, appropriate constructor failed, don’t want calling method assume object properly created valid. In example, finally clause definitely place close( ) file, since would close every time constructor completed. We want file open useful lifetime InputFile object. Error Handling Exceptions 341 The getLine( ) method returns String containing next line file. It calls readLine( ), throw exception, exception caught getLine( ) doesn’t throw exceptions. One design issues exceptions whether handle exception completely level, handle partially pass exception (or different one) on, whether simply pass on. Passing on, appropriate, certainly simplify coding. In situation, getLine( ) method converts exception RuntimeException indicate programming error. The dispose( ) method must called user InputFile object longer needed. This release system resources (such file handles) used BufferedReader and/or FileReader objects. You don’t want you’re finished InputFile object. You might think putting functionality finalize( ) method, mentioned Initialization & Cleanup chapter, can’t always sure finalize( ) called (even sure called, don’t know when). This one downsides Java: All cleanupother memory cleanup—doesn’t happen automatically, must inform client programmers responsible. The safest way use class might throw exception construction requires cleanup use nested try blocks: //: exceptions/Cleanup.java // Guaranteeing proper cleanup resource. public class Cleanup { public static void main(String[] args) { try { InputFile = new InputFile("Cleanup.java"); try { String s; int = 1; while((s = in.getLine()) != null) ; // Perform line-by-line processing here... } catch(Exception e) { System.out.println("Caught Exception main"); e.printStackTrace(System.out); } finally { in.dispose(); } } catch(Exception e) { System.out.println("InputFile construction failed"); } } } /* Output: dispose() successful *///:~ Look carefully logic here: The construction InputFile object effectively try block. If construction fails, outer catch clause entered dispose( ) called. However, construction succeeds want make sure object cleaned up, immediately construction create new try block. The finally performs cleanup associated inner try block; way, finally clause executed construction fails, always executed construction succeeds. This general cleanup idiom still used constructor throws exceptions. The basic rule is: Right create object requires cleanup, begin try-finally: //: exceptions/CleanupIdiom.java // Each disposable object must followed try-finally 342 Thinking Java Bruce Eckel class NeedsCleanup { // Construction can’t fail private static long counter = 1; private final long id = counter++; public void dispose() { System.out.println("NeedsCleanup " + id + " disposed"); } } class ConstructionException extends Exception {} class NeedsCleanup2 extends NeedsCleanup { // Construction fail: public NeedsCleanup2() throws ConstructionException {} } public class CleanupIdiom { public static void main(String[] args) { // Section 1: NeedsCleanup nc1 = new NeedsCleanup(); try { // ... } finally { nc1.dispose(); } // Section 2: // If construction cannot fail group objects: NeedsCleanup nc2 = new NeedsCleanup(); NeedsCleanup nc3 = new NeedsCleanup(); try { // ... } finally { nc3.dispose(); // Reverse order construction nc2.dispose(); } // Section 3: // If construction fail must guard one: try { NeedsCleanup2 nc4 = new NeedsCleanup2(); try { NeedsCleanup2 nc5 = new NeedsCleanup2(); try { // ... } finally { nc5.dispose(); } } catch(ConstructionException e) { // nc5 constructor System.out.println(e); } finally { nc4.dispose(); } } catch(ConstructionException e) { // nc4 constructor System.out.println(e); } } } /* Output: NeedsCleanup NeedsCleanup NeedsCleanup NeedsCleanup NeedsCleanup *///:~ 1 3 2 5 4 disposed disposed disposed disposed disposed Error Handling Exceptions 343 In main( ), section 1 fairly straightforward: You follow disposable object tryfinally. If object construction cannot fail, catch necessary. In section 2, see objects constructors cannot fail grouped together construction cleanup. Section 3 shows deal objects whose constructors fail need cleanup. To properly handle situation, things get messy, must surround construction try-catch, object construction must followed try-finally guarantee cleanup. The messiness exception handling case strong argument creating constructors cannot fail, although always possible. Note dispose( ) throw exception might need additional try blocks. Basically, must think carefully possibilities guard one. Exercise 21: (2) Demonstrate derived-class constructor cannot catch exceptions thrown base-class constructor. Exercise 22: (2) Create class called FailingConstructor constructor might fail partway construction process throw exception. In main( ), write code properly guards failure. Exercise 23: (4) Add class dispose( ) method previous exercise. Modify FailingConstructor constructor creates one disposable objects member object, constructor might throw exception, creates second disposable member object. Write code properly guard failure, main( ) verify possible failure situations covered. Exercise 24: (3) Add dispose( ) method FailingConstructor class write code properly use class. Exception matching When exception thrown, exception-handling system looks "nearest" handlers order written. When finds match, exception considered handled, searching occurs. Matching exception doesn’t require perfect match exception handler. A derived-class object match handler base class, shown example: //: exceptions/Human.java // Catching exception hierarchies. class Annoyance extends Exception {} class Sneeze extends Annoyance {} public class Human { public static void main(String[] args) { // Catch exact type: try { throw new Sneeze(); } catch(Sneeze s) { System.out.println("Caught Sneeze"); } catch(Annoyance a) { System.out.println("Caught Annoyance"); 344 Thinking Java Bruce Eckel } // Catch base type: try { throw new Sneeze(); } catch(Annoyance a) { System.out.println("Caught Annoyance"); } } } /* Output: Caught Sneeze Caught Annoyance *///:~ The Sneeze exception caught first catch clause matches, first one, course. However, remove first catch clause, leaving catch clause Annoyance, code still works it’s catching base class Sneeze. Put another way, catch(Annoyance a) catch Annoyance class derived it. This useful decide add derived exceptions method, client programmer’s code need changing long client catches baseclass exceptions. If try "mask" derived-class exceptions putting base-class catch clause first, like this: try { throw new Sneeze(); } catch(Annoyance a) { // ... } catch(Sneeze s) { // ... } compiler give error message, since sees Sneeze catch clause never reached. Exercise 25: (2) Create three-level hierarchy exceptions. Now create base-class A method throws exception base hierarchy. Inherit B A override method throws exception level two hierarchy. Repeat inheriting class C B. In main( ), create C upcast A, call method. Alternative approaches An exception-handling system trapdoor allows program abandon execution normal sequence statements. The trapdoor used "exceptional condition" occurs, normal execution longer possible desirable. Exceptions represent conditions current method unable handle. The reason exception-handling systems developed approach dealing possible error condition produced function call onerous, programmers simply weren’t it. As result, ignoring errors. It’s worth observing issue programmer convenience handling errors prime motivation exceptions first place. One important guidelines exception handling "Don’t catch exception unless know it." In fact, one important goals exception handling move error-handling code away point errors occur. This allows focus want accomplish one section code, you’re going deal problems distinct separate section code. As result, mainline code cluttered error-handling logic, it’s much easier understand maintain. Error Handling Exceptions 345 Exception handling also tends reduce amount error-handling code, allowing one handler deal many error sites. Checked exceptions complicate scenario bit, force add catch clauses places may ready handle error. This results "harmful swallowed" problem: try { // ... something useful } catch(ObligatoryException e) {} // Gulp! Programmers (myself included, 1st edition book) would simplest thing, "swallow" exception—often unintentionally, it, compiler satisfied, unless remember revisit correct code, exception lost. The exception happens, vanishes completely swallowed. Because compiler forces write code right away handle exception, seems like easiest solution even though it’s probably worst thing do. Horrified upon realizing I done this, 2nd edition I "fixed" problem printing stack trace inside handler (as still seen— appropriately—in number examples chapter). While useful trace behavior exceptions, still indicates don’t really know exception point code. In section you’ll learn issues complications arising checked exceptions, options dealing them. This topic seems simple. But complicated, also issue volatility. There people staunchly rooted either side fence feel correct answer (theirs) blatantly obvious. I believe reason one positions distinct benefit seen going poorly typed language like pre-ANSI C strong, statically typed language (that is, checked compile time) like C++ Java. When make transition (as I did), benefits dramatic seem like static type checking always best answer problems. My hope relate little bit evolution brought absolute value static type checking question; clearly, it’s helpful much time, there’s fuzzy line cross begins get way become hindrance (one favorite quotes "All models wrong. Some useful."). History Exception handling originated systems like PL/1 Mesa, later appeared CLU, Smalltalk, Modula-3, Ada, Eiffel, C++, Python, Java, post-Java languages Ruby C#. The Java design similar C++, except places Java designers felt C++ approach caused problems. To provide programmers framework likely use error handling recovery, exception handling added C++ rather late standardization process, promoted Bjarne Stroustrup, language’s original author. The model C++ exceptions came primarily CLU. However, languages existed time also supported exception handling: Ada, Smalltalk (both exceptions exception specifications) Modula-3 (which included exceptions specifications). In seminal paper 7 subject, Liskov Snyder observe major defect languages like C, report errors transient fashion, that: 7 Barbara Liskov Alan Snyder, Exception Handling CLU, IEEE Transactions Software Engineering, Vol. SE-5, No. 6, November 1979. This paper available Internet, print form, you’ll contact library get copy. 346 Thinking Java Bruce Eckel "...every invocation must followed conditional test determine outcome was. This requirement leads programs difficult read, probably inefficient well, thus discouraging programmers signaling handling exceptions." Thus one original motivations exception handling prevent requirement, checked exceptions Java commonly see exactly kind code. They go say: "...requiring text handler attached invocation raises exception would lead unreadable programs expressions broken handlers." Following CLU approach designing C++ exceptions, Stroustrup stated goal reduce amount code required recover errors. I believe observing programmers typically writing error-handling code C amount placement code daunting distracting. As result, used C way, ignoring errors code using debuggers track problems. To use exceptions, C programmers convinced write "additional" code weren’t normally writing. Thus, draw better way handling errors, amount code would need "add" must onerous. I think it’s important keep goal mind looking effects checked exceptions Java. C++ brought additional idea CLU: exception specification, programmatically state method signature exceptions could result calling method. The exception specification really two purposes. It say, "I’m originating exception code; handle it." But also mean, "I’m ignoring exception occur result code; handle it." We’ve focusing "you handle it" part looking mechanics syntax exceptions, I’m particularly interested fact often ignore exceptions that’s exception specification state. In C++ exception specification part type information function. The compile-time checking ensure exception specifications used consistently; example, function method throws exceptions, overloaded derived versions must also throw exceptions. Unlike Java, however, compile-time checking occurs determine whether function method actually throw exception, whether exception specification complete (that is, whether accurately describes exceptions maybe thrown). That validation happen, run time. If exception thrown violates exception specification, C++ program call standard library function unexpected( ). It interesting note that, use templates, exception specifications used Standard C++ Library. In Java, restrictions way Java generics used exception specifications. Perspectives First, it’s worth noting Java effectively invented checked exception (clearly inspired C++ exception specifications fact C++ programmers typically don’t bother them). However, experiment subsequent language chosen duplicate. Secondly, checked exceptions appear "obvious good thing" seen introductory examples small programs. It suggested subtle difficulties begin appear programs start get large. Of course, largeness usually doesn’t happen overnight; creeps. Languages may suited large-scale projects Error Handling Exceptions 347 used small projects. These projects grow, point realize things gone "manageable" "difficult." This I’m suggesting may case much type checking; particular, checked exceptions. The scale program seems significant issue. This problem discussions tend use small programs demonstrations. One C# designers observed that: "Examination small programs leads conclusion requiring exception specifications could enhance developer productivity enhance code quality, experience large software projects suggests different result—decreased productivity little increase code quality." 8 In reference uncaught exceptions, CLU creators stated: "We felt unrealistic require programmer provide handlers situations meaningful action taken." 9 When explaining function declaration specification means throw exception, rather exceptions, Stroustrup states: "However, would require exception specifications essentially every function, would significant cause recompilation, would inhibit cooperation software written languages. This would encourage programmers subvert exception-handling mechanisms write spurious code suppress exceptions. It would provide false sense security people failed notice exception." 10 We see behavior—subverting exceptions—happening checked exceptions Java. Martin Fowler (author UML Distilled, Refactoring, Analysis Patterns) wrote following me: "...on whole I think exceptions good, Java checked exceptions trouble worth." I think Java’s important step unify error-reporting model, errors reported using exceptions. This wasn’t happening C++, backward compatibility C old model ignoring errors still available. But consistent reporting exceptions, exceptions used desired, not, propagate highest level (the console container program). When Java modified C++ model exceptions way report errors, extra enforcement checked exceptions may become less necessary. In past, I strong believer checked exceptions static type checking essential robust program development. However, anecdotal direct experience 11 languages dynamic static led think great benefits actually come from: 8 http://discuss.develop.com/archives/wa.exe?A2=indoonA&L=DOTNET&P=R32820 9 Exception Handling CLU, Liskov & Snyder. 10 Bjarne Stroustrup, The C++ Programming Language, 3rd Edition (Addison-Wesley, 1997), P- 376. Indirectly Smalltalk via conversations many experienced programmers language; directly Python (www.Python.org). 11 348 Thinking Java Bruce Eckel 1. A unified error-reporting model via exceptions, regardless whether programmer forced compiler handle them. 2. Type checking, regardless takes place. That is, long proper use type enforced, often doesn’t matter happens compile time run time. On top this, significant productivity benefits reducing compile-time constraints upon programmer. Indeed, reflection generics required compensate overconstraining nature static typing, shall see number examples throughout book. I’ve already told I say constitutes blasphemy, uttering words reputation destroyed, civilizations fall, higher percentage programming projects fail. The belief compiler save project pointing errors compile time runs strong, it’s even important realize limitation compiler able do; supplement find http://MindView.net/Books/BetterJava, I emphasize value automated build process unit testing, give far leverage get trying turn everything syntax error. It’s worth keeping mind that: "A good programming language one helps programmers write good programs. No programming language prevent users writing bad programs." 12 In event, likelihood checked exceptions ever removed Java seems dim. It would radical language change, proponents within Sun appear quite strong. Sun history policy absolute backwards compatibility—to give sense this, virtually Sun software runs Sun hardware, matter old. However, find checked exceptions getting way, especially find forced catch exceptions, don’t know them, alternatives. Passing exceptions console In simple programs, like many book, easiest way preserve exceptions without writing lot code pass main( ) console. For example, want open file reading (something you’ll learn detail I/O chapter), must open close FilelnputStream, throws exceptions. For simple program, (you’ll see approach used numerous places throughout book): //: exceptions/MainException.java import java.io.*; public class MainException { // Pass exceptions console: public static void main(String[] args) throws Exception { // Open file: FileInputStream file = new FileInputStream("MainException.java"); // Use file ... // Close file: file.close(); } } ///:~ 12 Kees Koster, designer CDL language, quoted Bertrand Meyer, designer Eiffel language, www.elj.com/elj/vi/ni/bm/right/. Error Handling Exceptions 349 Note main( ) also method may exception specification, type exception Exception, root class checked exceptions. By passing console, relieved writing try-catch clauses within body main( ). (Unfortunately, file I/O significantly complex would appear example, don’t get excited you’ve read I/O chapter). Exercise 26: (1) Change file name string MainException.java name file doesn’t exist. Run program note result. Converting checked unchecked exceptions Throwing exception main( ) convenient you’re writing simple programs consumption, generally useful. The real problem writing ordinary method body, call another method realize, "I idea exception here, I don’t want swallow print banal message." With chained exceptions, new simple solution prevents itself. You simply "wrap" checked exception inside RuntimeException passing RuntimeException constructor, like this: try{ // ... something useful } catch(IDontKnowWhatToDoWithThisCheckedException e) { throw new RuntimeException(e); } This seems ideal solution want "turn checked exception—you don’t swallow it, don’t put method’s exception specification, exception chaining don’t lose information original exception. This technique provides option ignore exception let bubble call stack without required write try-catch clauses and/or exception specifications. However, may still catch handle specific exception using getCause( ), seen here: //: exceptions/TurnOffChecking.java // "Turning off" Checked exceptions. import java.io.*; import static net.mindview.util.Print.*; class WrapCheckedException { void throwRuntimeException(int type) { try { switch(type) { case 0: throw new FileNotFoundException(); case 1: throw new IOException(); case 2: throw new RuntimeException("Where I?"); default: return; } } catch(Exception e) { // Adapt unchecked: throw new RuntimeException(e); } } } class SomeOtherException extends Exception {} public class TurnOffChecking { public static void main(String[] args) { WrapCheckedException wce = new WrapCheckedException(); // You call throwRuntimeException() without try 350 Thinking Java Bruce Eckel // block, let RuntimeExceptions leave method: wce.throwRuntimeException(3); // Or choose catch exceptions: for(int = 0; < 4; i++) try { if(i < 3) wce.throwRuntimeException(i); else throw new SomeOtherException(); } catch(SomeOtherException e) { print("SomeOtherException: " + e); } catch(RuntimeException re) { try { throw re.getCause(); } catch(FileNotFoundException e) { print("FileNotFoundException: " + e); } catch(IOException e) { print("IOException: " + e); } catch(Throwable e) { print("Throwable: " + e); } } } } /* Output: FileNotFoundException: java.io.FileNotFoundException IOException: java.io.IOException Throwable: java.lang.RuntimeException: Where I? SomeOtherException: SomeOtherException *///:~ WrapCheckedException.throwRuntimeException( ) contains code generates different types exceptions. These caught wrapped inside RuntimeException objects, become "cause" exceptions. In TurnOffChecking, see it’s possible call throwRuntimeException( ) try block method throw checked exceptions. However, you’re ready catch exceptions, still ability catch exception want putting code inside try block. You start catching exceptions explicitly know might emerge code try block—in case, SomeOtherException caught first. Lastly, catch RuntimeException throw result getCause( ) (the wrapped exception). This extracts originating exceptions, handled catch clauses. The technique wrapping checked exception RuntimeException used appropriate throughout rest book. Another solution create subclass RuntimeException. This way, doesn’t need caught, someone catch want to. Exercise 27: (1) Modify Exercise 3 convert exception RuntimeException. Exercise 28: (1) Modify Exercise 4 custom exception class inherits RuntimeException, show compiler allows leave try block. Exercise 29: (1) Modify exception types Stormylnning.java extend RuntimeException, show exception specifications try blocks necessary. Remove ‘//!’ comments show methods compiled without specifications. Error Handling Exceptions 351 Exercise 30: (2) Modify Human.java exceptions inherit RuntimeException. Modify main( ) technique TurnOffChecking.java used handle different types exceptions. Exception guidelines Use exceptions to: 1. Handle problems appropriate level. (Avoid catching exceptions unless know them.) 2. Fix problem call method caused exception again. 3. Patch things continue without retrying method. 4. Calculate alternative result instead method supposed produce. 5. Do whatever current context rethrow exception higher context. 6. Do whatever current context throw different exception higher context. 7. Terminate program. 8. Simplify. (If exception scheme makes things complicated, painful annoying use.) 9. Make library program safer. (This short-term investment debugging, long-term investment application robustness.) Summary Exceptions integral programming Java; accomplish much without knowing work them. For reason, exceptions introduced point book—there many libraries (like I/O, mentioned earlier) can’t use without handling exceptions. One advantages exception handling allows concentrate problem you’re trying solve one place, deal errors code another place. And although exceptions generally explained tools allow report recover errors run time, I come wonder often "recovery" aspect implemented, even possible. My perception less 10 percent time, even probably amounts unwinding stack known stable state rather actually performing kind resumptive behavior. Whether true, I come believe "reporting" function essential value exceptions lie. The fact Java effectively insists errors reported form exceptions gives great advantage languages like C++, allow report errors number different ways, all. A consistent errorreporting system means longer ask question "Are errors slipping cracks?" piece code write (as long don’t "swallow" exceptions, is!). 352 Thinking Java Bruce Eckel As see future chapters, laying question rest—even throwing RuntimeException—your design implementation efforts focused interesting challenging issues. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Error Handling Exceptions 353 Strings String manipulation arguably one common activities computer programming. This especially true Web systems, Java heavily used. In chapter, we’ll look deeply certainly commonly used class language, String, along associated classes utilities. Immutable Strings Objects String class immutable. If examine JDK documentation String class, you’ll see every method class appears modify String actually creates returns brand new String object containing modification. The original String left untouched. Consider following code: //: strings/Immutable.java import static net.mindview.util.Print.*; public class Immutable { public static String upcase(String s) { return s.toUpperCase(); } public static void main(String[] args) { String q = "howdy"; print(q); // howdy String qq = upcase(q); print(qq); // HOWDY print(q); // howdy } } /* Output: howdy HOWDY howdy *///:~ When q passed upcase( ) it’s actually copy reference q. The object reference connected stays single physical location. The references copied passed around. Looking definition upcase( ), see reference that’s passed name s, exists long body upcase( ) executed. When upcase( ) completes, local reference vanishes. upcase( ) returns result, original string characters set uppercase. Of course, actually returns reference result. But turns reference returns new object, original q left alone. This behavior usually want. Suppose say: String = "asdf"; String x = Immutable.upcase(s); Do really want upcase( ) method change argument? To reader code, argument usually looks like piece information provided method, something modified. This important guarantee, since makes code easier write understand. Overloading ‘+’ vs. StringBuilder Since String objects immutable, alias particular String many times want. Because String read-only, there’s possibility one reference change something affect references. Immutability efficiency issues. A case point operator ‘+’ overloaded String objects. Overloading means operation given extra meaning used particular class. (The ‘+’ ‘+=‘ String operators overloaded Java, Java allow programmer overload others.) 1 The’+’ operator allows concatenate Strings: //: strings/Concatenation.java public class Concatenation { public static void main(String[] args) { String mango = "mango"; String = "abc" + mango + "def" + 47; System.out.println(s); } } /* Output: abcmangodef47 *///:~ You could imagine might work. The String "abc" could method append( ) creates new String object containing "abc" concatenated contents mango. The new String object would create another new String added "def," on. This would certainly work, requires creation lot String objects put together new String, bunch intermediate String objects need garbage collected. I suspect Java designers tried approach first (which lesson software design—you don’t really know anything system try code get something working). I also suspect discovered delivered unacceptable performance. To see really happens, decompile code using javap tool comes part JDK. Here’s command line: javap -c Concatenation The -c flag produce JVM bytecodes. After strip parts we’re interested bit editing, relevant bytecodes: public static void main(java.lang.String[]); Code: Stack=2, Locals=3, Args_size=1 0: ldc #2; //String mango 1 C++ allows programmer overload operators will. Because often complicated process (see Chapter 10 Thinking C++, 2nd Edition, Prentice Hall, 2000), Java designers deemed "bad" feature shouldn’t included Java. It wasn’t bad didn’t end themselves, ironically enough, operator overloading would much easier use Java C++. This seen Python (see www.Python.org) C#, garbage collection straightforward operator overloading. 356 Thinking Java Bruce Eckel 2: 3: 6: 7: 10: 12 15 16 19 21 24 26 29 32 33 36 37 40 astore_1 new #3; //class StringBuilder dup invokespecial #4; //StringBuilder."<init>":() ldc #5; // String abc invokevirtual #6; //StringBuilder.append:(String) aload_1 invokevirtual #6; //StringBuilder.append:(String) ldc #7; //String def invokevirtual #6; //StringBuilder.append:(String) bipush 47 invokevirtual #8; //StringBuilder.append:(I) invokevirtual #9; //StringBuilder.toString:() astore_2 getstatic #10; //Field System.out:PrintStream; aload_2 invokevirtual #11; // PrintStream.println:(String) return If you’ve experience assembly language, may look familiar you—statements like dup invokevirtual Java Virtual Machine (JVM) equivalent assembly language. If you’ve never seen assembly language, don’t worry it—the important part notice introduction compiler java.lang.StringBuilder class. There mention StringBuilder source code, compiler decided use anyway, much efficient. In case, compiler creates StringBuilder object build String s, calls append( ) four times, one pieces. Finally, calls toString( ) produce result, stores (with astore_2) s. Before assume use Strings everywhere compiler make everything efficient, let’s look little closely compiler doing. Here’s example produces String result two ways: using Strings, hand-coding StringBuilder: //: strings/WhitherStringBuilder.java public class WhitherStringBuilder { public String implicit(String[] fields) { String result = ""; for(int = 0; < fields.length; i++) result += fields[i]; return result; } public String explicit(String[] fields) { StringBuilder result = new StringBuilder(); for(int = 0; < fields.length; i++) result.append(fields[i]); return result.toString(); } } ///:~ Now run javap -c WitherStringBuilder, see (simplified) code two different methods. First, implicit( ): public java.lang.String implicit(java.lang.String[]); Code: 0: ldc #2; //String 2: astore_2 3: iconst_0 4: istore_3 Strings 357 5: 6: 7: 8: 11: 14: 15: 18: 19: 22: 23 24 25: 28: 31: 32: 35: 38: 39 iload_3 aload_1 arraylength if_icmpge 38 new #3; //class StringBuilder dup invokespecial #4; // StringBuilder.”<init>”:() aload_2 invokevirtual #5; // StringBuilder.append:() aload_1 iload_3 aaload invokevirtual #5; // StringBuilder.append:() invokevirtual #6; // StringBuiIder.toString:() astore_2 iinc 3, 1 goto 5 aload_2 areturn Notice 8: 35:, together form loop. 8: "integer compare greater equal to" operands stack jumps 38: loop done. 35: goto back beginning loop, 5:. The important thing note StringBuilder construction happens inside loop, means you’re going get new StringBuilder object every time pass loop. Here bytecodes explicit( ): public java.lang.String explicit(java.lang.String[]); Code: 0: new #3; //class StringBuilder 3: dup 4: invokespecial #4; // StringBuilder.”<init>”:() 7: astore_2 8: iconst_0 9: istore_3 10: iload_3 11: aload_1 12: arraylength 13: if_icmpge 30 16: aload_2 17: aload_1 18: iload_3 19: aaload 20 invokevirtual #5; // StringBuilder.append:() 23 pop 24: iinc 3,1 27: goto 10 30: aload_2 31: invokevirtual #6; // StringBuiIder.toString:() 34: areturn Not loop code shorter simpler, method creates single StringBuilder object. Creating explicit StringBuilder also allows preallocate size extra information big might need be, doesn’t need constantly reallocate buffer. 358 Thinking Java Bruce Eckel Thus, create toString( ) method, operations simple ones compiler figure own, generally rely compiler build result reasonable fashion. But looping involved, explicitly use StringBuilder toString( ), like this: //: strings/UsingStringBuilder.java import java.util.*; public class UsingStringBuilder { public static Random rand = new Random(47); public String toString() { StringBuilder result = new StringBuilder("["); for(int = 0; < 25; i++) { result.append(rand.nextInt(100)); result.append(", "); } result.delete(result.length()-2, result.length()); result.append("]"); return result.toString(); } public static void main(String[] args) { UsingStringBuilder usb = new UsingStringBuilder(); System.out.println(usb); } } /* Output: [58, 55, 93, 61, 61, 29, 68, 0, 22, 7, 88, 28, 51, 89, 9, 78, 98, 61, 20, 58, 16, 40, 11, 22, 4] *///:~ Notice piece result added append( ) statement. If try take shortcuts something like append(a + ": " + c), compiler jump start making StringBuilder objects again. If doubt approach use, always run javap double-check. Although StringBuilder full complement methods, including insert( ), replace( ), substring( ) even reverse( ), ones generally use append( ) toString( ). Note use delete( ) remove last comma space adding closing square bracket. StringBuilder introduced Java SE5. Prior this, Java used StringBuffer, ensured thread safety (see Concurrency chapter) significantly expensive. Thus, string operations Java SE5/6 faster. Exercise 1: (2) Analyze SprinklerSystem.toString( ) reusing/SprinklerSystem.java discover whether writing toString( ) explicit StringBuilder save StringBuilder creations. Unintended recursion Because (like every class) Java standard containers ultimately inherited Object, contain toString( ) method. This overridden produce String representation themselves, including objects hold. ArrayList.toString( ), example, steps elements Array List calls toString( ) one: //: strings/ArrayListDisplay.java import generics.coffee.*; Strings 359 import java.util.*; public class ArrayListDisplay { public static void main(String[] args) { ArrayList<Coffee> coffees = new ArrayList<Coffee>(); for(Coffee c : new CoffeeGenerator(10)) coffees.add(c); System.out.println(coffees); } } /* Output: [Americano 0, Latte 1, Americano 2, Mocha 3, Mocha 4, Breve 5, Americano 6, Latte 7, Cappuccino 8, Cappuccino 9] *///:~ Suppose you’d like toString( ) print address class. It seems make sense simply refer this: //: strings/InfiniteRecursion.java // Accidental recursion. // {RunByHand} import java.util.*; public class InfiniteRecursion { public String toString() { return " InfiniteRecursion address: " + + "\n"; } public static void main(String[] args) { List<InfiniteRecursion> v = new ArrayList<InfiniteRecursion>(); for(int = 0; < 10; i++) v.add(new InfiniteRecursion()); System.out.println(v); } } ///:~ If create InfiniteRecursion object print it, you’ll get long sequence exceptions. This also true place InfiniteRecursion objects ArrayList print ArrayList shown here. What’s happening automatic type conversion Strings. When say: "InfiniteRecursion address: " + The compiler sees String followed a’+’ something that’s String, tries convert String. It conversion calling toString( ), produces recursive call. If really want print address object, solution call ObjecttoString( ) method, that. So instead saying this, you’d say super.toString( ). Exercise 2: (1) Repair InfiniteRecursion.java. 360 Thinking Java Bruce Eckel Operations Strings Here basic methods available String objects. Methods overloaded summarized single row: Method Arguments, Overloading Use Constructor Overloaded: default, String, StringBuilder, StringBuffer, char arrays, byte arrays. Creating String objects. length( ) Number characters String. charAt( ) int Index The char location String. getChars( ), getBytes( ) The beginning end copy, array copy into, index destination array. Copy chars bytes external array. toCharArray( ) Produces char[] containing characters String. equals( ), equalsIgnoreCase( ) A String compare with. An equality check contents two Strings. compareTo( ) A String compare with. Result negative, zero, positive depending lexicographical ordering String argument. Uppercase lowercase equal! contains( ) A CharSequence search for. Result true argument contained String. contentEquals( ) A CharSequence StringBuffer compare to. Result true there’s exact match argument. equalsIgnoreCase( ) A String compare with. Result true contents equal, ignoring case. regionMatches( ) Offset String, String offset length compare. Overload adds "ignore case." boolean result indicates whether region matches. startsWith( ) String might start with. Overload adds offset argument. boolean result indicates whether String starts argument. endsWith( ) String might suffix String. boolean result indicates whether argument suffix. indexOf( ), lastIndexOf( ) Overloaded: char, char starting index, String, Returns -1 argument found within String; otherwise, returns Strings 361 Method Arguments, Overloading Use String starting index. index argument starts. lastIndexOf( ) searches backward end. substring( ) (also subSequence( )) Overloaded: starting index; starting index + ending index. Returns new String object containing specified character set. concat( ) The String concatenate. Returns new String object containing original String’s characters followed characters argument. replace() The old character search for, new character replace with. Can also replace CharSequence CharSequence. Returns new String object replacements made. Uses old String match found. toLowerCase( ) toUpperCase( ) Returns new String object case letters changed. Uses old String changes need made. trim( ) Returns new String object whitespace removed end. Uses old String changes need made. valueOf( ) Overloaded: Object, char[], char[] offset count, boolean, char, int, long, float, double. intern( ) Returns String containing character representation argument. Produces one one String reference per unique character sequence. You see every String method carefully returns new String object it’s necessary change contents. Also notice contents don’t need changing, method return reference original String. This saves storage overhead. The String methods involving regular expressions explained later chapter. Formatting output One long-awaited features finally appeared Java SE5 output formatting style C’s printf( ) statement. Not allow simplified output code, also gives Java developers powerful control output formatting alignment. 2 2 Mark Welsh assisted creation section, "Scanning input" section. 362 Thinking Java Bruce Eckel printf() C’s printf( ) doesn’t assemble strings way Java does, takes single format string inserts values it, formatting goes. Instead using overloaded ‘+’ operator (which C doesn’t overload) concatenate quoted text variables, printf( ) uses special placeholders show data go. The arguments inserted format string follow comma-separated list. For example: printf("Row 1: [%d %f]\n", x, y); At run time, value x inserted %d value inserted %f. These placeholders called/ormaf specifiers and, addition telling insert value, also tell kind variable inserted format it. For instance, ‘%d’ says x integer ‘%f says floating point value (a float double). System.out.format() Java SE5 introduced format( ) method, available PrintStream PrintWriter objects (which you’ll learn I/O chapter), includes System.out. The format( ) method modeled C’s printf( ). There’s even convenience printf( ) method use you’re feeling nostalgic, calls format( ). Here’s simple example: //: strings/SimpleFormat.java public class SimpleFormat { public static void main(String[] args) { int x = 5; double = 5.332542; // The old way: System.out.println("Row 1: [" + x + " " + + "]"); // The new way: System.out.format("Row 1: [%d %f]\n", x, y); // System.out.printf("Row 1: [%d %f]\n", x, y); } } /* Output: Row 1: [5 5.332542] Row 1: [5 5.332542] Row 1: [5 5.332542] *///:~ You see format( ) printf( ) equivalent. In cases, there’s single format string, followed one argument format specifier. The Formatter class All Java’s new formatting functionality handled Formatter class java.util package. You think Formatter translator converts format string data desired result. When create Formatter object, tell want result go passing information constructor: //: strings/Turtle.java Strings 363 import java.io.*; import java.util.*; public class Turtle { private String name; private Formatter f; public Turtle(String name, Formatter f) { this.name = name; this.f = f; } public void move(int x, int y) { f.format("%s The Turtle (%d,%d)\n", name, x, y); } public static void main(String[] args) { PrintStream outAlias = System.out; Turtle tommy = new Turtle("Tommy", new Formatter(System.out)); Turtle terry = new Turtle("Terry", new Formatter(outAlias)); tommy.move(0,0); terry.move(4,8); tommy.move(3,4); terry.move(2,5); tommy.move(3,3); terry.move(3,3); } } /* Output: Tommy The Turtle (0,0) Terry The Turtle (4,8) Tommy The Turtle (3,4) Terry The Turtle (2,5) Tommy The Turtle (3,3) Terry The Turtle (3,3) *///:~ All tommy output goes System.out terry output goes alias System.out. The constructor overloaded take range output locations, useful PrintStreams (as above), OutputStreams, Files. You’ll learn I/O chapter. Exercise 3: (1) Modify Turtle.java sends output System.err. The previous example uses new format specifier, ‘%s’. This indicates String argument example simplest kind format specifier-one conversion type. Format specifiers To control spacing alignment data inserted, need elaborate format specifiers. Here’s general syntax: %[argument_index$][flags][width][.precision]conversion Often, you’ll need control minimum size field. This accomplished specifying width. The Formatter guarantees field least certain number characters wide padding spaces necessary. By default, data right justified, overridden including ‘-’ flags section. 364 Thinking Java Bruce Eckel The opposite width precision, used specify maximum. Unlike width, applicable data conversion types behaves each, precision different meaning different types. For Strings, precision specifies maximum number characters String print. For floating point numbers, precision specifies number decimal places display (the default 6), rounding many adding trailing zeroes few. Since integers fractional part, precision isn’t applicable you’ll get exception use precision integer conversion type. This example uses format specifiers print shopping receipt: //: strings/Receipt.java import java.util.*; public class Receipt { private double total = 0; private Formatter f = new Formatter(System.out); public void printTitle() { f.format("%-15s %5s %10s\n", "Item", "Qty", "Price"); f.format("%-15s %5s %10s\n", "----", "---", "-----"); } public void print(String name, int qty, double price) { f.format("%-15.15s %5d %10.2f\n", name, qty, price); total += price; } public void printTotal() { f.format("%-15s %5s %10.2f\n", "Tax", "", total*0.06); f.format("%-15s %5s %10s\n", "", "", "-----"); f.format("%-15s %5s %10.2f\n", "Total", "", total * 1.06); } public static void main(String[] args) { Receipt receipt = new Receipt(); receipt.printTitle(); receipt.print("Jack’s Magic Beans", 4, 4.25); receipt.print("Princess Peas", 3, 5.1); receipt.print("Three Bears Porridge", 1, 14.29); receipt.printTotal(); } } /* Output: Item Qty Price ---------Jack’s Magic Be 4 4.25 Princess Peas 3 5.10 Three Bears Por 1 14.29 Tax 1.42 ----Total 25.06 *///:~ As see, Formatter provides powerful control spacing alignment fairly concise notation. Here, format strings simply copied order produce appropriate spacing. Exercise 4: (3) Modify Receipt.java widths controlled single set constant values. The goal allow easily change width changing single value one place. Strings 365 Formatter conversions These conversions you’ll come across frequently: Conversion Characters Integral (as decimal) c Unicode character b Boolean value String f Floating point (as decimal) e Floating point (in scientific notation) x Integral (as hex) h Hash code (as hex) % Literal "%" Here’s example shows conversions action: //: strings/Conversion.java import java.math.*; import java.util.*; public class Conversion { public static void main(String[] args) { Formatter f = new Formatter(System.out); char u = ‘a’; System.out.println("u = ‘a’"); f.format("s: %s\n", u); // f.format("d: %d\n", u); f.format("c: %c\n", u); f.format("b: %b\n", u); // f.format("f: %f\n", u); // f.format("e: %e\n", u); // f.format("x: %x\n", u); f.format("h: %h\n", u); int v = 121; System.out.println("v = 121"); f.format("d: %d\n", v); f.format("c: %c\n", v); f.format("b: %b\n", v); f.format("s: %s\n", v); // f.format("f: %f\n", v); // f.format("e: %e\n", v); f.format("x: %x\n", v); f.format("h: %h\n", v); BigInteger w = new BigInteger("50000000000000"); System.out.println( "w = new BigInteger(\"50000000000000\")"); 366 Thinking Java Bruce Eckel f.format("d: %d\n", w); // f.format("c: %c\n", w); f.format("b: %b\n", w); f.format("s: %s\n", w); // f.format("f: %f\n", w); // f.format("e: %e\n", w); f.format("x: %x\n", w); f.format("h: %h\n", w); double x = 179.543; System.out.println("x = 179.543"); // f.format("d: %d\n", x); // f.format("c: %c\n", x); f.format("b: %b\n", x); f.format("s: %s\n", x); f.format("f: %f\n", x); f.format("e: %e\n", x); // f.format("x: %x\n", x); f.format("h: %h\n", x); Conversion = new Conversion(); System.out.println("y = new Conversion()"); // f.format("d: %d\n", y); // f.format("c: %c\n", y); f.format("b: %b\n", y); f.format("s: %s\n", y); // f.format("f: %f\n", y); // f.format("e: %e\n", y); // f.format("x: %x\n", y); f.format("h: %h\n", y); boolean z = false; System.out.println("z = false"); // f.format("d: %d\n", z); // f.format("c: %c\n", z); f.format("b: %b\n", z); f.format("s: %s\n", z); // f.format("f: %f\n", z); // f.format("e: %e\n", z); // f.format("x: %x\n", z); f.format("h: %h\n", z); } } /* Output: (Sample) u = ‘a’ s: c: b: true h: 61 v = 121 d: 121 c: b: true s: 121 x: 79 h: 79 w = new BigInteger("50000000000000") d: 50000000000000 b: true s: 50000000000000 x: 2d79883d2000 h: 8842a1a7 x = 179.543 b: true Strings 367 s: 179.543 f: 179.543000 e: 1.795430e+02 h: 1ef462c = new Conversion() b: true s: Conversion@9cab16 h: 9cab16 z = false b: false s: false h: 4d5 *///:~ The commented lines show conversions invalid particular variable type; executing trigger exception. Notice ‘b’ conversion works variable above. Although it’s valid argument type, might behave you’d expect. For boolean primitives Boolean objects, result true false, accordingly. However, argument, long argument type null result always true. Even numeric value zero, synonymous false many languages (including C), produce true, careful using conversion non-boolean types. There obscure conversion types format specifier options. You read JDK documentation Formatter class. Exercise 5: (5) For basic conversion types table, write complex formatting expression possible. That is, use possible format specifiers available conversion type. String.format() Java SE5 also took cue C’s sprintf( ), used create Strings. String.format( ) static method takes arguments Formatter’s format( ) returns String. It come handy need call format( ) once: //: strings/DatabaseException.java public class DatabaseException extends Exception { public DatabaseException(int transactionID, int queryID, String message) { super(String.format("(t%d, q%d) %s", transactionID, queryID, message)); } public static void main(String[] args) { try { throw new DatabaseException(3, 7, "Write failed"); } catch(Exception e) { System.out.println(e); } } } /* Output: DatabaseException: (t3, q7) Write failed *///:~ 368 Thinking Java Bruce Eckel Under hood, String.format( ) instantiate Formatter pass arguments it, using convenience method often clearer easier hand. A hex dump tool As second example, often want look bytes inside binary file using hex format. Here’s small utility displays binary array bytes readable hex format, using String.format( ): //: net/mindview/util/Hex.java package net.mindview.util; import java.io.*; public class Hex { public static String format(byte[] data) { StringBuilder result = new StringBuilder(); int n = 0; for(byte b : data) { if(n % 16 == 0) result.append(String.format("%05X: ", n)); result.append(String.format("%02X ", b)); n++; if(n % 16 == 0) result.append("\n"); } result.append("\n"); return result.toString(); } public static void main(String[] args) throws Exception { if(args.length == 0) // Test displaying class file: System.out.println( format(BinaryFile.read("Hex.class"))); else System.out.println( format(BinaryFile.read(new File(args[0])))); } } /* Output: (Sample) 00000: CA FE BA BE 00 00 00 31 00 52 0A 00 05 00 22 07 00010: 00 23 0A 00 02 00 22 08 00 24 07 00 25 0A 00 26 00020: 00 27 0A 00 28 00 29 0A 00 02 00 2A 08 00 2B 0A 00030: 00 2C 00 2D 08 00 2E 0A 00 02 00 2F 09 00 30 00 00040: 31 08 00 32 0A 00 33 00 34 0A 00 15 00 35 0A 00 00050: 36 00 37 07 00 38 0A 00 12 00 39 0A 00 33 00 3A ... *///:~ To open read binary file, uses another utility introduced I/O chapter: net.mindview.util.BinaryFile. The read( ) method returns entire file byte array. Exercise 6: (2) Create class contains int, long, float double fields. Create toString( ) method class uses String.format( ), demonstrate class works correctly. Strings 369 Regular expressions Regular expressions long integral standard Unix utilities like sed awk, languages like Python Perl (some would argue predominant reason Perl’s success). String manipulation tools previously delegated String, StringBuffer, StringTokenizer classes Java, relatively simple facilities compared regular expressions. Regular expressions powerful flexible text-processing tools. They allow specify, programmatically, complex patterns text discovered input string. Once discover patterns, react way want. Although syntax regular expressions intimidating first, provide compact dynamic language employed solve sorts string processing, matching selection, editing, verification problems completely general way. Basics A regular expression way describe strings general terms, say, "If string things it, matches I’m looking for." For example, say number might might preceded minus sign, put minus sign followed question mark, like this: -? To describe integer, say it’s one digits. In regular expressions, digit described saying ‘\d’. If experience regular expressions languages, you’ll immediately notice difference way backslashes handled. In languages, ‘\\’ means "I want insert plain old (literal) backslash regular expression. Don’t give special meaning." In Java, ‘ \ \ ‘ means "I’m inserting regular expression backslash, following character special meaning." For example, want indicate digit, regular expression string ‘\\d’. If want insert literal backslash, say ‘\\\\’- However, things like newlines tabs use single backslash: ‘\n\t’. To indicate "one preceding expression," use ‘+’. So say, "possibly minus sign, followed one digits," write: -?\\d+ The simplest way use regular expressions use functionality built String class. For example, see whether String matches regular expression above: //: strings/IntegerMatch.java public class IntegerMatch { public static void main(String[] args) { System.out.println("-1234".matches("-?\\d+")); System.out.println("5678".matches("-?\\d+")); System.out.println("+911".matches("-?\\d+")); System.out.println("+911".matches("(-|\\+)?\\d+")); } } /* Output: true true false true *///:~ 370 Thinking Java Bruce Eckel The first two expressions match, third one starts ‘+’, legitimate sign means number doesn’t match regular expression. So need way say, "may start + -." In regular expressions, parentheses effect grouping expression, vertical bar ‘|’ means OR. So (-I\\+)? means part string may either ‘-’ ‘+’ nothing (because ‘?’). Because ‘+’ character special meaning regular expressions, must escaped ‘\\’ order appear ordinary character expression. A useful regular expression tool that’s built String split( ), means, "Split string around matches given regular expression." //: strings/Splitting.java import java.util.*; public class Splitting { public static String knights = "Then, found shrubbery, must " + "cut mightiest tree forest... " + "with... herring!"; public static void split(String regex) { System.out.println( Arrays.toString(knights.split(regex))); } public static void main(String[] args) { split(" "); // Doesn’t contain regex chars split("\\W+"); // Non-word characters split("n\\W+"); // ‘n’ followed non-word characters } } /* Output: [Then,, when, you, have, found, the, shrubbery,, you, must, cut, down, the, mightiest, tree, in, the, forest..., with..., a, herring!] [Then, when, you, have, found, the, shrubbery, you, must, cut, down, the, mightiest, tree, in, the, forest, with, a, herring] [The, whe, found shrubbery, must cut dow, mightiest tree i, forest... with... herring!] *///:~ First, note may use ordinary characters regular expressions—a regular expression doesn’t contain special characters, see first call split( ), splits whitespace. The second third calls split( ) use ‘\W’, means non-word character (the lowercase version, ‘\w’, means word character)—you see punctuation removed second case. The third call split( ) says, "the letter n followed one non-word characters." You see split patterns appear result. An overloaded version String. split( ) allows limit number splits occur. The final regular expression tool built String replacement. You either replace first occurrence, them: //: strings/Replacing.java import static net.mindview.util.Print.*; public class Replacing { static String = Splitting.knights; public static void main(String[] args) { Strings 371 print(s.replaceFirst("f\\w+", "located")); print(s.replaceAll("shrubbery|tree|herring","banana")); } } /* Output: Then, located shrubbery, must cut mightiest tree forest... with... herring! Then, found banana, must cut mightiest banana forest... with... banana! *///:~ The first expression matches letter f followed one word characters (note w lowercase time). It replaces first match finds, word "found" replaced word "located." The second expression matches three words separated OR vertical bars, replaces matches finds. You’ll see non-String regular expressions powerful replacement tools— example, call methods perform replacements. Non-String regular expressions also significantly efficient need use regular expression once. Exercise 7: (5) Using documentation java.util.regex.Pattern resource, write test regular expression checks sentence see begins capital letter ends period. Exercise 8: (2) Split string Splitting.knights words "the" “you." Exercise 9: (4) Using documentation java.util.regex.Pattern resource, replace vowels Splitting.knights underscores. Creating regular expressions You begin learning regular expressions subset possible constructs. A complete list constructs building regular expressions found JDK documentation Pattern class package java.util.regex. Characters 372 B The specific character B \xhh Character hex value oxhh \uhhhh The Unicode character hex representation 0xhhhh \t Tab \n Newline \r Carriage return \f Form feed \e Escape Thinking Java Bruce Eckel The power regular expressions begins appear defining character classes. Here typical ways create character classes, predefined classes: Character Classes . Any character [abc] Any characters a, b, c (same a|b|c) [^abc] Any character except a, b, c (negation) [a-zA-Z] Any character z A Z (range) [abc[hij]] Any a,b,c,h,I,j (same a|b|c|h|i|j) (union) [a-z&&[hij]] Either h, i, j (intersection) \s A whitespace character (space, tab, newline, form feed, carriage return) \S A non-whitespace character ([^\s]) \d A numeric digit [0-9] \D A non-digit [^o-9] \w A word character [a-zA-Z_0-9] \W A non-word character [^\w] What’s shown sample; you’ll want bookmark JDK documentation page java.util.regex.Pattern easily access possible regular expression patterns. Logical Operators XY X followed Y X|Y X Y (X) A capturing group. You refer ith captured group later expression \i. Boundary Matchers ^ Beginning line $ End line \b Word boundary \B Non-word boundary \G End previous match As example, following successfully matches character sequence "Rudolph": //: strings/Rudolph.java public class Rudolph { public static void main(String[] args) { for(String pattern : new String[]{ "Rudolph", "[rR]udolph", "[rR][aeiou][a-z]ol.*", "R.*" }) System.out.println("Rudolph".matches(pattern)); Strings 373 } } /* Output: true true true true *///:~ Of course, goal create obfuscated regular expression, rather simplest one necessary job. You’ll find that, start writing regular expressions, you’ll often use code reference writing new regular expressions. Quantifiers A quantifier describes way pattern absorbs input text: • Greedy: Quantifiers greedy unless otherwise altered. A greedy expression finds many possible matches pattern possible. A typical cause problems assume pattern match first possible group characters, it’s actually greedy keep going it’s matched largest possible string. • Reluctant: Specified question mark, quantifier matches minimum number characters necessary satisfy pattern. Also called lazy, minimal matching, non-greedy, ungreedy. • Possessive: Currently available Java (not languages) advanced, probably won’t use right away. As regular expression applied string, generates many states backtrack match fails. Possessive quantifiers keep intermediate states, thus prevent backtracking. They used prevent regular expression running away also make execute efficiently. Greedy Reluctant Possessive Matches X? X?? X?+ X, one none X* X*? x*+ X, zero x+ x+? X++ X, one X{n} X{n}? X{n}+ X, exactly n times X{n,} X{n,}? X{n,}+ X, least n times X{n,m} X{n,m}? X{n,m}+ X, least n times Keep mind expression ‘X’ often need surrounded parentheses work way desire. For example: abc+ might seem like would match sequence ‘abc’ one times, apply input string ‘abcabcabc’, fact get three matches. However, expression actually says, "Match ‘ab’ followed one occurrences ‘c’." To match entire string ‘abc’ one times, must say: 374 Thinking Java Bruce Eckel (abc)+ You easily fooled using regular expressions; it’s orthogonal language, top Java. CharSequence The interface called CharSequence establishes generalized definition character sequence abstracted CharBuffer, String, StringBuffer, StringBuilder classes: interface CharSequence { charAt(int i); length(); subSequence(int start,| int end); toString(); } The aforementioned classes implement interface. Many regular expression operations take CharSequence arguments. Pattern Matcher In general, you’ll compile regular expression objects rather using fairly limited String utilities. To this, import java.util.regex, compile regular expression using static Pattern.compile( ) method. This produces Pattern object based String argument. You use Pattern calling matcher( ) method, passing string want search. The matcher( ) method produces Matcher object, set operations choose (you see JDK documentation java.util.regex.Matcher). For example, replaceAll( ) method replaces matches argument. As first example, following class used test regular expressions input string. The first command-line argument input string match against, followed one regular expressions applied input. Under Unix/Linux, regular expressions must quoted command line. This program useful testing regular expressions construct see produce intended matching behavior. //: strings/TestRegularExpression.java // Allows easily try regular expressions. // {Args: abcabcabcdefabc "abc+" "(abc)+" "(abc){2,}" } import java.util.regex.*; import static net.mindview.util.Print.*; public class TestRegularExpression { public static void main(String[] args) { if(args.length < 2) { print("Usage:\njava TestRegularExpression " + "characterSequence regularExpression+"); System.exit(0); } print("Input: \"" + args[0] + "\""); for(String arg : args) { print("Regular expression: \"" + arg + "\""); Pattern p = Pattern.compile(arg); Matcher = p.matcher(args[0]); while(m.find()) { Strings 375 print("Match \"" + m.group() + "\" positions " + m.start() + "-" + (m.end() - 1)); } } } } /* Output: Input: "abcabcabcdefabc" Regular expression: "abcabcabcdefabc" Match "abcabcabcdefabc" positions 0-14 Regular expression: "abc+" Match "abc" positions 0-2 Match "abc" positions 3-5 Match "abc" positions 6-8 Match "abc" positions 12-14 Regular expression: "(abc)+" Match "abcabcabc" positions 0-8 Match "abc" positions 12-14 Regular expression: "(abc){2,}" Match "abcabcabc" positions 0-8 *///:~ A Pattern object represents compiled version regular expression. As seen preceding example, use matcher( ) method input string produce Matcher object compiled Pattern object. Pattern also static method: static boolean matches(String regex, CharSequence input) check whether regex matches entire input CharSequence, split( ) method produces array String broken around matches regex. A Matcher object generated calling Pattern.matcher( ) input string argument. The Matcher object used access results, using methods evaluate success failure different types matches: boolean boolean boolean boolean matches() lookingAt() find() find(int start) The matches ( ) method successful pattern matches entire input string, lookingAt( ) successful input string, starting beginning, match pattern. Exercise 10: (2) For phrase "Java regular expressions" evaluate whether following expressions find match: ^Java \Breg.* n.w\s+h(a|i)s s? s* s+ s{4} S{1}. s{0,3} 376 Thinking Java Bruce Eckel Exercise 11: (2) Apply regular expression (?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b "Arline ate eight apples one orange Anita hadn’t any" find() Matcher.find( ) used discover multiple pattern matches CharSequence applied. For example: //: strings/Finding.java import java.util.regex.*; import static net.mindview.util.Print.*; public class Finding { public static void main(String[] args) { Matcher = Pattern.compile("\\w+") .matcher("Evening full linnet’s wings"); while(m.find()) printnb(m.group() + " "); print(); int = 0; while(m.find(i)) { printnb(m.group() + " "); i++; } } } /* Output: Evening full linnet wings Evening vening ening ning ing ng g full full ull l f e linnet linnet innet nnet net et wings wings ings ngs gs *///:~ The pattern ‘\\w+’ splits input words. find( ) like iterator, moving forward input string. However, second version find( ) given integer argument tells character position beginning search—this version resets search position value argument, see output. Groups Groups regular expressions set parentheses called later group number. Group indicates whole expression match, group l first parenthesized group, etc. Thus A(B(C))D three groups: Group 0 ABCD, group 1 BC, group 2 C. The Matcher object methods give information groups: public int groupCount( ) returns number groups matcher’s pattern. Group included count. Strings 377 public String group( ) returns group 0 (the entire match) previous match operation (find( ), example). public String group(int i) returns given group number previous match operation. If match successful, group specified failed match part input string, null returned. public int start(int group) returns start index group found previous match operation. public int end(int group) returns index last character, plus one, group found previous match operation. Here’s example: //: strings/Groups.java import java.util.regex.*; import static net.mindview.util.Print.*; public class Groups { static public final String POEM = "Twas brillig, slithy toves\n" + "Did gyre gimble wabe.\n" + "All mimsy borogoves,\n" + "And mome raths outgrabe.\n\n" + "Beware Jabberwock, son,\n" + "The jaws bite, claws catch.\n" + "Beware Jubjub bird, shun\n" + "The frumious Bandersnatch."; public static void main(String[] args) { Matcher = Pattern.compile("(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$") .matcher(POEM); while(m.find()) { for(int j = 0; j <= m.groupCount(); j++) printnb("[" + m.group(j) + "]"); print(); } } } /* Output: [the slithy toves][the][slithy toves][slithy][toves] [in wabe.][in][the wabe.][the][wabe.] [were borogoves,][were][the borogoves,][the][borogoves,] [mome raths outgrabe.][mome][raths outgrabe.][raths][outgrabe.] [Jabberwock, son,][Jabberwock,][my son,][my][son,] [claws catch.][claws][that catch.][that][catch.] [bird, shun][bird,][and shun][and][shun] [The frumious Bandersnatch.][The][frumious Bandersnatch.][frumious][Bandersnatch.] *///:~ The poem first part Lewis Carroll’s "Jabberwocky," Through Looking Glass. You see regular expression pattern number parenthesized groups, consisting number non-whitespace characters (‘\S+’) followed number whitespace characters (‘\s+’). The goal capture last three words line; end line delimited ‘$’. However, normal behavior match ‘$’ end entire input sequence, must explicitly tell regular expression pay attention newlines within input. This accomplished ‘(?m)’ pattern flag beginning sequence (pattern flags shown shortly). 378 Thinking Java Bruce Eckel Exercise 12: (5) Modify Groups.java count unique words start capital letter. start() end() Following successful matching operation, start( ) returns start index previous match, end( ) returns index last character matched, plus one. Invoking either start( ) end( ) following unsuccessful matching operation (or attempting matching operation) produces IllegalStateException. The following program also demonstrates matches( ) lookingAt( ): 3 //: strings/StartEnd.java import java.util.regex.*; import static net.mindview.util.Print.*; public class StartEnd { public static String input = "As long injustice, whenever a\n" + "Targathian baby cries out, wherever distress\n" + "signal sounds among stars ... We’ll there.\n" + "This fine ship, fine crew ...\n" + "Never give up! Never surrender!"; private static class Display { private boolean regexPrinted = false; private String regex; Display(String regex) { this.regex = regex; } void display(String message) { if(!regexPrinted) { print(regex); regexPrinted = true; } print(message); } } static void examine(String s, String regex) { Display = new Display(regex); Pattern p = Pattern.compile(regex); Matcher = p.matcher(s); while(m.find()) d.display("find() ‘" + m.group() + "‘ start = "+ m.start() + " end = " + m.end()); if(m.lookingAt()) // No reset() necessary d.display("lookingAt() start = " + m.start() + " end = " + m.end()); if(m.matches()) // No reset() necessary d.display("matches() start = " + m.start() + " end = " + m.end()); } public static void main(String[] args) { for(String : input.split("\n")) { print("input : " + in); for(String regex : new String[]{"\\w*ere\\w*", "\\w*ever", "T\\w+", "Never.*?!"}) examine(in, regex); } } } /* Output: input : As long injustice, whenever 3 Quote one Commander Taggart’s speeches Galaxy Quest. Strings 379 \w*ere\w* find() ‘there’ start = 11 end = 16 \w*ever find() ‘whenever’ start = 31 end = 39 input : Targathian baby cries out, wherever distress \w*ere\w* find() ‘wherever’ start = 27 end = 35 \w*ever find() ‘wherever’ start = 27 end = 35 T\w+ find() ‘Targathian’ start = 0 end = 10 lookingAt() start = 0 end = 10 input : signal sounds among stars ... We’ll there. \w*ere\w* find() ‘there’ start = 43 end = 48 input : This fine ship, fine crew ... T\w+ find() ‘This’ start = 0 end = 4 lookingAt() start = 0 end = 4 input : Never give up! Never surrender! \w*ever find() ‘Never’ start = 0 end = 5 find() ‘Never’ start = 15 end = 20 lookingAt() start = 0 end = 5 Never.*?! find() ‘Never give up!’ start = 0 end = 14 find() ‘Never surrender!’ start = 15 end = 31 lookingAt() start = 0 end = 14 matches() start = 0 end = 31 *///:~ Notice find( ) locate regular expression anywhere input, lookingAt( ) matches( ) succeed regular expression starts matching beginning input. While matches( ) succeeds entire input matches regular expression, lookingAt( ) 4 succeeds first part input matches. Exercise 13: (2) Modify StartEnd.java uses Groups.POEM input, still produces positive outputs find( ), lookingAt( ) matches( ). Pattern flags An alternative compile( ) method accepts flags affect matching behavior: Pattern Pattern.compile(String regex, int flag) flag drawn among following Pattern class constants: 4 I idea came method name, it’s supposed refer to. But it’s reassuring know whoever comes nonintuitive method names still employed Sun. And apparent policy reviewing code designs still place. Sorry sarcasm, kind thing gets tiresome years. 380 Thinking Java Bruce Eckel Compile Flag Effect Pattern.CANON_EQ Two characters considered match if, if, full canonical decompositions match. The expression ‘\u003F’, example, match string ‘?’ flag specified. By default, matching take canonical equivalence account. Pattern.CASE INSENSITIVE (?i) By default, case-insensitive matching assumes characters USASCII character set matched. This flag allows pattern match without regard case (upper lower). Unicode-aware case-insensitive matching enabled specifying UNICODE_CASE flag conjunction flag. Pattern.COMMENTS (?x) In mode, whitespace ignored, embedded comments starting # ignored end line. Unix lines mode also enabled via embedded flag expression. Pattern.DOTALL (?s) In dotall mode, expression’.’ matches character, including line terminator. By default, ‘.’ expression match line terminators. Pattern.MULTILINE (?m) In multiline mode, expressions ‘^’ ‘$’ match beginning ending line, respectively.’^’ also matches beginning input string, ‘$’ also matches end input string. By default, expressions match beginning end entire input string. Pattern.UNICODE CASE (?u) Case-insensitive matching, enabled CASE_INSENSITIVE flag, done manner consistent Unicode Standard. By default, caseinsensitive matching assumes characters US-ASCII character set matched. Pattern.UNIX LINES (?d) In mode, ‘\n’ line terminator recognized behavior ‘.’, ‘^’, ‘$’. Particularly useful among flags Pattern.CASE_INSENSITIVE, Pattern.MULTILINE, Pattern.COMMENTS (which helpful clarity and/or documentation). Note behavior flags also obtained inserting parenthesized characters, shown beneath flags table, regular expression preceding place want mode take effect. Strings 381 You combine effect flags "OR" (‘|’) operation: //: strings/ReFlags.java import java.util.regex.*; public class ReFlags { public static void main(String[] args) { Pattern p = Pattern.compile("^java", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE); Matcher = p.matcher( "java regex\nJava regex\n" + "JAVA pretty good regular expressions\n" + "Regular expressions Java"); while(m.find()) System.out.println(m.group()); } } /* Output: java Java JAVA *///:~ This creates pattern match lines starting "Java," "Java," "JAVA," etc., attempt match line within multiline set (matches starting beginning character sequence following line terminator within character sequence). Note group( ) method produces matched portion. split() split( ) divides input string array String objects, delimited regular expression. String[] split(CharSequence input) String[] split(CharSequence input, int limit) This handy way break input text common boundary: //: strings/SplitDemo.java import java.util.regex.*; import java.util.*; import static net.mindview.util.Print.*; public class SplitDemo { public static void main(String[] args) { String input = "This!!unusual use!!of exclamation!!points"; print(Arrays.toString( Pattern.compile("!!").split(input))); // Only first three: print(Arrays.toString( Pattern.compile("!!").split(input, 3))); } } /* Output: [This, unusual use, exclamation, points] [This, unusual use, exclamation!!points] *///:~ The second form split( ) limits number splits occur. 382 Thinking Java Bruce Eckel Exercise 14: (1) Rewrite SplitDemo using String.split( ). Replace operations Regular expressions especially useful replace text. Here available methods: replaceFirst(String replacement) replaces first matching part input string replacement. replaceAll(String replacement) replaces every matching part input string replacement. appendReplacement(StringBuffer sbuf, String replacement) performs step-by-step replacements sbuf, rather replacing first one them, replaceFirst( ) replaceAll( ), respectively. This important method, allows call methods perform processing order produce replacement (replaceFirst( ) replaceAll( ) able put fixed strings). With method, programmatically pick apart groups create powerful replacements. appendTail(StringBuffer sbuf, String replacement) invoked one invocations appendReplacement( ) method order copy remainder input string. Here’s example shows use replace operations. The block commented text beginning extracted processed regular expressions use input rest example: //: strings/TheReplacements.java import java.util.regex.*; import net.mindview.util.*; import static net.mindview.util.Print.*; /*! Here’s block text use input regular expression matcher. Note we’ll first extract block text looking special delimiters, process extracted block. !*/ public class TheReplacements { public static void main(String[] args) throws Exception { String = TextFile.read("TheReplacements.java"); // Match specially commented block text above: Matcher mInput = Pattern.compile("/\\*!(.*)!\\*/", Pattern.DOTALL) .matcher(s); if(mInput.find()) = mInput.group(1); // Captured parentheses // Replace two spaces single space: = s.replaceAll(" {2,}", " "); // Replace one spaces beginning // line spaces. Must enable MULTILINE mode: = s.replaceAll("(?m)^ +", ""); print(s); = s.replaceFirst("[aeiou]", "(VOWEL1)"); StringBuffer sbuf = new StringBuffer(); Pattern p = Pattern.compile("[aeiou]"); Matcher = p.matcher(s); // Process find information Strings 383 // perform replacements: while(m.find()) m.appendReplacement(sbuf, m.group().toUpperCase()); // Put remainder text: m.appendTail(sbuf); print(sbuf); } } /* Output: Here’s block text use input regular expression matcher. Note we’ll first extract block text looking special delimiters, process extracted block. H(VOWEL1)rE’s A blOck Of tExt tO UsE As InpUt tO thE rEgUlAr ExprEssIOn mAtchEr. NOtE thAt wE’ll fIrst ExtrAct thE blOck Of tExt lOOkIng fOr thE spEcIAl dElImItErs, thEn prOcEss thE ExtrActEd blOck. *///:~ The file opened read using TextFile class net.mindview.util library (the code shown I/O chapter). The static read( ) method reads entire file returns String. mInput created match text (notice grouping parentheses) ‘/*!’ ‘!*/’. Then, two spaces reduced single space, space beginning line removed (in order lines beginning input, multiline mode must enabled). These two replacements performed equivalent (but convenient, case) replaceAll( ) that’s part String. Note since replacement used program, there’s extra cost way rather precompiling Pattern. replaceFirst( ) performs first replacement finds. In addition, replacement strings replaceFirst( ) replaceAll( ) literals, want perform processing replacement, don’t help. In case, need use appendReplacement( ), allows write amount code process performing replacement. In preceding example, group( ) selected processed—in situation, setting vowel found regular expression uppercase— resulting sbuf built. Normally, step perform replacements call appendTail( ), want simulate replaceFirst( ) (or "replace n"), replacement one time call appendTail( ) put rest sbuf. appendReplacement( ) also allows refer captured groups directly replacement string saying "$g", ‘g’ group number. However, simpler processing wouldn’t give desired results preceding program. reset() An existing Matcher object applied new character sequence using reset( ) methods: //: strings/Resetting.java import java.util.regex.*; public class Resetting { public static void main(String[] args) throws Exception { Matcher = Pattern.compile("[frb][aiu][gx]") .matcher("fix rug bags"); while(m.find()) 384 Thinking Java Bruce Eckel System.out.print(m.group() + " "); System.out.println(); m.reset("fix rig rags"); while(m.find()) System.out.print(m.group() + " "); } } /* Output: fix rug bag fix rig rag *///:~ reset( ) without arguments sets Matcher beginning current sequence. Regular expressions Java I/O Most examples far shown regular expressions applied static strings. The following example shows one way apply regular expressions search matches file. Inspired Unix’s grep, JGrep.java takes two arguments: file name regular expression want match. The output shows line match occurs match position(s) within line. //: strings/JGrep.java // A simple version "grep" program. // {Args: JGrep.java "\\b[Ssct]\\w+"} import java.util.regex.*; import net.mindview.util.*; public class JGrep { public static void main(String[] args) throws Exception { if(args.length < 2) { System.out.println("Usage: java JGrep file regex"); System.exit(0); } Pattern p = Pattern.compile(args[1]); // Iterate lines input file: int index = 0; Matcher = p.matcher(""); for(String line : new TextFile(args[0])) { m.reset(line); while(m.find()) System.out.println(index++ + ": " + m.group() + ": " + m.start()); } } } /* Output: (Sample) 0: strings: 4 1: simple: 10 2: the: 28 3: Ssct: 26 4: class: 7 5: static: 9 6: String: 26 7: throws: 41 8: System: 6 9: System: 6 10: compile: 24 11: through: 15 12: the: 23 13: the: 36 14: String: 8 15: System: 8 Strings 385 16: start: 31 *///:~ The file opened net.mindview.util.TextFile object (which shown I/O chapter), reads lines file ArrayList. This means foreach syntax iterate lines TextFile object. Although it’s possible create new Matcher object within loop, slightly optimal create empty Matcher object outside loop use reset( ) method assign line input Matcher. The result scanned find( ). The test arguments open JGrep.java file read input, search words starting [Ssct]. You learn much regular expressions Mastering Regular Expressions, 2nd Edition, Jeffrey E. F. Friedl (O’Reilly, 2002). There also numerous introductions regular expressions Internet, often find helpful information documentation languages like Perl Python. Exercise 15: (5) Modify JGrep.java accept flags arguments (e.g., Pattern.CASE_INSENSITIVE, Pattern.MULTILINE). Exercise 16: (5) Modify JGrep.java accept directory name file name argument (if directory provided, search include files directory). Hint: You generate list file names with: File[] files = new File(".").listFiles(); Exercise 17: (8) Write program reads Java source-code file (you provide file name command line) displays comments. Exercise 18: (8) Write program reads Java source-code file (you provide file name command line) displays string literals code. Exercise 19: (8) Building previous two exercises, write program examines Java source code produces class names used particular program. Scanning input Until relatively painful read data human-readable file standard input. The usual solution read line text, tokenize it, use various parse methods Integer, Double, etc., parse data: //: strings/SimpleRead.java import java.io.*; public class SimpleRead { public static BufferedReader input = new BufferedReader( new StringReader("Sir Robin Camelot\n22 1.61803")); public static void main(String[] args) { try { System.out.println("What name?"); String name = input.readLine(); System.out.println(name); System.out.println( "How old you? What favorite double?"); 386 Thinking Java Bruce Eckel System.out.println("(input: <age> <double>)"); String numbers = input.readLine(); System.out.println(numbers); String[] numArray = numbers.split(" "); int age = Integer.parseInt(numArray[0]); double favorite = Double.parseDouble(numArray[1]); System.out.format("Hi %s.\n", name); System.out.format("In 5 years %d.\n", age + 5); System.out.format("My favorite double %f.", favorite / 2); } catch(IOException e) { System.err.println("I/O exception"); } } } /* Output: What name? Sir Robin Camelot How old you? What favorite double? (input: <age> <double>) 22 1.61803 Hi Sir Robin Camelot. In 5 years 27. My favorite double 0.809015. *///:~ The input field uses classes java.io, officially introduced I/O chapter. A StringReader turns String readable stream, object used create BufferedReader BufferedReader readLine( ) method. The result input object read line time, standard input console. readLine( ) used get String line input. It’s fairly straightforward want get one input line data, two input values single line, things get messy—the line must split parse input separately. Here, splitting takes place creating numArray, note split( ) method introduced J2SE1.4, something else. The Scanner class, added Java SE5, relieves much burden scanning input: //: strings/BetterRead.java import java.util.*; public class BetterRead { public static void main(String[] args) { Scanner stdin = new Scanner(SimpleRead.input); System.out.println("What name?"); String name = stdin.nextLine(); System.out.println(name); System.out.println( "How old you? What favorite double?"); System.out.println("(input: <age> <double>)"); int age = stdin.nextInt(); double favorite = stdin.nextDouble(); System.out.println(age); System.out.println(favorite); System.out.format("Hi %s.\n", name); System.out.format("In 5 years %d.\n", age + 5); System.out.format("My favorite double %f.", favorite / 2); Strings 387 } } /* Output: What name? Sir Robin Camelot How old you? What favorite double? (input: <age> <double>) 22 1.61803 Hi Sir Robin Camelot. In 5 years 27. My favorite double 0.809015. *///:~ The Scanner constructor take kind input object, including File object (which also covered I/O chapter), InputStream, String, case Readable, interface introduced Java SE5 describe "something read( ) method." The BufferedReader previous example falls category. With Scanner, input, tokenizing, parsing ensconced various different kinds "next" methods. A plain next( ) returns next String token, "next" methods primitive types (except char) well BigDecimal Biglnteger. All "next" methods block, meaning return complete data token available input. There also corresponding "hasNext" methods return true next input token correct type. An interesting difference two previous examples lack try block IOExceptions BetterRead.java. One assumptions made Scanner IOException signals end input, swallowed Scanner. However, recent exception available ioException( ) method, able examine necessary. Exercise 20: (2) Create class contains int, long, float double String fields. Create constructor class takes single String argument, scans string various fields. Add toString( ) method demonstrate class works correctly. Scanner delimiters By default, Scanner splits input tokens along whitespace, also specify delimiter pattern form regular expression: //: strings/ScannerDelimiter.java import java.util.*; public class ScannerDelimiter { public static void main(String[] args) { Scanner scanner = new Scanner("12, 42, 78, 99, 42"); scanner.useDelimiter("\\s*,\\s*"); while(scanner.hasNextInt()) System.out.println(scanner.nextInt()); } } /* Output: 12 42 78 99 42 *///:~ 388 Thinking Java Bruce Eckel This example uses commas (surrounded arbitrary amounts whitespace) delimiter reading given String. This technique used read commadelimited files. In addition useDelimiter( ) setting delimiter pattern, also delimiter( ), returns current Pattern used delimiter. Scanning regular expressions In addition scanning predefined primitive types, also scan userdefined patterns, helpful scanning complex data. This example scans threat data log like firewall might produce: //: strings/ThreatAnalyzer.java import java.util.regex.*; import java.util.*; public class ThreatAnalyzer { static String threatData = "58.27.82.161@02/10/2005\n" + "204.45.234.40@02/11/2005\n" + "58.27.82.161@02/11/2005\n" + "58.27.82.161@02/12/2005\n" + "58.27.82.161@02/12/2005\n" + "[Next log section different data format]"; public static void main(String[] args) { Scanner scanner = new Scanner(threatData); String pattern = "(\\d+[.]\\d+[.]\\d+[.]\\d+)@" + "(\\d{2}/\\d{2}/\\d{4})"; while(scanner.hasNext(pattern)) { scanner.next(pattern); MatchResult match = scanner.match(); String ip = match.group(1); String date = match.group(2); System.out.format("Threat %s %s\n", date,ip); } } } /* Output: Threat 02/10/2005 58.27.82.161 Threat 02/11/2005 204.45.234.40 Threat 02/11/2005 58.27.82.161 Threat 02/12/2005 58.27.82.161 Threat 02/12/2005 58.27.82.161 *///:~ When use next( ) specific pattern, pattern matched next input token. The result made available match( ) method, see above, works like regular expression matching saw earlier. There’s one caveat scanning regular expressions. The pattern matched next input token only, pattern contains delimiter never matched. StringTokenizer Before regular expressions (in J2SE1.4) Scanner class (in Java SE5), way split string parts "tokenize" StringTokenizer. But it’s much easier succinct thing regular expressions Scanner class. Here’s simple comparison StringTokenizer two techniques: //: strings/ReplacingStringTokenizer.java Strings 389 import java.util.*; public class ReplacingStringTokenizer { public static void main(String[] args) { String input = "But I’m dead yet! I feel happy!"; StringTokenizer stoke = new StringTokenizer(input); while(stoke.hasMoreElements()) System.out.print(stoke.nextToken() + " "); System.out.println(); System.out.println(Arrays.toString(input.split(" "))); Scanner scanner = new Scanner(input); while(scanner.hasNext()) System.out.print(scanner.next() + " "); } } /* Output: But I’m dead yet! I feel happy! [But, I’m, not, dead, yet!, I, feel, happy!] But I’m dead yet! I feel happy! *///:~ With regular expressions Scanner objects, also split string parts using complex patterns—something that’s difficult StringTokenizer. It seems safe say StringTokenizer obsolete. 390 Thinking Java Bruce Eckel Summary In past, Java support string manipulation rudimentary, recent editions language we’ve seen far sophisticated support adopted languages. At point, support strings reasonably complete, although must sometimes pay attention efficiency details appropriate use StringBuilder. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Strings 391 Type Information Runtime type information (RTTI) allows discover use type information program running. It frees constraint type-oriented things compile time, enable powerful programs. The need RTTI uncovers plethora interesting (and often perplexing) 0 0 design issues, raises fundamental questions structure programs. This chapter looks ways Java allows discover information objects classes run time. This takes two forms: "traditional" RTTI, assumes types available compile time, reflection mechanism, allows discover use class information solely run time. The need RTTI Consider now-familiar example class hierarchy uses polymorphism. The generic type base class Shape, specific derived types Circle, Square, Triangle: This typical class hierarchy diagram, base class top derived classes growing downward. The normal goal object-oriented programming code manipulate references base type (Shape, case), decide extend program adding new class (such Rhomboid, derived Shape), bulk code affected. In example, dynamically bound method Shape interface draw( ), intent client programmer call draw( ) generic Shape reference. In derived classes, draw( ) overridden, dynamically bound method, proper behavior occur even though called generic Shape reference. That’s polymorphism. Thus, generally create specific object (Circle, Square, Triangle), upcast Shape (forgetting specific type object), use anonymous Shape reference rest program. You might code Shape hierarchy follows: //: typeinfo/Shapes.java import java.util.*; abstract class Shape { void draw() { System.out.println(this + ".draw()"); } abstract public String toString(); } class Circle extends Shape { public String toString() { return "Circle"; } } class Square extends Shape { public String toString() { return "Square"; } } class Triangle extends Shape { public String toString() { return "Triangle"; } } public class Shapes { public static void main(String[] args) { List<Shape> shapeList = Arrays.asList( new Circle(), new Square(), new Triangle() ); for(Shape shape : shapeList) shape.draw(); } } /* Output: Circle.draw() Square.draw() Triangle.draw() *///:~ The base class contains draw( ) method indirectly uses toString( ) print identifier class passing System.out.println( ) (notice toString( ) declared abstract force inheritors override it, prevent instantiation plain Shape). If object appears string concatenation expression (involving ‘+’ String objects), toString( ) method automatically called produce String representation object. Each derived classes overrides toString( ) method (from Object) draw( ) ends (polymorphically) printing something different case. In example, upcast occurs shape placed List<Shape>. During upcast Shape, fact objects specific types Shape lost. To array, Shapes. At point fetch element array, container—which actually holding everything Object—automatically casts result back Shape. This basic form RTTI, casts checked run time correctness. That’s RTTI means: At run time, type object identified. In case, RTTI cast partial: The Object cast Shape, way Circle, Square, Triangle. That’s thing know point List<Shape> full Shapes. At compile time, enforced container Java generic system, run time cast ensures it. Now polymorphism takes exact code that’s executed Shape determined whether reference Circle, Square, Triangle. And general, be; want bulk code know little possible specific types objects, deal general representation family objects (in case, Shape). As result, code easier write, read, maintain, designs easier implement, understand, change. So polymorphism general goal object-oriented programming. 394 Thinking Java Bruce Eckel But special programming problem that’s easiest solve know exact type generic reference? For example, suppose want allow users highlight shapes particular type turning special color. This way, find triangles screen highlighting them. Or perhaps method needs "rotate" list shapes, makes sense rotate circle you’d like skip circles. With RTTI, ask Shape reference exact type it’s referring to, thus select isolate special cases. The Class object To understand RTTI works Java, must first know type information represented run time. This accomplished special kind object called Class object, contains information class. In fact, Class object used create "regular" objects class. Java performs RTTI using Class object, even you’re something like cast. The class Class also number ways use RTTI. There’s one Class object class part program. That is, time write compile new class, single Class object also created (and stored, appropriately enough, identically named .class file). To make object class, Java Virtual Machine (JVM) that’s executing program uses subsystem called class loader. The class loader subsystem actually comprise chain class loaders, there’s one primordial class loader, part JVM implementation. The primordial class loader loads so-called trusted classes, including Java API classes, typically local disk. It’s usually necessary additional class loaders chain, special needs (such loading classes special way support Web server applications, downloading classes across network), way hook additional class loaders. All classes loaded JVM dynamically, upon first use class. This happens program makes first reference static member class. It turns constructor also static method class, even though static keyword used constructor. Therefore, creating new object class using new operator also counts reference static member class. Thus, Java program isn’t completely loaded begins, instead pieces loaded necessary. This different many traditional languages. Dynamic loading enables behavior difficult impossible duplicate statically loaded language like C++. The class loader first checks see Class object type loaded. If not, default class loader finds .class file name (an add-on class loader might, example, look bytecodes database instead). As bytes class loaded, verified ensure corrupted comprise bad Java code (this one lines defense security Java). Once Class object type memory, used create objects type. Here’s program prove it: //: typeinfo/SweetShop.java // Examination way class loader works. import static net.mindview.util.Print.*; class Candy { static { print("Loading Candy"); } } Type Information 395 class Gum { static { print("Loading Gum"); } } class Cookie { static { print("Loading Cookie"); } } public class SweetShop { public static void main(String[] args) { print("inside main"); new Candy(); print("After creating Candy"); try { Class.forName("Gum"); } catch(ClassNotFoundException e) { print("Couldn’t find Gum"); } print("After Class.forName(\"Gum\")"); new Cookie(); print("After creating Cookie"); } } /* Output: inside main Loading Candy After creating Candy Loading Gum After Class.forName("Gum") Loading Cookie After creating Cookie *///:~ Each classes Candy, Gum, Cookie static clause executed class loaded first time. Information printed tell loading occurs class. In main( ), object creations spread print statements help detect time loading. You see output Class object loaded it’s needed, static initialization performed upon class loading. A particularly interesting line is: Class.forName("Gum"); All Class objects belong class Class. A Class object like object, get manipulate reference (that’s loader does). One ways get reference Class object static forName( ) method, takes String containing textual name (watch spelling capitalization!) particular class want reference for. It returns Class reference, ignored here; call forName( ) made side effect, load class Gum isn’t already loaded. In process loading, Gum’s static clause executed. In preceding example, Class.forName( ) fails can’t find class you’re trying load, throw ClassNotFoundException. Here, simply report problem move on, sophisticated programs, might try fix problem inside exception handler. 396 Thinking Java Bruce Eckel Anytime want use type information run time, must first get reference appropriate Class object. Class.forName( ) one convenient way this, don’t need object type order get Class reference. However, already object type you’re interested in, fetch Class reference calling method that’s part Object root class: getClass( ). This returns Class reference representing actual type object. Class many interesting methods; them: //: typeinfo/toys/ToyTest.java // Testing class Class. package typeinfo.toys; import static net.mindview.util.Print.*; interface HasBatteries {} interface Waterproof {} interface Shoots {} class Toy { // Comment following default constructor // see NoSuchMethodError (*1*) Toy() {} Toy(int i) {} } class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots { FancyToy() { super(1); } } public class ToyTest { static void printInfo(Class cc) { print("Class name: " + cc.getName() + " interface? [" + cc.isInterface() + "]"); print("Simple name: " + cc.getSimpleName()); print("Canonical name : " + cc.getCanonicalName()); } public static void main(String[] args) { Class c = null; try { c = Class.forName("typeinfo.toys.FancyToy"); } catch(ClassNotFoundException e) { print("Can’t find FancyToy"); System.exit(1); } printInfo(c); for(Class face : c.getInterfaces()) printInfo(face); Class = c.getSuperclass(); Object obj = null; try { // Requires default constructor: obj = up.newInstance(); } catch(InstantiationException e) { print("Cannot instantiate"); System.exit(1); } catch(IllegalAccessException e) { print("Cannot access"); System.exit(1); } printInfo(obj.getClass()); } } /* Output: Type Information 397 Class name: typeinfo.toys.FancyToy interface? [false] Simple name: FancyToy Canonical name : typeinfo.toys.FancyToy Class name: typeinfo.toys.HasBatteries interface? [true] Simple name: HasBatteries Canonical name : typeinfo.toys.HasBatteries Class name: typeinfo.toys.Waterproof interface? [true] Simple name: Waterproof Canonical name : typeinfo.toys.Waterproof Class name: typeinfo.toys.Shoots interface? [true] Simple name: Shoots Canonical name : typeinfo.toys.Shoots Class name: typeinfo.toys.Toy interface? [false] Simple name: Toy Canonical name : typeinfo.toys.Toy *///:~ FancyToy inherits Toy implements interfaces HasBatteries, Waterproof, Shoots. In main( ), Class reference created initialized FancyToy Class using forName( ) inside appropriate try block. Notice must use fully qualified name (including package name) string pass forName( ). printInfo( ) uses getName( ) produce fully qualified class name, getSimpleName( ) getCanonicalName( ) (introduced Java SE5) produce name without package, fully qualified name, respectively. As name implies, islnterface( ) tells whether Class object represents interface. Thus, Class object find everything want know type. The Class.getlnterfaces( ) method called main( ) returns array Class objects representing interfaces contained Class object interest. If Class object, also ask direct base class using getSuperclass( ). This returns Class reference query. Thus discover object’s entire class hierarchy run time. The newlnstance( ) method Class way implement "virtual constructor," allows say, "I don’t know exactly type are, create properly anyway." In preceding example, Class reference type information known compile time. And create new instance, get back Object reference. But reference pointing Toy object. Of course, send messages accepted Object, must investigate bit casting. In addition, class that’s created newlnstance( ) must default constructor. Later chapter, you’ll see dynamically create objects classes using constructor, Java reflection API. Exercise 1: (1) In ToyTest.java, comment Toy’s default constructor explain happens. Exercise 2: (2) Incorporate new kind interface ToyTest.java verify detected displayed properly. Exercise 3: (2) Add Rhomboid Shapes.java. Create Rhomboid, upcast Shape, downcast back Rhomboid. Try downcasting Circle see happens. Exercise 4: (2) Modify previous exercise uses instanceof check type performing downcast. 398 Thinking Java Bruce Eckel Exercise 5: (3) Implement rotate(Shape) method Shapes.java, checks see rotating Circle (and, so, doesn’t perform operation). Exercise 6: (4) Modify Shapes.java "highlight" (set flag in) shapes particular type. The toString( ) method derived Shape indicate whether Shape "highlighted." Exercise 7: (3) Modify SweetShop.java type object creation controlled command-line argument. That is, command line "Java Sweetshop Candy," Candy object created. Notice control Class objects loaded via commandline argument. Exercise 8: (5) Write method takes object recursively prints classes object’s hierarchy. Exercise 9: (5) Modify previous exercise uses Class.getDeclaredFields( ) also display information fields class. Exercise 10: (3) Write program determine whether array char primitive type true Object. Class literals Java provides second way produce reference Class object: class literal. In preceding program would look like: FancyToy.class; simpler, also safer since it’s checked compile time (and thus need placed try block). Because eliminates forName( ) method call, it’s also efficient. Class literals work regular classes well interfaces, arrays, primitive types. In addition, there’s standard field called TYPE exists primitive wrapper classes. The TYPE field produces reference Class object associated primitive type, that: ... equivalent ... boolean.class Boolean.TYPE char.class Character.TYPE byte.class Byte.TYPE short.class Short.TYPE int.class Integer.TYPE long.class Long.TYPE float.class Float.TYPE double.class Double.TYPE void.class Void.TYPE My preference use ".class" versions can, since they’re consistent regular classes. Type Information 399 It’s interesting note creating reference Class object using ".class" doesn’t automatically initialize Class object. There actually three steps preparing class use: 1. Loading, performed class loader. This finds bytecodes (usually, necessarily, disk classpath) creates Class object bytecodes. 2. Linking. The link phase verifies bytecodes class, allocates storage static fields, necessary, resolves references classes made class. 3. Initialization. If there’s superclass, initialize that. Execute static initializers static initialization blocks. Initialization delayed first reference static method (the constructor implicitly static) non-constant static field: //: typeinfo/ClassInitialization.java import java.util.*; class Initable { static final int staticFinal = 47; static final int staticFinal2 = ClassInitialization.rand.nextInt(1000); static { System.out.println("Initializing Initable"); } } class Initable2 { static int staticNonFinal = 147; static { System.out.println("Initializing Initable2"); } } class Initable3 { static int staticNonFinal = 74; static { System.out.println("Initializing Initable3"); } } public class ClassInitialization { public static Random rand = new Random(47); public static void main(String[] args) throws Exception { Class initable = Initable.class; System.out.println("After creating Initable ref"); // Does trigger initialization: System.out.println(Initable.staticFinal); // Does trigger initialization: System.out.println(Initable.staticFinal2); // Does trigger initialization: System.out.println(Initable2.staticNonFinal); Class initable3 = Class.forName("Initable3"); System.out.println("After creating Initable3 ref"); System.out.println(Initable3.staticNonFinal); } } /* Output: After creating Initable ref 47 400 Thinking Java Bruce Eckel Initializing Initable 258 Initializing Initable2 147 Initializing Initable3 After creating Initable3 ref 74 *///:~ Effectively, initialization "as lazy possible." From creation initable reference, see using .class syntax get reference class doesn’t cause initialization. However, Class.forName( ) initializes class immediately order produce Class reference, see creation initable3. If static final value "compile-time constant," Initable.staticFinal, value read without causing Initable class initialized. Making field static final, however, guarantee behavior: accessing Initable.staticFinal2 forces class initialization cannot compile-time constant. If static field final, accessing always requires linking (to allocate storage field) initialization (to initialize storage) read, see access Initable2.staticNonFinal. Generic class references A Class reference points Class object, manufactures instances classes contains method code instances. It also contains statics class. So Class reference really indicate exact type it’s pointing to: object class Class. However, designers Java SE5 saw opportunity make bit specific allowing constrain type Class object Class reference pointing to, using generic syntax. In following example, syntaxes correct: //: typeinfo/GenericClassReferences.java public class GenericClassReferences { public static void main(String[] args) { Class intClass = int.class; Class<Integer> genericIntClass = int.class; genericIntClass = Integer.class; // Same thing intClass = double.class; // genericIntClass = double.class; // Illegal } } ///:~ The ordinary class reference produce warning. However, see ordinary class reference reassigned Class object, whereas generic class reference assigned declared type. By using generic syntax, allow compiler enforce extra type checking. What you’d like loosen constraint little? Initially, seems like ought able something like: Class<Number> genericNumberClass = int.class; This would seem make sense Integer inherited Number. But doesn’t work, Integer Class object subclass Number Class Type Information 401 object (this may seem like subtle distinction; we’ll look deeply Generics chapter). To loosen constraints using generic Class references, I employ wildcard, part Java generics. The wildcard symbol ‘?’, indicates "anything." So add wildcards ordinary Class reference example produce results: //: typeinfo/WildcardClassReferences.java public class WildcardClassReferences { public static void main(String[] args) { Class<?> intClass = int.class; intClass = double.class; } } ///:~ In Java SE5, Class<?> preferred plain Class, even though equivalent plain Class, saw, doesn’t produce compiler warning. The benefit Class<?> indicates aren’t using non-specific class reference accident, ignorance. You chose non-specific version. In order create Class reference constrained type subtype, combine wildcard extends keyword create bound. So instead saying Class<Number>, say: //: typeinfo/BoundedClassReferences.java public class BoundedClassReferences { public static void main(String[] args) { Class<? extends Number> bounded = int.class; bounded = double.class; bounded = Number.class; // Or anything else derived Number. } } ///:~ The reason adding generic syntax Class references provide compile-time type checking, something wrong find little sooner. You can’t actually go astray ordinary Class references, make mistake won’t find run time, inconvenient. Here’s example uses generic class syntax. It stores class reference, later produces List filled objects generates using newlnstance( ): //: typeinfo/FilledList.java import java.util.*; class CountedInteger { private static long counter; private final long id = counter++; public String toString() { return Long.toString(id); } } public class FilledList<T> { private Class<T> type; public FilledList(Class<T> type) { this.type = type; } public List<T> create(int nElements) { List<T> result = new ArrayList<T>(); try { 402 Thinking Java Bruce Eckel for(int = 0; < nElements; i++) result.add(type.newInstance()); } catch(Exception e) { throw new RuntimeException(e); } return result; } public static void main(String[] args) { FilledList<CountedInteger> fl = new FilledList<CountedInteger>(CountedInteger.class); System.out.println(fl.create(15)); } } /* Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] *///:~ Notice class must assume type works default constructor (one without arguments), you’ll get exception isn’t case. The compiler issue warnings program. An interesting thing happens use generic syntax Class objects: newlnstance( ) return exact type object, rather basic Object saw ToyTest.java. This somewhat limited: //: typeinfo/toys/GenericToyTest.java // Testing class Class. package typeinfo.toys; public class GenericToyTest { public static void main(String[] args) throws Exception { Class<FancyToy> ftClass = FancyToy.class; // Produces exact type: FancyToy fancyToy = ftClass.newInstance(); Class<? super FancyToy> = ftClass.getSuperclass(); // This won’t compile: // Class<Toy> up2 = ftClass.getSuperclass(); // Only produces Object: Object obj = up.newInstance(); } } ///:~ If get superclass, compiler allow say superclass reference "some class superclass FancyToy" seen expression Class <? super FancyToy >. It accept declaration Class<Toy>. This seems bit strange getSuperclass( ) returns base class (not interface) compiler knows class compile time—in case, Toy.class, "some superclass FancyToy." In event, vagueness, return value up.newlnstance( ) precise type, Object. New cast syntax Java SE5 also adds casting syntax use Class references, cast( ) method: //: typeinfo/ClassCasts.java class Building {} class House extends Building {} Type Information 403 public class ClassCasts { public static void main(String[] args) { Building b = new House(); Class<House> houseType = House.class; House h = houseType.cast(b); h = (House)b; // ... this. } } ///:~ The cast( ) method takes argument object casts type Class reference. Of course, look code seems like lot extra work compared last line main( ), thing. The new casting syntax useful situations can’t use ordinary cast. This usually happens you’re writing generic code (which you’ll learn Generics chapter), you’ve stored Class reference want use cast later time. It turns rare thing—I found one instance cast( ) used entire Java SE5 library (it com.sun.mirror.util.DeclarationFilter). Another new feature usage Java SE5 library: Class.asSubclass( ). This allows cast class object specific type. Checking cast So far, you’ve seen forms RTTI, including: 1. The classic cast; e.g., "(Shape)," uses RTTI make sure cast correct. This throw ClassCastException you’ve performed bad cast. 2. The Class object representing type object. The Class object queried useful runtime information. In C++, classic cast "(Shape)" perform RTTI. It simply tells compiler treat object new type. In Java, perform type check, cast often called "type-safe downcast." The reason term "downcast" historical arrangement class hierarchy diagram. If casting Circle Shape upcast, casting Shape Circle downcast. However, knows Circle also Shape, compiler freely allows upcast assignment, without requiring explicit cast syntax. The compiler cannot know, given Shape, Shape actually is—it could exactly Shape, could subtype Shape, Circle, Square, Triangle type. At compile time, compiler sees Shape. Thus, won’t allow perform downcast assignment without using explicit cast, tell extra information allows know particular type (the compiler check see downcast reasonable, won’t let downcast type that’s actually subclass). There’s third form RTTI Java. This keyword instanceof, tells object instance particular type. It returns boolean use form question, like this: if(x instanceof Dog) ((Dog)x).bark(); The statement checks see object x belongs class Dog casting x Dog. It’s important use instanceof downcast don’t information tells type object; otherwise, you’ll end ClassCastException. 404 Thinking Java Bruce Eckel Ordinarily, might hunting one type (triangles turn purple, example), easily tally objects using instanceof. For example, suppose family classes describe Pets (and people, feature come handy later example). Each Individual hierarchy id optional name. Although classes follow inherit Individual, complexities Individual class, code shown explained Containers Depth chapter. As see, it’s really necessary see code Individual point—you need know create without name, Individual method id( ) returns unique identifier (created counting object). There’s also toString( ) method; don’t provide name Individual, toString( ) produces simple type name. Here class hierarchy inherits Individual: //: typeinfo/pets/Person.java package typeinfo.pets; public class Person extends Individual { public Person(String name) { super(name); } } ///:~ //: typeinfo/pets/Pet.java package typeinfo.pets; public class Pet extends Individual { public Pet(String name) { super(name); } public Pet() { super(); } } ///:~ //: typeinfo/pets/Dog.java package typeinfo.pets; public class Dog extends Pet { public Dog(String name) { super(name); } public Dog() { super(); } } ///:~ //: typeinfo/pets/Mutt.java package typeinfo.pets; public class Mutt extends Dog { public Mutt(String name) { super(name); } public Mutt() { super(); } } ///:~ //: typeinfo/pets/Pug.java package typeinfo.pets; public class Pug extends Dog { public Pug(String name) { super(name); } public Pug() { super(); } } ///:~ //: typeinfo/pets/Cat.java package typeinfo.pets; public class Cat extends Pet { public Cat(String name) { super(name); } public Cat() { super(); } } ///:~ //: typeinfo/pets/EgyptianMau.java Type Information 405 package typeinfo.pets; public class EgyptianMau extends Cat { public EgyptianMau(String name) { super(name); } public EgyptianMau() { super(); } } ///:~ //: typeinfo/pets/Manx.java package typeinfo.pets; public class Manx extends Cat { public Manx(String name) { super(name); } public Manx() { super(); } } ///:~ //: typeinfo/pets/Cymric.java package typeinfo.pets; public class Cymric extends Manx { public Cymric(String name) { super(name); } public Cymric() { super(); } } ///:~ //: typeinfo/pets/Rodent.java package typeinfo.pets; public class Rodent extends Pet { public Rodent(String name) { super(name); } public Rodent() { super(); } } ///:~ //: typeinfo/pets/Rat.java package typeinfo.pets; public class Rat extends Rodent { public Rat(String name) { super(name); } public Rat() { super(); } } ///:~ //: typeinfo/pets/Mouse.java package typeinfo.pets; public class Mouse extends Rodent { public Mouse(String name) { super(name); } public Mouse() { super(); } } ///:~ //: typeinfo/pets/Hamster.java package typeinfo.pets; public class Hamster extends Rodent { public Hamster(String name) { super(name); } public Hamster() { super(); } } ///:~ Next, need way randomly create different types pets, convenience, create arrays Lists pets. To allow tool evolve several different implementations, we’ll define abstract class: //: typeinfo/pets/PetCreator.java // Creates random sequences Pets. package typeinfo.pets; 406 Thinking Java Bruce Eckel import java.util.*; public abstract class PetCreator { private Random rand = new Random(47); // The List different types Pet create: public abstract List<Class<? extends Pet>> types(); public Pet randomPet() { // Create one random Pet int n = rand.nextInt(types().size()); try { return types().get(n).newInstance(); } catch(InstantiationException e) { throw new RuntimeException(e); } catch(IllegalAccessException e) { throw new RuntimeException(e); } } public Pet[] createArray(int size) { Pet[] result = new Pet[size]; for(int = 0; < size; i++) result[i] = randomPet(); return result; } public ArrayList<Pet> arrayList(int size) { ArrayList<Pet> result = new ArrayList<Pet>(); Collections.addAll(result, createArray(size)); return result; } } ///:~ The abstract getTypes( ) method defers derived class get List Class objects (this variation Template Method design pattern). Notice type class specified "anything derived Pet," newlnstance( ) produces Pet without requiring cast. randomPet( ) randomly indexes List uses selected Class object generate new instance class Class.newlnstance( ). The createArray( ) method uses randomPet( ) fill array, arrayList( ) uses createArray( ) turn. You get two kinds exceptions calling newlnstance( ). You see handled catch clauses following try block. Again, names exceptions relatively useful explanations went wrong (IllegalAccessException relates violation Java security mechanism, case default constructor private). When derive subclass PetCreator, thing need supply List types pet want create using randomPet( ) methods. The getTypes( ) method normally return reference static List. Here’s implementation using forName( ): //: typeinfo/pets/ForNameCreator.java package typeinfo.pets; import java.util.*; public class ForNameCreator extends PetCreator { private static List<Class<? extends Pet>> types = new ArrayList<Class<? extends Pet>>(); // Types want randomly created: private static String[] typeNames = { "typeinfo.pets.Mutt", "typeinfo.pets.Pug", "typeinfo.pets.EgyptianMau", "typeinfo.pets.Manx", "typeinfo.pets.Cymric", Type Information 407 "typeinfo.pets.Rat", "typeinfo.pets.Mouse", "typeinfo.pets.Hamster" }; @SuppressWarnings("unchecked") private static void loader() { try { for(String name : typeNames) types.add( (Class<? extends Pet>)Class.forName(name)); } catch(ClassNotFoundException e) { throw new RuntimeException(e); } } static { loader(); } public List<Class<? extends Pet>> types() {return types;} } ///:~ The loader( ) method creates List Class objects using Class.forName( ). This may generate ClassNotFoundException, makes sense since you’re passing String cannot validated compile time. Since Pet objects package typeinfo, package name must used referring classes. In order produce typed List Class objects, cast required, produces compile-time warning. The loader( ) method defined separately placed inside static initialization clause @SuppressWarnings annotation cannot placed directly onto static initialization clause. To count Pets, need tool keeps track quantities various different types Pets. A Map perfect this; keys Pet type names values Integers hold Pet quantities. This way, say, "How many Hamster objects there?" We use instanceof count Pets: //: typeinfo/PetCount.java // Using instanceof. import typeinfo.pets.*; import java.util.*; import static net.mindview.util.Print.*; public class PetCount { static class PetCounter extends HashMap<String,Integer> { public void count(String type) { Integer quantity = get(type); if(quantity == null) put(type, 1); else put(type, quantity + 1); } } public static void countPets(PetCreator creator) { PetCounter counter= new PetCounter(); for(Pet pet : creator.createArray(20)) { // List individual pet: printnb(pet.getClass().getSimpleName() + " "); if(pet instanceof Pet) counter.count("Pet"); if(pet instanceof Dog) counter.count("Dog"); if(pet instanceof Mutt) counter.count("Mutt"); if(pet instanceof Pug) counter.count("Pug"); if(pet instanceof Cat) 408 Thinking Java Bruce Eckel counter.count("Cat"); if(pet instanceof Manx) counter.count("EgyptianMau"); if(pet instanceof Manx) counter.count("Manx"); if(pet instanceof Manx) counter.count("Cymric"); if(pet instanceof Rodent) counter.count("Rodent"); if(pet instanceof Rat) counter.count("Rat"); if(pet instanceof Mouse) counter.count("Mouse"); if(pet instanceof Hamster) counter.count("Hamster"); } // Show counts: print(); print(counter); } public static void main(String[] args) { countPets(new ForNameCreator()); } } /* Output: Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric {Pug=3, Cat=9, Hamster=1, Cymric=7, Mouse=2, Mutt=3, Rodent=5, Pet=20, Manx=7, EgyptianMau=7, Dog=6, Rat=2} *///:~ In countPets( ), array randomly filled Pets using PetCreator. Then Pet array tested counted using instanceof. There’s rather narrow restriction instanceof: You compare named type only, Class object. In preceding example might feel it’s tedious write instanceof expressions, you’re right. But way cleverly automate instanceof creating array Class objects comparing instead (stay tuned—you’ll see alternative). This isn’t great restriction might think, you’ll eventually understand design probably flawed end writing lot instanceof expressions. Using class literals If reimplement PetCreator using class literals, result cleaner many ways: //: typeinfo/pets/LiteralPetCreator.java // Using class literals. package typeinfo.pets; import java.util.*; public class LiteralPetCreator extends PetCreator { // No try block needed. @SuppressWarnings("unchecked") public static final List<Class<? extends Pet>> allTypes = Collections.unmodifiableList(Arrays.asList( Pet.class, Dog.class, Cat.class, Rodent.class, Mutt.class, Pug.class, EgyptianMau.class, Manx.class, Cymric.class, Rat.class, Mouse.class,Hamster.class)); // Types random creation: private static final List<Class<? extends Pet>> types = allTypes.subList(allTypes.indexOf(Mutt.class), Type Information 409 allTypes.size()); public List<Class<? extends Pet>> types() { return types; } public static void main(String[] args) { System.out.println(types); } } /* Output: [class typeinfo.pets.Mutt, class typeinfo.pets.Pug, class typeinfo.pets.EgyptianMau, class typeinfo.pets.Manx, class typeinfo.pets.Cymric, class typeinfo.pets.Rat, class typeinfo.pets.Mouse, class typeinfo.pets.Hamster] *///:~ In upcoming PetCount3.java example, need pre-load Map Pet types (not ones randomly generated), allTypes List necessary. The types list portion allTypes (created using List.subList( )) includes exact pet types, used random Pet generation. This time, creation types need surrounded try block since it’s evaluated compile time thus won’t throw exceptions, unlike Class.forName( ). We two implementations PetCreator typeinfo.pets library. In order provide second one default implementation, create Faqade utilizes LiteralPetCreator: //: typeinfo/pets/Pets.java // Facade produce default PetCreator. package typeinfo.pets; import java.util.*; public class Pets { public static final PetCreator creator = new LiteralPetCreator(); public static Pet randomPet() { return creator.randomPet(); } public static Pet[] createArray(int size) { return creator.createArray(size); } public static ArrayList<Pet> arrayList(int size) { return creator.arrayList(size); } } ///:~ This also provides indirection randomPet( ), createArray( ) arrayList( ). Because PetCount.countPets( ) takes PetCreator argument, easily test LiteralPetCreator (via Facade): //: typeinfo/PetCount2.java import typeinfo.pets.*; public class PetCount2 { public static void main(String[] args) { PetCount.countPets(Pets.creator); } } /* (Execute see output) *///:~ The output PetCount.java. 410 Thinking Java Bruce Eckel A dynamic instanceof The Class.islnstance( ) method provides way dynamically test type object. Thus, tedious instanceof statements removed PetCount.java: //: typeinfo/PetCount3.java // Using isInstance() import typeinfo.pets.*; import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class PetCount3 { static class PetCounter extends LinkedHashMap<Class<? extends Pet>,Integer> { public PetCounter() { super(MapData.map(LiteralPetCreator.allTypes, 0)); } public void count(Pet pet) { // Class.isInstance() eliminates instanceofs: for(Map.Entry<Class<? extends Pet>,Integer> pair : entrySet()) if(pair.getKey().isInstance(pet)) put(pair.getKey(), pair.getValue() + 1); } public String toString() { StringBuilder result = new StringBuilder("{"); for(Map.Entry<Class<? extends Pet>,Integer> pair : entrySet()) { result.append(pair.getKey().getSimpleName()); result.append("="); result.append(pair.getValue()); result.append(", "); } result.delete(result.length()-2, result.length()); result.append("}"); return result.toString(); } } public static void main(String[] args) { PetCounter petCount = new PetCounter(); for(Pet pet : Pets.createArray(20)) { printnb(pet.getClass().getSimpleName() + " "); petCount.count(pet); } print(); print(petCount); } } /* Output: Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric {Pet=20, Dog=6, Cat=9, Rodent=5, Mutt=3, Pug=3, EgyptianMau=2, Manx=7, Cymric=5, Rat=2, Mouse=2, Hamster=1} *///:~ In order count different types Pet, PetCounter Map preloaded types LiteralPetCreator.allTypes. This uses net.mindview.util.MapData class, takes Iterable (the allTypes List) constant value (zero, case), fills Map keys taken allTypes values zero). Without pre-loading Map, would end counting types randomly generated, base types like Pet Cat. Type Information 411 You see isInstance( ) method eliminated need instanceof expressions. In addition, means add new types Pet simply changing LiteralPetCreator.types array; rest program need modification (as using instanceof expressions). The toString( ) method overloaded easier-to-read output still matches typical output see printing Map. Counting recursively The Map PetCount3.PetCounter pre-loaded different Pet classes. Instead pre-loading map, use Class.isAssignableFrom( ) create general-purpose tool limited counting Pets: //: net/mindview/util/TypeCounter.java // Counts instances type family. package net.mindview.util; import java.util.*; public class TypeCounter extends HashMap<Class<?>,Integer>{ private Class<?> baseType; public TypeCounter(Class<?> baseType) { this.baseType = baseType; } public void count(Object obj) { Class<?> type = obj.getClass(); if(!baseType.isAssignableFrom(type)) throw new RuntimeException(obj + " incorrect type: " + type + ", type subtype " + baseType); countClass(type); } private void countClass(Class<?> type) { Integer quantity = get(type); put(type, quantity == null ? 1 : quantity + 1); Class<?> superClass = type.getSuperclass(); if(superClass != null && baseType.isAssignableFrom(superClass)) countClass(superClass); } public String toString() { StringBuilder result = new StringBuilder("{"); for(Map.Entry<Class<?>,Integer> pair : entrySet()) { result.append(pair.getKey().getSimpleName()); result.append("="); result.append(pair.getValue()); result.append(", "); } result.delete(result.length()-2, result.length()); result.append("}"); return result.toString(); } } ///:~ The count( ) method gets Class argument, uses isAssignableFrom( ) perform runtime check verify object you’ve passed actually belongs hierarchy interest. countClass( ) first counts exact type class. Then, baseType assignable superclass, countClass( ) called recursively superclass. 412 Thinking Java Bruce Eckel //: typeinfo/PetCount4.java import typeinfo.pets.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class PetCount4 { public static void main(String[] args) { TypeCounter counter = new TypeCounter(Pet.class); for(Pet pet : Pets.createArray(20)) { printnb(pet.getClass().getSimpleName() + " "); counter.count(pet); } print(); print(counter); } } /* Output: (Sample) Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric {Mouse=2, Dog=6, Manx=7, EgyptianMau=2, Rodent=5, Pug=3, Mutt=3, Cymric=5, Cat=9, Hamster=1, Pet=20, Rat=2} *///:~ As see output, base types well exact types counted. Exercise 11: (2) Add Gerbil typeinfo.pets library modify examples chapter adapt new class. Exercise 12: (3) Use TypeCounter CoffeeGenerator.java class Generics chapter. Exercise 13: (3) Use TypeCounter RegisteredFactories.java example chapter. Registered factories A problem generating objects Pets hierarchy fact every time add new type Pet hierarchy must remember add entries LiteralPetCreator.java. In system add classes regular basis become problematic. You might think adding static initializer subclass, initializer would add class list somewhere. Unfortunately, static initializers called class first loaded, chicken-and-egg problem: The generator doesn’t class list, never create object class, class won’t get loaded placed list. Basically, you’re forced create list yourself, hand (unless want write tool searches analyzes source code, creates compiles list). So best probably put list one central, obvious place. The base class hierarchy interest probably best place. The change we’ll make defer creation object class itself, using Factory Method design pattern. A factory method called polymorphically, creates object appropriate type you. In simple version, factory method create( ) method Factory interface: Type Information 413 //: typeinfo/factory/Factory.java package typeinfo.factory; public interface Factory<T> { T create(); } ///:~ The generic parameter T allows create( ) return different type implementation Factory. This also makes use covariant return types. In example, base class Part contains List factory objects. Factories types produced createRandom( ) method "registered" base class adding partFactories List: //: typeinfo/RegisteredFactories.java // Registering Class Factories base class. import typeinfo.factory.*; import java.util.*; class Part { public String toString() { return getClass().getSimpleName(); } static List<Factory<? extends Part>> partFactories = new ArrayList<Factory<? extends Part>>(); static { // Collections.addAll() gives "unchecked generic // array creation ... varargs parameter" warning. partFactories.add(new FuelFilter.Factory()); partFactories.add(new AirFilter.Factory()); partFactories.add(new CabinAirFilter.Factory()); partFactories.add(new OilFilter.Factory()); partFactories.add(new FanBelt.Factory()); partFactories.add(new PowerSteeringBelt.Factory()); partFactories.add(new GeneratorBelt.Factory()); } private static Random rand = new Random(47); public static Part createRandom() { int n = rand.nextInt(partFactories.size()); return partFactories.get(n).create(); } } class Filter extends Part {} class FuelFilter extends Filter { // Create Class Factory specific type: public static class Factory implements typeinfo.factory.Factory<FuelFilter> { public FuelFilter create() { return new FuelFilter(); } } } class AirFilter extends Filter { public static class Factory implements typeinfo.factory.Factory<AirFilter> { public AirFilter create() { return new AirFilter(); } } } class CabinAirFilter extends Filter { public static class Factory implements typeinfo.factory.Factory<CabinAirFilter> { public CabinAirFilter create() { return new CabinAirFilter(); } 414 Thinking Java Bruce Eckel } } class OilFilter extends Filter { public static class Factory implements typeinfo.factory.Factory<OilFilter> { public OilFilter create() { return new OilFilter(); } } } class Belt extends Part {} class FanBelt extends Belt { public static class Factory implements typeinfo.factory.Factory<FanBelt> { public FanBelt create() { return new FanBelt(); } } } class GeneratorBelt extends Belt { public static class Factory implements typeinfo.factory.Factory<GeneratorBelt> { public GeneratorBelt create() { return new GeneratorBelt(); } } } class PowerSteeringBelt extends Belt { public static class Factory implements typeinfo.factory.Factory<PowerSteeringBelt> { public PowerSteeringBelt create() { return new PowerSteeringBelt(); } } } public class RegisteredFactories { public static void main(String[] args) { for(int = 0; < 10; i++) System.out.println(Part.createRandom()); } } /* Output: GeneratorBelt CabinAirFilter GeneratorBelt AirFilter PowerSteeringBelt CabinAirFilter FuelFilter PowerSteeringBelt PowerSteeringBelt FuelFilter *///:~ Not classes hierarchy instantiated; case Filter Belt classifiers create instance either one, subclasses. If class created createRandom( ), contains inner Factory class. The way reuse name Factory seen qualifying typeinfo.factory.Factory. Although use Collections.addAll( ) add factories list, compiler expresses unhappiness warning "generic array creation" (which supposed Type Information 415 impossible, you’ll see Generics chapter), I reverted calling add( ). The createRandom( ) method randomly selects factory object partFactories calls create( ) produce new Part. Exercise 14: (4) A constructor kind factory method. Modify RegisteredFactories.java instead using explicit factory, class object stored List, newlnstance( ) used create object. Exercise 15: (4) Implement new PetCreator using Registered Factories, modify Pets Facade uses one instead two. Ensure rest examples use Pets .Java still work correctly. Exercise 16: (4) Modify Coffee hierarchy Generics chapter use Registered Factories. instanceof vs. Class equivalence When querying type information, there’s important difference either form instanceof (that is, instanceof islnstance( ), produce equivalent results) direct comparison Class objects. Here’s example demonstrates difference: //: typeinfo/FamilyVsExactType.java // The difference instanceof class package typeinfo; import static net.mindview.util.Print.*; class Base {} class Derived extends Base {} public class FamilyVsExactType { static void test(Object x) { print("Testing x type " + x.getClass()); print("x instanceof Base " + (x instanceof Base)); print("x instanceof Derived "+ (x instanceof Derived)); print("Base.isInstance(x) "+ Base.class.isInstance(x)); print("Derived.isInstance(x) " + Derived.class.isInstance(x)); print("x.getClass() == Base.class " + (x.getClass() == Base.class)); print("x.getClass() == Derived.class " + (x.getClass() == Derived.class)); print("x.getClass().equals(Base.class)) "+ (x.getClass().equals(Base.class))); print("x.getClass().equals(Derived.class)) " + (x.getClass().equals(Derived.class))); } public static void main(String[] args) { test(new Base()); test(new Derived()); } } /* Output: Testing x type class typeinfo.Base x instanceof Base true x instanceof Derived false Base.isInstance(x) true Derived.isInstance(x) false x.getClass() == Base.class true x.getClass() == Derived.class false 416 Thinking Java Bruce Eckel x.getClass().equals(Base.class)) true x.getClass().equals(Derived.class)) false Testing x type class typeinfo.Derived x instanceof Base true x instanceof Derived true Base.isInstance(x) true Derived.isInstance(x) true x.getClass() == Base.class false x.getClass() == Derived.class true x.getClass().equals(Base.class)) false x.getClass().equals(Derived.class)) true *///:~ The test( ) method performs type checking argument using forms instanceof. It gets Class reference uses == equals( ) test equality Class objects. Reassuringly, instanceof islnstance( ) produce exactly results, equals( ) ==. But tests draw different conclusions. In keeping concept type, instanceof says, "Are class, class derived class?" On hand, compare actual Class objects using ==, concern inheritance—it’s either exact type isn’t. Reflection: runtime class information If don’t know precise type object, RTTI tell you. However, there’s limitation: The type must known compile time order detect using RTTI something useful information. Put another way, compiler must know classes you’re working with. This doesn’t seem like much limitation first, suppose you’re given reference object that’s program space. In fact, class object isn’t even available program compile time. For example, suppose get bunch bytes disk file network connection, you’re told bytes represent class. Since class shows long compiler generates code program, possibly use class? In traditional programming environment, seems like far-fetched scenario. But move larger programming world, important cases happens. The first component-based programming, build projects using Rapid Application Development (RAD) Application Builder Integrated Development Environment, I shall refer simply IDE. This visual approach creating program moving icons represent components onto form. These components configured setting values program time. This design-time configuration requires component instantiable, exposes parts itself, allows properties read modified. In addition, components handle Graphical User Interface (GUI) events must expose information appropriate methods IDE assist programmer overriding event-handling methods. Reflection provides mechanism detect available methods produce method names. Java provides structure component-based programming JavaBeans (described Graphical User Interfaces chapter). Another compelling motivation discovering class information run time provide ability create execute objects remote platforms, across network. This called Remote Method Invocation (RMI), allows Java program objects distributed across many machines. This distribution happen number reasons. For example, perhaps you’re computation-intensive task, order speed things up, want break put pieces machines idle. In situations might want Type Information 417 place code handles particular types tasks (e.g., "Business Rules" multitier client/server architecture) particular machine, machine becomes common repository describing actions, easily changed affect everyone system. (This interesting development, since machine exists solely make software changes easy!) Along lines, distributed computing also supports specialized hardware might good particular task—matrix inversions, example—but inappropriate expensive generalpurpose programming. The class Class supports concept reflection, along java.lang.reflect library contains classes Field, Method, Constructor (each implements Member interface). Objects types created JVM run time represent corresponding member unknown class. You use Constructors create new objects, get( ) set( ) methods read modify fields associated Field objects, invoke( ) method call method associated Method object. In addition, call convenience methods getFields( ), getMethods( ), getConstructors( ), etc., return arrays objects representing fields, methods, constructors. (You find looking class Class JDK documentation.) Thus, class information anonymous objects completely determined run time, nothing need known compile time. It’s important realize there’s nothing magic reflection. When you’re using reflection interact object unknown type, JVM simply look object see belongs particular class (just like ordinary RTTI). Before anything done it, Class object must loaded. Thus, .class file particular type must still available JVM, either local machine across network. So true difference RTTI reflection RTTI, compiler opens examines .class file compile time. Put another way, call methods object "normal" way. With reflection, .class file unavailable compile time; opened examined runtime environment. A class method extractor Normally won’t need use reflection tools directly, helpful need create dynamic code. Reflection language support Java features, object serialization JavaBeans (both covered later book). However, times it’s quite useful dynamically extract information class. Consider class method extractor. Looking class definition source code JDK documentation shows methods defined overridden within class definition. But might dozens available come base classes. To locate tedious time consuming. 1 Fortunately, reflection provides way write simple tool automatically show entire interface. Here’s way works: //: typeinfo/ShowMethods.java // Using reflection show methods class, // even methods defined base class. // {Args: ShowMethods} import java.lang.reflect.*; import java.util.regex.*; import static net.mindview.util.Print.*; public class ShowMethods { private static String usage = 1 Especially past. However, Sun greatly improved HTML Java documentation it’s easier see baseclass methods. 418 Thinking Java Bruce Eckel "usage:\n" + "ShowMethods qualified.class.name\n" + "To show methods class or:\n" + "ShowMethods qualified.class.name word\n" + "To search methods involving ‘word’"; private static Pattern p = Pattern.compile("\\w+\\."); public static void main(String[] args) { if(args.length < 1) { print(usage); System.exit(0); } int lines = 0; try { Class<?> c = Class.forName(args[0]); Method[] methods = c.getMethods(); Constructor[] ctors = c.getConstructors(); if(args.length == 1) { for(Method method : methods) print( p.matcher(method.toString()).replaceAll("")); for(Constructor ctor : ctors) print(p.matcher(ctor.toString()).replaceAll("")); lines = methods.length + ctors.length; } else { for(Method method : methods) if(method.toString().indexOf(args[1]) != -1) { print( p.matcher(method.toString()).replaceAll("")); lines++; } for(Constructor ctor : ctors) if(ctor.toString().indexOf(args[1]) != -1) { print(p.matcher( ctor.toString()).replaceAll("")); lines++; } } } catch(ClassNotFoundException e) { print("No class: " + e); } } } /* Output: public static void main(String[]) public native int hashCode() public final native Class getClass() public final void wait(long,int) throws InterruptedException public final void wait() throws InterruptedException public final native void wait(long) throws InterruptedException public boolean equals(Object) public String toString() public final native void notify() public final native void notifyAll() public ShowMethods() *///:~ The Class methods getMethods( ) getConstructors( ) return array Method array Constructor, respectively. Each classes methods dissect names, arguments, return values methods represent. But also use toString( ), done here, produce String entire method signature. The rest code extracts command-line information, determines particular signature matches target string (using indexOf( )), strips name qualifiers using regular expressions (introduced Strings chapter). Type Information 419 The result produced Class.forName( ) cannot known compile time, therefore method signature information extracted run time. If investigate JDK reflection documentation, you’ll see enough support actually set make method call object that’s totally unknown compile time (there examples later book). Although initially something may think you’ll ever need, value full reflection quite surprising. The output produced command line: java ShowMethods ShowMethods You see output includes public default constructor, even though constructor defined. The constructor see one that’s automatically synthesized compiler. If make ShowMethods non-public class (that is, package access), synthesized default constructor longer shows output. The synthesized default constructor automatically given access class. Another interesting experiment invoke Java ShowMethods java.lang.String extra argument char, int, String, etc. This tool real time-saver you’re programming, can’t remember class particular method don’t want go hunting index class hierarchy JDK documentation, don’t know whether class anything with, example, Color objects. The Graphical User Interfaces chapter contains GUI version program (customized extract information Swing components) leave running you’re writing code, allow quick lookups. Exercise 17: (2) Modify regular expression ShowMethods.java additionally strip keywords native final (hint: use OR operator’|’)- Exercise 18: (1) Make ShowMethods non-public class verify synthesized default constructor longer shows output. Exercise 19: (4) In ToyTest.java, use reflection create Toy object using nondefault constructor. Exercise 20: (5) Look interface java.lang.Class JDK documentation http://java.sun.com. Write program takes name class command-line argument, uses Class methods dump information available class. Test program standard library class class create. Dynamic proxies Proxy one basic design patterns. It object insert place "real" object order provide additional different operations—these usually involve communication "real" object, proxy typically acts go-between. Here’s trivial example show structure proxy: //: typeinfo/SimpleProxyDemo.java import static net.mindview.util.Print.*; interface Interface { void doSomething(); void somethingElse(String arg); 420 Thinking Java Bruce Eckel } class RealObject implements Interface { public void doSomething() { print("doSomething"); } public void somethingElse(String arg) { print("somethingElse " + arg); } } class SimpleProxy implements Interface { private Interface proxied; public SimpleProxy(Interface proxied) { this.proxied = proxied; } public void doSomething() { print("SimpleProxy doSomething"); proxied.doSomething(); } public void somethingElse(String arg) { print("SimpleProxy somethingElse " + arg); proxied.somethingElse(arg); } } class SimpleProxyDemo { public static void consumer(Interface iface) { iface.doSomething(); iface.somethingElse("bonobo"); } public static void main(String[] args) { consumer(new RealObject()); consumer(new SimpleProxy(new RealObject())); } } /* Output: doSomething somethingElse bonobo SimpleProxy doSomething doSomething SimpleProxy somethingElse bonobo somethingElse bonobo *///:~ Because consumer( ) accepts Interface, can’t know it’s getting RealObject SimpleProxy, implement Interface. But SimpleProxy inserted client RealObject performs operations calls identical method RealObject. A proxy helpful anytime you’d like separate extra operations different place "real object," especially want easily change using extra operations using them, vice versa (the point design patterns encapsulate change—so need changing things order justify pattern). For example, wanted track calls methods RealObject, measure overhead calls? This code want incorporated application, proxy allows add remove easily. Java’s dynamic proxy takes idea proxy one step further, creating proxy object dynamically handling calls proxied methods dynamically. All calls made dynamic proxy redirected single invocation handler, job discovering call deciding it. Here’s SimpleProxyDemo.java rewritten use dynamic proxy: Type Information 421 //: typeinfo/SimpleDynamicProxy.java import java.lang.reflect.*; class DynamicProxyHandler implements InvocationHandler { private Object proxied; public DynamicProxyHandler(Object proxied) { this.proxied = proxied; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println("**** proxy: " + proxy.getClass() + ", method: " + method + ", args: " + args); if(args != null) for(Object arg : args) System.out.println(" " + arg); return method.invoke(proxied, args); } } class SimpleDynamicProxy { public static void consumer(Interface iface) { iface.doSomething(); iface.somethingElse("bonobo"); } public static void main(String[] args) { RealObject real = new RealObject(); consumer(real); // Insert proxy call again: Interface proxy = (Interface)Proxy.newProxyInstance( Interface.class.getClassLoader(), new Class[]{ Interface.class }, new DynamicProxyHandler(real)); consumer(proxy); } } /* Output: (95% match) doSomething somethingElse bonobo **** proxy: class $Proxy0, method: public abstract void Interface.doSomething(), args: null doSomething **** proxy: class $Proxy0, method: public abstract void Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@42e816 bonobo somethingElse bonobo *///:~ You create dynamic proxy calling static method Proxy.newProxyInstance( ), requires class loader (you generally hand class loader object already loaded), list interfaces (not classes abstract classes) wish proxy implement, implementation interface InvocationHandler. The dynamic proxy redirect calls invocation handler, constructor invocation handler usually given reference "real" object forward requests performs intermediary task. The invoke( ) method handed proxy object, case need distinguish request came from—but many cases won’t care. However, careful calling methods proxy inside invoke( ), calls interface redirected proxy. 422 Thinking Java Bruce Eckel In general perform proxied operation use Method.invoke( ) forward request proxied object, passing necessary arguments. This may initially seem limiting, perform generic operations. However, filter certain method calls, passing others through: //: typeinfo/SelectingMethods.java // Looking particular methods dynamic proxy. import java.lang.reflect.*; import static net.mindview.util.Print.*; class MethodSelector implements InvocationHandler { private Object proxied; public MethodSelector(Object proxied) { this.proxied = proxied; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(method.getName().equals("interesting")) print("Proxy detected interesting method"); return method.invoke(proxied, args); } } interface SomeMethods { void boring1(); void boring2(); void interesting(String arg); void boring3(); } class Implementation implements SomeMethods public void boring1() { print("boring1"); public void boring2() { print("boring2"); public void interesting(String arg) { print("interesting " + arg); } public void boring3() { print("boring3"); } { } } } class SelectingMethods { public static void main(String[] args) { SomeMethods proxy= (SomeMethods)Proxy.newProxyInstance( SomeMethods.class.getClassLoader(), new Class[]{ SomeMethods.class }, new MethodSelector(new Implementation())); proxy.boring1(); proxy.boring2(); proxy.interesting("bonobo"); proxy.boring3(); } } /* Output: boring1 boring2 Proxy detected interesting method interesting bonobo boring3 *///:~ Here, looking method names, could also looking aspects method signature, could even search particular argument values. Type Information 423 The dynamic proxy tool you’ll use every day, solve certain types problems nicely. You learn Proxy design patterns Thinking Patterns (see www.MindView.net) Design Patterns, Erich Gamma et al. (AddisonWesley, 1995). Exercise 21: (3) Modify SimpleProxyDemo.java measures method-call times. Exercise 22: (3) Modify SimpleDynamicProxy.java measures method-call times. Exercise 23: (3) Inside invoke( ) SimpleDynamicProxy.java, try print proxy argument explain happens. Project: 2 Write system using dynamic proxies implement transactions, proxy performs commit proxied call successful (doesn’t throw exceptions) rollback fails. Your commit rollback work external text file, outside control Java exceptions. You pay attention atomicity operations. Null Objects When use built-in null indicate absence object, must test reference null-ness every time use it. This get tedious produce ponderous code. The problem null behavior except producing NullPointerException try anything it. Sometimes useful introduce idea Null Object 3 accept messages object it’s "standing in" for, return values indicating "real" object actually there. This way, assume objects valid don’t waste programming time checking null (and reading resulting code). Although it’s fun imagine programming language would automatically create Null Objects you, practice doesn’t make sense use everywhere—sometimes checking null fine, sometimes reasonably assume won’t encounter null, sometimes even detecting aberrations via NullPointerException acceptable. The place Null Objects seem useful "closer data," objects represent entities problem space. As simple example, many systems Person class, situations code don’t actual person (or do, don’t information person yet), traditionally you’d use null reference test it. Instead, make Null Object. But even though Null Object respond messages "real" object respond to, still need way test nullness. The simplest way create tagging interface: //: net/mindview/util/Null.java package net.mindview.util; public interface Null {} ///:~ 2 Projects suggestions used (for example) term projects. Solutions projects included solution guide. 3 Discovered Bobby Woolf Bruce Anderson. This seen special case Strategy pattern. A variant Null Object Null Iterator pattern, makes iteration nodes composite hierarchy transparent client (the client use logic iterating composite leaf nodes). 424 Thinking Java Bruce Eckel This allows instanceof detect Null Object, importantly, require add isNull( ) method classes (which would be, all, different way performing RTTI—why use built-in facility instead?). //: typeinfo/Person.java // A class Null Object. import net.mindview.util.*; class Person { public final String first; public final String last; public final String address; // etc. public Person(String first, String last, String address){ this.first = first; this.last = last; this.address = address; } public String toString() { return "Person: " + first + " " + last + " " + address; } public static class NullPerson extends Person implements Null { private NullPerson() { super("None", "None", "None"); } public String toString() { return "NullPerson"; } } public static final Person NULL = new NullPerson(); } ///:~ In general, Null Object Singleton, created static final instance. This works Person immutable—you set values constructor, read values, can’t modify (because Strings inherently immutable). If want change NullPerson, replace new Person object. Notice option detecting generic Null specific NullPerson using instanceof, Singleton approach also use equals( ) even == compare Person.NULL. Now suppose you’re back high-flying days Internet startups you’ve given big pile venture funding Amazing Idea. You’re ready staff up, you’re waiting positions filled, use Person Null Objects placeholders Position: //: typeinfo/Position.java class Position { private String title; private Person person; public Position(String jobTitle, Person employee) { title = jobTitle; person = employee; if(person == null) person = Person.NULL; } public Position(String jobTitle) { title = jobTitle; person = Person.NULL; } public String getTitle() { return title; } public void setTitle(String newTitle) { title = newTitle; } Type Information 425 public Person getPerson() { return person; } public void setPerson(Person newPerson) { person = newPerson; if(person == null) person = Person.NULL; } public String toString() { return "Position: " + title + " " + person; } } ///:~ With Position, don’t need make Null Object existence Person.NULL implies null Position (it’s possible that, later, you’ll discover need add explicit Null Object Position, YAGNI 4 (You Aren’t Going Need It) says try "the simplest thing could possibly work" first draft, wait aspect program requires add extra feature, rather assuming it’s necessary). The Staff class look Null Objects filling positions: //: typeinfo/Staff.java import java.util.*; public class Staff extends ArrayList<Position> { public void add(String title, Person person) { add(new Position(title, person)); } public void add(String... titles) { for(String title : titles) add(new Position(title)); } public Staff(String... titles) { add(titles); } public boolean positionAvailable(String title) { for(Position position : this) if(position.getTitle().equals(title) && position.getPerson() == Person.NULL) return true; return false; } public void fillPosition(String title, Person hire) { for(Position position : this) if(position.getTitle().equals(title) && position.getPerson() == Person.NULL) { position.setPerson(hire); return; } throw new RuntimeException( "Position " + title + " available"); } public static void main(String[] args) { Staff staff = new Staff("President", "CTO", "Marketing Manager", "Product Manager", "Project Lead", "Software Engineer", "Software Engineer", "Software Engineer", "Software Engineer", "Test Engineer", "Technical Writer"); staff.fillPosition("President", new Person("Me", "Last", "The Top, Lonely At")); staff.fillPosition("Project Lead", 4 A tenet Extreme Programming (XP), "Do simplest thing could possibly work." 426 Thinking Java Bruce Eckel new Person("Janet", "Planner", "The Burbs")); if(staff.positionAvailable("Software Engineer")) staff.fillPosition("Software Engineer", new Person("Bob", "Coder", "Bright Light City")); System.out.println(staff); } } /* Output: [Position: President Person: Me Last The Top, Lonely At, Position: CTO NullPerson, Position: Marketing Manager NullPerson, Position: Product Manager NullPerson, Position: Project Lead Person: Janet Planner The Burbs, Position: Software Engineer Person: Bob Coder Bright Light City, Position: Software Engineer NullPerson, Position: Software Engineer NullPerson, Position: Software Engineer NullPerson, Position: Test Engineer NullPerson, Position: Technical Writer NullPerson] *///:~ Notice must still test Null Objects places, different checking null, places (such toString( ) conversions, case), don’t perform extra tests; assume object references valid. If working interfaces instead concrete classes, it’s possible use DynamicProxy automatically create Null Objects. Suppose Robot interface defines name, model, List < Operation > describes Robot capable doing. Operation contains description command (it’s type Command pattern): //: typeinfo/Operation.java public interface Operation { String description(); void command(); } ///:~ You access Robot’s services calling operations( ): //: typeinfo/Robot.java import java.util.*; import net.mindview.util.*; public interface Robot { String name(); String model(); List<Operation> operations(); class Test { public static void test(Robot r) { if(r instanceof Null) System.out.println("[Null Robot]"); System.out.println("Robot name: " + r.name()); System.out.println("Robot model: " + r.model()); for(Operation operation : r.operations()) { System.out.println(operation.description()); operation.command(); } } } } ///:~ This also incorporates nested class perform tests. We create Robot removes snow: Type Information 427 //: typeinfo/SnowRemovalRobot.java import java.util.*; public class SnowRemovalRobot implements Robot { private String name; public SnowRemovalRobot(String name) {this.name = name;} public String name() { return name; } public String model() { return "SnowBot Series 11"; } public List<Operation> operations() { return Arrays.asList( new Operation() { public String description() { return name + " shovel snow"; } public void command() { System.out.println(name + " shoveling snow"); } }, new Operation() { public String description() { return name + " chip ice"; } public void command() { System.out.println(name + " chipping ice"); } }, new Operation() { public String description() { return name + " clear roof"; } public void command() { System.out.println(name + " clearing roof"); } } ); } public static void main(String[] args) { Robot.Test.test(new SnowRemovalRobot("Slusher")); } } /* Output: Robot name: Slusher Robot model: SnowBot Series 11 Slusher shovel snow Slusher shoveling snow Slusher chip ice Slusher chipping ice Slusher clear roof Slusher clearing roof *///:~ There presumably many different types Robot, we’d like Null Object something special Robot type—in case, incorporate information exact type Robot Null Object standing for. This information captured dynamic proxy: //: typeinfo/NullRobot.java // Using dynamic proxy create Null Object. import java.lang.reflect.*; import java.util.*; import net.mindview.util.*; class NullRobotProxyHandler implements InvocationHandler { 428 Thinking Java Bruce Eckel } private String nullName; private Robot proxied = new NRobot(); NullRobotProxyHandler(Class<? extends Robot> type) { nullName = type.getSimpleName() + " NullRobot"; } private class NRobot implements Null, Robot { public String name() { return nullName; } public String model() { return nullName; } public List<Operation> operations() { return Collections.emptyList(); } } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { return method.invoke(proxied, args); } public class NullRobot { public static Robot newNullRobot(Class<? extends Robot> type) { return (Robot)Proxy.newProxyInstance( NullRobot.class.getClassLoader(), new Class[]{ Null.class, Robot.class }, new NullRobotProxyHandler(type)); } public static void main(String[] args) { Robot[] bots = { new SnowRemovalRobot("SnowBee"), newNullRobot(SnowRemovalRobot.class) }; for(Robot bot : bots) Robot.Test.test(bot); } } /* Output: Robot name: SnowBee Robot model: SnowBot Series 11 SnowBee shovel snow SnowBee shoveling snow SnowBee chip ice SnowBee chipping ice SnowBee clear roof SnowBee clearing roof [Null Robot] Robot name: SnowRemovalRobot NullRobot Robot model: SnowRemovalRobot NullRobot *///:~ Whenever need null Robot object, call newNullRobot( ), passing type Robot want proxy for. The proxy fulfills requirements Robot Null interfaces, provides specific name type proxies. Mock Objects & Stubs Logical variations Null Object MocA: Object Stub. Like Null Object, stand-ins "real" object used finished program. However, Mock Object Stub pretend live objects deliver real information, rather intelligent placeholder null, Null Object is. Type Information 429 The distinction Mock Object Stub one degree. Mock Objects tend lightweight self-testing, usually many created handle various testing situations. Stubs return stubbed data, typically heavyweight often reused tests. Stubs configured change depending called. So Stub sophisticated object lots things, whereas usually create lots small, simple Mock Objects need many things. Exercise 24: (4) Add Null Objects RegisteredFactories.java. Interfaces type information An important goal interface keyword allow programmer isolate components, thus reduce coupling. If write interfaces, accomplish this, type information it’s possible get around that— interfaces airtight guarantees decoupling. Here’s example, starting interface: //: typeinfo/interfacea/A.java package typeinfo.interfacea; public interface A { void f(); } ///:~ This interface implemented, see sneak around actual implementation type: //: typeinfo/InterfaceViolation.java // Sneaking around interface. import typeinfo.interfacea.*; class B implements A { public void f() {} public void g() {} } public class InterfaceViolation { public static void main(String[] args) { A = new B(); a.f(); // a.g(); // Compile error System.out.println(a.getClass().getName()); if(a instanceof B) { B b = (B)a; b.g(); } } } /* Output: B *///:~ Using RTTI, discover implemented B. By casting B, call method that’s A. 430 Thinking Java Bruce Eckel This perfectly legal acceptable, may want client programmers this, gives opportunity couple closely code you’d like. That is, may think interface keyword protecting you, isn’t, fact you’re using B implement A case effectively matter public record. 5 One solution simply say programmers decide use actual class rather interface. This probably reasonable many cases, "probably" isn’t enough, might want apply stringent controls. The easiest approach use package access implementation, clients outside package may see it: //: typeinfo/packageaccess/HiddenC.java package typeinfo.packageaccess; import typeinfo.interfacea.*; import static net.mindview.util.Print.*; class C implements A { public void f() { print("public C.f()"); } public void g() { print("public C.g()"); } void u() { print("package C.u()"); } protected void v() { print("protected C.v()"); } private void w() { print("private C.w()"); } } public class HiddenC { public static A makeA() { return new C(); } } ///:~ The public part package, HiddenC, produces A interface call it. What’s interesting even return C makeA( ), still couldn’t use anything A outside package, since cannot name C outside package. Now try downcast C, can’t ‘C type available outside package: //: typeinfo/HiddenImplementation.java // Sneaking around package access. import typeinfo.interfacea.*; import typeinfo.packageaccess.*; import java.lang.reflect.*; public class HiddenImplementation { public static void main(String[] args) throws Exception { A = HiddenC.makeA(); a.f(); System.out.println(a.getClass().getName()); // Compile error: cannot find symbol ‘C’: /* if(a instanceof C) { C c = (C)a; c.g(); } */ // Oops! Reflection still allows us call g(): callHiddenMethod(a, "g"); 5 The famous case Windows operating system, published API supposed write to, unpublished visible set functions could discover call. To solve problems, programmers used hidden API functions, forced Microsoft maintain part public API. This became source great cost effort company. Type Information 431 // And even methods callHiddenMethod(a, callHiddenMethod(a, callHiddenMethod(a, less accessible! "u"); "v"); "w"); } static void callHiddenMethod(Object a, String methodName) throws Exception { Method g = a.getClass().getDeclaredMethod(methodName); g.setAccessible(true); g.invoke(a); } } /* Output: public C.f() typeinfo.packageaccess.C public C.g() package C.u() protected C.v() private C.w() *///:~ As see, it’s still possible reach call methods using reflection, even private methods! If know name method, call setAccessible(true) Method object make callable, seen callHiddenMethod( ). You may think prevent distributing compiled code, that’s solution. All must run javap, decompiler comes JDK. Here’s command line: javap -private C The -private flag indicates members displayed, even private ones. Here’s output: class typeinfo.packageaccess.C extends java.lang.Object implements typeinfo.interfacea.A { typeinfo.packageaccess.C(); public void f( ); public void g( ); void u( ); protected void v( ); private void w(); } So anyone get names signatures private methods, call them. What implement interface private inner class? Here’s looks like: //: typeinfo/InnerImplementation.java // Private inner classes can’t hide reflection. import typeinfo.interfacea.*; import static net.mindview.util.Print.*; class InnerA { private static class C implements A { public void f() { print("public C.f()"); } public void g() { print("public C.g()"); } void u() { print("package C.u()"); } protected void v() { print("protected C.v()"); } private void w() { print("private C.w()"); } } 432 Thinking Java Bruce Eckel } public static A makeA() { return new C(); } public class InnerImplementation { public static void main(String[] args) throws Exception { A = InnerA.makeA(); a.f(); System.out.println(a.getClass().getName()); // Reflection still gets private class: HiddenImplementation.callHiddenMethod(a, "g"); HiddenImplementation.callHiddenMethod(a, "u"); HiddenImplementation.callHiddenMethod(a, "v"); HiddenImplementation.callHiddenMethod(a, "w"); } } /* Output: public C.f() InnerA$C public C.g() package C.u() protected C.v() private C.w() *///:~ That didn’t hide anything reflection. What anonymous class? //: typeinfo/AnonymousImplementation.java // Anonymous inner classes can’t hide reflection. import typeinfo.interfacea.*; import static net.mindview.util.Print.*; class AnonymousA { public static A makeA() { return new A() { public void f() { print("public C.f()"); } public void g() { print("public C.g()"); } void u() { print("package C.u()"); } protected void v() { print("protected C.v()"); } private void w() { print("private C.w()"); } }; } } public class AnonymousImplementation { public static void main(String[] args) throws Exception { A = AnonymousA.makeA(); a.f(); System.out.println(a.getClass().getName()); // Reflection still gets anonymous class: HiddenImplementation.callHiddenMethod(a, "g"); HiddenImplementation.callHiddenMethod(a, "u"); HiddenImplementation.callHiddenMethod(a, "v"); HiddenImplementation.callHiddenMethod(a, "w"); } } /* Output: public C.f() AnonymousA$1 public C.g() package C.u() protected C.v() private C.w() *///:~ Type Information 433 There doesn’t seem way prevent reflection reaching calling methods non-public access. This also true fields, even private fields: //: typeinfo/ModifyingPrivateFields.java import java.lang.reflect.*; class WithPrivateFinalField { private int = 1; private final String = "I’m totally safe"; private String s2 = "Am I safe?"; public String toString() { return "i = " + + ", " + + ", " + s2; } } public class ModifyingPrivateFields { public static void main(String[] args) throws Exception { WithPrivateFinalField pf = new WithPrivateFinalField(); System.out.println(pf); Field f = pf.getClass().getDeclaredField("i"); f.setAccessible(true); System.out.println("f.getInt(pf): " + f.getInt(pf)); f.setInt(pf, 47); System.out.println(pf); f = pf.getClass().getDeclaredField("s"); f.setAccessible(true); System.out.println("f.get(pf): " + f.get(pf)); f.set(pf, "No, you’re not!"); System.out.println(pf); f = pf.getClass().getDeclaredField("s2"); f.setAccessible(true); System.out.println("f.get(pf): " + f.get(pf)); f.set(pf, "No, you’re not!"); System.out.println(pf); } } /* Output: = 1, I’m totally safe, Am I safe? f.getInt(pf): 1 = 47, I’m totally safe, Am I safe? f.get(pf): I’m totally safe = 47, I’m totally safe, Am I safe? f.get(pf): Am I safe? = 47, I’m totally safe, No, you’re not! *///:~ However, final fields actually safe change. The runtime system accepts attempts change without complaint, nothing actually happens. In general, access violations worst thing world. If someone uses technique call methods marked private package access (thus clearly indicating call them), it’s difficult complain change aspect methods. On hand, fact always back door class may allow solve certain types problems could otherwise difficult impossible, benefits reflection general undeniable. 434 Thinking Java Bruce Eckel Exercise 25: (2) Create class containing private, protected package-access methods. Write code access methods outside class’s package. Type Information 435 Summary RTTI allows discover type information anonymous base-class reference. Thus, it’s ripe misuse novice, since might make sense polymorphic method calls do. For people coming procedural background, it’s difficult organize programs sets switch statements. You accomplish RTTI thus lose important value polymorphism code development maintenance. The intent 0 0 programming use polymorphic method calls everywhere can, RTTI must. However, using polymorphic method calls intended requires control base-class definition, point extension program might discover base class doesn’t include method need. If base class comes someone else’s library, one solution RTTI: You inherit new type add extra method. Elsewhere code detect particular type call special method. This doesn’t destroy polymorphism extensibility program, adding new type require hunt switch statements program. However, add code requires new feature, must use RTTI detect particular type. Putting feature base class might mean that, benefit one particular class, classes derived base require meaningless stub method. This makes interface less clear annoys must override abstract methods derive base class. For example, consider class hierarchy representing musical instruments. Suppose want clear spit valves appropriate instruments orchestra. One option put clearSpitValve( ) method base class Instrument, confusing implies Percussion, Stringed Electronic instruments also spit valves. RTTI provides much reasonable solution place method specific class it’s appropriate (Wind, case). At time, may discover there’s sensible solution—here, preparelnstrument( ) method base class. However, might see solution you’re first solving problem could mistakenly assume must use RTTI. Finally, RTTI sometimes solve efficiency problems. Suppose code nicely uses polymorphism, turns one objects reacts general-purpose code horribly inefficient way. You pick type using RTTI write case-specific code improve efficiency. Be wary, however, programming efficiency soon. It’s seductive trap. It’s best get program working/jrsf, decide it’s running fast enough, attack efficiency issues—with profiler (see supplement http://MindView.net/Books/BetterJava). We’ve also seen reflection opens new world programming possibilities allowing much dynamic style programming. There dynamic nature reflection disturbing. The fact things checked run time reported exceptions seems, mind grown comfortable security static type checking, wrong direction. Some people go far say introducing possibility runtime exception clear indicator code avoided. I find sense security illusionthere always things happen run time throw exceptions, even program contains try blocks exception specifications. Instead, I think existence consistent error-reporting model empowers us write dynamic code using reflection. Of course it’s worth trying write code statically checked ... can. But I believe dynamic code one important facilities separate Java languages like C++. Exercise 26: (3) Implement clearSpitValve( ) described summary. 436 Thinking Java Bruce Eckel Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Type Information 437 Generics Ordinary classes methods work specific types: either primitives class types. If writing code might used across types, rigidity overconstraining. 1 One way object-oriented languages allow generalization polymorphism. You write (for example) method takes base class object argument, use method class derived base class. Now method little general used places. The true within classes—anyplace use specific type, base type provides flexibility. Of course, anything final class 2 extended, flexibility automatic much time. Sometimes, constrained single hierarchy limiting. If method argument interface instead class, limitations loosened include anything implements interface—including classes haven’t created yet. This gives client programmer option implementing interface order conform class method. So interfaces allow cut across class hierarchies, long option create new class order so. Sometimes even interface restrictive. An interface still requires code work particular interface. You could write even general code could say code works "some unspecified type," rather specific interface class. This concept generics, one significant changes Java SE5. Generics implement concept parameterized types, allow multiple types. The term "generic" means "pertaining appropriate large groups classes." The original intent generics programming languages allow programmer greatest amount expressiveness possible writing classes methods, loosening constraints types classes methods work with. As see chapter, Java implementation generics broad reaching—indeed, may question whether term "generic" even appropriate feature. If you’ve never seen kind parameterized type mechanism before, Java generics probably seem like convenient addition language. When create instance parameterized type, casts taken care type correctness ensured compile time. This seems like improvement. However, you’ve experience parameterized type mechanism, C++, example, find can’t everything might expect using Java generics. While using someone else’s generic type fairly easy, creating encounter number surprises. One things I shall try explain feature came like is. This say Java generics useless. In many cases make code straightforward even elegant. But you’re coming language implemented pure version generics, may disappointed. In chapter, examine strengths limitations Java generics use new feature effectively. 1 Angelika Langer’s Java Generics FAQ (see www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html) well writings (together Klaus Kreft) invaluable preparation chapter. 2 Or class private constructors. Comparison C++ The Java designers stated much inspiration language came reaction C++. Despite this, possible teach Java largely without reference C++, I endeavored except comparison give greater depth understanding. Generics require comparison C++ two reasons. First, understanding certain aspects C++ templates (the main inspiration generics, including basic syntax) help understand foundations concept, well as—and important— limitations Java generics why. The ultimate goal give clear understanding boundaries lie, experience understanding boundaries, become powerful programmer. By knowing can’t do, make better use (partly don’t waste time bumping walls). The second reason significant misunderstanding Java community C++ templates, misunderstanding may confuse intent generics. So although I introduce C++ template examples chapter, I keep minimum. Simple generics One compelling initial motivations generics create container classes, saw Holding Your Objects chapter (you’ll learn Containers Depth chapter). A container place hold objects you’re working them. Although also true arrays, containers tend flexible different characteristics simple arrays. Virtually programs require hold group objects use them, containers one reusable class libraries. Let’s look class holds single object. Of course, class could specify exact type object, like this: //: generics/Holder1.java class Automobile {} public class Holder1 { private Automobile a; public Holder1(Automobile a) { this.a = a; } Automobile get() { return a; } } ///:~ But reusable tool, since can’t used hold anything else. We would prefer write new one every type encounter. Before Java SE5, would simply make hold Object: //: generics/Holder2.java public class Holder2 { private Object a; public Holder2(Object a) { this.a = a; } 440 Thinking Java Bruce Eckel public void set(Object a) { this.a = a; } public Object get() { return a; } public static void main(String[] args) { Holder2 h2 = new Holder2(new Automobile()); Automobile = (Automobile)h2.get(); h2.set("Not Automobile"); String = (String)h2.get(); h2.set(1); // Autoboxes Integer Integer x = (Integer)h2.get(); } } ///:~ Now Holder2 hold anything—and example, single Holder2 holds three different types objects. There cases want container hold multiple types objects, typically put one type object container. One primary motivations generics specify type object container holds, specification backed compiler. So instead Object, we’d like use unspecified type, decided later time. To this, put type parameter inside angle brackets class name, substitute actual type use class. For "holder" class, looks like this, T type parameter: //: generics/Holder3.java public class Holder3<T> { private T a; public Holder3(T a) { this.a = a; } public void set(T a) { this.a = a; } public T get() { return a; } public static void main(String[] args) { Holder3<Automobile> h3 = new Holder3<Automobile>(new Automobile()); Automobile = h3.get(); // No cast needed // h3.set("Not Automobile"); // Error // h3.set(1); // Error } } ///:~ Now create Holders, must specify type want put using angle-bracket syntax, see main( ). You allowed put objects type (or subtype, since substitution principle still works generics) holder. And get value out, automatically right type. That’s core idea Java generics: You tell type want use, takes care details. In general, treat generics type—they happen type parameters. But you’ll see, use generics naming along type argument list. Exercise 1: (1) Use Holders typeinfo.pets library show Holders specified hold base type also hold derived type. Exercise 2: (1) Create holder class holds three objects type, along methods store fetch objects constructor initialize three. Generics 441 A tuple library One things often want return multiple objects method call. The return statement allows specify single object, answer create object holds multiple objects want return. Of course, write special class every time encounter situation, generics it’s possible solve problem save effort future. At time, ensuring compile-time type safety. This concept called tuple, simply group objects wrapped together single object. The recipient object allowed read elements put new ones in. (This concept also called Data Transfer Object (or Messenger.) Tuples typically length, object tuple different type. However, want specify type object ensure recipient reads value, get right type. To deal problem multiple lengths, create multiple different tuples. Here’s one holds two objects: //: net/mindview/util/TwoTuple.java package net.mindview.util; public class TwoTuple<A,B> { public final A first; public final B second; public TwoTuple(A a, B b) { first = a; second = b; } public String toString() { return "(" + first + ", " + second + ")"; } } ///:~ The constructor captures object stored, toString( ) convenience function display values list. Note tuple implicitly keeps elements order. Upon first reading, may think could violate common safety principles Java programming. Shouldn’t first second private, accessed methods named getFirst( ) getSecond( )? Consider safety would get case: Clients could still read objects whatever want them, could assign first second anything else. The final declaration buys safety, form shorter simpler. Another design observation might want allow client programmer point first second another object. However, it’s safer leave form, force user create new TwoTuple want one different elements. The longer-length tuples created inheritance. You see adding type parameters simple matter: //: net/mindview/util/ThreeTuple.java package net.mindview.util; public class ThreeTuple<A,B,C> extends TwoTuple<A,B> { public final C third; public ThreeTuple(A a, B b, C c) { super(a, b); third = c; } public String toString() { return "(" + first + ", " + second + ", " + third +")"; 442 Thinking Java Bruce Eckel } } ///:~ //: net/mindview/util/FourTuple.java package net.mindview.util; public class FourTuple<A,B,C,D> extends ThreeTuple<A,B,C> { public final D fourth; public FourTuple(A a, B b, C c, D d) { super(a, b, c); fourth = d; } public String toString() { return "(" + first + ", " + second + ", " + third + ", " + fourth + ")"; } } ///:~ //: net/mindview/util/FiveTuple.java package net.mindview.util; public class FiveTuple<A,B,C,D,E> extends FourTuple<A,B,C,D> { public final E fifth; public FiveTuple(A a, B b, C c, D d, E e) { super(a, b, c, d); fifth = e; } public String toString() { return "(" + first + ", " + second + ", " + third + ", " + fourth + ", " + fifth + ")"; } } ///:~ To use tuple, simply define appropriate-length tuple return value function, create return return statement: //: generics/TupleTest.java import net.mindview.util.*; class Amphibian {} class Vehicle {} public class TupleTest { static TwoTuple<String,Integer> f() { // Autoboxing converts int Integer: return new TwoTuple<String,Integer>("hi", 47); } static ThreeTuple<Amphibian,String,Integer> g() { return new ThreeTuple<Amphibian, String, Integer>( new Amphibian(), "hi", 47); } static FourTuple<Vehicle,Amphibian,String,Integer> h() { return new FourTuple<Vehicle,Amphibian,String,Integer>( new Vehicle(), new Amphibian(), "hi", 47); } static FiveTuple<Vehicle,Amphibian,String,Integer,Double> k() { return new FiveTuple<Vehicle,Amphibian,String,Integer,Double>( Generics 443 new Vehicle(), new Amphibian(), "hi", 47, 11.1); } public static void main(String[] args) { TwoTuple<String,Integer> ttsi = f(); System.out.println(ttsi); // ttsi.first = "there"; // Compile error: final System.out.println(g()); System.out.println(h()); System.out.println(k()); } } /* Output: (80% match) (hi, 47) (Amphibian@1f6a7b9, hi, 47) (Vehicle@35ce36, Amphibian@757aef, hi, 47) (Vehicle@9cab16, Amphibian@1a46e30, hi, 47, 11.1) *///:~ Because generics, easily create tuple return group types, writing expression. You see final specification public fields prevents reassigned construction, failure statement ttsi.first = "there". The new expressions little verbose. Later chapter you’ll see simplify using generic methods. Exercise 3 : (1) Create test SixTuple generic. Exercise 4: (3) "Generify" innerclasses/Sequence.java. A stack class Let’s look something slightly complicated: traditional pushdown stack. In Holding Your Objects chapter, saw implemented using LinkedList net.mindview.util.Stack class (page 412). In example, see LinkedList already necessary methods create stack. The Stack constructed composing one generic class (Stack<T>) another generic class (LinkedList<T>). In example, notice (with exceptions shall look later) generic type another type. Instead using LinkedList, implement internal linked storage mechanism. //: generics/LinkedStack.java // A stack implemented internal linked structure. public class LinkedStack<T> { private static class Node<U> { U item; Node<U> next; Node() { item = null; next = null; } Node(U item, Node<U> next) { this.item = item; this.next = next; } boolean end() { return item == null && next == null; } } private Node<T> top = new Node<T>(); // End sentinel public void push(T item) { top = new Node<T>(item, top); 444 Thinking Java Bruce Eckel } public T pop() { T result = top.item; if(!top.end()) top = top.next; return result; } public static void main(String[] args) { LinkedStack<String> lss = new LinkedStack<String>(); for(String : "Phasers stun!".split(" ")) lss.push(s); String s; while((s = lss.pop()) != null) System.out.println(s); } } /* Output: stun! Phasers *///:~ The inner class Node also generic, type parameter. This example makes use end sentinel determine stack empty. The end sentinel created LinkedStack constructed, time call push( ) new Node<T> created linked previous Node<T>. When call pop( ), always return top.item, discard current Node<T> move next one— except hit end sentinel, case don’t move. That way, client keeps calling pop( ), keep getting null back indicate stack empty. Exercise 5: (2) Remove type parameter Node class modify rest code LinkedStack.java show inner class access generic type parameters outer class. RandomList For another example holder, suppose you’d like special type list randomly selects one elements time call select( ). When want build tool works objects, use generics: //: generics/RandomList.java import java.util.*; public class RandomList<T> { private ArrayList<T> storage = new ArrayList<T>(); private Random rand = new Random(47); public void add(T item) { storage.add(item); } public T select() { return storage.get(rand.nextInt(storage.size())); } public static void main(String[] args) { RandomList<String> rs = new RandomList<String>(); for(String s: ("The quick brown fox jumped " + "the lazy brown dog").split(" ")) rs.add(s); for(int = 0; < 11; i++) System.out.print(rs.select() + " "); } } /* Output: Generics 445 brown fox quick quick dog brown The brown lazy brown *///:~ Exercise 6: (1) Use RandomList two types addition one shown main( ). Generic interfaces Generics also work interfaces. For example, generator class creates objects. It’s actually specialization Factory Method design pattern, ask generator new object, don’t pass arguments, whereas typically pass arguments Factory Method. The generator knows create new objects without extra information. Typically, generator defines one method, method produces new objects. Here, we’ll call next( ), include standard utilities: //: net/mindview/util/Generator.java // A generic interface. package net.mindview.util; public interface Generator<T> { T next(); } ///:~ The return type next( ) parameterized T. As see, using generics interfaces different using generics classes. To demonstrate implementation Generator, we’ll need classes. Here’s coffee hierarchy: //: generics/coffee/Coffee.java package generics.coffee; public class Coffee { private static long counter = 0; private final long id = counter++; public String toString() { return getClass().getSimpleName() + " " + id; } } ///:~ //: generics/coffee/Latte.java package generics.coffee; public class Latte extends Coffee {} ///:~ //: generics/coffee/Mocha.java package generics.coffee; public class Mocha extends Coffee {} ///:~ //: generics/coffee/Cappuccino.java package generics.coffee; public class Cappuccino extends Coffee {} ///:~ //: generics/coffee/Americano.java package generics.coffee; public class Americano extends Coffee {} ///:~ //: generics/coffee/Breve.java package generics.coffee; public class Breve extends Coffee {} ///:~ 446 Thinking Java Bruce Eckel Now implement Generator < Coffee > produces random different types Coffee objects: //: generics/coffee/CoffeeGenerator.java // Generate different types Coffee: package generics.coffee; import java.util.*; import net.mindview.util.*; public class CoffeeGenerator implements Generator<Coffee>, Iterable<Coffee> { private Class[] types = { Latte.class, Mocha.class, Cappuccino.class, Americano.class, Breve.class, }; private static Random rand = new Random(47); public CoffeeGenerator() {} // For iteration: private int size = 0; public CoffeeGenerator(int sz) { size = sz; } public Coffee next() { try { return (Coffee) types[rand.nextInt(types.length)].newInstance(); // Report programmer errors run time: } catch(Exception e) { throw new RuntimeException(e); } } class CoffeeIterator implements Iterator<Coffee> { int count = size; public boolean hasNext() { return count > 0; } public Coffee next() { count--; return CoffeeGenerator.this.next(); } public void remove() { // Not implemented throw new UnsupportedOperationException(); } }; public Iterator<Coffee> iterator() { return new CoffeeIterator(); } public static void main(String[] args) { CoffeeGenerator gen = new CoffeeGenerator(); for(int = 0; < 5; i++) System.out.println(gen.next()); for(Coffee c : new CoffeeGenerator(5)) System.out.println(c); } } /* Output: Americano 0 Latte 1 Americano 2 Mocha 3 Mocha 4 Breve 5 Americano 6 Latte 7 Cappuccino 8 Cappuccino 9 *///:~ Generics 447 The parameterized Generator interface ensures next( ) returns parameter type. CoffeeGenerator also implements Iterable interface, used foreach statement. However, requires "end sentinel" know stop, produced using second constructor. Here’s second implementation Generator<T>, time produce Fibonacci numbers: //: generics/Fibonacci.java // Generate Fibonacci sequence. import net.mindview.util.*; public class Fibonacci implements Generator<Integer> { private int count = 0; public Integer next() { return fib(count++); } private int fib(int n) { if(n < 2) return 1; return fib(n-2) + fib(n-1); } public static void main(String[] args) { Fibonacci gen = new Fibonacci(); for(int = 0; < 18; i++) System.out.print(gen.next() + " "); } } /* Output: 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 *///:~ Although working ints inside outside class, type parameter Integer. This brings one limitations Java generics: You cannot use primitives type parameters. However, Java SE5 conveniently added autoboxing autounboxing convert primitive types wrapper types back. You see effect ints seamlessly used produced class. We go one step make Iterable Fibonacci generator. One option reimplement class add Iterable interface, don’t always control original code, don’t want rewrite don’t to. Instead, create adapter produce desired interface—this design pattern introduced earlier book. Adapters implemented multiple ways. For example, could use inheritance generate adapted class: //: generics/IterableFibonacci.java // Adapt Fibonacci class make Iterable. import java.util.*; public class IterableFibonacci extends Fibonacci implements Iterable<Integer> { private int n; public IterableFibonacci(int count) { n = count; } public Iterator<Integer> iterator() { return new Iterator<Integer>() { public boolean hasNext() { return n > 0; } public Integer next() { n--; return IterableFibonacci.this.next(); } public void remove() { // Not implemented throw new UnsupportedOperationException(); 448 Thinking Java Bruce Eckel } }; } public static void main(String[] args) { for(int : new IterableFibonacci(18)) System.out.print(i + " "); } } /* Output: 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 *///:~ To use IterableFibonacci foreach statement, give constructor boundary hasNext( ) know return false. Exercise 7: (2) Use composition instead inheritance adapt Fibonacci make Iterable. Exercise 8: (2) Following form Coffee example, create hierarchy StoryCharacters favorite movie, dividing GoodGuys BadGuys. Create generator StoryCharacters, following form CoffeeGenerator. Generic methods So far we’ve looked parameterizing entire classes. You also parameterize methods within class. The class may may generic—this independent whether generic method. A generic method allows method vary independently class. As guideline, use generic methods "whenever can." That is, it’s possible make method generic rather entire class, it’s probably going clearer so. In addition, method static, access generic type parameters class, needs use genericity must generic method. To define generic method, simply place generic parameter list return value, like this: //: generics/GenericMethods.java public class GenericMethods { public <T> void f(T x) { System.out.println(x.getClass().getName()); } public static void main(String[] args) { GenericMethods gm = new GenericMethods(); gm.f(""); gm.f(1); gm.f(1.0); gm.f(1.0F); gm.f(‘c’); gm.f(gm); } } /* Output: java.lang.String java.lang.Integer java.lang.Double java.lang.Float java.lang.Character GenericMethods Generics 449 *///:~ The class GenericMethods parameterized, although class methods may parameterized time. But case, method f( ) type parameter, indicated parameter list method’s return type. Notice generic class, must specify type parameters instantiate class. But generic method, don’t usually specify parameter types, compiler figure you. This called type argument inference. So calls f( ) look like normal method calls, appears f( ) infinitely overloaded. It even take argument type GenericMethods. For calls f( ) use primitive types, autoboxing comes play, automatically wrapping primitive types associated objects. In fact, generic methods autoboxing eliminate code previously required hand conversion. Exercise 9: (1) Modify GenericMethods.java f( ) accepts three arguments, different parameterized type. Exercise 10: (1) Modify previous exercise one f( )’s arguments non- parameterized. Leveraging type argument inference One complaints generics adds even text code. Consider holding/MapOfList.java Holding Your Objects chapter. The creation Map List looks like this: Map<Person, List<? extends Pet>> petPeople = new HashMap<Person, List<? extends Pet>>(); (This use extends question marks explained later chapter.) It appears repeating yourself, compiler figure one generic argument lists other. Alas, cannot, type argument inference generic method produce simplification. For example, create utility containing various static methods, produces commonly used implementations various containers: //: net/mindview/util/New.java // Utilities simplify generic container creation // using type argument inference. package net.mindview.util; import java.util.*; public class New { public static <K,V> Map<K,V> map() { return new HashMap<K,V>(); } public static <T> List<T> list() { return new ArrayList<T>(); } public static <T> LinkedList<T> lList() { return new LinkedList<T>(); } public static <T> Set<T> set() { return new HashSet<T>(); } public static <T> Queue<T> queue() { 450 Thinking Java Bruce Eckel return new LinkedList<T>(); } // Examples: public static void main(String[] args) { Map<String, List<String>> sls = New.map(); List<String> ls = New.list(); LinkedList<String> lls = New.lList(); Set<String> ss = New.set(); Queue<String> qs = New.queue(); } } ///:~ In main( ) see examples used—type argument inference eliminates need repeat generic parameter list. This applied holding/MapOfList.java: //: generics/SimplerPets.java import typeinfo.pets.*; import java.util.*; import net.mindview.util.*; public class SimplerPets { public static void main(String[] args) { Map<Person, List<? extends Pet>> petPeople = New.map(); // Rest code same... } } ///:~ Although interesting example type argument inference, it’s difficult say much actually buys you. The person reading code required parse understand additional library implications, might productive leave original (admittedly repetitious) definition place—ironically, simplicity. However, standard Java library add something like New.java utility above, would make sense use it. Type inference doesn’t work anything assignment. If pass result method call New.map( ) argument another method, compiler try perform type inference. Instead treat method call though return value assigned variable type Object. Here’s example fails: //: generics/LimitsOfInference.java import typeinfo.pets.*; import java.util.*; public class LimitsOfInference { static void f(Map<Person, List<? extends Pet>> petPeople) {} public static void main(String[] args) { // f(New.map()); // Does compile } } ///:~ Exercise 11: (1) Test New.java creating classes ensuring New work properly them. Generics 451 Explicit type specification It possible explicitly specify type generic method, although syntax rarely needed. To so, place type angle brackets dot immediately preceding method name. When calling method within class, must use dot, working static methods, must use class name dot. The problem shown LimitsOflnference.java solved using syntax: //: generics/ExplicitTypeSpecification.java import typeinfo.pets.*; import java.util.*; import net.mindview.util.*; public class ExplicitTypeSpecification { static void f(Map<Person, List<Pet>> petPeople) {} public static void main(String[] args) { f(New.<Person, List<Pet>>map()); } } ///:~ Of course, eliminates benefit using New class reduce amount typing, extra syntax required writing assignment statement. Exercise 12: (1) Repeat previous exercise using explicit type specification. Varargs generic methods Generic methods variable argument lists coexist nicely: //: generics/GenericVarargs.java import java.util.*; public class GenericVarargs { public static <T> List<T> makeList(T... args) { List<T> result = new ArrayList<T>(); for(T item : args) result.add(item); return result; } public static void main(String[] args) { List<String> ls = makeList("A"); System.out.println(ls); ls = makeList("A", "B", "C"); System.out.println(ls); ls = makeList("ABCDEFFHIJKLMNOPQRSTUVWXYZ".split("")); System.out.println(ls); } } /* Output: [A] [A, B, C] [, A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z] *///:~ The makeList( ) method shown produces functionality standard library’s java.util.Arrays.asList( ) method. 452 Thinking Java Bruce Eckel A generic method use Generators It convenient use generator fill Collection, makes sense "generify" operation: //: generics/Generators.java // A utility use Generators. import generics.coffee.*; import java.util.*; import net.mindview.util.*; public class Generators { public static <T> Collection<T> fill(Collection<T> coll, Generator<T> gen, int n) { for(int = 0; < n; i++) coll.add(gen.next()); return coll; } public static void main(String[] args) { Collection<Coffee> coffee = fill( new ArrayList<Coffee>(), new CoffeeGenerator(), 4); for(Coffee c : coffee) System.out.println(c); Collection<Integer> fnumbers = fill( new ArrayList<Integer>(), new Fibonacci(), 12); for(int : fnumbers) System.out.print(i + ", "); } } /* Output: Americano 0 Latte 1 Americano 2 Mocha 3 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, *///:~ Notice generic method fill( ) transparently applied Coffee Integer containers generators. Exercise 13: (4) Overload fill( ) method arguments return types specific subtypes Collection: List, Queue Set. This way, don’t lose type container. Can overload distinguish List LinkedList? A general-purpose Generator Here’s class produces Generator class default constructor. To reduce typing, also includes generic method produce BasicGenerator: //: net/mindview/util/BasicGenerator.java // Automatically create Generator, given class // default (no-arg) constructor. package net.mindview.util; public class BasicGenerator<T> implements Generator<T> { private Class<T> type; public BasicGenerator(Class<T> type){ this.type = type; } public T next() { Generics 453 try { // Assumes type public class: return type.newInstance(); } catch(Exception e) { throw new RuntimeException(e); } } // Produce Default generator given type token: public static <T> Generator<T> create(Class<T> type) { return new BasicGenerator<T>(type); } } ///:~ This class provides basic implementation produce objects class (1) public (because BasicGenerator separate package, class question must public package access) (2) default constructor (one takes arguments). To create one BasicGenerator objects, call create( ) method pass type token type want generated. The generic create( ) method allows say BasicGenerator.create(MyType.class) instead awkward new BasicGenerator<MyType>(MyType.class). For example, here’s simple class default constructor: //: generics/CountedObject.java public class CountedObject { private static long counter = 0; private final long id = counter++; public long id() { return id; } public String toString() { return "CountedObject " + id;} } ///:~ The CountedObject class keeps track many instances created, reports toString( ). Using BasicGenerator, easily create Generator CountedObject: //: generics/BasicGeneratorDemo.java import net.mindview.util.*; public class BasicGeneratorDemo { public static void main(String[] args) { Generator<CountedObject> gen = BasicGenerator.create(CountedObject.class); for(int = 0; < 5; i++) System.out.println(gen.next()); } } /* Output: CountedObject 0 CountedObject 1 CountedObject 2 CountedObject 3 CountedObject 4 *///:~ You see generic method reduces amount typing necessary produce Generator object. Java generics force pass Class object anyway, might well use type inference create( ) method. 454 Thinking Java Bruce Eckel Exercise 14: (1) Modify BasicGeneratorDemo.java use explicit form creation Generator (that is, use explicit constructor instead generic create( ) method). Simplifying tuple use Type argument inference, together static imports, allows tuples saw earlier rewritten general-purpose library. Here, tuples created using overloaded static method: //: net/mindview/util/Tuple.java // Tuple library using type argument inference. package net.mindview.util; public class Tuple { public static <A,B> TwoTuple<A,B> tuple(A a, B b) { return new TwoTuple<A,B>(a, b); } public static <A,B,C> ThreeTuple<A,B,C> tuple(A a, B b, C c) { return new ThreeTuple<A,B,C>(a, b, c); } public static <A,B,C,D> FourTuple<A,B,C,D> tuple(A a, B b, C c, D d) { return new FourTuple<A,B,C,D>(a, b, c, d); } public static <A,B,C,D,E> FiveTuple<A,B,C,D,E> tuple(A a, B b, C c, D d, E e) { return new FiveTuple<A,B,C,D,E>(a, b, c, d, e); } } ///:~ Here’s modification TupleTest.java test Tuple.java: //: generics/TupleTest2.java import net.mindview.util.*; import static net.mindview.util.Tuple.*; public class TupleTest2 { static TwoTuple<String,Integer> f() { return tuple("hi", 47); } static TwoTuple f2() { return tuple("hi", 47); } static ThreeTuple<Amphibian,String,Integer> g() { return tuple(new Amphibian(), "hi", 47); } static FourTuple<Vehicle,Amphibian,String,Integer> h() { return tuple(new Vehicle(), new Amphibian(), "hi", 47); } static FiveTuple<Vehicle,Amphibian,String,Integer,Double> k() { return tuple(new Vehicle(), new Amphibian(), "hi", 47, 11.1); } public static void main(String[] args) { TwoTuple<String,Integer> ttsi = f(); System.out.println(ttsi); System.out.println(f2()); System.out.println(g()); Generics 455 System.out.println(h()); System.out.println(k()); } } /* Output: (80% match) (hi, 47) (hi, 47) (Amphibian@7d772e, hi, 47) (Vehicle@757aef, Amphibian@d9f9c3, hi, 47) (Vehicle@1a46e30, Amphibian@3e25a5, hi, 47, 11.1) *///:~ Notice f( ) returns parameterized TwoTuple object, f2( ) returns unparameterized TwoTuple object. The compiler doesn’t warn f2( ) case return value used parameterized fashion; sense, "upcast" unparameterized TwoTuple. However, try capture result f2( ) parameterized TwoTuple, compiler would issue warning. Exercise 15: (1) Verify previous statement. Exercise 16: (2) Add SixTuple Tuple.java, test TupleTest2 .j ava. A Set utility For another example use generic methods, consider mathematical relationships expressed using Sets. These conveniently defined generic methods, used different types: //: net/mindview/util/Sets.java package net.mindview.util; import java.util.*; public class Sets { public static <T> Set<T> union(Set<T> a, Set<T> b) { Set<T> result = new HashSet<T>(a); result.addAll(b); return result; } public static <T> Set<T> intersection(Set<T> a, Set<T> b) { Set<T> result = new HashSet<T>(a); result.retainAll(b); return result; } // Subtract subset superset: public static <T> Set<T> difference(Set<T> superset, Set<T> subset) { Set<T> result = new HashSet<T>(superset); result.removeAll(subset); return result; } // Reflexive--everything intersection: public static <T> Set<T> complement(Set<T> a, Set<T> b) { return difference(union(a, b), intersection(a, b)); } } ///:~ The first three methods duplicate first argument copying references new HashSet object, argument Sets directly modified. The return value thus new Set object. 456 Thinking Java Bruce Eckel The four methods represent mathematical set operations: union( ) returns Set containing combination two arguments, intersection( ) returns Set containing common elements two arguments, difference( ) performs subtraction subset elements superset, complement( ) returns Set elements intersection. To create simple example showing effects methods, here’s enum containing different names watercolors: //: generics/watercolors/Watercolors.java package generics.watercolors; public enum Watercolors { ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW, ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER, BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK } ///:~ For convenience (so names don’t qualified), imported statically following example. This example uses EnumSet, Java SE5 tool easy creation Sets enums. (You’ll learn EnumSet Enumerated Types chapter.) Here, static method EnumSet.range( ) given first last elements range create resulting Set: //: generics/WatercolorSets.java import generics.watercolors.*; import java.util.*; import static net.mindview.util.Print.*; import static net.mindview.util.Sets.*; import static generics.watercolors.Watercolors.*; public class WatercolorSets { public static void main(String[] args) { Set<Watercolors> set1 = EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE); Set<Watercolors> set2 = EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER); print("set1: " + set1); print("set2: " + set2); print("union(set1, set2): " + union(set1, set2)); Set<Watercolors> subset = intersection(set1, set2); print("intersection(set1, set2): " + subset); print("difference(set1, subset): " + difference(set1, subset)); print("difference(set2, subset): " + difference(set2, subset)); print("complement(set1, set2): " + complement(set1, set2)); } } /* Output: (Sample) set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE] set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER, BURNT_UMBER] union(set1, set2): [SAP_GREEN, ROSE_MADDER, YELLOW_OCHRE, PERMANENT_GREEN, BURNT_UMBER, COBALT_BLUE_HUE, VIOLET, BRILLIANT_RED, RAW_UMBER, ULTRAMARINE, BURNT_SIENNA, CRIMSON, CERULEAN_BLUE_HUE, PHTHALO_BLUE, MAGENTA, VIRIDIAN_HUE] Generics 457 intersection(set1, set2): [ULTRAMARINE, PERMANENT_GREEN, COBALT_BLUE_HUE, PHTHALO_BLUE, CERULEAN_BLUE_HUE, VIRIDIAN_HUE] difference(set1, subset): [ROSE_MADDER, CRIMSON, VIOLET, MAGENTA, BRILLIANT_RED] difference(set2, subset): [RAW_UMBER, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, BURNT_UMBER] complement(set1, set2): [SAP_GREEN, ROSE_MADDER, YELLOW_OCHRE, BURNT_UMBER, VIOLET, BRILLIANT_RED, RAW_UMBER, BURNT_SIENNA, CRIMSON, MAGENTA] *///:~ You see results operation output. The following example uses Sets.difference( ) show method differences various Collection Map classes java.util: //: net/mindview/util/ContainerMethodDifferences.java package net.mindview.util; import java.lang.reflect.*; import java.util.*; public class ContainerMethodDifferences { static Set<String> methodSet(Class<?> type) { Set<String> result = new TreeSet<String>(); for(Method : type.getMethods()) result.add(m.getName()); return result; } static void interfaces(Class<?> type) { System.out.print("Interfaces " + type.getSimpleName() + ": "); List<String> result = new ArrayList<String>(); for(Class<?> c : type.getInterfaces()) result.add(c.getSimpleName()); System.out.println(result); } static Set<String> object = methodSet(Object.class); static { object.add("clone"); } static void difference(Class<?> superset, Class<?> subset) { System.out.print(superset.getSimpleName() + " extends " + subset.getSimpleName() + ", adds: "); Set<String> comp = Sets.difference( methodSet(superset), methodSet(subset)); comp.removeAll(object); // Don’t show ‘Object’ methods System.out.println(comp); interfaces(superset); } public static void main(String[] args) { System.out.println("Collection: " + methodSet(Collection.class)); interfaces(Collection.class); difference(Set.class, Collection.class); difference(HashSet.class, Set.class); difference(LinkedHashSet.class, HashSet.class); difference(TreeSet.class, Set.class); difference(List.class, Collection.class); difference(ArrayList.class, List.class); difference(LinkedList.class, List.class); difference(Queue.class, Collection.class); difference(PriorityQueue.class, Queue.class); System.out.println("Map: " + methodSet(Map.class)); difference(HashMap.class, Map.class); 458 Thinking Java Bruce Eckel difference(LinkedHashMap.class, HashMap.class); difference(SortedMap.class, Map.class); difference(TreeMap.class, Map.class); } } ///:~ The output program used "Summary" section Holding Your Objects chapter. Exercise 17: (4) Study JDK documentation EnumSet. You’ll see there’s clone( ) method defined. However, cannot clone( ) reference Set interface passed Sets.java. Can modify Sets.java handle general case Set interface shown, special case EnumSet, using clone( ) instead creating new HashSet? Anonymous inner classes Generics also used inner classes anonymous inner classes. Here’s example implements Generator interface using anonymous inner classes: //: generics/BankTeller.java // A simple bank teller simulation. import java.util.*; import net.mindview.util.*; class Customer { private static long counter = 1; private final long id = counter++; private Customer() {} public String toString() { return "Customer " + id; } // A method produce Generator objects: public static Generator<Customer> generator() { return new Generator<Customer>() { public Customer next() { return new Customer(); } }; } } class Teller { private static long counter = 1; private final long id = counter++; private Teller() {} public String toString() { return "Teller " + id; } // A single Generator object: public static Generator<Teller> generator = new Generator<Teller>() { public Teller next() { return new Teller(); } }; } public class BankTeller { public static void serve(Teller t, Customer c) { System.out.println(t + " serves " + c); } public static void main(String[] args) { Random rand = new Random(47); Queue<Customer> line = new LinkedList<Customer>(); Generators.fill(line, Customer.generator(), 15); List<Teller> tellers = new ArrayList<Teller>(); Generators.fill(tellers, Teller.generator, 4); Generics 459 for(Customer c : line) serve(tellers.get(rand.nextInt(tellers.size())), c); } } /* Output: Teller 3 serves Teller 2 serves Teller 3 serves Teller 1 serves Teller 1 serves Teller 3 serves Teller 1 serves Teller 2 serves Teller 3 serves Teller 3 serves Teller 2 serves Teller 4 serves Teller 2 serves Teller 1 serves Teller 1 serves *///:~ Customer Customer Customer Customer Customer Customer Customer Customer Customer Customer Customer Customer Customer Customer Customer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Both Customer Teller private constructors, thereby forcing use Generator objects. Customer generator( ) method produces new Generator<Customer> object time call it. You may need multiple Generator objects, Teller creates single public generator object. You see approaches used fill( ) methods main( ). Since generator( ) method Customer Generator object Teller static, cannot part interface, way "generify" particular idiom. Despite that, works reasonably well fill( ) method. We’ll look versions queuing problem Concurrency chapter. Exercise 18: (3) Following form BankTeller.java, create example BigFish eat LittleFish Ocean. Building complex models An important benefit generics ability simply safely create complex models. For example, easily create List tuples: //: generics/TupleList.java // Combining generic types make complex generic types. import java.util.*; import net.mindview.util.*; public class TupleList<A,B,C,D> extends ArrayList<FourTuple<A,B,C,D>> { public static void main(String[] args) { TupleList<Vehicle, Amphibian, String, Integer> tl = new TupleList<Vehicle, Amphibian, String, Integer>(); tl.add(TupleTest.h()); tl.add(TupleTest.h()); for(FourTuple<Vehicle,Amphibian,String,Integer> i: tl) System.out.println(i); } } /* Output: (75% match) (Vehicle@11b86e7, Amphibian@35ce36, hi, 47) (Vehicle@757aef, Amphibian@d9f9c3, hi, 47) 460 Thinking Java Bruce Eckel *///:~ Although gets somewhat verbose (especially creation iterator), end fairly powerful data structure without much code. Here’s another example showing straightforward build complex models using generic types. Even though class created building block, total many parts. In case, model retail store aisles, shelves products: //: generics/Store.java // Building complex model using generic containers. import java.util.*; import net.mindview.util.*; class Product { private final int id; private String description; private double price; public Product(int IDnumber, String descr, double price){ id = IDnumber; description = descr; this.price = price; System.out.println(toString()); } public String toString() { return id + ": " + description + ", price: $" + price; } public void priceChange(double change) { price += change; } public static Generator<Product> generator = new Generator<Product>() { private Random rand = new Random(47); public Product next() { return new Product(rand.nextInt(1000), "Test", Math.round(rand.nextDouble() * 1000.0) + 0.99); } }; } class Shelf extends ArrayList<Product> { public Shelf(int nProducts) { Generators.fill(this, Product.generator, nProducts); } } class Aisle extends ArrayList<Shelf> { public Aisle(int nShelves, int nProducts) { for(int = 0; < nShelves; i++) add(new Shelf(nProducts)); } } class CheckoutStand {} class Office {} public class Store extends ArrayList<Aisle> { private ArrayList<CheckoutStand> checkouts = new ArrayList<CheckoutStand>(); private Office office = new Office(); public Store(int nAisles, int nShelves, int nProducts) { for(int = 0; < nAisles; i++) Generics 461 add(new Aisle(nShelves, nProducts)); } public String toString() { StringBuilder result = new StringBuilder(); for(Aisle : this) for(Shelf : a) for(Product p : s) { result.append(p); result.append("\n"); } return result.toString(); } public static void main(String[] args) { System.out.println(new Store(14, 5, 10)); } } /* Output: 258: Test, price: $400.99 861: Test, price: $160.99 868: Test, price: $417.99 207: Test, price: $268.99 551: Test, price: $114.99 278: Test, price: $804.99 520: Test, price: $554.99 140: Test, price: $530.99 ... *///:~ As see Store.toString( ), result many layers containers nonetheless type-safe manageable. What’s impressive intellectually prohibitive assemble model. Exercise 19: (2) Following form Store.java, build model containerized cargo ship. The mystery erasure As begin delve deeply generics, number things won’t initially make sense. For example, although say ArrayList.class, cannot say ArrayList<Integer>.class. And consider following: //: generics/ErasedTypeEquivalence.java import java.util.*; public class ErasedTypeEquivalence { public static void main(String[] args) { Class c1 = new ArrayList<String>().getClass(); Class c2 = new ArrayList<Integer>().getClass(); System.out.println(c1 == c2); } } /* Output: true *///:~ Array List < String > Array List < Integer > could easily argued distinct types. Different types behave differently, try, example, put Integer Array List < String >, get different behavior (it fails) put Integer ArrayList< Integer > (it succeeds). And yet program suggests type. 462 Thinking Java Bruce Eckel Here’s example adds puzzle: //: generics/LostInformation.java import java.util.*; class class class class Frob {} Fnorkle {} Quark<Q> {} Particle<POSITION,MOMENTUM> {} public class LostInformation { public static void main(String[] args) { List<Frob> list = new ArrayList<Frob>(); Map<Frob,Fnorkle> map = new HashMap<Frob,Fnorkle>(); Quark<Fnorkle> quark = new Quark<Fnorkle>(); Particle<Long,Double> p = new Particle<Long,Double>(); System.out.println(Arrays.toString( list.getClass().getTypeParameters())); System.out.println(Arrays.toString( map.getClass().getTypeParameters())); System.out.println(Arrays.toString( quark.getClass().getTypeParameters())); System.out.println(Arrays.toString( p.getClass().getTypeParameters())); } } /* Output: [E] [K, V] [Q] [POSITION, MOMENTUM] *///:~ According JDK documentation, Class.getTypeParameters( ) "returns array TypeVariable objects represent type variables declared generic declaration..." This seems suggest might able find parameter types are. However, see output, find identifiers used parameter placeholders, interesting piece information. The cold truth is: There’s information generic parameter types available inside generic code. Thus, know things like identifier type parameter bounds generic type—you can’t know actual type parameter(s) used create particular instance. This fact, especially frustrating you’re coming C++, fundamental issue must deal working Java generics. Java generics implemented using erasure. This means specific type information erased use generic. Inside generic, thing know you’re using object. So List<String> List< Integer> are, fact, type run time. Both forms "erased" raw type, List. Understanding erasure must deal one biggest hurdles face learning Java generics, that’s we’ll explore section. Generics 463 The C++ approach Here’s C++ example uses templates. You’ll notice syntax parameterized types quite similar, Java took inspiration C++: //: generics/Templates.cpp #include <iostream> using namespace std; template<class T> class Manipulator { T obj; public: Manipulator(T x) { obj = x; } void manipulate() { obj.f(); } }; class HasF { public: void f() { cout << "HasF::f()" << endl; } }; int main() { HasF hf; Manipulator<HasF> manipulator(hf); manipulator.manipulate(); } /* Output: HasF::f() ///:~ The Manipulator class stores object type T. What’s interesting manipulate( ) method, calls method f( ) obj. How know f( ) method exists type parameter T? The C++ compiler checks instantiate template, point instantiation Manipulator <HasF>, sees HasF method f( ). If case, you’d get compile-time error, thus type safety preserved. Writing kind code C++ straightforward template instantiated, template code knows type template parameters. Java generics different. Here’s translation HasF: //: generics/HasF.java public class HasF { public void f() { System.out.println("HasF.f()"); } } ///:~ If take rest example translate Java, won’t compile: //: generics/Manipulation.java // {CompileTimeError} (Won’t compile) class Manipulator<T> { private T obj; public Manipulator(T x) { obj = x; } // Error: cannot find symbol: method f(): public void manipulate() { obj.f(); } } public class Manipulation { public static void main(String[] args) { HasF hf = new HasF(); 464 Thinking Java Bruce Eckel Manipulator<HasF> manipulator = new Manipulator<HasF>(hf); manipulator.manipulate(); } } ///:~ Because erasure, Java compiler can’t map requirement manipulate( ) must able call f( ) obj fact HasF method f( ). In order call f( ), must assist generic class giving bound tells compiler accept types conform bound. This reuses extends keyword. Because bound, following compiles: //: generics/Manipulator2.java class Manipulator2<T extends HasF> { private T obj; public Manipulator2(T x) { obj = x; } public void manipulate() { obj.f(); } } ///:~ The bound <T extends HasF> says T must type HasF something derived HasF. If true, safe call f( ) obj. We say generic type parameter erases first bound (it’s possible multiple bounds, shall see later). We also talk erasure type parameter. The compiler actually replaces type parameter erasure, case, T erases HasF, replacing T HasF class body. You may correctly observe Manipulations.Java, generics contribute anything. You could easily perform erasure produce class without generics: //: generics/Manipulator3.java class Manipulator3 { private HasF obj; public Manipulator3(HasF x) { obj = x; } public void manipulate() { obj.f(); } } ///:~ This brings important point: Generics useful want use type parameters "generic" specific type (and subtypes)—that is, want code work across multiple classes. As result, type parameters application useful generic code usually complex simple class replacement. However, can’t say anything form <T extends HasF> therefore flawed. For example, class method returns T, generics helpful, return exact type: //: generics/ReturnGenericType.java class ReturnGenericType<T extends HasF> { private T obj; public ReturnGenericType(T x) { obj = x; } public T get() { return obj; } } ///:~ You look code understand whether "complex enough" warrant use generics. Generics 465 We’ll look bounds detail later chapter. Exercise 20: (1) Create interface two methods, class implements interface adds another method. In another class, create generic method argument type bounded interface, show methods interface callable inside generic method. In main( ), pass instance implementing class generic method. Migration compatibility To allay potential confusion erasure, must clearly understand language feature. It compromise implementation Java generics, necessary generics made part language beginning. This compromise cause pain, need get used early understand it’s there. If generics part Java l.o, feature would implemented using erasure—it would used reification retain type parameters first-class entities, would able perform type-based language reflective operations type parameters. You’ll see later chapter erasure reduces "genericity" generics. Generics still useful Java, useful could be, reason erasure. In erasure-based implementation, generic types treated secondclass types cannot used important contexts. The generic types present static type checking, every generic type program erased replacing non-generic upper bound. For example, type annotations List<T> erased List, ordinary type variables erased Object unless bound specified. The core motivation erasure allows generified clients used nongenerified libraries, vice versa. This often called migration compatibility. In ideal world, would single day everything generified once. In reality, even programmers writing generic code, deal non-generic libraries written Java SE5. The authors libraries may never incentive generify code, may take time getting it. So Java generics must support backwards compatibility—existing code class files still legal, continue mean meant before—but also must support migration compatibility, libraries become generic pace, library become generic, doesn’t break code applications depend upon it. After deciding goal, Java designers various groups working problem decided erasure feasible solution. Erasure enables migration towards generics allowing non-generic code coexist generic code. For example, suppose application uses two libraries, X Y, Y uses library Z. With advent Java SE5, creators application libraries probably, eventually, want migrate generics. Each them, however, different motivations constraints migration happens. To achieve migration compatibility, library application must independent others regarding whether generics used. Thus, must able detect whether libraries using generics. Ergo, evidence particular library using generics must "erased." Without kind migration path, libraries built time stood chance cut developers chose move Java generics. Libraries arguably part programming language greatest productivity impact, acceptable cost. Whether erasure best migration path something time tell. 466 Thinking Java Bruce Eckel The problem erasure So primary justification erasure transition process nongenerified code generified code, incorporate generics language without breaking existing libraries. Erasure allows existing nongeneric client code continue used without change, clients ready rewrite code generics. This noble motivation, doesn’t suddenly break existing code. The cost erasure significant. Generic types cannot used operations explicitly refer runtime types, casts, instanceof operations, new expressions. Because type information parameters lost, whenever you’re writing generic code must constantly reminding appears type information parameter. So write piece code like this: class Foo<T> { T var; } appears create instance Foo: Foo<Cat> f = new Foo<Cat>(); code class Foo ought know working Cat. The syntax strongly suggests type T substituted everywhere throughout class. But isn’t, must remind yourself, "No, it’s Object," whenever you’re writing code class. In addition, erasure migration compatibility mean use generics enforced might want be: //: generics/ErasureAndInheritance.java class GenericBase<T> { private T element; public void set(T arg) { arg = element; } public T get() { return element; } } class Derived1<T> extends GenericBase<T> {} class Derived2 extends GenericBase {} // No warning // class Derived3 extends GenericBase<?> {} // Strange error: // unexpected type found : ? // required: class interface without bounds public class ErasureAndInheritance { @SuppressWarnings("unchecked") public static void main(String[] args) { Derived2 d2 = new Derived2(); Object obj = d2.get(); d2.set(obj); // Warning here! } } ///:~ Derived2 inherits GenericBase generic parameters, compiler doesn’t issue warning. The warning doesn’t occur set( ) called. Generics 467 To turn warning, Java provides annotation, one see listing (this annotation supported earlier releases Java SE5): @SuppressWarnings("unchecked") Notice placed method generates warning, rather entire class. It’s best "focused" possible turn warning, don’t accidentally cloak real problem turning warnings broadly. Presumably, error produced Derived3 means compiler expects raw base class. Add extra effort managing bounds want treat type parameter Object, far effort much less payoff get parameterized types languages like C++, Ada Eiffel. This say languages general buy Java majority programming problems, rather parameterized type mechanisms flexible powerful Java’s. The action boundaries Because erasure, I find confusing aspect generics fact represent things meaning. For example: //: generics/ArrayMaker.java import java.lang.reflect.*; import java.util.*; public class ArrayMaker<T> { private Class<T> kind; public ArrayMaker(Class<T> kind) { this.kind = kind; } @SuppressWarnings("unchecked") T[] create(int size) { return (T[])Array.newInstance(kind, size); } public static void main(String[] args) { ArrayMaker<String> stringMaker = new ArrayMaker<String>(String.class); String[] stringArray = stringMaker.create(9); System.out.println(Arrays.toString(stringArray)); } } /* Output: [null, null, null, null, null, null, null, null, null] *///:~ Even though kind stored Class<T>, erasure means actually stored Class, parameter. So, something it, creating array, Array.newInstance( ) doesn’t actually type information that’s implied kind; cannot produce specific result, must therefore cast, produces warning cannot satisfy. Note using Array.newInstance( ) recommended approach creating arrays generics. If create container instead array, things different: //: generics/ListMaker.java import java.util.*; 468 Thinking Java Bruce Eckel public class ListMaker<T> { List<T> create() { return new ArrayList<T>(); } public static void main(String[] args) { ListMaker<String> stringMaker= new ListMaker<String>(); List<String> stringList = stringMaker.create(); } } ///:~ The compiler gives warnings, even though know (from erasure) <T> new ArrayList<T>( ) inside create( ) removed—at run time there’s <T> inside class, seems meaningless. But follow idea change expression new ArrayList( ), compiler gives warning. Is really meaningless case? What put objects list returning it, like this: //: generics/FilledListMaker.java import java.util.*; public class FilledListMaker<T> { List<T> create(T t, int n) { List<T> result = new ArrayList<T>(); for(int = 0; < n; i++) result.add(t); return result; } public static void main(String[] args) { FilledListMaker<String> stringMaker = new FilledListMaker<String>(); List<String> list = stringMaker.create("Hello", 4); System.out.println(list); } } /* Output: [Hello, Hello, Hello, Hello] *///:~ Even though compiler unable know anything T inside create( ), still ensure—at compile time—that put result type T, agrees ArrayList<T>. Thus, even though erasure removes information actual type inside method class, compiler still ensure internal consistency way type used within method class. Because erasure removes type information body method, matters run time boundaries: points objects enter leave method. These points compiler performs type checks compile time, inserts casting code. Consider following nongeneric example: //: generics/SimpleHolder.java public class SimpleHolder { private Object obj; public void set(Object obj) { this.obj = obj; } public Object get() { return obj; } public static void main(String[] args) { SimpleHolder holder = new SimpleHolder(); holder.set("Item"); String = (String)holder.get(); } } ///:~ Generics 469 If decompile result javap -c SimpleHolder, get (after editing): public void set(java.lang.Object); 0: aload_0 1: aload_1 2: putfield #2; //Field obj:Object; 5: return public java.lang.Object get(); 0: aload_0 1: getfield #2; //Field obj:Object; 4: areturn public static void main(java.lang.String[]); 0: new #3; //class SimpleHolder 3: dup 4: invokespecial #4; //Method "<init>":()V 7: astore_1 8: aload_1 9: ldc #5; //String Item 11: invokevirtual #6; //Method set:(Object;)V 14: aload_1 15: invokevirtual #7; //Method get:()Object; 18: checkcast #8; //class java/lang/String 21: astore_2 22: return The set( ) get( ) methods simply store produce value, cast checked point call get( ). Now incorporate generics code: //: generics/GenericHolder.java public class GenericHolder<T> { private T obj; public void set(T obj) { this.obj = obj; } public T get() { return obj; } public static void main(String[] args) { GenericHolder<String> holder = new GenericHolder<String>(); holder.set("Item"); String = holder.get(); } } ///:~ The need cast get( ) disappeared, also know value passed set( ) type-checked compile time. Here relevant bytecodes: public void set(java.lang.Object); 0: aload_0 1: aload_1 2: putfield #2; //Field obj:Object; 5: return public java.lang.Object get(); 0: aload_0 1: getfield #2; //Field obj:Object; 4: areturn public static void main(java.lang.String[]); 470 Thinking Java Bruce Eckel 0: 3: 4: 7: 8: 9: 11: 14: 15: 18: 21: 22: new #3; //class GenericHolder dup invokespecial #4; //Method "<init>":()V astore_1 aload_1 ldc #5; //String Item invokevirtual #6; //Method set:(Object;)V aload_1 invokevirtual #7; //Method get:()Object; checkcast #8; //class java/lang/String astore_2 return The resulting code identical. The extra work checking incoming type set( ) free, performed compiler. And cast outgoing value get( ) still there, it’s less you’d yourself—and it’s automatically inserted compiler, code write (and read) less noisy. Since get( ) set( ) produce bytecodes, action generics happens boundaries—the extra compile-time check incoming values, inserted cast outgoing values. It helps counter confusion erasure remember "the boundaries action takes place." Compensating erasure As we’ve seen, erasure loses ability perform certain operations generic code. Anything requires knowledge exact type run time won’t work: //: generics/Erased.java // {CompileTimeError} (Won’t compile) public class Erased<T> { private final int SIZE = 100; public static void f(Object arg) { if(arg instanceof T) {} T var = new T(); T[] array = new T[SIZE]; T[] array = (T)new Object[SIZE]; } } ///:~ // // // // Error Error Error Unchecked warning Occasionally program around issues, sometimes must compensate erasure introducing type tag. This means explicitly pass Class object type use type expressions. For example, attempt use instanceof previous program fails type information erased. If introduce type tag, dynamic islnstance( ) used instead: //: generics/ClassTypeCapture.java class Building {} class House extends Building {} public class ClassTypeCapture<T> { Class<T> kind; public ClassTypeCapture(Class<T> kind) { this.kind = kind; } Generics 471 public boolean f(Object arg) { return kind.isInstance(arg); } public static void main(String[] args) { ClassTypeCapture<Building> ctt1 = new ClassTypeCapture<Building>(Building.class); System.out.println(ctt1.f(new Building())); System.out.println(ctt1.f(new House())); ClassTypeCapture<House> ctt2 = new ClassTypeCapture<House>(House.class); System.out.println(ctt2.f(new Building())); System.out.println(ctt2.f(new House())); } } /* Output: true true false true *///:~ The compiler ensures type tag matches generic argument. Exercise 21: (4) Modify ClassTypeCapture.java adding Map<String,Class<?>>, method addType(String typename, Class<?> kind), method createNew(String typename). createNew( ) either produce new instance class associated argument string, produce error message. Creating instances types The attempt create new T( ) Erased.java won’t work, partly erasure, partly compiler cannot verify T default (no-arg) constructor. But C++ operation natural, straightforward, safe (it’s checked compile time): //: generics/InstantiateGenericType.cpp // C++, Java! template<class T> class Foo { T x; // Create field type T T* y; // Pointer T public: // Initialize pointer: Foo() { = new T(); } }; class Bar {}; int main() { Foo<Bar> fb; Foo<int> fi; // ... works primitives } ///:~ 472 Thinking Java Bruce Eckel The solution Java pass factory object, use make new instance. A convenient factory object Class object, use type tag, use newlnstance( ) create new object type: //: generics/InstantiateGenericType.java import static net.mindview.util.Print.*; class ClassAsFactory<T> { T x; public ClassAsFactory(Class<T> kind) { try { x = kind.newInstance(); } catch(Exception e) { throw new RuntimeException(e); } } } class Employee {} public class InstantiateGenericType { public static void main(String[] args) { ClassAsFactory<Employee> fe = new ClassAsFactory<Employee>(Employee.class); print("ClassAsFactory<Employee> succeeded"); try { ClassAsFactory<Integer> fi = new ClassAsFactory<Integer>(Integer.class); } catch(Exception e) { print("ClassAsFactory<Integer> failed"); } } } /* Output: ClassAsFactory<Employee> succeeded ClassAsFactory<Integer> failed *///:~ This compiles, fails ClassAsFactory<Integer> Integer default constructor. Because error caught compile time, approach frowned upon Sun folks. They suggest instead use explicit factory constrain type takes class implements factory: //: generics/FactoryConstraint.java interface FactoryI<T> { T create(); } class Foo2<T> { private T x; public <F extends FactoryI<T>> Foo2(F factory) { x = factory.create(); } // ... } class IntegerFactory implements FactoryI<Integer> { public Integer create() { return new Integer(0); } } Generics 473 class Widget { public static class Factory implements FactoryI<Widget> { public Widget create() { return new Widget(); } } } public class FactoryConstraint { public static void main(String[] args) { new Foo2<Integer>(new IntegerFactory()); new Foo2<Widget>(new Widget.Factory()); } } ///:~ Note really variation passing Class<T>. Both approaches pass factory objects; Class<T> happens built-in factory object, whereas approach creates explicit factory object. But get compile-time checking. Another approach Template Method design pattern. In following example, get( ) Template Method, create( ) defined subclass produce object type: //: generics/CreatorGeneric.java abstract class GenericWithCreate<T> { final T element; GenericWithCreate() { element = create(); } abstract T create(); } class X {} class Creator extends GenericWithCreate<X> { X create() { return new X(); } void f() { System.out.println(element.getClass().getSimpleName()); } } public class CreatorGeneric { public static void main(String[] args) { Creator c = new Creator(); c.f(); } } /* Output: X *///:~ Exercise 22: (6) Use type tag along reflection create method uses argument version newInstance( ) create object class constructor arguments. Exercise 23: (1) Modify FactoryConstraint.java create( ) takes argument. Exercise 24: (3) Modify Exercise 21 factory objects held Map instead Class<?>. 474 Thinking Java Bruce Eckel Arrays generics As saw Erased.java, can’t create arrays generics. The general solution use ArrayList everywhere tempted create array generics: //: generics/ListOfGenerics.java import java.util.*; public class ListOfGenerics<T> { private List<T> array = new ArrayList<T>(); public void add(T item) { array.add(item); } public T get(int index) { return array.get(index); } } ///:~ Here get behavior array compile-time type safety afforded generics. At times, still want create array generic types (the ArrayList, example, uses arrays internally). Interestingly enough, define reference way makes compiler happy. For example: //: generics/ArrayOfGenericReference.java class Generic<T> {} public class ArrayOfGenericReference { static Generic<Integer>[] gia; } ///:~ The compiler accepts without producing warnings. But never create array exact type (including type parameters), it’s little confusing. Since arrays structure (size array slot array layout) regardless type hold, seems able create array Object cast desired array type. This fact compile, won’t run; produces ClassCastException: //: generics/ArrayOfGeneric.java public class ArrayOfGeneric { static final int SIZE = 100; static Generic<Integer>[] gia; @SuppressWarnings("unchecked") public static void main(String[] args) { // Compiles; produces ClassCastException: //! gia = (Generic<Integer>[])new Object[SIZE]; // Runtime type raw (erased) type: gia = (Generic<Integer>[])new Generic[SIZE]; System.out.println(gia.getClass().getSimpleName()); gia[0] = new Generic<Integer>(); //! gia[1] = new Object(); // Compile-time error // Discovers type mismatch compile time: //! gia[2] = new Generic<Double>(); } } /* Output: Generic[] *///:~ The problem arrays keep track actual type, type established point creation array. So even though gia cast Generic < Integer >[], information exists compile time (and without @SuppressWarnings annotation, you’d get warning cast). At run time, it’s still array Object, Generics 475 causes problems. The way successfully create array generic type create new array erased type, cast that. Let’s look slightly sophisticated example. Consider simple generic wrapper around array: //: generics/GenericArray.java public class GenericArray<T> { private T[] array; @SuppressWarnings("unchecked") public GenericArray(int sz) { array = (T[])new Object[sz]; } public void put(int index, T item) { array[index] = item; } public T get(int index) { return array[index]; } // Method exposes underlying representation: public T[] rep() { return array; } public static void main(String[] args) { GenericArray<Integer> gai = new GenericArray<Integer>(10); // This causes ClassCastException: //! Integer[] ia = gai.rep(); // This OK: Object[] oa = gai.rep(); } } ///:~ As before, can’t say T[] array = new T[sz], create array objects cast it. The rep( ) method returns T[], main( ) Integer[] gai, call try capture result Integer [] reference, get ClassCastException, actual runtime type Object[]. If compile GenericArray .Java commenting @SuppressWarnings annotation, compiler produces warning: Note: GenericArray.Java uses unchecked unsafe operations. Note: Recompile -Xlint:unchecked details. In case, we’ve gotten single warning, believe it’s cast. But really want make sure, compile -Xlint:unchecked: GenericArray.java:7: warning: [unchecked] unchecked cast found : java.lang.Object[] required: T[] array = (T[])new Object[sz]; ^ 1 warning It indeed complaining cast. Because warnings become noise, best thing could possibly do, verify particular warning expected, turn using @SuppressWarnings. That way, warning appear, we’ll actually investigate it. 476 Thinking Java Bruce Eckel Because erasure, runtime type array Object[]. If immediately cast T[], compile time actual type array lost, compiler may miss potential error checks. Because this, it’s better use Object[] inside collection, add cast T use array element. Let’s see would look GenericArray.java example: //: generics/GenericArray2.java public class GenericArray2<T> { private Object[] array; public GenericArray2(int sz) { array = new Object[sz]; } public void put(int index, T item) { array[index] = item; } @SuppressWarnings("unchecked") public T get(int index) { return (T)array[index]; } @SuppressWarnings("unchecked") public T[] rep() { return (T[])array; // Warning: unchecked cast } public static void main(String[] args) { GenericArray2<Integer> gai = new GenericArray2<Integer>(10); for(int = 0; < 10; ++) gai.put(i, i); for(int = 0; < 10; ++) System.out.print(gai.get(i) + " "); System.out.println(); try { Integer[] ia = gai.rep(); } catch(Exception e) { System.out.println(e); } } } /* Output: (Sample) 0 1 2 3 4 5 6 7 8 9 java.lang.ClassCastException: [Ljava.lang.Object; cannot cast [Ljava.lang.Integer; *///:~ Initially, doesn’t look different, cast moved. Without ©SuppressWarnings annotations, still get "unchecked" warnings. However, internal representation Object[] rather T[]. When get( ) called, casts object T, fact correct type, safe. However, call rep( ), attempts cast Object[] T[], still incorrect, produces warning compile time exception run time. Thus there’s way subvert type underlying array, Object[]. The advantage treating array internally Object[] instead T[] it’s less likely you’ll forget runtime type array accidentally introduce bug (although majority, perhaps all, bugs would rapidly detected run time). For new code, pass type token. In case, GenericArray looks like this: //: generics/GenericArrayWithTypeToken.java import java.lang.reflect.*; public class GenericArrayWithTypeToken<T> { private T[] array; @SuppressWarnings("unchecked") public GenericArrayWithTypeToken(Class<T> type, int sz) { Generics 477 array = (T[])Array.newInstance(type, sz); } public void put(int index, T item) { array[index] = item; } public T get(int index) { return array[index]; } // Expose underlying representation: public T[] rep() { return array; } public static void main(String[] args) { GenericArrayWithTypeToken<Integer> gai = new GenericArrayWithTypeToken<Integer>( Integer.class, 10); // This works: Integer[] ia = gai.rep(); } } ///:~ The type token Class<T> passed constructor order recover erasure, create actual type array need, although warning cast must suppressed @SuppressWarnings. Once get actual type, return get desired results, see main( ). The runtime type array exact type T[]. Unfortunately, look source code Java SE5 standard libraries, you’ll see casts Object arrays parameterized types everywhere. For example, here’s copy-ArrayList-from-Collection constructor, cleaning simplifying: public ArrayList(Collection c) { size = c.size(); elementData = (E[])new Object[size]; c.toArray(elementData); } If look ArrayList.java, you’ll find plenty casts. And happens compile it? Note: ArrayList.java uses unchecked unsafe operations. Note: Recompile -Xlint:unchecked details. Sure enough, standard libraries produce lots warnings. If you’ve worked C, especially pre-ANSI C, remember particular effect warnings: When discover ignore them, do. For reason, it’s best issue kind message compiler unless programmer must something it. In weblog, 3 Neal Gafter (one lead developers Java SE5) points lazy rewriting Java libraries, did. Neal also points could fix Java library code without breaking existing interface. So even certain idioms appear Java library sources, that’s necessarily right way it. When look library code, cannot assume it’s example follow code. 3 478 http://gafter.blogspot.com/2004/og/puzzling-through-erasure-answer.html Thinking Java Bruce Eckel Bounds Bounds briefly introduced earlier chapter (see page 652). Bounds allow place constraints parameter types used generics. Although allows enforce rules types generics applied to, potentially important effect call methods bound types. Because erasure removes type information, methods call unbounded generic parameter available Object. If, however, able constrain parameter subset types, call methods subset. To perform constraint, Java generics reuse extends keyword. It’s important understand extends significantly different meaning context generic bounds ordinarily. This example shows basics bounds: //: generics/BasicBounds.java interface HasColor { java.awt.Color getColor(); } class Colored<T extends HasColor> { T item; Colored(T item) { this.item = item; } T getItem() { return item; } // The bound allows call method: java.awt.Color color() { return item.getColor(); } } class Dimension { public int x, y, z; } // This won’t work -- class must first, interfaces: // class ColoredDimension<T extends HasColor & Dimension> { // Multiple bounds: class ColoredDimension<T extends Dimension & HasColor> { T item; ColoredDimension(T item) { this.item = item; } T getItem() { return item; } java.awt.Color color() { return item.getColor(); } int getX() { return item.x; } int getY() { return item.y; } int getZ() { return item.z; } } interface Weight { int weight(); } // As inheritance, one // concrete class multiple interfaces: class Solid<T extends Dimension & HasColor & Weight> { T item; Solid(T item) { this.item = item; } T getItem() { return item; } java.awt.Color color() { return item.getColor(); } int getX() { return item.x; } int getY() { return item.y; } int getZ() { return item.z; } int weight() { return item.weight(); } } class Bounded extends Dimension implements HasColor, Weight { public java.awt.Color getColor() { return null; } Generics 479 } public int weight() { return 0; } public class BasicBounds { public static void main(String[] args) { Solid<Bounded> solid = new Solid<Bounded>(new Bounded()); solid.color(); solid.getY(); solid.weight(); } } ///:~ You might observe BasicBounds.java seems contain redundancies could eliminated inheritance. Here, see level inheritance also adds bounds constraints: //: generics/InheritBounds.java class HoldItem<T> { T item; HoldItem(T item) { this.item = item; } T getItem() { return item; } } class Colored2<T extends HasColor> extends HoldItem<T> { Colored2(T item) { super(item); } java.awt.Color color() { return item.getColor(); } } class ColoredDimension2<T extends Dimension & HasColor> extends Colored2<T> { ColoredDimension2(T item) { super(item); } int getX() { return item.x; } int getY() { return item.y; } int getZ() { return item.z; } } class Solid2<T extends Dimension & HasColor & Weight> extends ColoredDimension2<T> { Solid2(T item) { super(item); } int weight() { return item.weight(); } } public class InheritBounds { public static void main(String[] args) { Solid2<Bounded> solid2 = new Solid2<Bounded>(new Bounded()); solid2.color(); solid2.getY(); solid2.weight(); } } ///:~ Holdltem simply holds object, behavior inherited Colored2, also requires parameter conforms HasColor. ColoredDimension2 Solid2 extend hierarchy add bounds level. Now methods inherited don’t repeated class. 480 Thinking Java Bruce Eckel Here’s example layers: //: generics/EpicBattle.java // Demonstrating bounds Java generics. import java.util.*; interface SuperPower {} interface XRayVision extends SuperPower { void seeThroughWalls(); } interface SuperHearing extends SuperPower { void hearSubtleNoises(); } interface SuperSmell extends SuperPower { void trackBySmell(); } class SuperHero<POWER extends SuperPower> { POWER power; SuperHero(POWER power) { this.power = power; } POWER getPower() { return power; } } class SuperSleuth<POWER extends XRayVision> extends SuperHero<POWER> { SuperSleuth(POWER power) { super(power); } void see() { power.seeThroughWalls(); } } class CanineHero<POWER extends SuperHearing & SuperSmell> extends SuperHero<POWER> { CanineHero(POWER power) { super(power); } void hear() { power.hearSubtleNoises(); } void smell() { power.trackBySmell(); } } class SuperHearSmell implements SuperHearing, SuperSmell { public void hearSubtleNoises() {} public void trackBySmell() {} } class DogBoy extends CanineHero<SuperHearSmell> { DogBoy() { super(new SuperHearSmell()); } } public class EpicBattle { // Bounds generic methods: static <POWER extends SuperHearing> void useSuperHearing(SuperHero<POWER> hero) { hero.getPower().hearSubtleNoises(); } static <POWER extends SuperHearing & SuperSmell> void superFind(SuperHero<POWER> hero) { hero.getPower().hearSubtleNoises(); hero.getPower().trackBySmell(); } public static void main(String[] args) { DogBoy dogBoy = new DogBoy(); useSuperHearing(dogBoy); superFind(dogBoy); // You this: List<? extends SuperHearing> audioBoys; // But can’t this: Generics 481 // List<? extends SuperHearing & SuperSmell> dogBoys; } } ///:~ Notice wildcards (which shall study next) limited single bound. Exercise 25: (2) Create two interfaces class implements both. Create two generic methods, one whose argument parameter bounded first interface one whose argument parameter bounded second interface. Create instance class implements interfaces, show used generic methods. Wildcards You’ve already seen simple uses wildcards—question marks generic argument expressions—in Holding Your Objects chapter Type Information chapter. This section explore issue deeply. We’ll start example shows particular behavior arrays: You assign array derived type array reference base type: //: generics/CovariantArrays.java class class class class Fruit {} Apple extends Fruit {} Jonathan extends Apple {} Orange extends Fruit {} public class CovariantArrays { public static void main(String[] args) { Fruit[] fruit = new Apple[10]; fruit[0] = new Apple(); // OK fruit[1] = new Jonathan(); // OK // Runtime type Apple[], Fruit[] Orange[]: try { // Compiler allows add Fruit: fruit[0] = new Fruit(); // ArrayStoreException } catch(Exception e) { System.out.println(e); } try { // Compiler allows add Oranges: fruit[0] = new Orange(); // ArrayStoreException } catch(Exception e) { System.out.println(e); } } } /* Output: java.lang.ArrayStoreException: Fruit java.lang.ArrayStoreException: Orange *///:~ The first line main( ) creates array Apple assigns reference array Fruit. This makes sense—an Apple kind Fruit, array Apple also array Fruit. However, actual array type Apple [], able place Apple subtype Apple array, fact works compile time run time. But notice compiler allows place Fruit object array. This makes sense compiler, Fruit[] reference—why shouldn’t allow Fruit object, anything descended Fruit, Orange, placed array? So compile 482 Thinking Java Bruce Eckel time, allowed. The runtime array mechanism, however, knows it’s dealing Apple [] throws exception foreign type placed array. "Upcast" actually rather misnomer here. What you’re really assigning one array another. The array behavior holds objects, able upcast, it’s clear array objects preserve rules type objects contain. It’s arrays conscious holding, compiletime checks runtime checks, can’t abuse them. This arrangement arrays terrible, find run time you’ve inserted improper type. But one primary goals generics move error detection compile time. So happens try use generic containers instead arrays? //: generics/NonCovariantGenerics.java // {CompileTimeError} (Won’t compile) import java.util.*; public class NonCovariantGenerics { // Compile Error: incompatible types: List<Fruit> flist = new ArrayList<Apple>(); Although may first read saying, "You can’t assign container Apple container Fruit," remember generics containers. What it’s really saying is, "You can’t assign generic involving Apples generic involving Fruit." If, case arrays, compiler knew enough code determine containers involved, perhaps could give leeway. But doesn’t know anything like that, refuses allow "upcast." But really isn’t "upcast" anyway—a List Apple List Fruit. A List Apple hold Apples subtypes Apple, List Fruit hold kind Fruit. Yes, including Apples, doesn’t make List Apple; it’s still List Fruit. A List Apple type-equivalent List Fruit, even Apple type Fruit. The real issue talking type container, rather type container holding. Unlike arrays, generics built-in covariance. This arrays completely defined language thus compile-time runtime checks built in, generics, compiler runtime system cannot know want types rules be. Sometimes, however, you’d like establish kind upcasting relationship two. This wildcards allow. //: generics/GenericsAndCovariance.java import java.util.*; public class GenericsAndCovariance { public static void main(String[] args) { // Wildcards allow covariance: List<? extends Fruit> flist = new ArrayList<Apple>(); // Compile Error: can’t add type object: // flist.add(new Apple()); // flist.add(new Fruit()); // flist.add(new Object()); flist.add(null); // Legal uninteresting // We know returns least Fruit: Fruit f = flist.get(0); } } ///:~ Generics 483 The type flist List<? extends Fruit>, read "a list type that’s inherited Fruit." This doesn’t actually mean List hold type Fruit, however. The wildcard refers definite type, means "some specific type flist reference doesn’t specify." So List that’s assigned holding specified type Fruit Apple, order upcast flist, type "don’t actually care." If constraint List hold specific Fruit subtype Fruit, don’t actually care is, List? If don’t know type List holding, safely add object? Just "upcast" array CovariantArrays.java, can’t, except compiler prevents happening rather runtime system. You discover problem sooner. You might argue things gone bit overboard, can’t even add Apple List said would hold Apples. Yes, compiler doesn’t know that. A List<? extends Fruit> could legally point List<Orange>. Once kind "upcast," lose ability pass anything in, even Object. On hand, call method returns Fruit, that’s safe know anything List must least type Fruit, compiler allows it. Exercise 26: (2) Demonstrate array covariance using Numbers Integers. Exercise 27: (2) Show covariance doesn’t work Lists, using Numbers Integers, introduce wildcards. How smart compiler? Now, might guess prevented calling methods take arguments, consider this: //: generics/CompilerIntelligence.java import java.util.*; public class CompilerIntelligence { public static void main(String[] args) { List<? extends Fruit> flist = Arrays.asList(new Apple()); Apple = (Apple)flist.get(0); // No warning flist.contains(new Apple()); // Argument ‘Object’ flist.indexOf(new Apple()); // Argument ‘Object’ } } ///:~ You see calls contains( ) indexOf( ) take Apple objects arguments, fine. Does mean compiler actually examines code see particular method modifies object? By looking documentation ArrayList, find compiler smart. While add( ) takes argument generic parameter type, contains( ) indexOf( ) take arguments type Object. So specify ArrayList <? extends Fruit >, argument add( ) becomes’? extends Fruit’. From description, compiler cannot know specific subtype Fruit required there, won’t accept type Fruit. It doesn’t matter upcast Apple Fruit first—the compiler simply refuses call method (such add( )) wildcard involved argument list. 484 Thinking Java Bruce Eckel With contains( ) indexOf( ), arguments type Object, wildcards involved compiler allows call. This means it’s generic class designer decide calls "safe," use Object types arguments. To disallow call type used wildcards, use type parameter argument list. You see simple Holder class: //: generics/Holder.java public class Holder<T> { private T value; public Holder() {} public Holder(T val) { value = val; } public void set(T val) { value = val; } public T get() { return value; } public boolean equals(Object obj) { return value.equals(obj); } public static void main(String[] args) { Holder<Apple> Apple = new Holder<Apple>(new Apple()); Apple = Apple.get(); Apple.set(d); // Holder<Fruit> Fruit = Apple; // Cannot upcast Holder<? extends Fruit> fruit = Apple; // OK Fruit p = fruit.get(); = (Apple)fruit.get(); // Returns ‘Object’ try { Orange c = (Orange)fruit.get(); // No warning } catch(Exception e) { System.out.println(e); } // fruit.set(new Apple()); // Cannot call set() // fruit.set(new Fruit()); // Cannot call set() System.out.println(fruit.equals(d)); // OK } } /* Output: (Sample) java.lang.ClassCastException: Apple cannot cast Orange true *///:~ Holder set( ) takes T, get( ) returns T, equals( ) takes Object. As you’ve already seen, create Holder<Apple>, cannot upcast Holder<Fruit>, upcast Holder<? extends Fruit>. If call get( ), returns Fruit—that’s much knows given "anything extends Fruit" bound. If know what’s there, cast specific type Fruit won’t warning it, risk ClassCastException. The set( ) method won’t work either Apple Fruit, set( ) argument also "? Extends Fruit," means anything compiler can’t verify type safety "anything." However, equals( ) method works fine takes Object instead T argument. Thus, compiler paying attention types objects passed returned. It analyzing code see perform actual writes reads. Contravariance It’s also possible go way, use supertype wildcards. Here, say wildcard bounded base class particular class, specifying <? super MyClass> even using type parameter: <? super T> (although cannot give generic parameter supertype bound; is, cannot say <T super MyClass>). This Generics 485 allows safely pass typed object generic type. Thus, supertype wildcards write Collection: //: generics/SuperTypeWildcards.java import java.util.*; public class SuperTypeWildcards { static void writeTo(List<? super Apple> apples) { apples.add(new Apple()); apples.add(new Jonathan()); // apples.add(new Fruit()); // Error } } ///:~ The argument apples List type base type Apple; thus know safe add Apple subtype Apple. Since lower bound Apple, however, don’t know safe add Fruit List, would allow List opened addition non-Apple types, would violate static type safety. You thus begin think subtype supertype bounds terms "write" (pass method) generic type, "read" (return method) generic type. Supertype bounds relax constraints pass method: //: generics/GenericWriting.java import java.util.*; public class GenericWriting { static <T> void writeExact(List<T> list, T item) { list.add(item); } static List<Apple> apples = new ArrayList<Apple>(); static List<Fruit> fruit = new ArrayList<Fruit>(); static void f1() { writeExact(apples, new Apple()); // writeExact(fruit, new Apple()); // Error: // Incompatible types: found Fruit, required Apple } static <T> void writeWithWildcard(List<? super T> list, T item) { list.add(item); } static void f2() { writeWithWildcard(apples, new Apple()); writeWithWildcard(fruit, new Apple()); } public static void main(String[] args) { f1(); f2(); } } ///:~ The writeExact( ) method uses exact parameter type (no wildcards). In fi( ) see works fine—as long put Apple List<Apple>. However, writeExact( ) allow put Apple List<Fruit>, even though know possible. In writeWithWildcard( ), argument List<? super T>, List holds specific type derived T; thus safe pass T anything derived T argument List methods. You see f2( ), it’s still possible put Apple 486 Thinking Java Bruce Eckel List<Apple>, before, also possible put Apple List<Fruit>, expect. We perform type analysis review covariance wildcards: //: generics/GenericReading.java import java.util.*; public class GenericReading { static <T> T readExact(List<T> list) { return list.get(0); } static List<Apple> apples = Arrays.asList(new Apple()); static List<Fruit> fruit = Arrays.asList(new Fruit()); // A static method adapts call: static void f1() { Apple = readExact(apples); Fruit f = readExact(fruit); f = readExact(apples); } // If, however, class, type // established class instantiated: static class Reader<T> { T readExact(List<T> list) { return list.get(0); } } static void f2() { Reader<Fruit> fruitReader = new Reader<Fruit>(); Fruit f = fruitReader.readExact(fruit); // Fruit = fruitReader.readExact(apples); // Error: // readExact(List<Fruit>) cannot // applied (List<Apple>). } static class CovariantReader<T> { T readCovariant(List<? extends T> list) { return list.get(0); } } static void f3() { CovariantReader<Fruit> fruitReader = new CovariantReader<Fruit>(); Fruit f = fruitReader.readCovariant(fruit); Fruit = fruitReader.readCovariant(apples); } public static void main(String[] args) { f1(); f2(); f3(); } } ///:~ As before, first method readExact( ) uses precise type. So use precise type wildcards, write read precise type List. In addition, return value, static generic method readExact( ) effectively "adapts" method call, returns Apple List<Apple> Fruit List<Fruit>, see f1( ). Thus, get away static generic method, don’t necessarily need covariance you’re reading. If generic class, however, parameter established class make instance class. As see f2( ), fruitReader instance read piece Fruit List<Fruit>, since exact type. But List<Apple> also produce Fruit objects, fruitReader doesn’t allow this. Generics 487 To fix problem, CovariantReader.readCovariant( ) method takes List<? extends T>, it’s safe read T list (you know everything list least T, possibly something derived T). In f3( ) see it’s possible read Fruit List<Apple>. Exercise 28: (4) Create generic class Generic1<T> single method takes argument type T. Create second generic class Generic2<T> single method returns argument type T. Write generic method contravariant argument first generic class calls method. Write second generic method covariant argument second generic class calls method. Test using typeinfo.pets library. Unbounded wildcards The unbounded wildcard <?> appears mean "anything," using unbounded wildcard seems equivalent using raw type. Indeed, compiler seems first agree assessment: //: generics/UnboundedWildcards1.java import java.util.*; public class UnboundedWildcards1 { static List list1; static List<?> list2; static List<? extends Object> list3; static void assign1(List list) { list1 = list; list2 = list; // list3 = list; // Warning: unchecked conversion // Found: List, Required: List<? extends Object> } static void assign2(List<?> list) { list1 = list; list2 = list; list3 = list; } static void assign3(List<? extends Object> list) { list1 = list; list2 = list; list3 = list; } public static void main(String[] args) { assign1(new ArrayList()); assign2(new ArrayList()); // assign3(new ArrayList()); // Warning: // Unchecked conversion. Found: ArrayList // Required: List<? extends Object> assign1(new ArrayList<String>()); assign2(new ArrayList<String>()); assign3(new ArrayList<String>()); // Both forms acceptable List<?>: List<?> wildList = new ArrayList(); wildList = new ArrayList<String>(); assign1(wildList); assign2(wildList); assign3(wildList); } } ///:~ 488 Thinking Java Bruce Eckel There many cases like ones see compiler could care less whether use raw type <?>. In cases, <?> thought decoration; yet valuable because, effect, says, "I wrote code Java generics mind, I don’t mean I’m using raw type, case generic parameter hold type." A second example shows important use unbounded wildcards. When dealing multiple generic parameters, it’s sometimes important allow one parameter type establishing particular type parameter: //: generics/UnboundedWildcards2.java import java.util.*; public class UnboundedWildcards2 { static Map map1; static Map<?,?> map2; static Map<String,?> map3; static void assign1(Map map) { map1 = map; } static void assign2(Map<?,?> map) { map2 = map; } static void assign3(Map<String,?> map) { map3 = map; } public static void main(String[] args) { assign1(new HashMap()); assign2(new HashMap()); // assign3(new HashMap()); // Warning: // Unchecked conversion. Found: HashMap // Required: Map<String,?> assign1(new HashMap<String,Integer>()); assign2(new HashMap<String,Integer>()); assign3(new HashMap<String,Integer>()); } } ///:~ But again, unbounded wildcards, seen Map<?,?>, compiler doesn’t seem distinguish raw Map. In addition, UnboundedWildcards1.java shows compiler treats List<?> List<? extends Object> differently. What’s confusing compiler doesn’t always care difference between, example, List List<?>, seem like thing. Indeed, since generic argument erases first bound, List<?> would seem equivalent List<Object>, List effectively List<Object> well—except neither statements exactly true. List actually means "a raw List holds Object type," whereas List<?> means "a non-raw List specific type, don’t know type is." When compiler actually care difference raw types types involving unbounded wildcards? The following example uses previously defined Holder<T> class. It contains methods take Holder argument, various forms: raw type, specific type parameter, unbounded wildcard parameter: //: generics/Wildcards.java // Exploring meaning wildcards. public class Wildcards { // Raw argument: static void rawArgs(Holder holder, Object arg) { // holder.set(arg); // Warning: // Unchecked call set(T) // member raw type Holder // holder.set(new Wildcards()); // Same warning Generics 489 // Can’t this; don’t ‘T’: // T = holder.get(); // OK, type information lost: Object obj = holder.get(); } // Similar rawArgs(), errors instead warnings: static void unboundedArg(Holder<?> holder, Object arg) { // holder.set(arg); // Error: // set(capture ?) Holder<capture ?> // cannot applied (Object) // holder.set(new Wildcards()); // Same error // Can’t this; don’t ‘T’: // T = holder.get(); // OK, type information lost: Object obj = holder.get(); } static <T> T exact1(Holder<T> holder) { T = holder.get(); return t; } static <T> T exact2(Holder<T> holder, T arg) { holder.set(arg); T = holder.get(); return t; } static <T> T wildSubtype(Holder<? extends T> holder, T arg) { // holder.set(arg); // Error: // set(capture ? extends T) // Holder<capture ? extends T> // cannot applied (T) T = holder.get(); return t; } static <T> void wildSupertype(Holder<? super T> holder, T arg) { holder.set(arg); // T = holder.get(); // Error: // Incompatible types: found Object, required T // OK, type information lost: Object obj = holder.get(); } public static void main(String[] args) { Holder raw = new Holder<Long>(); // Or: raw = new Holder(); Holder<Long> qualified = new Holder<Long>(); Holder<?> unbounded = new Holder<Long>(); Holder<? extends Long> bounded = new Holder<Long>(); Long lng = 1L; rawArgs(raw, lng); rawArgs(qualified, lng); rawArgs(unbounded, lng); rawArgs(bounded, lng); unboundedArg(raw, lng); unboundedArg(qualified, lng); unboundedArg(unbounded, lng); 490 Thinking Java Bruce Eckel unboundedArg(bounded, lng); // Object r1 = exact1(raw); // Warnings: // Unchecked conversion Holder Holder<T> // Unchecked method invocation: exact1(Holder<T>) // applied (Holder) Long r2 = exact1(qualified); Object r3 = exact1(unbounded); // Must return Object Long r4 = exact1(bounded); // Long r5 = exact2(raw, lng); // Warnings: // Unchecked conversion Holder Holder<Long> // Unchecked method invocation: exact2(Holder<T>,T) // applied (Holder,Long) Long r6 = exact2(qualified, lng); // Long r7 = exact2(unbounded, lng); // Error: // exact2(Holder<T>,T) cannot applied // (Holder<capture ?>,Long) // Long r8 = exact2(bounded, lng); // Error: // exact2(Holder<T>,T) cannot applied // (Holder<capture ? extends Long>,Long) // Long r9 = wildSubtype(raw, lng); // Warnings: // Unchecked conversion Holder // Holder<? extends Long> // Unchecked method invocation: // wildSubtype(Holder<? extends T>,T) // applied (Holder,Long) Long r10 = wildSubtype(qualified, lng); // OK, return Object: Object r11 = wildSubtype(unbounded, lng); Long r12 = wildSubtype(bounded, lng); // wildSupertype(raw, lng); // Warnings: // Unchecked conversion Holder // Holder<? super Long> // Unchecked method invocation: // wildSupertype(Holder<? super T>,T) // applied (Holder,Long) wildSupertype(qualified, lng); // wildSupertype(unbounded, lng); // Error: // wildSupertype(Holder<? super T>,T) cannot // applied (Holder<capture ?>,Long) // wildSupertype(bounded, lng); // Error: // wildSupertype(Holder<? super T>,T) cannot // applied (Holder<capture ? extends Long>,Long) } } ///:~ In rawArgs( ), compiler knows Holder generic type, even though expressed raw type here, compiler knows passing Object set( ) unsafe. Since it’s raw type, pass object type set( ), object upcast Object. So anytime raw type, give compile-time checking. The call get( ) shows issue: There’s T, result Object. It’s easy start thinking raw Holder Holder<?> roughly thing. But unboundedArg( ) emphasizes differentit discovers kind problems, reports errors rather warnings, raw Holder hold combination types, whereas Holder<?> holds homogeneous collection specific type, thus can’t pass Object. Generics 491 In exact1( ) exact2( ), see exact generic parameters used—no wildcards. You’ll see exact2( ) different limitations exact1( ), extra argument. In wildSubtype( ), constraints type Holder relaxed include Holder anything extends T. Again, means T could Fruit, holder could legitimately Holder<Apple>. To prevent putting Orange Holder<Apple>, call set( ) (or method takes argument type parameter) disallowed. However, still know anything comes Holder<? extends Fruit> least Fruit, get( ) (or method produces return value type parameter) allowed. Supertype wildcards shown wildSupertype( ), shows opposite behavior wildSubtype( ): holder container holds type that’s base class T. Thus, set( ) accept T, since anything works base type polymorphically work derived type (thus T). However, trying call get( ) helpful, type held holder supertype all, safe one Object. This example also shows limitations can’t unbounded parameter unbounded( ): You can’t get( ) set( ) T don’t T. In main( ) see methods accept types arguments without errors warnings. For migration compatibility, rawArgs( ) take different variations Holder without producing warnings. The unboundedArg( ) method equally accepting types, although, previously noted, handles differently inside body method. If pass raw Holder reference method takes "exact" generic type (no wildcards), get warning exact argument expecting information doesn’t exist raw type. And pass unbounded reference exact1( ), there’s type information establish return type. You see exact2( ) constraints, since wants exactly Holder<T> argument type T, generates errors warnings unless give exact arguments. Sometimes OK, it’s overconstraining, use wildcards, depending whether want get typed return values generic argument (as seen wildSubtype( )) want pass typed arguments generic argument (as seen wildSupertype( )). Thus, benefit using exact types instead wildcard types generic parameters. But using wildcards allows accept broader range parameterized types arguments. You must decide trade-off appropriate needs case-by-case basis. Capture conversion One situation particular requires use <?> rather raw type. If pass raw type method uses <?>, it’s possible compiler infer actual type parameter, method turn around call another method uses exact type. The following example demonstrates technique, called capture conversion unspecified wildcard type captured converted exact type. Here, comments warnings take effect @SuppressWarnings annotation removed: 492 Thinking Java Bruce Eckel //: generics/CaptureConversion.java public class CaptureConversion { static <T> void f1(Holder<T> holder) { T = holder.get(); System.out.println(t.getClass().getSimpleName()); } static void f2(Holder<?> holder) { f1(holder); // Call captured type } @SuppressWarnings("unchecked") public static void main(String[] args) { Holder raw = new Holder<Integer>(1); // f1(raw); // Produces warnings f2(raw); // No warnings Holder rawBasic = new Holder(); rawBasic.set(new Object()); // Warning f2(rawBasic); // No warnings // Upcast Holder<?>, still figures out: Holder<?> wildcarded = new Holder<Double>(1.0); f2(wildcarded); } } /* Output: Integer Object Double *///:~ The type parameters f1( ) exact, without wildcards bounds. In f2( ), Holder parameter unbounded wildcard, would seem effectively unknown. However, within f2( ), f1( ) called f1( ) requires known parameter. What’s happening parameter type captured process calling f2( ), used call f1( ). You might wonder technique could used writing, would require pass specific type along Holder<?>. Capture conversion works situations where, within method, need work exact type. Notice can’t return T f2( ), T unknown f2( ). Capture conversion interesting, quite limited. Exercise 29: (5) Create generic method takes argument Holder<List<?>>. Determine methods can’t call Holder List. Repeat argument List<Holder<?>>. Issues This section addresses assorted set issues appear using Java generics. No primitives type parameters As mentioned earlier chapter, one limitations discover Java generics cannot use primitives type parameters. So cannot, example, create ArrayList<int>. The solution use primitive wrapper classes conjunction Java SE5 autoboxing. If create ArrayList< Integer> use primitive ints container, you’ll Generics 493 discover autoboxing conversion Integer automatically—so it’s almost Ar r ayList < int >: //: generics/ListOfInt.java // Autoboxing compensates inability use // primitives generics. import java.util.*; public class ListOfInt { public static void main(String[] args) { List<Integer> li = new ArrayList<Integer>(); for(int = 0; < 5; i++) li.add(i); for(int : li) System.out.print(i + " "); } } /* Output: 0 1 2 3 4 *///:~ Note autoboxing even allows foreach syntax produce ints. In general solution works fine—you’re able successfully store retrieve ints. There happen conversions going hidden you. However, performance problem, use specialized version containers adapted primitive types; one opensource version org.apache.commons.collections.primitives. Here’s another approach, creates Set Bytes: //: generics/ByteSet.java import java.util.*; public class ByteSet { Byte[] possibles = { 1,2,3,4,5,6,7,8,9 }; Set<Byte> mySet = new HashSet<Byte>(Arrays.asList(possibles)); // But can’t this: // Set<Byte> mySet2 = new HashSet<Byte>( // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9)); } ///:~ Notice autoboxing solves problems, all. The following example shows generic Generator interface specifies next( ) returns object parameter type. The FArray class contains generic method uses generator fill array objects (making class generic wouldn’t work case method static). The Generator implementations come Arrays chapter, main( ) see FArray.fill( ) used fill arrays objects: //: generics/PrimitiveGenericTest.java import net.mindview.util.*; // Fill array using generator: class FArray { public static <T> T[] fill(T[] a, Generator<T> gen) { for(int = 0; < a.length; i++) a[i] = gen.next(); return a; } } 494 Thinking Java Bruce Eckel public class PrimitiveGenericTest { public static void main(String[] args) { String[] strings = FArray.fill( new String[7], new RandomGenerator.String(10)); for(String : strings) System.out.println(s); Integer[] integers = FArray.fill( new Integer[7], new RandomGenerator.Integer()); for(int i: integers) System.out.println(i); // Autoboxing won’t save here. This won’t compile: // int[] b = // FArray.fill(new int[7], new RandIntGenerator()); } } /* Output: YNzbrnyGcF OWZnTcQrGs eGZMmJMRoE suEcUOneOE dLsmwHLGEa hKcxrEqUCB bkInaMesbt 7052 6665 2654 3909 5202 2209 5458 *///:~ Since RandomGenerator.Integer implements Generator<Integer>, hope autoboxing would automatically convert value next( ) Integer int. However, autoboxing doesn’t apply arrays, won’t work. Exercise 30: (2) Create Holder primitive wrapper types, show autoboxing autounboxing works set( ) get( ) methods instance. Implementing parameterized interfaces A class cannot implement two variants generic interface. Because erasure, interface. Here’s situation clash occurs: //: generics/MultipleInterfaceVariants.java // {CompileTimeError} (Won’t compile) interface Payable<T> {} class Employee implements Payable<Employee> {} class Hourly extends Employee implements Payable<Hourly> {} ///:~ Hourly won’t compile erasure reduces Payable<Employee> Payable<Hourly> class, Payable, code would mean you’d implementing interface twice. Interestingly enough, remove generic parameters uses Payable—as compiler erasure—the code compiles. Generics 495 This issue become annoying working fundamental Java interfaces, Comparable<T>, you’ll see little later section. Exercise 31: (1) Remove generics MultipleInterfaceVariants.java modify code example compiles. Casting warnings Using cast instanceof generic type parameter doesn’t effect. The following container stores values internally Objects casts back T fetch them: //: generics/GenericCast.java class FixedSizeStack<T> { private int index = 0; private Object[] storage; public FixedSizeStack(int size) { storage = new Object[size]; } public void push(T item) { storage[index++] = item; } @SuppressWarnings("unchecked") public T pop() { return (T)storage[--index]; } } public class GenericCast { public static final int SIZE = 10; public static void main(String[] args) { FixedSizeStack<String> strings = new FixedSizeStack<String>(SIZE); for(String : "A B C D E F G H I J".split(" ")) strings.push(s); for(int = 0; < SIZE; i++) { String = strings.pop(); System.out.print(s + " "); } } } /* Output: J I H G F E D C B A *///:~ Without @SuppressWarnings annotation, compiler produce "unchecked cast" warning pop( ). Because erasure, can’t know whether cast safe, pop( ) method doesn’t actually casting. T erased first bound, Object default, pop( ) actually casting Object Object. There times generics eliminate need cast, generates warning compiler inappropriate. For example: //: generics/NeedCasting.java import java.io.*; import java.util.*; public class NeedCasting { @SuppressWarnings("unchecked") public void f(String[] args) throws Exception { ObjectInputStream = new ObjectInputStream( new FileInputStream(args[0])); List<Widget> shapes = (List<Widget>)in.readObject(); 496 Thinking Java Bruce Eckel } } ///:~ As you’ll learn next chapter, readObject( ) cannot know reading, returns object must cast. But comment @SuppressWarnings annotation compile program, get warning: Note: NeedCasting.Java uses unchecked unsafe operations. Note: Recompile -Xlint:unchecked details. And follow instructions recompile -Xlint:unchecked: NeedCasting.Java:12: warning: [unchecked] unchecked cast found : java.lang.Object required: java.uti1.List<Widget> List<Shape> shapes = (List<Widget>)in.readObject(); You’re forced cast, yet you’re told shouldn’t. To solve problem, must use new form cast introduced Java SE5, cast via generic class: //: generics/ClassCasting.java import java.io.*; import java.util.*; public class ClassCasting { @SuppressWarnings("unchecked") public void f(String[] args) throws Exception { ObjectInputStream = new ObjectInputStream( new FileInputStream(args[0])); // Won’t Compile: // List<Widget> lw1 = // List<Widget>.class.cast(in.readObject()); List<Widget> lw2 = List.class.cast(in.readObject()); } } ///:~ However, can’t cast actual type (List<Widget>). That is, can’t say List<Widget>.class.cast(in.readObject()) even add another cast like this: (List<Widget>)List.class.cast(in.readObject()) you’ll still get warning. Exercise 32: (1) Verify FixedSizeStack GenericCast.java generates exceptions try go bounds. Does mean bounds-checking code required? Exercise 33: (3) Repair GenericCast.java using ArrayList. Generics 497 Overloading This won’t compile, even though it’s reasonable thing try: //: generics/UseList.java // {CompileTimeError} (Won’t compile) import java.util.*; public class UseList<W,T> { void f(List<T> v) {} void f(List<W> v) {} } ///:~ Overloading method produces identical type signature erasure. Instead, must provide distinct method names erased arguments produce unique argument list: //: generics/UseList2.java import java.util.*; public class UseList2<W,T> { void f1(List<T> v) {} void f2(List<W> v) {} } ///:~ Fortunately, kind problem detected compiler. Base class hijacks interface Suppose Pet class Comparable Pet objects: //: generics/ComparablePet.java public class ComparablePet implements Comparable<ComparablePet> { public int compareTo(ComparablePet arg) { return 0; } } ///:~ It makes sense try narrow type subclass ComparablePet compared to. For example, Cat Comparable Cats: //: generics/HijackedInterface.java // {CompileTimeError} (Won’t compile) class Cat extends ComparablePet implements Comparable<Cat>{ // Error: Comparable cannot inherited // different arguments: <Cat> <Pet> public int compareTo(Cat arg) { return 0; } } ///:~ Unfortunately, won’t work. Once ComparablePet argument established Comparable, implementing class ever compared anything ComparablePet: //: generics/RestrictedComparablePets.java 498 Thinking Java Bruce Eckel class Hamster extends ComparablePet implements Comparable<ComparablePet> { public int compareTo(ComparablePet arg) { return 0; } } // Or just: class Gecko extends ComparablePet { public int compareTo(ComparablePet arg) { return 0; } } ///:~ Hamster shows possible reimplement interface ComparablePet, long exactly same, including parameter types. However, overriding methods base class, seen Gecko. Generics 499 Self-bounded types There’s one rather mind-bending idiom appears periodically Java generics. Here’s looks like: class SelfBounded<T extends SelfBounded<T>> { // ... This dizzying effect two mirrors pointed other, kind infinite reflection. The class SelfBounded takes generic argument T, T constrained bound, bound SelfBounded, T argument. This difficult parse first see it, emphasizes extends keyword, used bounds, definitely different used create subclasses. Curiously recurring generics To understand self-bounded type means, let’s start simpler version idiom, without self-bound. You can’t inherit directly generic parameter. However, inherit class uses generic parameter definition. That is, say: //: generics/CuriouslyRecurringGeneric.java class GenericType<T> {} public class CuriouslyRecurringGeneric extends GenericType<CuriouslyRecurringGeneric> {} ///:~ This could called curiously recurring generics (CRG) Jim Coplien’s Curiously Recurring Template Pattern C++. The "curiously recurring" part refers fact class appears, rather curiously, base class. To understand means, try saying aloud: "I’m creating new class inherits generic type takes class name parameter." What generic base type accomplish given derived class name? Well, generics Java arguments return types, produce base class uses derived type arguments return types. It also use derived type field types, even though erased Object. Here’s generic class expresses this: //: generics/BasicHolder.java public class BasicHolder<T> { T element; void set(T arg) { element = arg; } T get() { return element; } void f() { System.out.println(element.getClass().getSimpleName()); } } ///:~ It’s ordinary generic type methods accept produce objects parameter type, along method operates stored field (although performs Object operations field). 500 Thinking Java Bruce Eckel We use BasicHolder curiously recurring generic: //: generics/CRGWithBasicHolder.java class Subtype extends BasicHolder<Subtype> {} public class CRGWithBasicHolder { public static void main(String[] args) { Subtype st1 = new Subtype(), st2 = new Subtype(); st1.set(st2); Subtype st3 = st1.get(); st1.f(); } } /* Output: Subtype *///:~ Notice something important here: The new class Subtype takes arguments returns values Subtype, base class BasicHolder. This essence CRG: The base class substitutes derived class parameters. This means generic base class becomes kind template common functionality derived classes, functionality use derived type arguments return values. That is, exact type instead base type used resulting class. So Subtype, argument set( ) return type get( ) exactly Subtypes. Self-bounding The BasicHolder use type generic parameter, seen here: //: generics/Unconstrained.java class Other {} class BasicOther extends BasicHolder<Other> {} public class Unconstrained { public static void main(String[] args) { BasicOther b = new BasicOther(), b2 = new BasicOther(); b.set(new Other()); Other = b.get(); b.f(); } } /* Output: Other *///:~ Self-bounding takes extra step forcing generic used bound argument. Look resulting class can’t used: //: generics/SelfBounding.java class SelfBounded<T extends SelfBounded<T>> { T element; SelfBounded<T> set(T arg) { element = arg; return this; } T get() { return element; } } class A extends SelfBounded<A> {} Generics 501 class B extends SelfBounded<A> {} // Also OK class C extends SelfBounded<C> { C setAndGet(C arg) { set(arg); return get(); } } class D {} // Can’t this: // class E extends SelfBounded<D> {} // Compile error: Type parameter D within bound // Alas, this, can’t force idiom: class F extends SelfBounded {} public class SelfBounding { public static void main(String[] args) { A = new A(); a.set(new A()); = a.set(new A()).get(); = a.get(); C c = new C(); c = c.setAndGet(new C()); } } ///:~ What self-bounding require use class inheritance relationship like this: class A extends SelfBounded<A> {} This forces pass class defining parameter base class. What’s added value self-bounding parameter? The type parameter must class defined. As see definition class B, also derive SelfBounded uses parameter another SelfBounded, although predominant use seems one see class A. The attempt define E shows cannot use type parameter SelfBounded. Unfortunately, F compiles without warnings, self-bounding idiom enforceable. If it’s really important, may require external tool ensure raw types used place parameterized types. Notice remove constraint classes still compile, E also compile: //: generics/NotSelfBounded.java public class NotSelfBounded<T> { T element; NotSelfBounded<T> set(T arg) { element = arg; return this; } T get() { return element; } } class A2 extends NotSelfBounded<A2> {} class B2 extends NotSelfBounded<A2> {} class C2 extends NotSelfBounded<C2> { 502 Thinking Java Bruce Eckel } C2 setAndGet(C2 arg) { set(arg); return get(); } class D2 {} // Now OK: class E2 extends NotSelfBounded<D2> {} ///:~ So clearly, self-bounding constraint serves force inheritance relationship. If use self-bounding, know type parameter used class basic type class that’s using parameter. It forces anyone using class follow form. It’s also possible use self-bounding generic methods: //: generics/SelfBoundingMethods.java public class SelfBoundingMethods { static <T extends SelfBounded<T>> T f(T arg) { return arg.set(arg).get(); } public static void main(String[] args) { A = f(new A()); } } ///:~ This prevents method applied anything self-bounded argument form shown. Argument covariance The value self-bounding types produce covariant argument types—method argument types vary follow subclasses. Although self-bounding types also produce return types subclass type, important covariant return types introduced Java SE5: //: generics/CovariantReturnTypes.java class Base {} class Derived extends Base {} interface OrdinaryGetter { Base get(); } interface DerivedGetter extends OrdinaryGetter { // Return type overridden method allowed vary: Derived get(); } public class CovariantReturnTypes { void test(DerivedGetter d) { Derived d2 = d.get(); } } ///:~ The get( ) method DerivedGetter overrides get( ) OrdinaryGetter returns type derived type returned OrdinaryGetter.get( ). Although Generics 503 perfectly logical thing do—a derived type method able return specific type base type method it’s overriding—it illegal earlier versions Java. A self-bounded generic fact produce exact derived type return value, seen get( ): //: generics/GenericsAndReturnTypes.java interface GenericGetter<T extends GenericGetter<T>> { T get(); } interface Getter extends GenericGetter<Getter> {} public class GenericsAndReturnTypes { void test(Getter g) { Getter result = g.get(); GenericGetter gg = g.get(); // Also base type } } ///:~ Notice code would compiled unless covariant return types included Java SE5. In non-generic code, however, argument types cannot made vary subtypes: //: generics/OrdinaryArguments.java class OrdinarySetter { void set(Base base) { System.out.println("OrdinarySetter.set(Base)"); } } class DerivedSetter extends OrdinarySetter { void set(Derived derived) { System.out.println("DerivedSetter.set(Derived)"); } } public class OrdinaryArguments { public static void main(String[] args) { Base base = new Base(); Derived derived = new Derived(); DerivedSetter ds = new DerivedSetter(); ds.set(derived); ds.set(base); // Compiles: overloaded, overridden! } } /* Output: DerivedSetter.set(Derived) OrdinarySetter.set(Base) *///:~ Both set(derived) set(base) legal, DerivedSetter.set( ) overriding OrdinarySetter.set( ), instead overloading method. From output, see two methods DerivedSetter, base-class version still available, thus verifying overloaded. However, self-bounding types, one method derived class, method takes derived type argument, base type: 504 Thinking Java Bruce Eckel //: generics/SelfBoundingAndCovariantArguments.java interface SelfBoundSetter<T extends SelfBoundSetter<T>> { void set(T arg); } interface Setter extends SelfBoundSetter<Setter> {} public class SelfBoundingAndCovariantArguments { void testA(Setter s1, Setter s2, SelfBoundSetter sbs) { s1.set(s2); // s1.set(sbs); // Error: // set(Setter) SelfBoundSetter<Setter> // cannot applied (SelfBoundSetter) } } ///:~ The compiler doesn’t recognize attempt pass base type argument set( ), method signature. The argument has, effect, overridden. Without self-bounding, ordinary inheritance mechanism steps in, get overloading, non-generic case: //: generics/PlainGenericInheritance.java class GenericSetter<T> { // Not self-bounded void set(T arg){ System.out.println("GenericSetter.set(Base)"); } } class DerivedGS extends GenericSetter<Base> { void set(Derived derived){ System.out.println("DerivedGS.set(Derived)"); } } public class PlainGenericInheritance { public static void main(String[] args) { Base base = new Base(); Derived derived = new Derived(); DerivedGS dgs = new DerivedGS(); dgs.set(derived); dgs.set(base); // Compiles: overloaded, overridden! } } /* Output: DerivedGS.set(Derived) GenericSetter.set(Base) *///:~ This code mimics OrdinaryArguments.java; example, DerivedSetter inherits OrdinarySetter contains set(Base). Here, DerivedGS inherits GenericSetter<Base> also contains set(Base), created generic. And like OrdinaryArguments.java, see output DerivedGS contains two overloaded versions set( ). Without self-bounding, overload argument types. If use self-bounding, end one version method, takes exact argument type. Exercise 34: (4) Create self-bounded generic type contains abstract method takes argument generic type parameter produces return value Generics 505 generic type parameter. In non-abstract method class, call abstract method return result. Inherit self-bounded type test resulting class. Dynamic type safety Because pass generic containers pre-Java SE5 code, there’s still possibility old-style code corrupt containers. Java SE5 set utilities java.util.Collections solve type-checking problem situation: static methods checkedCollection( ), checkedList( ), checkedMap( ), checkedSet( ), checkedSortedMap( ) checkedSortedSet( ). Each takes container want dynamically check first argument type want enforce second argument. A checked container throw ClassCastException point try insert improper object, opposed pre-generic (raw) container would inform problem pulled object out. In latter case, know there’s problem don’t know culprit is, checked containers find tried insert bad object. Let’s look problem "putting cat list dogs" using checked container. Here, oldStyleMethod( ) represents legacy code takes raw List, @SuppressWarnings("unchecked") annotation necessary suppress resulting warning: //: generics/CheckedList.java // Using Collection.checkedList(). import typeinfo.pets.*; import java.util.*; public class CheckedList { @SuppressWarnings("unchecked") static void oldStyleMethod(List probablyDogs) { probablyDogs.add(new Cat()); } public static void main(String[] args) { List<Dog> dogs1 = new ArrayList<Dog>(); oldStyleMethod(dogs1); // Quietly accepts Cat List<Dog> dogs2 = Collections.checkedList( new ArrayList<Dog>(), Dog.class); try { oldStyleMethod(dogs2); // Throws exception } catch(Exception e) { System.out.println(e); } // Derived types work fine: List<Pet> pets = Collections.checkedList( new ArrayList<Pet>(), Pet.class); pets.add(new Dog()); pets.add(new Cat()); } } /* Output: java.lang.ClassCastException: Attempt insert class typeinfo.pets.Cat element collection element type class typeinfo.pets.Dog *///:~ When run program you’ll see insertion Cat goes unchallenged dogs1, dogs2 immediately throws exception upon insertion incorrect type. You also see it’s fine put derived-type objects checked container checking base type. 506 Thinking Java Bruce Eckel Exercise 35: (1) Modify CheckedList.java uses Coffee classes defined chapter. Exceptions Because erasure, use generics exceptions extremely limited. A catch clause cannot catch exception generic type, exact type exception must known compile time run time. Also, generic class can’t directly indirectly inherit Throwable (this prevents trying define generic exceptions can’t caught). However, type parameters may used throws clause method declaration. This allows write generic code varies type checked exception: //: generics/ThrowGenericException.java import java.util.*; interface Processor<T,E extends Exception> { void process(List<T> resultCollector) throws E; } class ProcessRunner<T,E extends Exception> extends ArrayList<Processor<T,E>> { List<T> processAll() throws E { List<T> resultCollector = new ArrayList<T>(); for(Processor<T,E> processor : this) processor.process(resultCollector); return resultCollector; } } class Failure1 extends Exception {} class Processor1 implements Processor<String,Failure1> { static int count = 3; public void process(List<String> resultCollector) throws Failure1 { if(count-- > 1) resultCollector.add("Hep!"); else resultCollector.add("Ho!"); if(count < 0) throw new Failure1(); } } class Failure2 extends Exception {} class Processor2 implements Processor<Integer,Failure2> { static int count = 2; public void process(List<Integer> resultCollector) throws Failure2 { if(count-- == 0) resultCollector.add(47); else { resultCollector.add(11); } if(count < 0) throw new Failure2(); } Generics 507 } public class ThrowGenericException { public static void main(String[] args) { ProcessRunner<String,Failure1> runner = new ProcessRunner<String,Failure1>(); for(int = 0; < 3; i++) runner.add(new Processor1()); try { System.out.println(runner.processAll()); } catch(Failure1 e) { System.out.println(e); } ProcessRunner<Integer,Failure2> runner2 = new ProcessRunner<Integer,Failure2>(); for(int = 0; < 3; i++) runner2.add(new Processor2()); try { System.out.println(runner2.processAll()); } catch(Failure2 e) { System.out.println(e); } } } ///:~ A Processor performs process( ) may throw exception type E. The result process( ) stored List<T> resultCollector (this called collecting parameter). A ProcessRunner processAll( ) method executes every Process object holds, returns resultCollector. If could parameterize exceptions thrown, would unable write code generically checked exceptions. Exercise 36: (2) Add second parameterized exception Processor class demonstrate exceptions vary independently. 508 Thinking Java Bruce Eckel Mixins The term mixin seems acquired numerous meanings time, fundamental concept mixing capabilities multiple classes order produce resulting class represents types mixins. This often something last minute, makes convenient easily assemble classes. One value mixins consistently apply characteristics behaviors across multiple classes. As bonus, want change something mixin class, changes applied across classes mixin applied. Because this, mixins part flavor aspect-oriented programming (AOP), aspects often suggested solve mixin problem. Mixins C++ One strongest arguments made multiple inheritance C++ use mixins. However, interesting elegant approach mixins using parameterized types, whereby mixin class inherits type parameter. In C++, easily create mixins C++ remembers type template parameters. Here’s C++ example two mixin types: one allows mix property time stamp, another mixes serial number object instance: //: generics/Mixins.cpp #include <string> #include <ctime> #include <iostream> using namespace std; template<class T> class TimeStamped : public T { long timeStamp; public: TimeStamped() { timeStamp = time(0); } long getStamp() { return timeStamp; } }; template<class T> class SerialNumbered : public T { long serialNumber; static long counter; public: SerialNumbered() { serialNumber = counter++; } long getSerialNumber() { return serialNumber; } }; // Define initialize static storage: template<class T> long SerialNumbered<T>::counter = 1; class Basic { string value; public: void set(string val) { value = val; } string get() { return value; } }; int main() { TimeStamped<SerialNumbered<Basic> > mixin1, mixin2; mixin1.set("test string 1"); mixin2.set("test string 2"); Generics 509 cout << mixin1.get() << " " << mixin1.getStamp() << " " << mixin1.getSerialNumber() << endl; cout << mixin2.get() << " " << mixin2.getStamp() << " " << mixin2.getSerialNumber() << endl; } /* Output: (Sample) test string 1 1129840250 1 test string 2 1129840250 2 *///:~ In main( ), resulting type mixin1 mixin2 methods mixed-in types. You think mixin function maps existing classes new subclasses. Notice trivial create mixin using technique; basically, say, "Here’s I want," happens: TimeStamped<SerialNumbered<Basic> > mixin1, mixin2; Unfortunately, Java generics don’t permit this. Erasure forgets base-class type, generic class cannot inherit directly generic parameter. Mixing interfaces A commonly suggested solution use interfaces produce effect mixins, like this: //: generics/Mixins.java import java.util.*; interface TimeStamped { long getStamp(); } class TimeStampedImp implements TimeStamped { private final long timeStamp; public TimeStampedImp() { timeStamp = new Date().getTime(); } public long getStamp() { return timeStamp; } } interface SerialNumbered { long getSerialNumber(); } class SerialNumberedImp implements SerialNumbered { private static long counter = 1; private final long serialNumber = counter++; public long getSerialNumber() { return serialNumber; } } interface Basic { public void set(String val); public String get(); } class BasicImp implements Basic { private String value; public void set(String val) { value = val; } public String get() { return value; } } class Mixin extends BasicImp implements TimeStamped, SerialNumbered { private TimeStamped timeStamp = new TimeStampedImp(); private SerialNumbered serialNumber = new SerialNumberedImp(); 510 Thinking Java Bruce Eckel public long getStamp() { return timeStamp.getStamp(); } public long getSerialNumber() { return serialNumber.getSerialNumber(); } } public class Mixins { public static void main(String[] args) { Mixin mixin1 = new Mixin(), mixin2 = new Mixin(); mixin1.set("test string 1"); mixin2.set("test string 2"); System.out.println(mixin1.get() + " " + mixin1.getStamp() + " " + mixin1.getSerialNumber()); System.out.println(mixin2.get() + " " + mixin2.getStamp() + " " + mixin2.getSerialNumber()); } } /* Output: (Sample) test string 1 1132437151359 1 test string 2 1132437151359 2 *///:~ The Mixin class basically using delegation, mixed-in type requires field Mixin, must write necessary methods Mixin forward calls appropriate object. This example uses trivial classes, complex mixin code grows rapidly. 4 Exercise 37: (2) Add new mixin class Colored Mixins.java, mix Mixin, show works. Using Decorator pattern When look way used, concept mixin seems closely related Decorator design pattern. 5 Decorators often used when, order satisfy every possible combination, simple subclassing produces many classes becomes impractical. The Decorator pattern uses layered objects dynamically transparently add responsibilities individual objects. Decorator specifies objects wrap around initial object basic interface. Something decoratable, layer functionality wrapping classes around decoratable. This makes use decorators transparentthere set common messages send object whether decorated not. A decorating class also add methods, shall see, limited. Decorators implemented using composition formal structures (the decoratable/decorator hierarchy), whereas mixins inheritance-based. So could think parameterized-type-based mixins generic decorator mechanism require inheritance structure Decorator design pattern. The previous example recast using Decorator: //: generics/decorator/Decoration.java package generics.decorator; import java.util.*; 4 Note programming environments, Eclipse IntelliJ Idea, automatically generate delegation code. 5 Patterns subject Thinking Patterns (with Java), find www.MindView.net. See also Design Patterns, Erich Gamma et al. (Addison-Wesley, 1995)- Generics 511 class Basic { private String value; public void set(String val) { value = val; } public String get() { return value; } } class Decorator extends Basic { protected Basic basic; public Decorator(Basic basic) { this.basic = basic; } public void set(String val) { basic.set(val); } public String get() { return basic.get(); } } class TimeStamped extends Decorator { private final long timeStamp; public TimeStamped(Basic basic) { super(basic); timeStamp = new Date().getTime(); } public long getStamp() { return timeStamp; } } class SerialNumbered extends Decorator { private static long counter = 1; private final long serialNumber = counter++; public SerialNumbered(Basic basic) { super(basic); } public long getSerialNumber() { return serialNumber; } } public class Decoration { public static void main(String[] args) { TimeStamped = new TimeStamped(new Basic()); TimeStamped t2 = new TimeStamped( new SerialNumbered(new Basic())); //! t2.getSerialNumber(); // Not available SerialNumbered = new SerialNumbered(new Basic()); SerialNumbered s2 = new SerialNumbered( new TimeStamped(new Basic())); //! s2.getStamp(); // Not available } } ///:~ The class resulting mixin contains methods interest, type object results using decorators last type decorated with. That is, although it’s possible add one layer, final layer actual type, final layer’s methods visible, whereas type mixin types mixed together. So significant drawback Decorator effectively works one layer decoration (the final one), mixin approach arguably natural. Thus, Decorator limited solution problem addressed mixins. Exercise 38: (4) Create simple Decorator system starting basic coffee, providing decorators steamed milk, foam, chocolate, caramel whipped cream. Mixins dynamic proxies It’s possible use dynamic proxy create mechanism closely models mixins Decorator (see Type Information chapter explanation Java’s dynamic proxies work). With dynamic proxy, dynamic type resulting class combined types mixed in. 512 Thinking Java Bruce Eckel Because constraints dynamic proxies, class mixed must implementation interface: //: generics/DynamicProxyMixin.java import java.lang.reflect.*; import java.util.*; import net.mindview.util.*; import static net.mindview.util.Tuple.*; class MixinProxy implements InvocationHandler { Map<String,Object> delegatesByMethod; public MixinProxy(TwoTuple<Object,Class<?>>... pairs) { delegatesByMethod = new HashMap<String,Object>(); for(TwoTuple<Object,Class<?>> pair : pairs) { for(Method method : pair.second.getMethods()) { String methodName = method.getName(); // The first interface map // implements method. (!delegatesByMethod.containsKey(methodName)) delegatesByMethod.put(methodName, pair.first); } } } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); Object delegate = delegatesByMethod.get(methodName); return method.invoke(delegate, args); } @SuppressWarnings("unchecked") public static Object newInstance(TwoTuple... pairs) { Class[] interfaces = new Class[pairs.length]; for(int = 0; < pairs.length; i++) { interfaces[i] = (Class)pairs[i].second; } ClassLoader cl = pairs[0].first.getClass().getClassLoader(); return Proxy.newProxyInstance( cl, interfaces, new MixinProxy(pairs)); } } public class DynamicProxyMixin { public static void main(String[] args) { Object mixin = MixinProxy.newInstance( tuple(new BasicImp(), Basic.class), tuple(new TimeStampedImp(), TimeStamped.class), tuple(new SerialNumberedImp(),SerialNumbered.class)); Basic b = (Basic)mixin; TimeStamped = (TimeStamped)mixin; SerialNumbered = (SerialNumbered)mixin; b.set("Hello"); System.out.println(b.get()); System.out.println(t.getStamp()); System.out.println(s.getSerialNumber()); } } /* Output: (Sample) Hello 1132519137015 1 *///:~ Generics 513 Because dynamic type, static type, includes mixed-in types, still quite nice C++ approach, you’re forced downcast appropriate type call methods it. However, significantly closer true mixin. There fair amount work done towards support mixins Java, including creation least one language add-on, Jam language, specifically supporting mixins. Exercise 39: (1) Add new mixin class Colored DynamicProxyMixin.java, mix mixin, show works. Latent typing The beginning chapter introduced idea writing code applied generally possible. To this, need ways loosen constraints types code works with, without losing benefits static type checking. We able write code used situations without change—that is, "generic" code. Java generics appear take step direction. When writing using generics simply hold objects, code works type (except primitives, although you’ve seen, autoboxing smoothes over). Or, put another way, "holder" generics able say, "I don’t care type are." Code doesn’t care type works indeed applied everywhere, thus quite "generic." As you’ve also seen, problem arises want perform manipulations generic types (other calling Object methods), erasure requires specify bounds generic types may used, order safely call specific methods generic objects code. This significant limitation concept "generic" must constrain generic types inherit particular classes implement particular interfaces. In cases might end using ordinary class interface instead, bounded generic might different specifying class interface. One solution programming languages provide called latent typing structural typing. A whimsical term duck typing, in, "If walks like duck talks like duck, might well treat like duck." Duck typing become fairly popular term, possibly doesn’t carry historical baggage terms do. Generic code typically calls methods generic type, language latent typing loosens constraint (and produces generic code) requiring subset methods implemented, particular class interface. Because this, latent typing allows cut across class hierarchies, calling methods part common interface. So piece code might say, effect, "I don’t care type long speak( ) sit( )." By requiring specific type, code generic. Latent typing code organization reuse mechanism. With write piece code reused easily without it. Code organization reuse foundational levers computer programming: Write once, use once, keep code one place. Because I required name exact interface code operates upon, latent typing I write less code apply easily places. 514 Thinking Java Bruce Eckel Two examples languages support latent typing Python (freely downloadable www.Python.org) C++. 6 Python dynamically typed language (virtually type checking happens run time) C++ statically typed language (the type checking happens compile time), latent typing require either static dynamic type checking. If take description express Python, looks like this: #: generics/DogsAndRobots.py class Dog: def speak(self): print "Arf!" def sit(self): print "Sitting" def reproduce(self): pass class Robot: def speak(self): print "Click!" def sit(self): print "Clank!" def oilChange(self) : pass def perform(anything): anything.speak() anything.sit() = Dog() b = Robot() perform(a) perform(b) #:~ Python uses indentation determine scope (so curly braces needed), colon begin new scope. A ‘#’ indicates comment end line, like ‘//’ Java. The methods class explicitly specify equivalent reference first argument, called self convention. Constructor calls require sort "new" keyword. And Python allows regular (non-member) functions, evidenced perform( ). In perform(anything), notice type anything, anything identifier. It must able perform operations perform( ) asks it, interface implied. But never explicitly write interface—it’s latent. perform( ) doesn’t care type argument, I pass object long supports speak( ) sit( ) methods. If pass object perform( ) support operations, you’ll get runtime exception. We produce effect C++: //: generics/DogsAndRobots.cpp class Dog { public: void speak() {} void sit() {} void reproduce() {} 6 The Ruby Smalltalk languages also support latent typing. Generics 515 }; class Robot { public: void speak() {} void sit() {} void oilChange() { }; template<class T> void perform(T anything) { anything.speak(); anything.sit(); } int main() { Dog d; Robot r; perform(d); perform(r); } ///:~ In Python C++, Dog Robot nothing common, happen two methods identical signatures. From type standpoint, completely distinct types. However, perform( ) doesn’t care specific type argument, latent typing allows accept types object. C++ ensures actually send messages. The compiler gives error message try pass wrong type (these error messages historically terrible verbose, primary reason C++ templates poor reputation). Although different times— C++ compile time, Python run time—both languages ensure types cannot misused thus considered strongly typed. 7 Latent typing compromise strong typing. Because generics added Java late game, chance kind latent typing could implemented, Java support feature. As result, initially seems Java’s generic mechanism "less generic" language supports latent typing. 8 For instance, try implement example Java, forced use class interface specify bounds expression: //: generics/Performs.java public interface Performs { void speak(); void sit(); } ///:~ //: generics/DogsAndRobots.java // No latent typing Java import typeinfo.pets.*; import static net.mindview.util.Print.*; class PerformingDog extends Dog implements Performs { public void speak() { print("Woof!"); } public void sit() { print("Sitting"); } public void reproduce() {} } 7 Because use casts, effectively disable type system, people argue C++ weakly typed, that’s extreme. It’s probably safer say C++ "strongly typed trap door." 8 516 The implementation Java’s generics using erasure sometimes referred secondclass generic types. Thinking Java Bruce Eckel class Robot implements Performs { public void speak() { print("Click!"); } public void sit() { print("Clank!"); } public void oilChange() {} } class Communicate { public static <T extends Performs> void perform(T performer) { performer.speak(); performer.sit(); } } public class DogsAndRobots { public static void main(String[] args) { PerformingDog = new PerformingDog(); Robot r = new Robot(); Communicate.perform(d); Communicate.perform(r); } } /* Output: Woof! Sitting Click! Clank! *///:~ However, note perform( ) need use generics order work. It simply specified accept Performs object: //: generics/SimpleDogsAndRobots.java // Removing generic; code still works. class CommunicateSimply { static void perform(Performs performer) { performer.speak(); performer.sit(); } } public class SimpleDogsAndRobots { public static void main(String[] args) { CommunicateSimply.perform(new PerformingDog()); CommunicateSimply.perform(new Robot()); } } /* Output: Woof! Sitting Click! Clank! *///:~ In case, generics simply necessary, since classes already forced implement Performs interface. Generics 517 Compensating lack latent typing Although Java support latent typing, turns mean bounded generic code cannot applied across different type hierarchies. That is, still possible create truly generic code, takes extra effort. Reflection One approach use reflection. Here’s perform( ) method uses latent typing: //: generics/LatentReflection.java // Using Reflection produce latent typing. import java.lang.reflect.*; import static net.mindview.util.Print.*; // Does implement Performs: class Mime { public void walkAgainstTheWind() {} public void sit() { print("Pretending sit"); } public void pushInvisibleWalls() {} public String toString() { return "Mime"; } } // Does implement Performs: class SmartDog { public void speak() { print("Woof!"); } public void sit() { print("Sitting"); } public void reproduce() {} } class CommunicateReflectively { public static void perform(Object speaker) { Class<?> spkr = speaker.getClass(); try { try { Method speak = spkr.getMethod("speak"); speak.invoke(speaker); } catch(NoSuchMethodException e) { print(speaker + " cannot speak"); } try { Method sit = spkr.getMethod("sit"); sit.invoke(speaker); } catch(NoSuchMethodException e) { print(speaker + " cannot sit"); } } catch(Exception e) { throw new RuntimeException(speaker.toString(), e); } } } public class LatentReflection { public static void main(String[] args) { CommunicateReflectively.perform(new SmartDog()); CommunicateReflectively.perform(new Robot()); CommunicateReflectively.perform(new Mime()); 518 Thinking Java Bruce Eckel } } /* Output: Woof! Sitting Click! Clank! Mime cannot speak Pretending sit *///:~ Here, classes completely disjoint base classes (other Object) interfaces common. Through reflection, CommunicateReflectively.perform( ) able dynamically establish whether desired methods available call them. It even able deal fact Mime one necessary methods, partially fulfills goal. Applying method sequence Reflection provides interesting possibilities, relegates type checking run time, thus undesirable many situations. If achieve compile-time type checking, that’s usually desirable. But possible compile-time type checking latent typing? Let’s look example explores problem. Suppose want create apply( ) method apply method every object sequence. This situation interfaces don’t seem fit. You want apply method collection objects, interfaces constrain much describe "any method." How Java? Initially, solve problem reflection, turns fairly elegant Java SE5 varargs: //: generics/Apply.java // {main: ApplyTest} import java.lang.reflect.*; import java.util.*; import static net.mindview.util.Print.*; public class Apply { public static <T, S extends Iterable<? extends T>> void apply(S seq, Method f, Object... args) { try { for(T t: seq) f.invoke(t, args); } catch(Exception e) { // Failures programmer errors throw new RuntimeException(e); } } } class Shape { public void rotate() { print(this + " rotate"); } public void resize(int newSize) { print(this + " resize " + newSize); } } class Square extends Shape {} class FilledList<T> extends ArrayList<T> { Generics 519 } public FilledList(Class<? extends T> type, int size) { try { for(int = 0; < size; i++) // Assumes default constructor: add(type.newInstance()); } catch(Exception e) { throw new RuntimeException(e); } } class ApplyTest { public static void main(String[] args) throws Exception { List<Shape> shapes = new ArrayList<Shape>(); for(int = 0; < 10; i++) shapes.add(new Shape()); Apply.apply(shapes, Shape.class.getMethod("rotate")); Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 5); List<Square> squares = new ArrayList<Square>(); for(int = 0; < 10; i++) squares.add(new Square()); Apply.apply(squares, Shape.class.getMethod("rotate")); Apply.apply(squares, Shape.class.getMethod("resize", int.class), 5); Apply.apply(new FilledList<Shape>(Shape.class, 10), Shape.class.getMethod("rotate")); Apply.apply(new FilledList<Shape>(Square.class, 10), Shape.class.getMethod("rotate")); SimpleQueue<Shape> shapeQ = new SimpleQueue<Shape>(); for(int = 0; < 5; i++) { shapeQ.add(new Shape()); shapeQ.add(new Square()); } Apply.apply(shapeQ, Shape.class.getMethod("rotate")); } } /* (Execute see output) *///:~ In Apply, get lucky happens Iterable interface built Java used Java containers library. Because this, apply( ) method accept anything implements Iterable interface, includes Collection classes List. But also accept anything else, long make Iterable—for example, SimpleQueue class defined used main( ): //: generics/SimpleQueue.java // A different kind container Iterable import java.util.*; public class SimpleQueue<T> implements Iterable<T> { private LinkedList<T> storage = new LinkedList<T>(); public void add(T t) { storage.offer(t); } public T get() { return storage.poll(); } public Iterator<T> iterator() { return storage.iterator(); } } ///:~ In Apply.java, exceptions converted RuntimeExceptions there’s much way recover exceptions—they really represent programmer errors case. 520 Thinking Java Bruce Eckel Note I put bounds wildcards order Apply FilledList used desired situations. You experiment taking out, you’ll discover applications Apply FilledList work. FilledList presents bit quandary. In order type used, must default (no-arg) constructor. Java way assert thing compile time, becomes runtime issue. A common suggestion ensure compile-time checking define factory interface method generates objects; FilledList would accept interface rather "raw factory" type token. The problem classes use FilledList must implement factory interface. Alas, classes created without knowledge interface, therefore implement it. Later, I’ll show one solution using adapters. But approach shown, using type token, perhaps reasonable tradeoff (at least first-cut solution). With approach, using something like FilledList easy enough may used rather ignored. Of course, errors reported run time, need confidence errors appear early development process. Note type token technique recommended Java literature, Gilad Bracha’s paper Generics Java Programming Language, 9 notes, "It’s idiom that’s used extensively new APIs manipulating annotations, example." However, I’ve discovered inconsistency people’s comfort level technique; people strongly prefer factory approach, presented earlier chapter. Also, elegant Java solution turns be, must observe use reflection (although improved significantly recent versions Java) may slower non-reflection implementation, since much happening run time. This stop using solution, least first cut (lest fall sway premature optimization), it’s certainly distinction two approaches. Exercise 40: (3) Add speak( ) method pets typeinfo.pets. Modify Apply.java call speak( ) method heterogeneous collection Pet. When don’t happen right interface The example benefited Iterable interface already built in, exactly needed. But general case, isn’t interface already place happens fit needs? For example, let’s generalize idea FilledList create parameterized fill( ) method take sequence fill using Generator. When try write Java, run problem, convenient "Addable" interface Iterable interface previous example. So instead saying, "anything call add( ) for," must say, "subtype Collection." The resulting code particularly generic, since must constrained work Collection implementations. If I try use class doesn’t implement Collection, generic code won’t work. Here’s looks like: //: generics/Fill.java // Generalizing FilledList idea // {main: FillTest} import java.util.*; 9 See citation end chapter. Generics 521 // Doesn’t work "anything add()." There // "Addable" interface narrowed using // Collection. We cannot generalize using generics // case. public class Fill { public static <T> void fill(Collection<T> collection, Class<? extends T> classToken, int size) { for(int = 0; < size; i++) // Assumes default constructor: try { collection.add(classToken.newInstance()); } catch(Exception e) { throw new RuntimeException(e); } } } class Contract { private static long counter = 0; private final long id = counter++; public String toString() { return getClass().getName() + " " + id; } } class TitleTransfer extends Contract {} class FillTest { public static void main(String[] args) { List<Contract> contracts = new ArrayList<Contract>(); Fill.fill(contracts, Contract.class, 3); Fill.fill(contracts, TitleTransfer.class, 2); for(Contract c: contracts) System.out.println(c); SimpleQueue<Contract> contractQueue = new SimpleQueue<Contract>(); // Won’t work. fill() generic enough: // Fill.fill(contractQueue, Contract.class, 3); } } /* Output: Contract 0 Contract 1 Contract 2 TitleTransfer 3 TitleTransfer 4 *///:~ This parameterized type mechanism latent typing valuable, mercy past design decisions particular library creator, rewrite code every time encounter new library didn’t take situation account (thus code truly "generic"). In case, Java designers (understandably) see need "Addable" interface, constrained within Collection hierarchy, SimpleQueue, even though add( ) method, work. Because thus constrained working Collection, code particularly "generic." With latent typing, would case. 522 Thinking Java Bruce Eckel Simulating latent typing adapters So Java generics don’t latent typing, need something like latent typing order write code applied across class boundaries (that is, "generic" code). Is way get around limitation? What would latent typing accomplish here? It means could write code saying, "I don’t care type I’m using long methods." In effect, latent typing creates implicit interface containing desired methods. So follows write necessary interface hand (since Java doesn’t us), solve problem. Writing code produce interface want interface example Adapter design pattern. We use adapters adapt existing classes produce desired interface, relatively small amount code. The solution, uses previously defined Coffee hierarchy, demonstrates different ways writing adapters: //: generics/Fill2.java // Using adapters simulate latent typing. // {main: Fill2Test} import generics.coffee.*; import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; interface Addable<T> { void add(T t); } public class Fill2 { // Classtoken version: public static <T> void fill(Addable<T> addable, Class<? extends T> classToken, int size) { for(int = 0; < size; i++) try { addable.add(classToken.newInstance()); } catch(Exception e) { throw new RuntimeException(e); } } // Generator version: public static <T> void fill(Addable<T> addable, Generator<T> generator, int size) { for(int = 0; < size; i++) addable.add(generator.next()); } } // To adapt base type, must use composition. // Make Collection Addable using composition: class AddableCollectionAdapter<T> implements Addable<T> { private Collection<T> c; public AddableCollectionAdapter(Collection<T> c) { this.c = c; } public void add(T item) { c.add(item); } } // A Helper capture type automatically: class Adapter { public static <T> Addable<T> collectionAdapter(Collection<T> c) { return new AddableCollectionAdapter<T>(c); } Generics 523 } // To adapt specific type, use inheritance. // Make SimpleQueue Addable using inheritance: class AddableSimpleQueue<T> extends SimpleQueue<T> implements Addable<T> { public void add(T item) { super.add(item); } } class Fill2Test { public static void main(String[] args) { // Adapt Collection: List<Coffee> carrier = new ArrayList<Coffee>(); Fill2.fill( new AddableCollectionAdapter<Coffee>(carrier), Coffee.class, 3); // Helper method captures type: Fill2.fill(Adapter.collectionAdapter(carrier), Latte.class, 2); for(Coffee c: carrier) print(c); print("----------------------"); // Use adapted class: AddableSimpleQueue<Coffee> coffeeQueue = new AddableSimpleQueue<Coffee>(); Fill2.fill(coffeeQueue, Mocha.class, 4); Fill2.fill(coffeeQueue, Latte.class, 1); for(Coffee c: coffeeQueue) print(c); } } /* Output: Coffee 0 Coffee 1 Coffee 2 Latte 3 Latte 4 ---------------------Mocha 5 Mocha 6 Mocha 7 Mocha 8 Latte 9 *///:~ Fill2 doesn’t require Collection Fill did. Instead, needs something implements Addable, Addable written Fill—it manifestation latent type I wanted compiler make me. In version, I’ve also added overloaded fill( ) takes Generator rather type token. The Generator type-safe compile time: The compiler ensures pass proper Generator, exceptions thrown. The first adapter, AddableCollectionAdapter, works base type Collection, means implementation Collection used. This version simply stores Collection reference uses implement add( ). If specific type rather base class hierarchy, write somewhat less code creating adapter using inheritance, see AddableSimpleQueue. 524 Thinking Java Bruce Eckel In Fill2Test.main( ), see various types adapters work. First, Collection type adapted AddableCollectionAdapter. A second version uses generic helper method, see generic method captures type doesn’t explicitly written— convenient trick produces elegant code. Next, pre-adapted AddableSimpleQueue used. Note cases adapters allow classes previously didn’t implement Addable used Fill2.fill( ). Using adapters like would seem compensate lack latent typing, thus allow write genuinely generic code. However, it’s extra step something must understood library creator library consumer, concept may grasped readily less experienced programmers. By removing extra step, latent typing makes generic code easier apply, value. Exercise 41: (1) Modify Fill2.java use classes typeinfo.pets instead Coffee classes. Generics 525 Using function objects strategies This final example create truly generic code using adapter approach described previous section. The example began attempt create sum sequence elements (of type summed), evolved performing general operations using afunctional style programming. If look process trying add objects, see case common operations across classes, operations represented base class specify—sometimes even use a’+’ operator, times may kind "add" method. This generally situation encounter trying write generic code, want code apply across multiple classes— especially, case, multiple classes already exist ability "fix." Even narrow case subclasses Number, superclass doesn’t include anything "addability." The solution use Strategy design pattern, produces elegant code completely isolates "the thing changes" inside function object. 10 A function object object way behaves like function—typically, there’s one method interest (in languages support operator overloading, make call method look like ordinary method call). The value function objects that, unlike ordinary method, passed around, also state persists across calls. Of course, accomplish something like method class, (as design pattern) function object primarily distinguished intent. Here intent create something behaves like single method pass around; thus closely coupled with—and sometimes indistinguishable from—the Strategy design pattern. As I’ve found number design patterns, lines get kind blurry here: We creating function objects perform adaptation, passed methods used strategies. Taking approach, I added various kinds generic methods I originally set create, more. Here result: //: generics/Functional.java import java.math.*; import java.util.concurrent.atomic.*; import java.util.*; import static net.mindview.util.Print.*; // Different types function objects: interface Combiner<T> { T combine(T x, T y); } interface UnaryFunction<R,T> { R function(T x); } interface Collector<T> extends UnaryFunction<T,T> { T result(); // Extract result collecting parameter } interface UnaryPredicate<T> { boolean test(T x); } public class Functional { // Calls Combiner object element combine // running result, finally returned: public static <T> T You sometimes see called functors. I use term function object rather than^unctor, term "functor" specific different meaning mathematics. 10 526 Thinking Java Bruce Eckel reduce(Iterable<T> seq, Combiner<T> combiner) { Iterator<T> = seq.iterator(); if(it.hasNext()) { T result = it.next(); while(it.hasNext()) result = combiner.combine(result, it.next()); return result; } // If seq empty list: return null; // Or throw exception } // Take function object call object // list, ignoring return value. The function // object may act collecting parameter, // returned end. public static <T> Collector<T> forEach(Iterable<T> seq, Collector<T> func) { for(T : seq) func.function(t); return func; } // Creates list results calling // function object object list: public static <R,T> List<R> transform(Iterable<T> seq, UnaryFunction<R,T> func) { List<R> result = new ArrayList<R>(); for(T : seq) result.add(func.function(t)); return result; } // Applies unary predicate item sequence, // returns list items produced "true": public static <T> List<T> filter(Iterable<T> seq, UnaryPredicate<T> pred) { List<T> result = new ArrayList<T>(); for(T : seq) if(pred.test(t)) result.add(t); return result; } // To use generic methods, need create // function objects adapt particular needs: static class IntegerAdder implements Combiner<Integer> { public Integer combine(Integer x, Integer y) { return x + y; } } static class IntegerSubtracter implements Combiner<Integer> { public Integer combine(Integer x, Integer y) { return x - y; } } static class BigDecimalAdder implements Combiner<BigDecimal> { public BigDecimal combine(BigDecimal x, BigDecimal y) { return x.add(y); } } static class BigIntegerAdder implements Combiner<BigInteger> { public BigInteger combine(BigInteger x, BigInteger y) { return x.add(y); Generics 527 } } static class AtomicLongAdder implements Combiner<AtomicLong> { public AtomicLong combine(AtomicLong x, AtomicLong y) { // Not clear whether meaningful: return new AtomicLong(x.addAndGet(y.get())); } } // We even make UnaryFunction "ulp" // (Units last place): static class BigDecimalUlp implements UnaryFunction<BigDecimal,BigDecimal> { public BigDecimal function(BigDecimal x) { return x.ulp(); } } static class GreaterThan<T extends Comparable<T>> implements UnaryPredicate<T> { private T bound; public GreaterThan(T bound) { this.bound = bound; } public boolean test(T x) { return x.compareTo(bound) > 0; } } static class MultiplyingIntegerCollector implements Collector<Integer> { private Integer val = 1; public Integer function(Integer x) { val *= x; return val; } public Integer result() { return val; } } public static void main(String[] args) { // Generics, varargs & boxing working together: List<Integer> li = Arrays.asList(1, 2, 3, 4, 5, 6, 7); Integer result = reduce(li, new IntegerAdder()); print(result); result = reduce(li, new IntegerSubtracter()); print(result); print(filter(li, new GreaterThan<Integer>(4))); print(forEach(li, new MultiplyingIntegerCollector()).result()); print(forEach(filter(li, new GreaterThan<Integer>(4)), new MultiplyingIntegerCollector()).result()); MathContext mc = new MathContext(7); List<BigDecimal> lbd = Arrays.asList( new BigDecimal(1.1, mc), new BigDecimal(2.2, mc), new BigDecimal(3.3, mc), new BigDecimal(4.4, mc)); BigDecimal rbd = reduce(lbd, new BigDecimalAdder()); print(rbd); print(filter(lbd, new GreaterThan<BigDecimal>(new BigDecimal(3)))); // Use prime-generation facility BigInteger: List<BigInteger> lbi = new ArrayList<BigInteger>(); 528 Thinking Java Bruce Eckel BigInteger bi = BigInteger.valueOf(11); for(int = 0; < 11; i++) { lbi.add(bi); bi = bi.nextProbablePrime(); } print(lbi); BigInteger rbi = reduce(lbi, new BigIntegerAdder()); print(rbi); // The sum list primes also prime: print(rbi.isProbablePrime(5)); List<AtomicLong> lal = Arrays.asList( new AtomicLong(11), new AtomicLong(47), new AtomicLong(74), new AtomicLong(133)); AtomicLong ral = reduce(lal, new AtomicLongAdder()); print(ral); print(transform(lbd,new BigDecimalUlp())); } } /* Output: 28 -26 [5, 6, 7] 5040 210 11.000000 [3.300000, 4.400000] [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] 311 true 265 [0.000001, 0.000001, 0.000001, 0.000001] *///:~ I begin defining interfaces different types function objects. These created demand, I developed different methods discovered need each. The Combiner class suggested anonymous contributor one articles posted Web site. The Combiner abstracts away specific detail trying add two objects, says combined somehow. As result, see IntegerAdder IntegerSubtracter types Combiner. A UnaryFunction takes single argument produces result; argument result need type. A Collector used "collecting parameter," extract result you’re finished. A UnaryPredicate produces boolean result. There types function objects defined, enough make point. The Functional class contains number generic methods apply function objects sequences. reduce( ) applies function Combiner element sequence order produce single result. forEach( ) takes Collector applies function element, ignoring result function call. This called side effect (which wouldn’t "functional" style programming still useful), Collector maintain internal state become collecting parameter, case example. transform( ) produces list calling UnaryFunction object sequence capturing result. Generics 529 Finally, filter( ) applies UnaryPredicate object sequence stores ones produce true List, returns. You define additional generic functions. The C++ STL, example, lots them. The problem also solved open-source libraries, JGA (Generic Algorithms Java). In C++, latent typing takes care matching operations call functions, Java need write function objects adapt generic methods particular needs. So next part class shows various different implementations function objects. Note, example, IntegerAdder BigDecimalAdder solve problemadding two objects—by calling appropriate operations particular type. So that’s Adapter pattern Strategy pattern combined. In main( ), see method call, sequence passed along appropriate function object. Also, number expressions get fairly complex, as: forEach(filter(li, new GreaterThan(4)), new MultiplyingIntegerCollector()).result() This produces list selecting elements li greater 4, applies MultiplyingIntegerCollector( ) resulting list extracts result( ). I won’t explain details rest code say probably figure walking it. Exercise 42: (5) Create two separate classes, nothing common. Each class hold value, least methods produce value perform modification upon value. Modify Functional.java performs functional operations collections classes (these operations arithmetic Functional.java). 530 Thinking Java Bruce Eckel Summary: Is casting really bad? Having worked explain C++ templates since inception, I probably putting forward following argument longer people. Only recently I stopped wonder often argument valid—how many times problem I’m describe really slip cracks? The argument goes like this. One compelling places use generic type mechanism container classes Lists, Sets, Maps, etc. saw Holding Your Objects shall see Containers Depth chapter. Before Java SE5, put object container, would upcast Object, you’d lose type information. When wanted pull back something it, cast back proper type. My example List Cat (a variation using apples oranges shown beginning Holding Your Objects chapter). Without Java SE5 generic version container, put Objects get Objects out, it’s easily possible put Dog List Cat. However, pre-generic Java wouldn’t let misuse objects put container. If threw Dog container Cats tried treat everything container Cat, you’d get RuntimeException pulled Dog reference Cat container tried cast Cat. You’d still discover problem, discovered run time rather compile time. In previous editions book, I go say: This annoyance. It’s something create difficult-to-find bugs. If one part (or several parts) program inserts objects container, discover separate part program exception bad object placed container, must find bad insert occurred. However, upon examination argument, I began wonder it. First, often happen? I don’t remember kind thing ever happening me, I asked people conferences, I didn’t hear anyone say happened them. Another book used example list called files contained String objects—in example seemed perfectly natural add File object files, better name object might fileNames. No matter much type checking Java provides, it’s still possible write obscure programs, badly written program compiles still badly written program. Perhaps people use well-named containers "cats" provide visual warning programmer would try add non-Cat. And even happen, long would thing really stay buried? It would seem soon started running tests real data, you’d see exception pretty quickly. One author even asserted bug could "remain buried years." But I recall deluge reports people great difficulty finding "dog cat list" bugs, even producing often. Whereas see Concurrency chapter threads, easy common bugs may appear extremely rarely, give vague idea what’s wrong. So "dog cat list" argument really reason significant fairly complex feature added Java? I believe intent general-purpose language feature called "generics" (not necessarily Java’s particular implementation it) expressiveness, creating type-safe containers. Type-safe containers come side effect ability create generalpurpose code. Generics 531 So even though "dog cat list" argument often used justify generics, questionable. And I asserted beginning chapter, I believe concept generics really about. Instead, generics name implies—a way write "generic" code less constrained types work with, single piece code applied types. As seen chapter, fairly easy write truly generic "holder" classes (which Java containers are), write generic code manipulates generic types requires extra effort, part class creator class consumer, must understand concept implementation Adapter design pattern. That extra effort reduces ease use feature, may thus make less applicable places might otherwise added value. Also note generics back-engineered Java instead designed language start, containers cannot made robust be. For example, look Map, particular methods containsKey(Object key) get(Object key). If classes designed pre-existing generics, methods would used parameterized types instead Object, thus affording compile-time checking generics supposed provide. In C++ maps, example, key type always checked compile time. One thing clear: Introducing kind generic mechanism later version language, language come general use, very, messy proposition, one cannot accomplished without pain. In C++, templates introduced initial ISO version language (although even caused pain earlier nontemplate version use first Standard C++ appeared), effect templates always part language. In Java, generics introduced almost 10 years language first released, issues migrating generics quite considerable, made significant impact design generics. The result you, programmer, suffer lack vision exhibited Java designers created version l.o. When Java first created, designers, course, knew C++ templates, even considered including language, one reason another decided leave (indications hurry). As result, language programmers use suffer. Only time show ultimate impact Java’s approach generics language. Some languages, notably Nice (see http://nice.sourceforge.net; language generates Java bytecodes works existing Java libraries) NextGen (see http://japan.cs.rice.edu/nextgen) incorporated cleaner less impactful approaches parameterized types. It’s impossible imagine language becoming successor Java, takes exactly approach C++ C: Use what’s improve upon it. 532 Thinking Java Bruce Eckel Further reading The introductory document generics Generics Java Programming Language, Gilad Bracha, located http://java.sun.eom/j2se/1.5/pdf/generics-tutorial.pdf Angelika Langer’s Java Generics FAQs helpful resource, located www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html. You find wildcards Adding Wildcards Java Programming Language, Torgerson, Ernst, Hansen, von der Ahe, Bracha Gafter, located www.jot.fm/issues/issue_2004_12/article5. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Generics 533 Arrays At end Initialization & Cleanup chapter, learned define initialize array. The simple view arrays create populate them, select elements using int indexes, don’t change size. Most time that’s need know, sometimes need perform sophisticated operations arrays, may also need evaluate use array vs. flexible container. This chapter show think arrays depth. Why arrays special There number ways hold objects, makes array special? There three issues distinguish arrays types containers: efficiency, type, ability hold primitives. The array Java’s efficient way store randomly access sequence object references. The array simple linear sequence, makes element access fast. The cost speed size array object fixed cannot changed lifetime array. You might suggest ArrayList (from Holding Your Objects), automatically allocate space, creating new one moving references old one new one. Although generally prefer ArrayList array, flexibility overhead, ArrayList measurably less efficient array. Both arrays containers guarantee can’t abuse them. Whether you’re using array container, you’ll get RuntimeException exceed bounds, indicating programmer error. Before generics, container classes dealt objects specific type. That is, treated type Object, root class classes Java. Arrays superior pre-generic containers create array hold specific type. This means get compile-time type checking prevent inserting wrong type mistaking type you’re extracting. Of course, Java prevent sending inappropriate message object either compile time run time. So it’s riskier one way other; it’s nicer compiler points you, there’s less likelihood end user get surprised exception. An array hold primitives, whereas pre-generic container could not. With generics, however, containers specify check type objects hold, autoboxing containers act able hold primitives, since conversion automatic. Here’s example compares arrays generic containers: //: arrays/ContainerComparison.java import java.util.*; import static net.mindview.util.Print.*; class BerylliumSphere { private static long counter; private final long id = counter++; public String toString() { return "Sphere " + id; } } public class ContainerComparison { public static void main(String[] args) { BerylliumSphere[] spheres = new BerylliumSphere[10]; for(int = 0; < 5; i++) spheres[i] = new BerylliumSphere(); print(Arrays.toString(spheres)); print(spheres[4]); List<BerylliumSphere> sphereList = new ArrayList<BerylliumSphere>(); for(int = 0; < 5; i++) sphereList.add(new BerylliumSphere()); print(sphereList); print(sphereList.get(4)); int[] integers = { 0, 1, 2, 3, 4, 5 }; print(Arrays.toString(integers)); print(integers[4]); List<Integer> intList = new ArrayList<Integer>( Arrays.asList(0, 1, 2, 3, 4, 5)); intList.add(97); print(intList); print(intList.get(4)); } } /* Output: [Sphere 0, Sphere 1, Sphere 2, Sphere 3, Sphere 4, null, null, null, null, null] Sphere 4 [Sphere 5, Sphere 6, Sphere 7, Sphere 8, Sphere 9] Sphere 9 [0, 1, 2, 3, 4, 5] 4 [0, 1, 2, 3, 4, 5, 97] 4 *///:~ Both ways holding objects type-checked, apparent difference arrays use [ ] accessing elements, List uses methods add( ) get( ). The similarity arrays ArrayList intentional, it’s conceptually easy switch two. But saw Holding Your Objects chapter, containers significantly functionality arrays. With advent autoboxing, containers nearly easy use primitives arrays. The remaining advantage arrays efficiency. However, you’re solving general problem, arrays restrictive, cases use container class. Arrays first-class objects Regardless type array you’re working with, array identifier actually reference true object that’s created heap. This object holds references objects, created either implicitly, part array initialization syntax, explicitly new expression. Part array object (in fact, field method access) read-only length member tells many elements stored array object. The ‘[ ]’ syntax access array object. The following example summarizes various ways array initialized, array references assigned different array objects. It also shows arrays 536 Thinking Java Bruce Eckel objects arrays primitives almost identical use. The difference arrays objects hold references, arrays primitives hold primitive values directly. //: arrays/ArrayOptions.java // Initialization & re-assignment arrays. import java.util.*; import static net.mindview.util.Print.*; public class ArrayOptions { public static void main(String[] args) { // Arrays objects: BerylliumSphere[] a; // Local uninitialized variable BerylliumSphere[] b = new BerylliumSphere[5]; // The references inside array // automatically initialized null: print("b: " + Arrays.toString(b)); BerylliumSphere[] c = new BerylliumSphere[4]; for(int = 0; < c.length; i++) if(c[i] == null) // Can test null reference c[i] = new BerylliumSphere(); // Aggregate initialization: BerylliumSphere[] = { new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere() }; // Dynamic aggregate initialization: = new BerylliumSphere[]{ new BerylliumSphere(), new BerylliumSphere(), }; // (Trailing comma optional cases) print("a.length = " + a.length); print("b.length = " + b.length); print("c.length = " + c.length); print("d.length = " + d.length); = d; print("a.length = " + a.length); // Arrays primitives: int[] e; // Null reference int[] f = new int[5]; // The primitives inside array // automatically initialized zero: print("f: " + Arrays.toString(f)); int[] g = new int[4]; for(int = 0; < g.length; i++) g[i] = i*i; int[] h = { 11, 47, 93 }; // Compile error: variable e initialized: //!print("e.length = " + e.length); print("f.length = " + f.length); print("g.length = " + g.length); print("h.length = " + h.length); e = h; print("e.length = " + e.length); e = new int[]{ 1, 2 }; print("e.length = " + e.length); } } /* Output: b: [null, null, null, null, null] a.length = 2 b.length = 5 c.length = 4 d.length = 3 a.length = 3 Arrays 537 f: [0, 0, 0, 0, 0] f.length = 5 g.length = 4 h.length = 3 e.length = 3 e.length = 2 *///:~ The array uninitialized local variable, compiler prevents anything reference you’ve properly initialized it. The array b initialized point array BerylliumSphere references, actual BerylliumSphere objects ever placed array. However, still ask size array is, since b pointing legitimate object. This brings slight drawback: You can’t find many elements actually array, since length tells many elements placed array; is, size array object, number elements actually holds. However, array object created, references automatically initialized null, see whether particular array slot object checking see whether it’s null. Similarly, array primitives automatically initialized zero numeric types, (char)o char, false boolean. Array c shows creation array object followed assignment BerylliumSphere objects slots array. Array shows "aggregate initialization" syntax causes array object created (implicitly new heap, like array c) initialized BerylliumSphere objects, one statement. The next array initialization thought "dynamic aggregate initialization." The aggregate initialization used must used point d’s definition, second syntax create initialize array object anywhere. For example, suppose hide( ) method takes array BerylliumSphere objects. You could call saying: hide(d); also dynamically create array want pass argument: hide(new BerylliumSphere[]{ new BerylliumSphere(), new BerylliumSphere() }); In many situations syntax provides convenient way write code. The expression: = d; shows take reference that’s attached one array object assign another array object, type object reference. Now pointing array object heap. The second part ArrayOptions.java shows primitive arrays work like object arrays except primitive arrays hold primitive values directly. Exercise 1: (2) Create method takes array BerylliumSphere argument. Call method, creating argument dynamically. Demonstrate ordinary aggregate array initialization doesn’t work case. Discover situations ordinary aggregate array initialization works, dynamic aggregate initialization redundant. 538 Thinking Java Bruce Eckel Returning array Suppose you’re writing method don’t want return one thing, whole bunch things. Languages like C C++ make difficult can’t return array, pointer array. This introduces problems becomes messy control lifetime array, leads memory leaks. In Java, return array. You never worry responsibility array—it around long need it, garbage collector clean you’re done. As example, consider returning array String: //: arrays/IceCream.java // Returning arrays methods. import java.util.*; public class IceCream { private static Random rand = new Random(47); static final String[] FLAVORS = { "Chocolate", "Strawberry", "Vanilla Fudge Swirl", "Mint Chip", "Mocha Almond Fudge", "Rum Raisin", "Praline Cream", "Mud Pie" }; public static String[] flavorSet(int n) { if(n > FLAVORS.length) throw new IllegalArgumentException("Set big"); String[] results = new String[n]; boolean[] picked = new boolean[FLAVORS.length]; for(int = 0; < n; i++) { int t; = rand.nextInt(FLAVORS.length); while(picked[t]); results[i] = FLAVORS[t]; picked[t] = true; } return results; } public static void main(String[] args) { for(int = 0; < 7; i++) System.out.println(Arrays.toString(flavorSet(3))); } } /* Output: [Rum Raisin, Mint Chip, Mocha Almond Fudge] [Chocolate, Strawberry, Mocha Almond Fudge] [Strawberry, Mint Chip, Mocha Almond Fudge] [Rum Raisin, Vanilla Fudge Swirl, Mud Pie] [Vanilla Fudge Swirl, Chocolate, Mocha Almond Fudge] [Praline Cream, Strawberry, Mocha Almond Fudge] [Mocha Almond Fudge, Strawberry, Mint Chip] *///:~ The method flavorSet( ) creates array String called results. The size array n, determined argument pass method. Then proceeds choose flavors randomly array FLAVORS place results, returns. Returning array like returning object—it’s reference. It’s important array created within flavorSet( ), array created anyplace else, matter. The garbage collector takes care cleaning array you’re done it, array persist long need it. Arrays 539 As aside, notice flavorSet( ) chooses flavors randomly, ensures particular choice hasn’t already selected. This performed loop keeps making random choices finds one already picked array. (Of course, String comparison also could performed see random choice already results array.) If it’s successful, adds entry finds next one (i gets incremented). You see output flavorSet( ) chooses flavors random order time. Exercise 2: (1) Write method takes int argument returns array size, filled BerylliumSphere objects. Multidimensional arrays You easily create multidimensional arrays. For multidimensional array primitives, delimit vector array using curly braces: //: arrays/MultidimensionalPrimitiveArray.java // Creating multidimensional arrays. import java.util.*; public class MultidimensionalPrimitiveArray { public static void main(String[] args) { int[][] = { { 1, 2, 3, }, { 4, 5, 6, }, }; System.out.println(Arrays.deepToString(a)); } } /* Output: [[1, 2, 3], [4, 5, 6]] *///:~ Each nested set curly braces moves next level array. This example uses Java SE5 Arrays.deepToString( ) method, turns multidimensional arrays Strings, see output. You also allocate array using new. Here’s three-dimensional array allocated new expression: //: arrays/ThreeDWithNew.java import java.util.*; public class ThreeDWithNew { public static void main(String[] args) { // 3-D array fixed length: int[][][] = new int[2][2][4]; System.out.println(Arrays.deepToString(a)); } } /* Output: [[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0]]] *///:~ 540 Thinking Java Bruce Eckel You see primitive array values automatically initialized don’t give explicit initialization value. Arrays objects initialized null. Each vector arrays make matrix length (this called ragged array): //: arrays/RaggedArray.java import java.util.*; public class RaggedArray { public static void main(String[] args) { Random rand = new Random(47); // 3-D array varied-length vectors: int[][][] = new int[rand.nextInt(7)][][]; for(int = 0; < a.length; i++) { a[i] = new int[rand.nextInt(5)][]; for(int j = 0; j < a[i].length; j++) a[i][j] = new int[rand.nextInt(5)]; } System.out.println(Arrays.deepToString(a)); } } /* Output: [[], [[0], [0], [0, 0, 0, 0]], [[], [0, 0], [0, 0]], [[0, 0, 0], [0], [0, 0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0], []], [[0], [], [0]]] *///:~ The first new creates array random-length first element rest undetermined. The second new inside loop fills elements leaves third index undetermined hit third new. You deal arrays non-primitive objects similar fashion. Here, see collect many new expressions curly braces: //: arrays/MultidimensionalObjectArrays.java import java.util.*; public class MultidimensionalObjectArrays { public static void main(String[] args) { BerylliumSphere[][] spheres = { { new BerylliumSphere(), new BerylliumSphere() }, { new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere() }, { new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere(), new BerylliumSphere() }, }; System.out.println(Arrays.deepToString(spheres)); } } /* Output: [[Sphere 0, Sphere 1], [Sphere 2, Sphere 3, Sphere 4, Sphere 5], [Sphere 6, Sphere 7, Sphere 8, Sphere 9, Sphere 10, Sphere 11, Sphere 12, Sphere 13]] *///:~ You see spheres another ragged array, length list objects different. Arrays 541 Autoboxing also works array initializers: //: arrays/AutoboxingArrays.java import java.util.*; public class AutoboxingArrays { public static void main(String[] args) { Integer[][] = { // Autoboxing: { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, { 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 }, { 51, 52, 53, 54, 55, 56, 57, 58, 59, 60 }, { 71, 72, 73, 74, 75, 76, 77, 78, 79, 80 }, }; System.out.println(Arrays.deepToString(a)); } } /* Output: [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30], [51, 52, 53, 54, 55, 56, 57, 58, 59, 60], [71, 72, 73, 74, 75, 76, 77, 78, 79, 80]] *///:~ Here’s array non-primitive objects built piece-by-piece: //: arrays/AssemblingMultidimensionalArrays.java // Creating multidimensional arrays. import java.util.*; public class AssemblingMultidimensionalArrays { public static void main(String[] args) { Integer[][] a; = new Integer[3][]; for(int = 0; < a.length; i++) { a[i] = new Integer[3]; for(int j = 0; j < a[i].length; j++) a[i][j] = * j; // Autoboxing } System.out.println(Arrays.deepToString(a)); } } /* Output: [[0, 0, 0], [0, 1, 2], [0, 2, 4]] *///:~ The i*j put interesting value Integer. The Arrays.deepToString( ) method works primitive arrays object arrays: //: arrays/MultiDimWrapperArray.java // Multidimensional arrays "wrapper" objects. import java.util.*; public class MultiDimWrapperArray { public static void main(String[] args) { Integer[][] a1 = { // Autoboxing { 1, 2, 3, }, { 4, 5, 6, }, }; Double[][][] a2 = { // Autoboxing { { 1.1, 2.2 }, { 3.3, 4.4 } }, { { 5.5, 6.6 }, { 7.7, 8.8 } }, { { 9.9, 1.2 }, { 2.3, 3.4 } }, }; 542 Thinking Java Bruce Eckel String[][] a3 = { { "The", "Quick", "Sly", "Fox" }, { "Jumped", "Over" }, { "The", "Lazy", "Brown", "Dog", "and", "friend" }, }; System.out.println("a1: " + Arrays.deepToString(a1)); System.out.println("a2: " + Arrays.deepToString(a2)); System.out.println("a3: " + Arrays.deepToString(a3)); } } /* Output: a1: [[1, 2, 3], [4, 5, 6]] a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]] a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, and, friend]] *///:~ Again, Integer Double arrays, Java SE5 autoboxing creates wrapper objects you. Exercise 3: (4) Write method creates initializes twodimensional array double. The size array determined arguments method, initialization values range determined beginning ending values also arguments method. Create second method print array generated first method. In main( ) test methods creating printing several different sizes arrays. Exercise 4: (2) Repeat previous exercise three-dimensional array. Exercise 5: (1) Demonstrate multidimensional arrays nonprimitive types automatically initialized null. Exercise 6: (1) Write method takes two int arguments, indicating two sizes 2-D array. The method create fill 2-D array BerylliumSphere according size arguments. Exercise 7: (1) Repeat previous exercise 3-D array. Arrays generics In general, arrays generics mix well. You cannot instantiate arrays parameterized types: Peel<Banana>[] peels = new Peel<Banana> [10]; // Illegal Erasure removes parameter type information, arrays must know exact type hold, order enforce type safety. However, parameterize type array itself: //: arrays/ParameterizedArrayType.java class ClassParameter<T> { public T[] f(T[] arg) { return arg; } Arrays 543 } class MethodParameter { public static <T> T[] f(T[] arg) { return arg; } } public class ParameterizedArrayType { public static void main(String[] args) { Integer[] ints = { 1, 2, 3, 4, 5 }; Double[] doubles = { 1.1, 2.2, 3.3, 4.4, 5.5 }; Integer[] ints2 = new ClassParameter<Integer>().f(ints); Double[] doubles2 = new ClassParameter<Double>().f(doubles); ints2 = MethodParameter.f(ints); doubles2 = MethodParameter.f(doubles); } } ///:~ Note convenience using parameterized method instead parameterized class: You don’t instantiate class parameter different type need apply to, make static. Of course, can’t always choose use parameterized method instead parameterized class, preferable. As turns out, it’s precisely correct say cannot create arrays generic types. True, compiler won’t let instantiate array generic type. However, let create reference array. For example: List<String>[] ls; This passes compiler without complaint. And although cannot create actual array object holds generics, create array non-generified type cast it: //: arrays/ArrayOfGenerics.java // It possible create arrays generics. import java.util.*; public class ArrayOfGenerics { @SuppressWarnings("unchecked") public static void main(String[] args) { List<String>[] ls; List[] la = new List[10]; ls = (List<String>[])la; // "Unchecked" warning ls[0] = new ArrayList<String>(); // Compile-time checking produces error: //! ls[1] = new ArrayList<Integer>(); // The problem: List<String> subtype Object Object[] objects = ls; // So assignment OK // Compiles runs without complaint: objects[1] = new ArrayList<Integer>(); } 544 // However, needs straightforward // possible create array generics, albeit // "unchecked" warning: List<BerylliumSphere>[] spheres = (List<BerylliumSphere>[])new List[10]; for(int = 0; < spheres.length; i++) spheres[i] = new ArrayList<BerylliumSphere>(); Thinking Java Bruce Eckel } ///:~ Once reference List<String>[], see get compile-time checking. The problem arrays covariant, List<String>[] also Object[], use assign ArrayList<Integer> array, error either compile time run time. If know you’re going upcast needs relatively simple, however, possible create array generics, provide basic compile-time type checking. However, generic container virtually always better choice array generics. In general you’ll find generics effective boundaries class method. In interiors, erasure usually makes generics unusable. So cannot, example, create array generic type: //: arrays/ArrayOfGenericType.java // Arrays generic types won’t compile. public class ArrayOfGenericType<T> { T[] array; // OK @SuppressWarnings("unchecked") public ArrayOfGenericType(int size) { //! array = new T[size]; // Illegal array = (T[])new Object[size]; // "unchecked" Warning } // Illegal: //! public <U> U[] makeArray() { return new U[10]; } } ///:~ Erasure gets way again—this example attempts create arrays types erased, thus unknown types. Notice create array Object, cast it, without @SuppressWarnings annotation get "unchecked" warning compile time array doesn’t really hold dynamically check type T. That is, I create String[], Java enforce compile time run time I place String objects array. However, I create Object[], I put anything array except primitive types. Exercise 8: (1) Demonstrate assertions previous paragraph. Exercise 9: (3) Create classes necessary Peel<Banana> example show compiler doesn’t accept it. Fix problem using ArrayList. Exercise 10: (2) Modify ArrayOfGenerics .Java use containers instead arrays. Show eliminate compile-time warnings. Arrays 545 Creating test data When experimenting arrays, programs general, it’s helpful able easily generate arrays filled test data. The tools section fill array values objects. Arrays.fill() The Java standard library Arrays class rather trivial fill( ) method: It duplicates single value location, case objects, copies reference location. Here’s example: //: arrays/FillingArrays.java // Using Arrays.fill() import java.util.*; import static net.mindview.util.Print.*; public class FillingArrays { public static void main(String[] args) { int size = 6; boolean[] a1 = new boolean[size]; byte[] a2 = new byte[size]; char[] a3 = new char[size]; short[] a4 = new short[size]; int[] a5 = new int[size]; long[] a6 = new long[size]; float[] a7 = new float[size]; double[] a8 = new double[size]; String[] a9 = new String[size]; Arrays.fill(a1, true); print("a1 = " + Arrays.toString(a1)); Arrays.fill(a2, (byte)11); print("a2 = " + Arrays.toString(a2)); Arrays.fill(a3, ‘x’); print("a3 = " + Arrays.toString(a3)); Arrays.fill(a4, (short)17); print("a4 = " + Arrays.toString(a4)); Arrays.fill(a5, 19); print("a5 = " + Arrays.toString(a5)); Arrays.fill(a6, 23); print("a6 = " + Arrays.toString(a6)); Arrays.fill(a7, 29); print("a7 = " + Arrays.toString(a7)); Arrays.fill(a8, 47); print("a8 = " + Arrays.toString(a8)); Arrays.fill(a9, "Hello"); print("a9 = " + Arrays.toString(a9)); // Manipulating ranges: Arrays.fill(a9, 3, 5, "World"); print("a9 = " + Arrays.toString(a9)); } } /* Output: a1 = [true, true, true, true, true, true] a2 = [11, 11, 11, 11, 11, 11] a3 = [x, x, x, x, x, x] a4 = [17, 17, 17, 17, 17, 17] a5 = [19, 19, 19, 19, 19, 19] a6 = [23, 23, 23, 23, 23, 23] a7 = [29.0, 29.0, 29.0, 29.0, 29.0, 29.0] 546 Thinking Java Bruce Eckel a8 = [47.0, 47.0, 47.0, 47.0, 47.0, 47.0] a9 = [Hello, Hello, Hello, Hello, Hello, Hello] a9 = [Hello, Hello, Hello, World, World, Hello] *///:~ You either fill entire array or, last two statements show, fill range elements. But since call Arrays.fill( ) single data value, results especially useful. Data Generators To create interesting arrays data, flexible fashion, we’ll use Generator concept introduced Generics chapter. If tool uses Generator, produce kind data via choice Generator (this example Strategy design pattern—each different Generator represents different strategy 1 ). This section supply Generators, you’ve seen before, easily define own. First, here’s basic set counting generators primitive wrapper types, Strings. The generator classes nested within CountingGenerator class may use name object types generating; example, generator creates Integer objects would created expression new CountingGenerator.Integer( ): //: net/mindview/util/CountingGenerator.java // Simple generator implementations. package net.mindview.util; public class CountingGenerator { public static class Boolean implements Generator<java.lang.Boolean> { private boolean value = false; public java.lang.Boolean next() { value = !value; // Just flips back forth return value; } } public static class Byte implements Generator<java.lang.Byte> { private byte value = 0; public java.lang.Byte next() { return value++; } } static char[] chars = ("abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ").toCharArray(); public static class Character implements Generator<java.lang.Character> { int index = -1; public java.lang.Character next() { index = (index + 1) % chars.length; return chars[index]; } } public static class String implements Generator<java.lang.String> { private int length = 7; Although place things bit fuzzy. You could also make argument Generator represents Command pattern. However, I think task fill array, Generator fulfills part task, it’s strategy-like command-like. 1 Arrays 547 Generator<java.lang.Character> cg = new Character(); public String() {} public String(int length) { this.length = length; } public java.lang.String next() { char[] buf = new char[length]; for(int = 0; < length; i++) buf[i] = cg.next(); return new java.lang.String(buf); } } public static class Short implements Generator<java.lang.Short> { private short value = 0; public java.lang.Short next() { return value++; } } public static class Integer implements Generator<java.lang.Integer> { private int value = 0; public java.lang.Integer next() { return value++; } } public static class Long implements Generator<java.lang.Long> { private long value = 0; public java.lang.Long next() { return value++; } } public static class Float implements Generator<java.lang.Float> { private float value = 0; public java.lang.Float next() { float result = value; value += 1.0; return result; } } public static class Double implements Generator<java.lang.Double> { private double value = 0.0; public java.lang.Double next() { double result = value; value += 1.0; return result; } } } ///:~ Each class implements meaning "counting." In case CountingGenerator.Character, upper lowercase letters repeated over. The CountingGenerator.String class uses CountingGenerator.Character fill array characters, turned String. The size array determined constructor argument. Notice CountingGenerator.String uses basic Generator <java.lang. Character > instead specific reference CountingGenerator.Character. Later, generator replaced produce RandomGenerator.String RandomGenerator.java. Here’s test tool uses reflection nested Generator idiom, used test set Generators follow form: //: arrays/GeneratorsTest.java import net.mindview.util.*; public class GeneratorsTest { public static int size = 10; 548 Thinking Java Bruce Eckel public static void test(Class<?> surroundingClass) { for(Class<?> type : surroundingClass.getClasses()) { System.out.print(type.getSimpleName() + ": "); try { Generator<?> g = (Generator<?>)type.newInstance(); for(int = 0; < size; i++) System.out.printf(g.next() + " "); System.out.println(); } catch(Exception e) { throw new RuntimeException(e); } } } public static void main(String[] args) { test(CountingGenerator.class); } } /* Output: Double: 0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 Float: 0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 Long: 0 1 2 3 4 5 6 7 8 9 Integer: 0 1 2 3 4 5 6 7 8 9 Short: 0 1 2 3 4 5 6 7 8 9 String: abcdefg hijklmn opqrstu vwxyzAB CDEFGHI JKLMNOP QRSTUVW XYZabcd efghijk lmnopqr Character: b c e f g h j Byte: 0 1 2 3 4 5 6 7 8 9 Boolean: true false true false true false true false true false *///:~ This assumes class test contains set nested Generator objects, default constructor (one without arguments). The reflection method getClasses( ) produces nested classes. The test( ) method creates instance generators, prints result produced calling next( ) ten times. Here set Generators use random number generator. Because Random constructor initialized constant value, output repeatable time run program using one Generators: //: net/mindview/util/RandomGenerator.java // Generators produce random values. package net.mindview.util; import java.util.*; public class RandomGenerator { private static Random r = new Random(47); public static class Boolean implements Generator<java.lang.Boolean> { public java.lang.Boolean next() { return r.nextBoolean(); } } public static class Byte implements Generator<java.lang.Byte> { public java.lang.Byte next() { return (byte)r.nextInt(); } } public static class Character implements Generator<java.lang.Character> { public java.lang.Character next() { return CountingGenerator.chars[ r.nextInt(CountingGenerator.chars.length)]; Arrays 549 } } public static class String extends CountingGenerator.String { // Plug random Character generator: { cg = new Character(); } // Instance initializer public String() {} public String(int length) { super(length); } } public static class Short implements Generator<java.lang.Short> { public java.lang.Short next() { return (short)r.nextInt(); } } public static class Integer implements Generator<java.lang.Integer> { private int mod = 10000; public Integer() {} public Integer(int modulo) { mod = modulo; } public java.lang.Integer next() { return r.nextInt(mod); } } public static class Long implements Generator<java.lang.Long> { private int mod = 10000; public Long() {} public Long(int modulo) { mod = modulo; } public java.lang.Long next() { return new java.lang.Long(r.nextInt(mod)); } } public static class Float implements Generator<java.lang.Float> { public java.lang.Float next() { // Trim first two decimal places: int trimmed = Math.round(r.nextFloat() * 100); return ((float)trimmed) / 100; } } public static class Double implements Generator<java.lang.Double> { public java.lang.Double next() { long trimmed = Math.round(r.nextDouble() * 100); return ((double)trimmed) / 100; } } } ///:~ You see RandomGenerator.String inherits CountingGenerator.String simply plugs new Character generator. To generate numbers aren’t large, RandomGenerator.Integer defaults modulus 10,000, overloaded constructor allows choose smaller value. The approach used RandomGenerator.Long. For Float Double Generators, values decimal point trimmed. We reuse GeneratorsTest test RandomGenerator: //: arrays/RandomGeneratorsTest.java import net.mindview.util.*; 550 Thinking Java Bruce Eckel public class RandomGeneratorsTest { public static void main(String[] args) { GeneratorsTest.test(RandomGenerator.class); } } /* Output: Double: 0.73 0.53 0.16 0.19 0.52 0.27 0.26 0.05 0.8 0.76 Float: 0.53 0.16 0.53 0.4 0.49 0.25 0.8 0.11 0.02 0.8 Long: 7674 8804 8950 7826 4322 896 8033 2984 2344 5810 Integer: 8303 3141 7138 6012 9966 8689 7185 6992 5746 3976 Short: 3358 20592 284 26791 12834 -8092 13656 29324 -1423 5327 String: bkInaMe sbtWHkj UrUkZPg wsqPzDy CyRFJQA HxxHvHq XumcXZJ oogoYWM NvqeuTp nXsgqia Character: x x E A J J z M Byte: -60 -17 55 -14 -5 115 39 -37 79 115 Boolean: false true false false true true true true true true *///:~ You change number values produced changing GeneratorsTest.size value, public. Creating arrays Generators In order take Generator produce array, need two conversion tools. The first one uses Generator produce array Object subtypes. To cope problem primitives, second tool takes array primitive wrapper types produces associated array primitives. The first tool two options, represented overloaded static method, array( ). The first version method takes existing array fills using Generator, second version takes Class object, Generator, desired number elements, creates new array, filling using Generator. Notice tool produces arrays Object subtypes cannot create primitive arrays: //: net/mindview/util/Generated.java package net.mindview.util; import java.util.*; public class Generated { // Fill existing array: public static <T> T[] array(T[] a, Generator<T> gen) { return new CollectionData<T>(gen, a.length).toArray(a); } // Create new array: @SuppressWarnings("unchecked") public static <T> T[] array(Class<T> type, Generator<T> gen, int size) { T[] = (T[])java.lang.reflect.Array.newInstance(type, size); return new CollectionData<T>(gen, size).toArray(a); } } ///:~ The CollectionData class defined Containers Depth chapter. It creates Collection object filled elements produced Generator gen. The number elements determined second constructor argument. All Collection subtypes toArray( ) method fill argument array elements Collection. Arrays 551 The second method uses reflection dynamically create new array appropriate type size. This filled using technique first method. We test Generated using one CountingGenerator classes defined previous section: //: arrays/TestGenerated.java import java.util.*; import net.mindview.util.*; public class TestGenerated { public static void main(String[] args) { Integer[] = { 9, 8, 7, 6 }; System.out.println(Arrays.toString(a)); = Generated.array(a,new CountingGenerator.Integer()); System.out.println(Arrays.toString(a)); Integer[] b = Generated.array(Integer.class, new CountingGenerator.Integer(), 15); System.out.println(Arrays.toString(b)); } } /* Output: [9, 8, 7, 6] [0, 1, 2, 3] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] *///:~ Even though array initialized, values overwritten passing Generated.array( ), replaces values (but leaves original array place). The initialization b shows create filled array scratch. Generics don’t work primitives, want use generators fill primitive arrays. To solve problem, create converter takes array wrapper objects converts array associated primitive types. Without tool, would create special case generators primitives. //: net/mindview/util/ConvertTo.java package net.mindview.util; public class ConvertTo { public static boolean[] primitive(Boolean[] in) { boolean[] result = new boolean[in.length]; for(int = 0; < in.length; i++) result[i] = in[i]; // Autounboxing return result; } public static char[] primitive(Character[] in) { char[] result = new char[in.length]; for(int = 0; < in.length; i++) result[i] = in[i]; return result; } public static byte[] primitive(Byte[] in) { byte[] result = new byte[in.length]; for(int = 0; < in.length; i++) result[i] = in[i]; return result; } public static short[] primitive(Short[] in) { short[] result = new short[in.length]; for(int = 0; < in.length; i++) result[i] = in[i]; 552 Thinking Java Bruce Eckel return result; } public static int[] primitive(Integer[] in) { int[] result = new int[in.length]; for(int = 0; < in.length; i++) result[i] = in[i]; return result; } public static long[] primitive(Long[] in) { long[] result = new long[in.length]; for(int = 0; < in.length; i++) result[i] = in[i]; return result; } public static float[] primitive(Float[] in) { float[] result = new float[in.length]; for(int = 0; < in.length; i++) result[i] = in[i]; return result; } public static double[] primitive(Double[] in) { double[] result = new double[in.length]; for(int = 0; < in.length; i++) result[i] = in[i]; return result; } } ///:~ Each version primitive( ) creates appropriate primitive array correct length, copies elements array wrapper types. Notice autounboxing takes place expression: result[i] = [1]; Here’s example shows use ConvertTo versions Generated.array( ): //: arrays/PrimitiveConversionDemonstration.java import java.util.*; import net.mindview.util.*; public class PrimitiveConversionDemonstration { public static void main(String[] args) { Integer[] = Generated.array(Integer.class, new CountingGenerator.Integer(), 15); int[] b = ConvertTo.primitive(a); System.out.println(Arrays.toString(b)); boolean[] c = ConvertTo.primitive( Generated.array(Boolean.class, new CountingGenerator.Boolean(), 7)); System.out.println(Arrays.toString(c)); } } /* Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] [true, false, true, false, true, false, true] *///:~ Finally, here’s program tests array generation tools using RandomGenerator classes: //: arrays/TestArrayGeneration.java Arrays 553 // Test tools use generators fill arrays. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class TestArrayGeneration { public static void main(String[] args) { int size = 6; boolean[] a1 = ConvertTo.primitive(Generated.array( Boolean.class, new RandomGenerator.Boolean(), size)); print("a1 = " + Arrays.toString(a1)); byte[] a2 = ConvertTo.primitive(Generated.array( Byte.class, new RandomGenerator.Byte(), size)); print("a2 = " + Arrays.toString(a2)); char[] a3 = ConvertTo.primitive(Generated.array( Character.class, new RandomGenerator.Character(), size)); print("a3 = " + Arrays.toString(a3)); short[] a4 = ConvertTo.primitive(Generated.array( Short.class, new RandomGenerator.Short(), size)); print("a4 = " + Arrays.toString(a4)); int[] a5 = ConvertTo.primitive(Generated.array( Integer.class, new RandomGenerator.Integer(), size)); print("a5 = " + Arrays.toString(a5)); long[] a6 = ConvertTo.primitive(Generated.array( Long.class, new RandomGenerator.Long(), size)); print("a6 = " + Arrays.toString(a6)); float[] a7 = ConvertTo.primitive(Generated.array( Float.class, new RandomGenerator.Float(), size)); print("a7 = " + Arrays.toString(a7)); double[] a8 = ConvertTo.primitive(Generated.array( Double.class, new RandomGenerator.Double(), size)); print("a8 = " + Arrays.toString(a8)); } } /* Output: a1 = [true, false, true, false, false, true] a2 = [104, -79, -76, 126, 33, -64] a3 = [Z, n, T, c, Q, r] a4 = [-13408, 22612, 15401, 15161, -28466, -12603] a5 = [7704, 7383, 7706, 575, 8410, 6342] a6 = [7674, 8804, 8950, 7826, 4322, 896] a7 = [0.01, 0.2, 0.4, 0.79, 0.27, 0.45] a8 = [0.16, 0.87, 0.7, 0.66, 0.87, 0.59] *///:~ This also ensures version ConvertTo.primitive( ) works correctly. Exercise 11: (2) Show autoboxing doesn’t work arrays. Exercise 12: (1) Create initialized array double using CountingGenerator. Print results. Exercise 13: (2) Fill String using CountingGenerator.Character. Exercise 14: (6) Create array primitive type, fill array using CountingGenerator. Print array. Exercise 15: (2) Modify ContainerComparison.java creating Generator BerylliumSphere, change main( ) use Generator Generated.array(). 554 Thinking Java Bruce Eckel Exercise 16: (3) Starting CountingGenerator.java, create SkipGenerator class produces new values incrementing according constructor argument. Modify TestArrayGeneration.java show new class works correctly. Exercise 17: (5) Create test Generator BigDecimal, ensure works Generated methods. Arrays utilities In java.util, you’ll find Arrays class, holds set static utility methods arrays. There six basic methods: equals( ), compare two arrays equality (and deepEquals( ) multidimensional arrays); fill( ), you’ve seen earlier chapter; sort( ), sort array; binarySearch( ), find element sorted array; toString( ), produce String representation array; hashCode( ), produce hash value array (you’ll learn means Containers Depth chapter). All methods overloaded primitive types Objects. In addition, Arrays.asList( ) takes sequence array turns List container—this method covered Holding Your Objects chapter. Before discussing Arrays methods, there’s one useful method isn’t part Arrays. Copying array The Java standard library provides static method, System.arraycopy( ), copy arrays far quickly use loop perform copy hand. System.arraycopyC ) overloaded handle types. Here’s example manipulates arrays int: //: arrays/CopyingArrays.java // Using System.arraycopy() import java.util.*; import static net.mindview.util.Print.*; public class CopyingArrays { public static void main(String[] args) { int[] = new int[7]; int[] j = new int[10]; Arrays.fill(i, 47); Arrays.fill(j, 99); print("i = " + Arrays.toString(i)); print("j = " + Arrays.toString(j)); System.arraycopy(i, 0, j, 0, i.length); print("j = " + Arrays.toString(j)); int[] k = new int[5]; Arrays.fill(k, 103); System.arraycopy(i, 0, k, 0, k.length); print("k = " + Arrays.toString(k)); Arrays.fill(k, 103); System.arraycopy(k, 0, i, 0, k.length); print("i = " + Arrays.toString(i)); // Objects: Integer[] u = new Integer[10]; Integer[] v = new Integer[5]; Arrays.fill(u, new Integer(47)); Arrays 555 Arrays.fill(v, new Integer(99)); print("u = " + Arrays.toString(u)); print("v = " + Arrays.toString(v)); System.arraycopy(v, 0, u, u.length/2, v.length); print("u = " + Arrays.toString(u)); } } /* Output: = [47, 47, 47, 47, 47, j = [99, 99, 99, 99, 99, j = [47, 47, 47, 47, 47, k = [47, 47, 47, 47, 47] = [103, 103, 103, 103, u = [47, 47, 47, 47, 47, v = [99, 99, 99, 99, 99] u = [47, 47, 47, 47, 47, *///:~ 47, 47] 99, 99, 99, 99, 99] 47, 47, 99, 99, 99] 103, 47, 47] 47, 47, 47, 47, 47] 99, 99, 99, 99, 99] The arguments arraycopy( ) source array, offset source array whence start copying, destination array, offset destination array copying begins, number elements copy. Naturally, violation array boundaries cause exception. The example shows primitive arrays object arrays copied. However, copy arrays objects, references get copied—there’s duplication objects themselves. This called shallow copy (see online supplements book details). System.arraycopy( ) perform autoboxing autounboxing—the two arrays must exactly type. Exercise 18: (3) Create fill array BerylliumSphere. Copy array new array show it’s shallow copy. Comparing arrays Arrays provides equals( ) method compare entire arrays equality, overloaded primitives Object. To equal, arrays must number elements, element must equivalent corresponding element array, using equals( ) element. (For primitives, primitive’s wrapper class equals( ) used; example, Integer.equals( ) int.) For example: //: arrays/ComparingArrays.java // Using Arrays.equals() import java.util.*; import static net.mindview.util.Print.*; public class ComparingArrays { public static void main(String[] args) { int[] a1 = new int[10]; int[] a2 = new int[10]; Arrays.fill(a1, 47); Arrays.fill(a2, 47); print(Arrays.equals(a1, a2)); a2[3] = 11; print(Arrays.equals(a1, a2)); String[] s1 = new String[4]; Arrays.fill(s1, "Hi"); 556 Thinking Java Bruce Eckel String[] s2 = { new String("Hi"), new String("Hi"), new String("Hi"), new String("Hi") }; print(Arrays.equals(s1, s2)); } } /* Output: true false true *///:~ Originally, a1 a2 exactly equal, output "true," one elements changed, makes result "false." In last case, elements s1 point object, s2 five unique objects. However, array equality based contents (via Object.equals( )), result "true." Exercise 19: (2) Create class int field that’s initialized constructor argument. Create two arrays objects, using identical initialization values array, show Arrays.equals( ) says unequal. Add equals( ) method class fix problem. Exercise 20: (4) Demonstrate deepEquals( ) multidimensional arrays. Array element comparisons Sorting must perform comparisons based actual type object. Of course, one approach write different sorting method every different type, code reusable new types. A primary goal programming design "separate things change things stay same," here, code stays general sort algorithm, thing changes one use next way objects compared. So instead placing comparison code many different sort routines, Strategy design pattern used. 2 With Strategy, part code varies encapsulated inside separate class (the Strategy object). You hand Strategy object code that’s always same, uses Strategy fulfill algorithm. That way, make different objects express different ways comparison feed sorting code. Java two ways provide comparison functionality. The first "natural" comparison method imparted class implementing java.lang.Comparable interface. This simple interface single method, compareTo( ). This method takes another object type argument produces negative value current object less argument, zero argument equal, positive value current object greater argument. Here’s class implements Comparable demonstrates comparability using Java standard library method Arrays.sort( ): //: arrays/CompType.java // Implementing Comparable class. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; 2 Design Patterns, Erich Gamma et al. (Addison-Wesley, 1995). See Thinking Patterns (with Java) www.MindView.net. Arrays 557 public class CompType implements Comparable<CompType> { int i; int j; private static int count = 1; public CompType(int n1, int n2) { = n1; j = n2; } public String toString() { String result = "[i = " + + ", j = " + j + "]"; if(count++ % 3 == 0) result += "\n"; return result; } public int compareTo(CompType rv) { return (i < rv.i ? -1 : (i == rv.i ? 0 : 1)); } private static Random r = new Random(47); public static Generator<CompType> generator() { return new Generator<CompType>() { public CompType next() { return new CompType(r.nextInt(100),r.nextInt(100)); } }; } public static void main(String[] args) { CompType[] = Generated.array(new CompType[12], generator()); print("before sorting:"); print(Arrays.toString(a)); Arrays.sort(a); print("after sorting:"); print(Arrays.toString(a)); } } /* Output: sorting: [[i = 58, j = 55], [i = 93, j = 61], [i = 61, j = 29] , [i = 68, j = 0], [i = 22, j = 7], [i = 88, j = 28] , [i = 51, j = 89], [i = 9, j = 78], [i = 98, j = 61] , [i = 20, j = 58], [i = 16, j = 40], [i = 11, j = 22] ] sorting: [[i = 9, j = 78], [i = 11, j = 22], [i = 16, j = 40] , [i = 20, j = 58], [i = 22, j = 7], [i = 51, j = 89] , [i = 58, j = 55], [i = 61, j = 29], [i = 68, j = 0] , [i = 88, j = 28], [i = 93, j = 61], [i = 98, j = 61] ] *///:~ When define comparison method, responsible deciding means compare one objects another. Here, values used comparison, j values ignored. The generator( ) method produces object implements Generator interface creating anonymous inner class. This builds CompType objects initializing random values. In main( ), generator used fill array CompType, sorted. If Comparable hadn’t implemented, you’d get ClassCastException run time tried call sort( ). This sort( ) casts argument Comparable. 558 Thinking Java Bruce Eckel Now suppose someone hands class doesn’t implement Comparable, hands class implement Comparable, decide don’t like way works would rather different comparison method type. To solve problem, create separate class implements interface called Comparator (briefly introduced Holding Your Objects chapter). This example Strategy design pattern. It two methods, compare( ) equals( ). However, don’t implement equals( ) except special performance needs, anytime create class, implicitly inherited Object, equals( ). So use default Object equals( ) satisfy contract imposed interface. The Collections class (which we’ll look next chapter) contains method reverseOrder( ) produces Comparator reverse natural sorting order. This applied CompType: //: arrays/Reverse.java // The Collections.reverseOrder() Comparator import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class Reverse { public static void main(String[] args) { CompType[] = Generated.array( new CompType[12], CompType.generator()); print("before sorting:"); print(Arrays.toString(a)); Arrays.sort(a, Collections.reverseOrder()); print("after sorting:"); print(Arrays.toString(a)); } } /* Output: sorting: [[i = 58, j = 55], [i = 93, j = 61], [i = 61, j = 29] , [i = 68, j = 0], [i = 22, j = 7], [i = 88, j = 28] , [i = 51, j = 89], [i = 9, j = 78], [i = 98, j = 61] , [i = 20, j = 58], [i = 16, j = 40], [i = 11, j = 22] ] sorting: [[i = 98, j = 61], [i = 93, j = 61], [i = 88, j = 28] , [i = 68, j = 0], [i = 61, j = 29], [i = 58, j = 55] , [i = 51, j = 89], [i = 22, j = 7], [i = 20, j = 58] , [i = 16, j = 40], [i = 11, j = 22], [i = 9, j = 78] ] *///:~ You also write Comparator. This one compares CompType objects based j values rather values: //: arrays/ComparatorTest.java // Implementing Comparator class. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; class CompTypeComparator implements Comparator<CompType> { public int compare(CompType o1, CompType o2) { return (o1.j < o2.j ? -1 : (o1.j == o2.j ? 0 : 1)); } } public class ComparatorTest { Arrays 559 public static void main(String[] args) { CompType[] = Generated.array( new CompType[12], CompType.generator()); print("before sorting:"); print(Arrays.toString(a)); Arrays.sort(a, new CompTypeComparator()); print("after sorting:"); print(Arrays.toString(a)); } } /* Output: sorting: [[i = 58, j = 55], [i = 93, j = 61], [i = 61, j = 29] , [i = 68, j = 0], [i = 22, j = 7], [i = 88, j = 28] , [i = 51, j = 89], [i = 9, j = 78], [i = 98, j = 61] , [i = 20, j = 58], [i = 16, j = 40], [i = 11, j = 22] ] sorting: [[i = 68, j = 0], [i = 22, j = 7], [i = 11, j = 22] , [i = 88, j = 28], [i = 61, j = 29], [i = 16, j = 40] , [i = 58, j = 55], [i = 20, j = 58], [i = 93, j = 61] , [i = 98, j = 61], [i = 9, j = 78], [i = 51, j = 89] ] *///:~ Exercise 21: (3) Try sort array objects Exercise 18. Implement Comparable fix problem. Now create Comparator sort objects reverse order. Sorting array With built-in sorting methods, sort array primitives, array objects either implements Comparable associated Comparator. 3 Here’s example generates random String objects sorts them: //: arrays/StringSorting.java // Sorting array Strings. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class StringSorting { public static void main(String[] args) { String[] sa = Generated.array(new String[20], new RandomGenerator.String(5)); print("Before sort: " + Arrays.toString(sa)); Arrays.sort(sa); print("After sort: " + Arrays.toString(sa)); Arrays.sort(sa, Collections.reverseOrder()); print("Reverse sort: " + Arrays.toString(sa)); Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); print("Case-insensitive sort: " + Arrays.toString(sa)); } } /* Output: Before sort: [YNzbr, nyGcF, OWZnT, cQrGs, eGZMm, JMRoE, suEcU, OneOE, dLsmw, HLGEa, hKcxr, EqUCB, bkIna, Mesbt, WHkjU, rUkZP, gwsqP, zDyCy, RFJQA, HxxHv] 3 560 Surprisingly, support Java 1.0 1.1 sorting Strings. Thinking Java Bruce Eckel After sort: [EqUCB, HLGEa, HxxHv, JMRoE, Mesbt, OWZnT, OneOE, RFJQA, WHkjU, YNzbr, bkIna, cQrGs, dLsmw, eGZMm, gwsqP, hKcxr, nyGcF, rUkZP, suEcU, zDyCy] Reverse sort: [zDyCy, suEcU, rUkZP, nyGcF, hKcxr, gwsqP, eGZMm, dLsmw, cQrGs, bkIna, YNzbr, WHkjU, RFJQA, OneOE, OWZnT, Mesbt, JMRoE, HxxHv, HLGEa, EqUCB] Case-insensitive sort: [bkIna, cQrGs, dLsmw, eGZMm, EqUCB, gwsqP, hKcxr, HLGEa, HxxHv, JMRoE, Mesbt, nyGcF, OneOE, OWZnT, RFJQA, rUkZP, suEcU, WHkjU, YNzbr, zDyCy] *///:~ One thing you’ll notice output String sorting algorithm it’s lexicographic, puts words starting uppercase letters first, followed words starting lowercase letters. (Telephone books typically sorted way.) If want group words together regardless case, use String.CASE_INSENSITIVE_ORDER shown last call sort( ) example. The sorting algorithm that’s used Java standard library designed optimal particular type you’re sorting—a Quicksort primitives, stable merge sort objects. You don’t need worry performance unless profiler points sorting process bottleneck. Searching sorted array Once array sorted, perform fast search particular item using Arrays.binarySearch( ). However, try use binarySearchC ) unsorted array results unpredictable. The following example uses RandomGenerator.Integer fill array, uses generator produce search values: //: arrays/ArraySearching.java // Using Arrays.binarySearch(). import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class ArraySearching { public static void main(String[] args) { Generator<Integer> gen = new RandomGenerator.Integer(1000); int[] = ConvertTo.primitive( Generated.array(new Integer[25], gen)); Arrays.sort(a); print("Sorted array: " + Arrays.toString(a)); while(true) { int r = gen.next(); int location = Arrays.binarySearch(a, r); if(location >= 0) { print("Location " + r + " " + location + ", a[" + location + "] = " + a[location]); break; // Out loop } } } } /* Output: Sorted array: [128, 140, 200, 207, 258, 258, 278, 288, 322, 429, 511, 520, 522, 551, 555, 589, 693, 704, 809, 861, 861, 868, 916, 961, 998] Arrays 561 Location 322 8, a[8] = 322 *///:~ In loop, random values generated search items one found. Arrays.binarySearch( ) produces value greater equal zero search item found. Otherwise, produces negative value representing place element inserted maintaining sorted array hand. The value produced -(insertion point) - 1 The insertion point index first element greater key, a.size( ), elements array less specified key. If array contains duplicate elements, guarantee duplicates found. The search algorithm designed support duplicate elements, rather tolerate them. If need sorted list non-duplicated elements, use TreeSet (to maintain sorted order) LinkedHashSet (to maintain insertion order). These classes take care details automatically. Only cases performance bottlenecks replace one classes hand-maintained array. If sort object array using Comparator (primitive arrays allow sorting Comparator), must include Comparator perform binarySearch( ) (using overloaded version binarySearch( )). For example, StringSorting.java program modified perform search: //: arrays/AlphabeticSearch.java // Searching Comparator. import java.util.*; import net.mindview.util.*; public class AlphabeticSearch { public static void main(String[] args) { String[] sa = Generated.array(new String[30], new RandomGenerator.String(5)); Arrays.sort(sa, String.CASE_INSENSITIVE_ORDER); System.out.println(Arrays.toString(sa)); int index = Arrays.binarySearch(sa, sa[10], String.CASE_INSENSITIVE_ORDER); System.out.println("Index: "+ index + "\n"+ sa[index]); } } /* Output: [bkIna, cQrGs, cXZJo, dLsmw, eGZMm, EqUCB, gwsqP, hKcxr, HLGEa, HqXum, HxxHv, JMRoE, JmzMs, Mesbt, MNvqe, nyGcF, ogoYW, OneOE, OWZnT, RFJQA, rUkZP, sgqia, slJrL, suEcU, uTpnX, vpfFv, WHkjU, xxEAJ, YNzbr, zDyCy] Index: 10 HxxHv *///:~ The Comparator must passed overloaded binarySearch( ) third argument. In example, success guaranteed search item selected array itself. Exercise 22: (2) Show results performing binarySearch( ) unsorted array unpredictable. Exercise 23: (2) Create array Integer, fill random int values (using autoboxing), sort reverse order using Comparator. 562 Thinking Java Bruce Eckel Exercise 24: (3) Show class Exercise 19 searched. Arrays 563 Summary In chapter, you’ve seen Java provides reasonable support fixedsized, low-level arrays. This sort array emphasizes performance flexibility, like C C++ array model. In initial version Java, fixed-sized, low-level arrays absolutely necessary, Java designers chose include primitive types (also performance), support containers version minimal. Thus, early versions Java, always reasonable choose arrays. In subsequent versions Java, container support improved significantly, containers tend outshine arrays ways except performance, even then, performance containers significantly improved. As stated places book, performance problems usually never imagine be, anyway. With addition autoboxing generics, holding primitives containers become effortless, encourages replace low-level arrays containers. Because generics produce type-safe containers, arrays long advantage front, either. As noted chapter you’ll see try use them, generics fairly hostile towards arrays. Often, even get generics arrays work together form (as you’ll see next chapter), you’ll still end "unchecked" warnings compilation. On several occasions I told directly Java language designers I using containers instead arrays, discussing particular examples (I using arrays demonstrate specific techniques I option). All issues indicate "prefer containers arrays" programming recent versions Java. Only it’s proven performance issue (and switching array make difference) refactor arrays. This rather bold statement, languages fixed-sized, lowlevel arrays all. They resizable containers significantly functionality C/C++/Javastyle arrays. Python, 4 example, list type uses basic array syntax, much greater functionality—you even inherit it: #: arrays/PythonLists.py aList = [1, 2, 3, 4, 5] print type(aList) # <type ‘list’> print aList # [1, 2, 3, 4, 5] print aList[4] # 5 Basic list indexing aList.append(6) # lists resized aList += [7, 8] # Add list list print aList # [1, 2, 3, 4, 5, 6, 7, 8] aSlice = aList[2:4] print aSlice # [3, 4] class MyList(list): # Inherit list # Define method, ‘this’ pointer explicit: def getReversed(self): reversed = self[:] # Copy list using slices reversed.reverse() # Built-in list method return reversed 4 564 See www.Python.org. Thinking Java Bruce Eckel list2 = MyList(aList) # No ‘new’ needed object creation print type(list2) # <class ‘__main__.MyList’> print list2.getReversed() # [8, 7, 6, 5, 4, 3, 2, 1] #:~ Basic Python syntax introduced previous chapter. Here, list created simply surrounding comma-separated sequence objects square brackets. The result object runtime type list (the output print statements shown comments line). The result printing list using Arrays.toString() Java. Creating sub-sequence list accomplished "slicing," placing the’:’ operator inside index operation. The list type many builtin operations. MyList class definition; base classes placed within parentheses. Inside class, def statements produce methods, first argument method automatically equivalent Java, except Python it’s explicit identifier self used convention (it’s keyword). Notice constructor automatically inherited. Although everything Python really object (including integral floating point types), still escape hatch optimize performance-critical portions code writing extensions C, C++ special tool called Pyrex, designed easily speed code. This way object purity without prevented performance improvements. The PHP language 5 goes even single array type, acts int-indexed array associative array (a Map). It’s interesting speculate, many years Java evolution, whether designers would put primitives low-level arrays language start again. If left out, would possible make truly pure object-oriented language (despite claims, Java pure 0 0 language, precisely low-level detritus). The initial argument efficiency always seems compelling, time seen evolution away idea towards use higher-level components like containers. Add fact containers built core language languages, compiler much better opportunity optimize. Green-fields speculation aside, certainly stuck arrays, see reading code. Containers, however, almost always better choice. Exercise 25: (3) Rewrite PythonLists.py Java. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. 5 See www.php.net. Arrays 565 Containers Depth The Holding Your Objects chapter introduced ideas basic functionality Java containers library, enough get started using containers. This chapter explores important library deeply. In order get full use containers library, need know introduced Holding Your Objects, chapter relies advanced material (like generics) delayed later book. After complete overview containers, you’ll learn hashing works, write hashCode( ) equals( ) work hashed containers. You’ll learn different versions containers choose them. The chapter finishes exploration general-purpose utilities special classes. Full container taxonomy The "Summary" section Holding Your Objects chapter showed simplified diagram Java containers library. Here complete diagram collections library, including abstract classes legacy components (with exception Queue implementations): Full Container Taxonomy Java SE5 adds: • The Queue interface (which LinkedList modified implement, saw Holding Your Objects) implementations PriorityQueue various flavors BlockingQueue shown Concurrency chapter. • A ConcurrentMap interface implementation ConcurrentHashMap, also use threading shown Concurrency chapter. • CopyOnWriteArrayList CopyOnWriteArraySet, also concurrency. • EnumSet EnumMap, special implementations Set Map use enums, shown Enumerated Types chapter. • Several utilities Collections class. The long-dashed boxes represent abstract classes, see number classes whose names begin "Abstract." These seem bit confusing first, simply tools partially implement particular interface. If making Set, example, wouldn’t start Set interface implement methods; instead, you’d inherit AbstractSet minimal necessary work make new class. However, containers library contains enough functionality satisfy needs virtually time, usually ignore class begins "Abstract." Filling containers Although problem printing containers solved, filling containers suffers deficiency java.utiLArrays. Just Arrays, companion class called Collections containing static utility methods, including one called fill( ). Like Arrays version, fill( ) duplicates single object reference throughout container. In addition, works List objects, resulting list passed constructor addAll( ) method: //: containers/FillingLists.java // The Collections.fill() & Collections.nCopies() methods. import java.util.*; class StringAddress { private String s; public StringAddress(String s) { this.s = s; } public String toString() { return super.toString() + " " + s; } } public class FillingLists { public static void main(String[] args) { List<StringAddress> list= new ArrayList<StringAddress>( Collections.nCopies(4, new StringAddress("Hello"))); System.out.println(list); Collections.fill(list, new StringAddress("World!")); System.out.println(list); } } /* Output: (Sample) [StringAddress@82ba41 Hello, StringAddress@82ba41 Hello, StringAddress@82ba41 Hello, StringAddress@82ba41 Hello] [StringAddress@923e30 World!, StringAddress@923e30 World!, StringAddress@923e30 World!, StringAddress@923e30 World!] *///:~ 568 Thinking Java Bruce Eckel This example shows two ways fill Collection references single object. The first, Collections.nCopies( ), creates List passed constructor; fills ArrayList. The toString( ) method StringAddress calls Object.toString( ), produces class name followed unsigned hexadecimal representation hash code object (generated hashCode( ) method). You see output references set object, also true second method, Collections.fill( ), called. The fill( ) method made even less useful fact replace elements already List add new elements. A Generator solution Virtually Collection subtypes constructor takes another Collection object, fill new container. In order easily create test data, then, need build class takes constructor arguments Generator (defined Generics chapter explored Arrays chapter) quantity value: //: net/mindview/util/CollectionData.java // A Collection filled data using generator object. package net.mindview.util; import java.util.*; public class CollectionData<T> extends ArrayList<T> { public CollectionData(Generator<T> gen, int quantity) { for(int = 0; < quantity; i++) add(gen.next()); } // A generic convenience method: public static <T> CollectionData<T> list(Generator<T> gen, int quantity) { return new CollectionData<T>(gen, quantity); } } ///:~ This uses Generator put many objects container need. The resulting container passed constructor Collection, constructor copy data itself. The addAll( ) method that’s part every Collection subtype also used populate existing Collection. The generic convenience method reduces amount typing necessary using class. CollectionData example Adapter design pattern; 1 adapts Generator constructor Collection. Here’s example initializes LinkedHashSet: //: containers/CollectionDataTest.java import java.util.*; import net.mindview.util.*; class Government implements Generator<String> { String[] foundation = ("strange women lying ponds " + "distributing swords basis system " + This may strict definition adapter defined Design Patterns book, I think meets spirit idea. 1 Containers Depth 569 } "government").split(" "); private int index; public String next() { return foundation[index++]; } public class CollectionDataTest { public static void main(String[] args) { Set<String> set = new LinkedHashSet<String>( new CollectionData<String>(new Government(), 15)); // Using convenience method: set.addAll(CollectionData.list(new Government(), 15)); System.out.println(set); } } /* Output: [strange, women, lying, in, ponds, distributing, swords, is, no, basis, for, a, system, of, government] *///:~ The elements order inserted LinkedHashSet maintains linked list holding insertion order. All generators defined Arrays chapter available via CollectionData adapter. Here’s example uses two them: //: containers/CollectionDataGeneration.java // Using Generators defined Arrays chapter. import java.util.*; import net.mindview.util.*; public class CollectionDataGeneration { public static void main(String[] args) { System.out.println(new ArrayList<String>( CollectionData.list( // Convenience method new RandomGenerator.String(9), 10))); System.out.println(new HashSet<Integer>( new CollectionData<Integer>( new RandomGenerator.Integer(), 10))); } } /* Output: [YNzbrnyGc, FOWZnTcQr, GseGZMmJM, RoEsuEcUO, neOEdLsmw, HLGEahKcx, rEqUCBbkI, naMesbtWH, kjUrUkZPg, wsqPzDyCy] [573, 4779, 871, 4367, 6090, 7882, 2017, 8037, 3455, 299] *///:~ The String length produced RandomGenerator.String controlled constructor argument. Map generators We take approach Map, requires Pair class since pair objects (one key one value) must produced call Generator’s next( ) order populate Map: //: net/mindview/util/Pair.java package net.mindview.util; public class Pair<K,V> { public final K key; public final V value; public Pair(K k, V v) { 570 Thinking Java Bruce Eckel key = k; value = v; } } ///:~ The key value fields made public final Pair becomes read-only Data Transfer Object (or Messenger). The Map adapter use various combinations Generators, Iterables, constant values fill Map initialization objects: //: net/mindview/util/MapData.java // A Map filled data using generator object. package net.mindview.util; import java.util.*; public class MapData<K,V> extends LinkedHashMap<K,V> { // A single Pair Generator: public MapData(Generator<Pair<K,V>> gen, int quantity) { for(int = 0; < quantity; i++) { Pair<K,V> p = gen.next(); put(p.key, p.value); } } // Two separate Generators: public MapData(Generator<K> genK, Generator<V> genV, int quantity) { for(int = 0; < quantity; i++) { put(genK.next(), genV.next()); } } // A key Generator single value: public MapData(Generator<K> genK, V value, int quantity){ for(int = 0; < quantity; i++) { put(genK.next(), value); } } // An Iterable value Generator: public MapData(Iterable<K> genK, Generator<V> genV) { for(K key : genK) { put(key, genV.next()); } } // An Iterable single value: public MapData(Iterable<K> genK, V value) { for(K key : genK) { put(key, value); } } // Generic convenience methods: public static <K,V> MapData<K,V> map(Generator<Pair<K,V>> gen, int quantity) { return new MapData<K,V>(gen, quantity); } public static <K,V> MapData<K,V> map(Generator<K> genK, Generator<V> genV, int quantity) { return new MapData<K,V>(genK, genV, quantity); } public static <K,V> MapData<K,V> map(Generator<K> genK, V value, int quantity) { return new MapData<K,V>(genK, value, quantity); } Containers Depth 571 public static <K,V> MapData<K,V> map(Iterable<K> genK, Generator<V> genV) { return new MapData<K,V>(genK, genV); } public static <K,V> MapData<K,V> map(Iterable<K> genK, V value) { return new MapData<K,V>(genK, value); } } ///:~ This gives choice using single Generator<Pair<K,V> >, two separate Generators, one Generator constant value, Iterable (which includes Collection) Generator, Iterable single value. The generic convenience methods reduce amount typing necessary creating MapData object. Here’s example using MapData. The Letters Generator also implements Iterable producing Iterator; way, used test MapData.map( ) methods work Iterable: //: containers/MapDataTest.java import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; class Letters implements Generator<Pair<Integer,String>>, Iterable<Integer> { private int size = 9; private int number = 1; private char letter = ‘A’; public Pair<Integer,String> next() { return new Pair<Integer,String>( number++, "" + letter++); } public Iterator<Integer> iterator() { return new Iterator<Integer>() { public Integer next() { return number++; } public boolean hasNext() { return number < size; } public void remove() { throw new UnsupportedOperationException(); } }; } } public class MapDataTest { public static void main(String[] args) { // Pair Generator: print(MapData.map(new Letters(), 11)); // Two separate generators: print(MapData.map(new CountingGenerator.Character(), new RandomGenerator.String(3), 8)); // A key Generator single value: print(MapData.map(new CountingGenerator.Character(), "Value", 6)); // An Iterable value Generator: print(MapData.map(new Letters(), new RandomGenerator.String(3))); // An Iterable single value: print(MapData.map(new Letters(), "Pop")); } } /* Output: {1=A, 2=B, 3=C, 4=D, 5=E, 6=F, 7=G, 8=H, 9=I, 10=J, 11=K} 572 Thinking Java Bruce Eckel {a=YNz, b=brn, c=yGc, d=FOW, e=ZnT, f=cQr, g=Gse, h=GZM} {a=Value, b=Value, c=Value, d=Value, e=Value, f=Value} {1=mJM, 2=RoE, 3=suE, 4=cUO, 5=neO, 6=EdL, 7=smw, 8=HLG} {1=Pop, 2=Pop, 3=Pop, 4=Pop, 5=Pop, 6=Pop, 7=Pop, 8=Pop} *///:~ This example also uses generators Arrays chapter. You create generated data set Maps Collections using tools, initialize Map Collection using constructor Map.putAll( ) Collection.addAll( ) methods. Using Abstract classes An alternative approach problem producing test data containers create custom Collection Map implementations. Each java.util container Abstract class provides partial implementation container, must implement necessary methods order produce desired container. If resulting container read-only, typically test data, number methods need provide minimized. Although isn’t particularly necessary case, following solution also provides opportunity demonstrate another design pattern: Flyweight. You use flyweight ordinary solution requires many objects, producing normal objects takes much space. The Flyweight pattern externalizes part object that, instead everything object contained within object, object looked efficient external table (or produced calculation saves space). An important point example demonstrate relatively simple create custom Map Collection inheriting java.util.Abstract classes. In order create read-only Map, inherit AbstractMap implement entrySet( ). In order create readonly Set, inherit AbstractSet implement iterator( ) size( ). The data set example Map countries world capitals. 2 The capitals( ) method produces Map countries capitals. The names( ) method produces List country names. In cases get partial listing providing int argument indicating desired size: //: net/mindview/util/Countries.java // "Flyweight" Maps Lists sample data. package net.mindview.util; import java.util.*; import static net.mindview.util.Print.*; public class Countries { public static final String[][] DATA = { // Africa {"ALGERIA","Algiers"}, {"ANGOLA","Luanda"}, {"BENIN","Porto-Novo"}, {"BOTSWANA","Gaberone"}, {"BURKINA FASO","Ouagadougou"}, {"BURUNDI","Bujumbura"}, {"CAMEROON","Yaounde"}, {"CAPE VERDE","Praia"}, {"CENTRAL AFRICAN REPUBLIC","Bangui"}, {"CHAD","N’djamena"}, {"COMOROS","Moroni"}, 2 This data found Internet. Various corrections submitted readers time. Containers Depth 573 {"CONGO","Brazzaville"}, {"DJIBOUTI","Dijibouti"}, {"EGYPT","Cairo"}, {"EQUATORIAL GUINEA","Malabo"}, {"ERITREA","Asmara"}, {"ETHIOPIA","Addis Ababa"}, {"GABON","Libreville"}, {"THE GAMBIA","Banjul"}, {"GHANA","Accra"}, {"GUINEA","Conakry"}, {"BISSAU","Bissau"}, {"COTE D’IVOIR (IVORY COAST)","Yamoussoukro"}, {"KENYA","Nairobi"}, {"LESOTHO","Maseru"}, {"LIBERIA","Monrovia"}, {"LIBYA","Tripoli"}, {"MADAGASCAR","Antananarivo"}, {"MALAWI","Lilongwe"}, {"MALI","Bamako"}, {"MAURITANIA","Nouakchott"}, {"MAURITIUS","Port Louis"}, {"MOROCCO","Rabat"}, {"MOZAMBIQUE","Maputo"}, {"NAMIBIA","Windhoek"}, {"NIGER","Niamey"}, {"NIGERIA","Abuja"}, {"RWANDA","Kigali"}, {"SAO TOME E PRINCIPE","Sao Tome"}, {"SENEGAL","Dakar"}, {"SEYCHELLES","Victoria"}, {"SIERRA LEONE","Freetown"}, {"SOMALIA","Mogadishu"}, {"SOUTH AFRICA","Pretoria/Cape Town"}, {"SUDAN","Khartoum"}, {"SWAZILAND","Mbabane"}, {"TANZANIA","Dodoma"}, {"TOGO","Lome"}, {"TUNISIA","Tunis"}, {"UGANDA","Kampala"}, {"DEMOCRATIC REPUBLIC OF THE CONGO (ZAIRE)", "Kinshasa"}, {"ZAMBIA","Lusaka"}, {"ZIMBABWE","Harare"}, // Asia {"AFGHANISTAN","Kabul"}, {"BAHRAIN","Manama"}, {"BANGLADESH","Dhaka"}, {"BHUTAN","Thimphu"}, {"BRUNEI","Bandar Seri Begawan"}, {"CAMBODIA","Phnom Penh"}, {"CHINA","Beijing"}, {"CYPRUS","Nicosia"}, {"INDIA","New Delhi"}, {"INDONESIA","Jakarta"}, {"IRAN","Tehran"}, {"IRAQ","Baghdad"}, {"ISRAEL","Jerusalem"}, {"JAPAN","Tokyo"}, {"JORDAN","Amman"}, {"KUWAIT","Kuwait City"}, {"LAOS","Vientiane"}, {"LEBANON","Beirut"}, {"MALAYSIA","Kuala Lumpur"}, {"THE MALDIVES","Male"}, {"MONGOLIA","Ulan Bator"}, {"MYANMAR (BURMA)","Rangoon"}, {"NEPAL","Katmandu"}, {"NORTH KOREA","P’yongyang"}, {"OMAN","Muscat"}, {"PAKISTAN","Islamabad"}, {"PHILIPPINES","Manila"}, {"QATAR","Doha"}, {"SAUDI ARABIA","Riyadh"}, {"SINGAPORE","Singapore"}, {"SOUTH KOREA","Seoul"}, {"SRI LANKA","Colombo"}, {"SYRIA","Damascus"}, {"TAIWAN (REPUBLIC OF CHINA)","Taipei"}, {"THAILAND","Bangkok"}, {"TURKEY","Ankara"}, {"UNITED ARAB EMIRATES","Abu Dhabi"}, {"VIETNAM","Hanoi"}, {"YEMEN","Sana’a"}, // Australia Oceania {"AUSTRALIA","Canberra"}, {"FIJI","Suva"}, {"KIRIBATI","Bairiki"}, {"MARSHALL ISLANDS","Dalap-Uliga-Darrit"}, {"MICRONESIA","Palikir"}, {"NAURU","Yaren"}, {"NEW ZEALAND","Wellington"}, {"PALAU","Koror"}, {"PAPUA NEW GUINEA","Port Moresby"}, {"SOLOMON ISLANDS","Honaira"}, {"TONGA","Nuku’alofa"}, {"TUVALU","Fongafale"}, {"VANUATU","< Port-Vila"}, {"WESTERN SAMOA","Apia"}, // Eastern Europe former USSR {"ARMENIA","Yerevan"}, {"AZERBAIJAN","Baku"}, {"BELARUS (BYELORUSSIA)","Minsk"}, 574 Thinking Java Bruce Eckel {"BULGARIA","Sofia"}, {"GEORGIA","Tbilisi"}, {"KAZAKSTAN","Almaty"}, {"KYRGYZSTAN","Alma-Ata"}, {"MOLDOVA","Chisinau"}, {"RUSSIA","Moscow"}, {"TAJIKISTAN","Dushanbe"}, {"TURKMENISTAN","Ashkabad"}, {"UKRAINE","Kyiv"}, {"UZBEKISTAN","Tashkent"}, // Europe {"ALBANIA","Tirana"}, {"ANDORRA","Andorra la Vella"}, {"AUSTRIA","Vienna"}, {"BELGIUM","Brussels"}, {"BOSNIA","-"}, {"HERZEGOVINA","Sarajevo"}, {"CROATIA","Zagreb"}, {"CZECH REPUBLIC","Prague"}, {"DENMARK","Copenhagen"}, {"ESTONIA","Tallinn"}, {"FINLAND","Helsinki"}, {"FRANCE","Paris"}, {"GERMANY","Berlin"}, {"GREECE","Athens"}, {"HUNGARY","Budapest"}, {"ICELAND","Reykjavik"}, {"IRELAND","Dublin"}, {"ITALY","Rome"}, {"LATVIA","Riga"}, {"LIECHTENSTEIN","Vaduz"}, {"LITHUANIA","Vilnius"}, {"LUXEMBOURG","Luxembourg"}, {"MACEDONIA","Skopje"}, {"MALTA","Valletta"}, {"MONACO","Monaco"}, {"MONTENEGRO","Podgorica"}, {"THE NETHERLANDS","Amsterdam"}, {"NORWAY","Oslo"}, {"POLAND","Warsaw"}, {"PORTUGAL","Lisbon"}, {"ROMANIA","Bucharest"}, {"SAN MARINO","San Marino"}, {"SERBIA","Belgrade"}, {"SLOVAKIA","Bratislava"}, {"SLOVENIA","Ljuijana"}, {"SPAIN","Madrid"}, {"SWEDEN","Stockholm"}, {"SWITZERLAND","Berne"}, {"UNITED KINGDOM","London"}, {"VATICAN CITY","---"}, // North Central America {"ANTIGUA AND BARBUDA","Saint John’s"}, {"BAHAMAS","Nassau"}, {"BARBADOS","Bridgetown"}, {"BELIZE","Belmopan"}, {"CANADA","Ottawa"}, {"COSTA RICA","San Jose"}, {"CUBA","Havana"}, {"DOMINICA","Roseau"}, {"DOMINICAN REPUBLIC","Santo Domingo"}, {"EL SALVADOR","San Salvador"}, {"GRENADA","Saint George’s"}, {"GUATEMALA","Guatemala City"}, {"HAITI","Port-au-Prince"}, {"HONDURAS","Tegucigalpa"}, {"JAMAICA","Kingston"}, {"MEXICO","Mexico City"}, {"NICARAGUA","Managua"}, {"PANAMA","Panama City"}, {"ST. KITTS","-"}, {"NEVIS","Basseterre"}, {"ST. LUCIA","Castries"}, {"ST. VINCENT AND THE GRENADINES","Kingstown"}, {"UNITED STATES OF AMERICA","Washington, D.C."}, // South America {"ARGENTINA","Buenos Aires"}, {"BOLIVIA","Sucre (legal)/La Paz(administrative)"}, {"BRAZIL","Brasilia"}, {"CHILE","Santiago"}, {"COLOMBIA","Bogota"}, {"ECUADOR","Quito"}, {"GUYANA","Georgetown"}, {"PARAGUAY","Asuncion"}, {"PERU","Lima"}, {"SURINAME","Paramaribo"}, {"TRINIDAD AND TOBAGO","Port Spain"}, {"URUGUAY","Montevideo"}, {"VENEZUELA","Caracas"}, }; // Use AbstractMap implementing entrySet() private static class FlyweightMap extends AbstractMap<String,String> { private static class Entry implements Map.Entry<String,String> { int index; Entry(int index) { this.index = index; } public boolean equals(Object o) { return DATA[index][0].equals(o); } Containers Depth 575 public String getKey() { return DATA[index][0]; } public String getValue() { return DATA[index][1]; } public String setValue(String value) { throw new UnsupportedOperationException(); } public int hashCode() { return DATA[index][0].hashCode(); } } // Use AbstractSet implementing size() & iterator() static class EntrySet extends AbstractSet<Map.Entry<String,String>> { private int size; EntrySet(int size) { if(size < 0) this.size = 0; // Can’t bigger array: else if(size > DATA.length) this.size = DATA.length; else this.size = size; } public int size() { return size; } private class Iter implements Iterator<Map.Entry<String,String>> { // Only one Entry object per Iterator: private Entry entry = new Entry(-1); public boolean hasNext() { return entry.index < size - 1; } public Map.Entry<String,String> next() { entry.index++; return entry; } public void remove() { throw new UnsupportedOperationException(); } } public Iterator<Map.Entry<String,String>> iterator() { return new Iter(); } } private static Set<Map.Entry<String,String>> entries = new EntrySet(DATA.length); public Set<Map.Entry<String,String>> entrySet() { return entries; } } // Create partial map ‘size’ countries: static Map<String,String> select(final int size) { return new FlyweightMap() { public Set<Map.Entry<String,String>> entrySet() { return new EntrySet(size); } }; } static Map<String,String> map = new FlyweightMap(); public static Map<String,String> capitals() { return map; // The entire map } public static Map<String,String> capitals(int size) { return select(size); // A partial map 576 Thinking Java Bruce Eckel } static List<String> names = new ArrayList<String>(map.keySet()); // All names: public static List<String> names() { return names; } // A partial list: public static List<String> names(int size) { return new ArrayList<String>(select(size).keySet()); } public static void main(String[] args) { print(capitals(10)); print(names(10)); print(new HashMap<String,String>(capitals(3))); print(new LinkedHashMap<String,String>(capitals(3))); print(new TreeMap<String,String>(capitals(3))); print(new Hashtable<String,String>(capitals(3))); print(new HashSet<String>(names(6))); print(new LinkedHashSet<String>(names(6))); print(new TreeSet<String>(names(6))); print(new ArrayList<String>(names(6))); print(new LinkedList<String>(names(6))); print(capitals().get("BRAZIL")); } } /* Output: {ALGERIA=Algiers, ANGOLA=Luanda, BENIN=Porto-Novo, BOTSWANA=Gaberone, BULGARIA=Sofia, BURKINA FASO=Ouagadougou, BURUNDI=Bujumbura, CAMEROON=Yaounde, CAPE VERDE=Praia, CENTRAL AFRICAN REPUBLIC=Bangui} [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, BURUNDI, CAMEROON, CAPE VERDE, CENTRAL AFRICAN REPUBLIC] {BENIN=Porto-Novo, ANGOLA=Luanda, ALGERIA=Algiers} {ALGERIA=Algiers, ANGOLA=Luanda, BENIN=Porto-Novo} {ALGERIA=Algiers, ANGOLA=Luanda, BENIN=Porto-Novo} {ALGERIA=Algiers, ANGOLA=Luanda, BENIN=Porto-Novo} [BULGARIA, BURKINA FASO, BOTSWANA, BENIN, ANGOLA, ALGERIA] [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] Brasilia *///:~ The two-dimensional array String DATA public used elsewhere. FlyweightMap must implement entrySet( ) method, requires custom Set implementation custom Map.Entry class. Here’s part flyweight: Map.Entry object simply stores index, rather actual key value. When call getKey( ) getValue( ), uses index return appropriate DATA element. The EntrySet ensures size bigger DATA. You see part flyweight implemented EntrySet.Iterator. Instead creating Map.Entry object data pair DATA, there’s one Map.Entry object per iterator. The Entry object used window data; contains index static array strings. Every time call next( ) iterator, index Entry incremented points next element pair, Iterator’s single Entry object returned next( ). 3 The select( ) method produces FlyweightMap containing EntrySet desired size, used overloaded capitals( ) names( ) methods see demonstrated main( ). 3 The Maps java.util perform bulk copies using getKey( ) getValue( ) Maps, works. If custom Map simply copy entire Map.Entry approach would cause problem. Containers Depth 577 For tests, limited size Countries problem. We take approach produce initialized custom containers data set size. This class List size, (effectively) preinitialized Integer data: //: net/mindview/util/CountingIntegerList.java // List length, containing sample data. package net.mindview.util; import java.util.*; public class CountingIntegerList extends AbstractList<Integer> { private int size; public CountingIntegerList(int size) { this.size = size < 0 ? 0 : size; } public Integer get(int index) { return Integer.valueOf(index); } public int size() { return size; } public static void main(String[] args) { System.out.println(new CountingIntegerList(30)); } } /* Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29] *///:~ To create read-only List AbstractList, must implement get( ) size( ). Again, flyweight solution used: get( ) produces value ask it, List doesn’t actually populated. Here Map containing pre-initialized unique Integers Strings; also size: //: net/mindview/util/CountingMapData.java // Unlimited-length Map containing sample data. package net.mindview.util; import java.util.*; public class CountingMapData extends AbstractMap<Integer,String> { private int size; private static String[] chars = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z" .split(" "); public CountingMapData(int size) { if(size < 0) this.size = 0; this.size = size; } private static class Entry implements Map.Entry<Integer,String> { int index; Entry(int index) { this.index = index; } public boolean equals(Object o) { return Integer.valueOf(index).equals(o); } public Integer getKey() { return index; } public String getValue() { return chars[index % chars.length] + Integer.toString(index / chars.length); } public String setValue(String value) { 578 Thinking Java Bruce Eckel throw new UnsupportedOperationException(); } public int hashCode() { return Integer.valueOf(index).hashCode(); } } public Set<Map.Entry<Integer,String>> entrySet() { // LinkedHashSet retains initialization order: Set<Map.Entry<Integer,String>> entries = new LinkedHashSet<Map.Entry<Integer,String>>(); for(int = 0; < size; i++) entries.add(new Entry(i)); return entries; } public static void main(String[] args) { System.out.println(new CountingMapData(60)); } } /* Output: {0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 7=H0, 8=I0, 9=J0, 10=K0, 11=L0, 12=M0, 13=N0, 14=O0, 15=P0, 16=Q0, 17=R0, 18=S0, 19=T0, 20=U0, 21=V0, 22=W0, 23=X0, 24=Y0, 25=Z0, 26=A1, 27=B1, 28=C1, 29=D1, 30=E1, 31=F1, 32=G1, 33=H1, 34=I1, 35=J1, 36=K1, 37=L1, 38=M1, 39=N1, 40=O1, 41=P1, 42=Q1, 43=R1, 44=S1, 45=T1, 46=U1, 47=V1, 48=W1, 49=X1, 50=Y1, 51=Z1, 52=A2, 53=B2, 54=C2, 55=D2, 56=E2, 57=F2, 58=G2, 59=H2} *///:~ Here, LinkedHashSet used instead creating custom Set class, flyweight fully implemented. Exercise 1: (1) Create List (try ArrayList LinkedList) fill using Countries. Sort list print it, apply Collections.shuffle( ) list repeatedly, printing time see shuffle( ) method randomizes list differently time. Exercise 2: (2) Produce Map Set containing countries begin ‘A’. Exercise 3: (1) Using Countries, fill Set multiple times data verify Set ends one instance. Try HashSet, LinkedHashSet, TreeSet. Exercise 4: (2) Create Collection initializer opens file breaks words using TextFile, uses words source data resulting Collection. Demonstrate works. Exercise 5: (3) Modify CountingMapData.java fully implement flyweight adding custom EntrySet class like one Countries.java. Containers Depth 579 Collection functionality The following table shows everything Collection (not including methods automatically come Object), thus, everything Set List. (List also additional functionality.) Maps inherited Collection treated separately. boolean add(T) Ensures container holds argument generic type T. Returns false doesn’t add argument. (This "optional" method, described next section.) boolean addAll( Collection<? extends T>) Adds elements argument. Returns true elements added. ("Optional.") void clear( ) Removes elements container. ("Optional.") boolean contains (T) true container holds argument generic type T. Boolean containsAll( Collection<?>) true container holds elements argument. boolean isEmpty( ) true container elements. Iterator<T> iterator( ) Returns Iterator<T> use move elements container. Boolean remove(Object) If argument container, one instance element removed. Returns true removal occurred. ("Optional") boolean removeAll( Collection<?>) Removes elements contained argument. Returns true removals occurred. ("Optional.") Boolean retainAll( Collection<?>) Retains elements contained argument (an "intersection," set theory). Returns true changes occurred. ("Optional.") int size( ) Returns number elements container. Object[] toArray( ) Returns array containing elements container. <T>T[] toArray(T[] a) Returns array containing elements container. The runtime type result argument array rather plain Object. Notice there’s get( ) method random-access element selection. That’s Collection also includes Set, maintains internal ordering (and thus makes random-access lookup meaningless). Thus, want examine elements Collection, must use iterator. 580 Thinking Java Bruce Eckel The following example demonstrates methods. Although methods work anything implements Collection, ArrayList used "least-common denominator": //: containers/CollectionMethods.java // Things Collections. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class CollectionMethods { public static void main(String[] args) { Collection<String> c = new ArrayList<String>(); c.addAll(Countries.names(6)); c.add("ten"); c.add("eleven"); print(c); // Make array List: Object[] array = c.toArray(); // Make String array List: String[] str = c.toArray(new String[0]); // Find max min elements; means // different things depending way // Comparable interface implemented: print("Collections.max(c) = " + Collections.max(c)); print("Collections.min(c) = " + Collections.min(c)); // Add Collection another Collection Collection<String> c2 = new ArrayList<String>(); c2.addAll(Countries.names(6)); c.addAll(c2); print(c); c.remove(Countries.DATA[0][0]); print(c); c.remove(Countries.DATA[1][0]); print(c); // Remove components // argument collection: c.removeAll(c2); print(c); c.addAll(c2); print(c); // Is element Collection? String val = Countries.DATA[3][0]; print("c.contains(" + val + ") = " + c.contains(val)); // Is Collection Collection? print("c.containsAll(c2) = " + c.containsAll(c2)); Collection<String> c3 = ((List<String>)c).subList(3, 5); // Keep elements // c2 c3 (an intersection sets): c2.retainAll(c3); print(c2); // Throw away elements // c2 also appear c3: c2.removeAll(c3); print("c2.isEmpty() = " + c2.isEmpty()); c = new ArrayList<String>(); c.addAll(Countries.names(6)); print(c); c.clear(); // Remove elements print("after c.clear():" + c); } } /* Output: Containers Depth 581 [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, ten, eleven] Collections.max(c) = ten Collections.min(c) = ALGERIA [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, ten, eleven, ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] [ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, ten, eleven, ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] [BENIN, BOTSWANA, BULGARIA, BURKINA FASO, ten, eleven, ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] [ten, eleven] [ten, eleven, ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] c.contains(BOTSWANA) = true c.containsAll(c2) = true [ANGOLA, BENIN] c2.isEmpty() = true [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] c.clear():[] *///:~ ArrayLists created containing different sets data upcast Collection objects, it’s clear nothing Collection interface used. main( ) uses simple exercises show methods Collection. Subsequent sections chapter describe various implementations List, Set, Map indicate case (with asterisk) one default choice. Descriptions legacy classes Vector, Stack, Hashtable delayed end chapter—although shouldn’t use classes, see old code. Optional operations The methods perform various kinds addition removal optional operations Collection interface. This means implementing class required provide functioning definitions methods. This unusual way define interface. As you’ve seen, interface contract object-oriented design. It says, "No matter choose implement interface, I guarantee send messages object." 4 But "optional" operation violates fundamental principle; says calling methods perform meaningful behavior. Instead, throw exceptions! It appears compile-time type safety discarded. It’s quite bad. If operation optional, compiler still restricts calling methods interface. It’s like dynamic language, call method object, find run time whether particular call work. 5 In addition, methods take Collection argument read Collection, "read" methods Collection optional. Why would define methods "optional"? Doing prevents explosion interfaces design. Other designs container libraries always seem end confusing plethora interfaces describe variations main theme. It’s even possible capture special cases interfaces, someone always invent new interface. The "unsupported operation" approach achieves important goal Java I using term "interface" describe formal interface keyword general meaning "the methods supported class subclass." 4 5 Although sounds odd possibly useless I describe way, you’ve seen, especially Type Information chapter, kind dynamic behavior powerful. 582 Thinking Java Bruce Eckel containers library: The containers simple learn use. Unsupported operations special case delayed necessary. For approach work, however: 1. The UnsupportedOperationException must rare event. That is, classes, operations work, special cases operation unsupported. This true Java containers library, since classes you’ll use 99 percent time—ArrayList, LinkedList, HashSet, HashMap, well concrete implementations—support operations. The design provide "back door" want create new Collection without providing meaningful definitions methods Collection interface, yet still fit existing library. 2. When operation unsupported, reasonable likelihood UnsupportedOperationException appear implementation time, rather you’ve shipped product customer. After all, indicates programming error: You’ve used implementation incorrectly. It’s worth noting unsupported operations detectable run time, therefore represent dynamic type checking. If you’re coming statically typed language like C++, Java might appear another statically typed language. Java certainly static type checking, also significant amount dynamic typing, it’s hard say it’s exactly one type language another. Once begin notice this, you’ll start see examples dynamic type checking Java. Unsupported operations A common source unsupported operations involves container backed fixed-sized data structure. You get container turn array List Arrays.asList( ) method. You also choose make container (including Map) throw UnsupportedOperationExceptions using "unmodifiable" methods Collections class. This example shows cases: //: containers/Unsupported.java // Unsupported operations Java containers. import java.util.*; public class Unsupported { static void test(String msg, List<String> list) { System.out.println("--- " + msg + " ---"); Collection<String> c = list; Collection<String> subList = list.subList(1,8); // Copy sublist: Collection<String> c2 = new ArrayList<String>(subList); try { c.retainAll(c2); } catch(Exception e) { System.out.println("retainAll(): " + e); } try { c.removeAll(c2); } catch(Exception e) { System.out.println("removeAll(): " + e); } try { c.clear(); } catch(Exception e) { System.out.println("clear(): " + e); } try { c.add("X"); } catch(Exception e) { System.out.println("add(): " + e); } try { c.addAll(c2); } catch(Exception e) { System.out.println("addAll(): " + e); } try { c.remove("C"); } catch(Exception e) { Containers Depth 583 System.out.println("remove(): " } // The List.set() method modifies // doesn’t change size try { list.set(0, "X"); } catch(Exception e) { System.out.println("List.set(): } + e); value data structure: " + e); } public static void main(String[] args) { List<String> list = Arrays.asList("A B C D E F G H I J K L".split(" ")); test("Modifiable Copy", new ArrayList<String>(list)); test("Arrays.asList()", list); test("unmodifiableList()", Collections.unmodifiableList( new ArrayList<String>(list))); } } /* Output: --- Modifiable Copy ----- Arrays.asList() --retainAll(): java.lang.UnsupportedOperationException removeAll(): java.lang.UnsupportedOperationException clear(): java.lang.UnsupportedOperationException add(): java.lang.UnsupportedOperationException addAll(): java.lang.UnsupportedOperationException remove(): java.lang.UnsupportedOperationException --- unmodifiableList() --retainAll(): java.lang.UnsupportedOperationException removeAll(): java.lang.UnsupportedOperationException clear(): java.lang.UnsupportedOperationException add(): java.lang.UnsupportedOperationException addAll(): java.lang.UnsupportedOperationException remove(): java.lang.UnsupportedOperationException List.set(): java.lang.UnsupportedOperationException *///:~ Because Arrays.asList( ) produces List backed fixed-size array, makes sense supported operations ones don’t change size array. Any method would cause change size underlying data structure produces UnsupportedOperationException, indicate call unsupported method (a programming error). Note always pass result Arrays.asList( ) constructor argument Collection (or use addAll( ) method, Collections.addAll( ) static method) order create regular container allows use methods—this shown first call test( ) main( ). Such call produces new resizable underlying data structure. The "unmodifiable" methods Collections class wrap container proxy produces UnsupportedOperationException perform operation modifies container way. The goal using methods produce "constant" container object. The full list "unmodifiable" Collections methods described later. The last try block test( ) examines set( ) method that’s part List. This interesting, see granularity "unsupported operation" technique comes handy—the resulting "interface" vary one method object returned Arrays.asList( ) returned Collections.unmodifiableList( ). Arrays.asList( ) returns fixed-sized List, whereas Collections.unmodifiableList( ) produces list cannot changed. As see 584 Thinking Java Bruce Eckel output, it’s OK modify elements List returned Arrays.asList( ), would violate "fixed-sized" nature List. But clearly, result unmodifiableList( ) modifiable way. If interfaces used, would required two additional interfaces, one working set( ) method one without. Additional interfaces would required various unmodifiable subtypes Collection. The documentation method takes container argument specify optional methods must implemented. Exercise 6: (2) Note List additional "optional" operations included Collection. Write version Unsupported.java tests additional optional operations. Containers Depth 585 List functionality As you’ve seen, basic List quite simple use: Most time call add( ) insert objects, use get( ) get one time, call iterator( ) get Iterator sequence. The methods following example cover different group activities: things every List (basicTest( )), moving around Iterator (iterMotion( )) versus changing things Iterator (iterManipulation( )), seeing effects List manipulation (testVisual( )), operations available LinkedLists: //: containers/Lists.java // Things Lists. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class Lists { private static boolean b; private static String s; private static int i; private static Iterator<String> it; private static ListIterator<String> lit; public static void basicTest(List<String> a) { a.add(1, "x"); // Add location 1 a.add("x"); // Add end // Add collection: a.addAll(Countries.names(25)); // Add collection starting location 3: a.addAll(3, Countries.names(25)); b = a.contains("1"); // Is there? // Is entire collection there? b = a.containsAll(Countries.names(25)); // Lists allow random access, cheap // ArrayList, expensive LinkedList: = a.get(1); // Get (typed) object location 1 = a.indexOf("1"); // Tell index object b = a.isEmpty(); // Any elements inside? = a.iterator(); // Ordinary Iterator lit = a.listIterator(); // ListIterator lit = a.listIterator(3); // Start loc 3 = a.lastIndexOf("1"); // Last match a.remove(1); // Remove location 1 a.remove("3"); // Remove object a.set(1, "y"); // Set location 1 "y" // Keep everything that’s argument // (the intersection two sets): a.retainAll(Countries.names(25)); // Remove everything that’s argument: a.removeAll(Countries.names(25)); = a.size(); // How big it? a.clear(); // Remove elements } public static void iterMotion(List<String> a) { ListIterator<String> = a.listIterator(); b = it.hasNext(); b = it.hasPrevious(); = it.next(); = it.nextIndex(); = it.previous(); 586 Thinking Java Bruce Eckel = it.previousIndex(); } public static void iterManipulation(List<String> a) { ListIterator<String> = a.listIterator(); it.add("47"); // Must move element add(): it.next(); // Remove element newly produced one: it.remove(); // Must move element remove(): it.next(); // Change element deleted one: it.set("47"); } public static void testVisual(List<String> a) { print(a); List<String> b = Countries.names(25); print("b = " + b); a.addAll(b); a.addAll(b); print(a); // Insert, remove, replace elements // using ListIterator: ListIterator<String> x = a.listIterator(a.size()/2); x.add("one"); print(a); print(x.next()); x.remove(); print(x.next()); x.set("47"); print(a); // Traverse list backwards: x = a.listIterator(a.size()); while(x.hasPrevious()) printnb(x.previous() + " "); print(); print("testVisual finished"); } // There things LinkedLists do: public static void testLinkedList() { LinkedList<String> = new LinkedList<String>(); ll.addAll(Countries.names(25)); print(ll); // Treat like stack, pushing: ll.addFirst("one"); ll.addFirst("two"); print(ll); // Like "peeking" top stack: print(ll.getFirst()); // Like popping stack: print(ll.removeFirst()); print(ll.removeFirst()); // Treat like queue, pulling elements // tail end: print(ll.removeLast()); print(ll); } public static void main(String[] args) { // Make fill new list time: basicTest( new LinkedList<String>(Countries.names(25))); basicTest( new ArrayList<String>(Countries.names(25))); Containers Depth 587 iterMotion( new LinkedList<String>(Countries.names(25))); iterMotion( new ArrayList<String>(Countries.names(25))); iterManipulation( new LinkedList<String>(Countries.names(25))); iterManipulation( new ArrayList<String>(Countries.names(25))); testVisual( new LinkedList<String>(Countries.names(25))); testLinkedList(); } } /* (Execute see output) *///:~ In basicTest( ) iterMotion( ) calls made order show proper syntax, although return value captured, used. In cases, return value isn’t captured all. You look full usage methods JDK documentation use them. Exercise 7: (4) Create ArrayList LinkedList, fill using Countries.names( ) generator. Print list using ordinary Iterator, insert one list using Listlterator, inserting every location. Now perform insertion starting end first list moving backward. Exercise 8: (7) Create generic, singly linked list class called SList, which, keep things simple, implement List interface. Each Link object list contain reference next element list, previous one (LinkedList, contrast, doubly linked list, means maintains links directions). Create SListIterator which, simplicity, implement ListIterator. The method SList toString( ) iterator( ), produces SListIterator. The way insert remove elements SList SListIterator. Write code demonstrate SList. 588 Thinking Java Bruce Eckel Sets storage order The Set examples Holding Your Objects chapter provide good introduction operations performed basic Sets. However, examples conveniently use predefined Java types Integer String, designed usable inside containers. When creating types, aware Set needs way maintain storage order. How storage order maintained varies one implementation Set another. Thus, different Set implementations different behaviors, different requirements type object put particular Set: Set (interface) Each element add Set must unique; otherwise, Set doesn’t add duplicate element. Elements added Set must least define equals( ) establish object uniqueness. Set exactly interface Collection. The Set interface guarantee maintain elements particular order. HashSet* For Sets fast lookup time important. Elements must also define hashCode( ). TreeSet An ordered Set backed tree. This way, extract ordered sequence Set. Elements must also implement Comparable interface. LinkedHashSet Has lookup speed HashSet, internally maintains order add elements (the insertion order) using linked list. Thus, iterate Set, results appear insertion order. Elements must also define hashCode( ). The asterisk HashSet indicates that, absence constraints, default choice optimized speed. Defining hashCode( ) described later chapter. You must create equals( ) hashed tree storage, hashCode( ) necessary class placed HashSet (which likely, since generally first choice Set implementation) LinkedHashSet. However, good programming style, always override hashCode( ) override equals( ). This example demonstrates methods must defined order successfully use type particular Set implementation: //: containers/TypesForSets.java // Methods necessary put type Set. import java.util.*; class SetType { int i; public SetType(int n) { = n; } public boolean equals(Object o) { return instanceof SetType && (i == ((SetType)o).i); } public String toString() { return Integer.toString(i); } } Containers Depth 589 class HashType extends SetType { public HashType(int n) { super(n); } public int hashCode() { return i; } } class TreeType extends SetType implements Comparable<TreeType> { public TreeType(int n) { super(n); } public int compareTo(TreeType arg) { return (arg.i < ? -1 : (arg.i == ? 0 : 1)); } } public class TypesForSets { static <T> Set<T> fill(Set<T> set, Class<T> type) { try { for(int = 0; < 10; i++) set.add( type.getConstructor(int.class).newInstance(i)); } catch(Exception e) { throw new RuntimeException(e); } return set; } static <T> void test(Set<T> set, Class<T> type) { fill(set, type); fill(set, type); // Try add duplicates fill(set, type); System.out.println(set); } public static void main(String[] args) { test(new HashSet<HashType>(), HashType.class); test(new LinkedHashSet<HashType>(), HashType.class); test(new TreeSet<TreeType>(), TreeType.class); // Things don’t work: test(new HashSet<SetType>(), SetType.class); test(new HashSet<TreeType>(), TreeType.class); test(new LinkedHashSet<SetType>(), SetType.class); test(new LinkedHashSet<TreeType>(), TreeType.class); try { test(new TreeSet<SetType>(), SetType.class); } catch(Exception e) { System.out.println(e.getMessage()); } try { test(new TreeSet<HashType>(), HashType.class); } catch(Exception e) { System.out.println(e.getMessage()); } } } /* Output: (Sample) [2, 4, 9, 8, 6, 1, 3, 7, 5, 0] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] [9, 9, 7, 5, 1, 2, 6, 3, 0, 7, 2, 4, 4, 7, 9, 1, 3, 6, 2, 4, 8, 8, 8, 6, 5, 1] [0, 5, 5, 6, 5, 0, 3, 1, 9, 8, 4, 2, 3, 9, 7, 3, 4, 4, 0, 7, 1, 8, 2, 8, 6, 7] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9] 590 Thinking Java 3, 0, 5, 0, 1, 9, 6, 2, 0, 1, 2, 3, 0, 1, 2, 3, Bruce Eckel java.lang.ClassCastException: SetType cannot cast java.lang.Comparable java.lang.ClassCastException: HashType cannot cast java.lang.Comparable *///:~ In order prove methods necessary particular Set time avoid code duplication, three classes created. The base class, SetType, simply stores int, produces via toString( ). Since classes stored Sets must equals( ), method also placed base class. Equality based value int i. HashType inherits SetType adds hashCode( ) method necessary object placed hashed implementation Set. The Comparable interface, implemented TreeType, necessary object used kind sorted container, SortedSet (of TreeSet implementation). In compareTo( ), note I use "simple obvious" form return i-i2. Although common programming error, would work properly i2 "unsigned" ints (if Java "unsigned" keyword, not). It breaks Java’s signed int, big enough represent difference two signed ints. If large positive integer j large negative integer, i-j overflow return negative value, work. You’ll usually want compareTo( ) method produce natural ordering consistent equals( ) method. If equals( ) produces true particular comparison, compareTo( ) produce zero result comparison, equals ( ) produces false comparison compareTo( ) produce nonzero result comparison. In TypesForSets, fill( ) test( ) defined using generics, order prevent code duplication. To verify behavior Set, test( ) calls fill( ) test set three times, attempting introduce duplicate objects. The fill( ) method takes Set type, Class object type. It uses Class object discover constructor takes int argument, calls constructor add elements Set. From output, see HashSet keeps elements mysterious order (which made clear later chapter), LinkedHashSet keeps elements order inserted, TreeSet maintains elements sorted order (because way compareTo( ) implemented, happens descending order). If try use types don’t properly support necessary operations Sets require operations, things go wrong. Placing SetType TreeType object, doesn’t include redefined hashCode( ) method, hashed implementations results duplicate values, primary contract Set violated. This rather disturbing there’s even runtime error. However, default hashCode( ) legitimate legal behavior, even it’s incorrect. The reliable way ensure correctness program incorporate unit tests build system (see supplement http://MindView.net/Books/BetterJava information). If try use type doesn’t implement Comparable TreeSet, get definitive result: An exception thrown TreeSet attempts use object Comparable. SortedSet Containers Depth 591 The elements SortedSet guaranteed sorted order, allows additional functionality provided following methods SortedSet interface: Comparator comparator( ): Produces Comparator used Set, null natural ordering. Object first( ): Produces lowest element. Object last( ): Produces highest element. SortedSet subSet(fromElement, toElement): Produces view Set elements fromElement, inclusive, toElement, exclusive. SortedSet headSet(toElement): Produces view Set elements less toElement. SortedSet tailSet(fromElement): Produces view Set elements greater equal fromElement. Here’s simple demonstration: //: containers/SortedSetDemo.java // What TreeSet. import java.util.*; import static net.mindview.util.Print.*; public class SortedSetDemo { public static void main(String[] args) { SortedSet<String> sortedSet = new TreeSet<String>(); Collections.addAll(sortedSet, "one two three four five six seven eight" .split(" ")); print(sortedSet); String low = sortedSet.first(); String high = sortedSet.last(); print(low); print(high); Iterator<String> = sortedSet.iterator(); for(int = 0; <= 6; i++) { if(i == 3) low = it.next(); if(i == 6) high = it.next(); else it.next(); } print(low); print(high); print(sortedSet.subSet(low, high)); print(sortedSet.headSet(high)); print(sortedSet.tailSet(low)); } } /* Output: [eight, five, four, one, seven, six, three, two] eight two one two [one, seven, six, three] [eight, five, four, one, seven, six, three] [one, seven, six, three, two] *///:~ Note SortedSet means "sorted according comparison function object," "insertion order." Insertion order preserved using LinkedHashSet. 592 Thinking Java Bruce Eckel Exercise 9: (2) Use RandomGenerator.String fill TreeSet, use alphabetic ordering. Print TreeSet verify sort order. Exercise 10: (7) Using LinkedList underlying implementation, define SortedSet. Containers Depth 593 Queues Other concurrency applications, two Java SE5 implementations Queue LinkedList PriorityQueue, differentiated ordering behavior rather performance. Here’s basic example involves Queue implementations (not work example), including concurrency-based Queues. You place elements one end extract other: //: containers/QueueBehavior.java // Compares behavior queues import java.util.concurrent.*; import java.util.*; import net.mindview.util.*; public class QueueBehavior { private static int count = 10; static <T> void test(Queue<T> queue, Generator<T> gen) { for(int = 0; < count; i++) queue.offer(gen.next()); while(queue.peek() != null) System.out.print(queue.remove() + " "); System.out.println(); } static class Gen implements Generator<String> { String[] = ("one two three four five six seven " + "eight nine ten").split(" "); int i; public String next() { return s[i++]; } } public static void main(String[] args) { test(new LinkedList<String>(), new Gen()); test(new PriorityQueue<String>(), new Gen()); test(new ArrayBlockingQueue<String>(count), new Gen()); test(new ConcurrentLinkedQueue<String>(), new Gen()); test(new LinkedBlockingQueue<String>(), new Gen()); test(new PriorityBlockingQueue<String>(), new Gen()); } } /* Output: one two three four five six seven eight nine ten eight five four nine one seven six ten three two one two three four five six seven eight nine ten one two three four five six seven eight nine ten one two three four five six seven eight nine ten eight five four nine one seven six ten three two *///:~ You see that, exception priority queues, Queue produce elements exactly order placed Queue. Priority queues Priority queues given simple introduction Holding Your Objects chapter. A interesting problem to-do list, object contains string primary secondary priority value. The ordering list controlled implementing Comparable: //: containers/ToDoList.java // A complex use PriorityQueue. import java.util.*; 594 Thinking Java Bruce Eckel class ToDoList extends PriorityQueue<ToDoList.ToDoItem> { static class ToDoItem implements Comparable<ToDoItem> { private char primary; private int secondary; private String item; public ToDoItem(String td, char pri, int sec) { primary = pri; secondary = sec; item = td; } public int compareTo(ToDoItem arg) { if(primary > arg.primary) return +1; if(primary == arg.primary) if(secondary > arg.secondary) return +1; else if(secondary == arg.secondary) return 0; return -1; } public String toString() { return Character.toString(primary) + secondary + ": " + item; } } public void add(String td, char pri, int sec) { super.add(new ToDoItem(td, pri, sec)); } public static void main(String[] args) { ToDoList toDoList = new ToDoList(); toDoList.add("Empty trash", ‘C’, 4); toDoList.add("Feed dog", ‘A’, 2); toDoList.add("Feed bird", ‘B’, 7); toDoList.add("Mow lawn", ‘C’, 3); toDoList.add("Water lawn", ‘A’, 1); toDoList.add("Feed cat", ‘B’, 1); while(!toDoList.isEmpty()) System.out.println(toDoList.remove()); } } /* Output: A1: Water lawn A2: Feed dog B1: Feed cat B7: Feed bird C3: Mow lawn C4: Empty trash *///:~ You see ordering items happens automatically priority queue. Exercise 11: (2) Create class contains Integer initialized value 100 using java.util.Random. Implement Comparable using Integer field. Fill PriorityQueue objects class, extract values using poll( ) show produces expected order. Deques Containers Depth 595 A deque (double-ended queue) like queue, add remove elements either end. There methods LinkedList support deque operations, explicit interface deque Java standard libraries. Thus, LinkedList cannot implement interface cannot upcast Deque interface Queue previous example. However, create Deque class using composition, simply expose relevant methods LinkedList: //: net/mindview/util/Deque.java // Creating Deque LinkedList. package net.mindview.util; import java.util.*; public class Deque<T> { private LinkedList<T> deque = new LinkedList<T>(); public void addFirst(T e) { deque.addFirst(e); } public void addLast(T e) { deque.addLast(e); } public T getFirst() { return deque.getFirst(); } public T getLast() { return deque.getLast(); } public T removeFirst() { return deque.removeFirst(); } public T removeLast() { return deque.removeLast(); } public int size() { return deque.size(); } public String toString() { return deque.toString(); } // And methods necessary... } ///:~ If put Deque use programs, may discover need add methods order make practical. Here’s simple test Deque class: //: containers/DequeTest.java import net.mindview.util.*; import static net.mindview.util.Print.*; public class DequeTest { static void fillTest(Deque<Integer> deque) { for(int = 20; < 27; i++) deque.addFirst(i); for(int = 50; < 55; i++) deque.addLast(i); } public static void main(String[] args) { Deque<Integer> di = new Deque<Integer>(); fillTest(di); print(di); while(di.size() != 0) printnb(di.removeFirst() + " "); print(); fillTest(di); while(di.size() != 0) printnb(di.removeLast() + " "); } } /* Output: [26, 25, 24, 23, 22, 21, 20, 50, 51, 52, 53, 54] 26 25 24 23 22 21 20 50 51 52 53 54 54 53 52 51 50 20 21 22 23 24 25 26 *///:~ It’s less likely you’ll put elements take ends, Deque commonly used Queue. 596 Thinking Java Bruce Eckel Containers Depth 597 Understanding Maps As learned Holding Your Objects chapter, basic idea map (also called associative array) maintains key-value associations (pairs) look value using key. The standard Java library contains different basic implementations Maps: HashMap, TreeMap, LinkedHashMap, WeakHashMap, ConcurrentHashMap, IdentityHashMap. They basic Map interface, differ behaviors including efficiency, order pairs held presented, long objects held map, map works multithreaded programs, key equality determined. The number implementations Map interface tell something importance tool. So gain deeper understanding Maps, helpful look associative array constructed. Here extremely simple implementation: //: containers/AssociativeArray.java // Associates keys values. import static net.mindview.util.Print.*; public class AssociativeArray<K,V> { private Object[][] pairs; private int index; public AssociativeArray(int length) { pairs = new Object[length][2]; } public void put(K key, V value) { if(index >= pairs.length) throw new ArrayIndexOutOfBoundsException(); pairs[index++] = new Object[]{ key, value }; } @SuppressWarnings("unchecked") public V get(K key) { for(int = 0; < index; i++) if(key.equals(pairs[i][0])) return (V)pairs[i][1]; return null; // Did find key } public String toString() { StringBuilder result = new StringBuilder(); for(int = 0; < index; i++) { result.append(pairs[i][0].toString()); result.append(" : "); result.append(pairs[i][1].toString()); if(i < index - 1) result.append("\n"); } return result.toString(); } public static void main(String[] args) { AssociativeArray<String,String> map = new AssociativeArray<String,String>(6); map.put("sky", "blue"); map.put("grass", "green"); map.put("ocean", "dancing"); map.put("tree", "tall"); map.put("earth", "brown"); map.put("sun", "warm"); try { map.put("extra", "object"); // Past end 598 Thinking Java Bruce Eckel } catch(ArrayIndexOutOfBoundsException e) { print("Too many objects!"); } print(map); print(map.get("ocean")); } } /* Output: Too many objects! sky : blue grass : green ocean : dancing tree : tall earth : brown sun : warm dancing *///:~ The essential methods associative array put( ) get( ), easy display, toString( ) overridden print key-value pairs. To show works, main( ) loads AssociativeArray pairs strings prints resulting map, followed get( ) one values. To use get( ) method, pass key want look up, produces associated value result returns null can’t found. The get( ) method using possibly least efficient approach imaginable locate value: starting top array using equals( ) compare keys. But point simplicity, efficiency. So version instructive, isn’t efficient fixed size, inflexible. Fortunately, Maps java.util problems substituted example. Exercise 12: (1) Substitute HashMap, TreeMap LinkedHashMap AssociativeArray .Java’s main( ). Exercise 13: (4) Use AssociativeArray Java create wordoccurrence counter, mapping String Integer. Using net.mindview.util.TextFile utility book, open text file break words file using whitespace punctuation, count occurrence words file. Performance Performance fundamental issue maps, it’s slow use linear search get( ) hunting key. This HashMap speeds things up. Instead slow search key, uses special value called hash code. The hash code way take information object question turn "relatively unique" int object. hashCode( ) method root class Object, Java objects produce hash code. A HashMap takes hashCode( ) object uses quickly hunt key. This results dramatic performance improvement. 6 Here basic Map implementations. The asterisk HashMap indicates that, absence constraints, default choice optimized 6 If speedups still don’t meet performance needs, accelerate table lookup writing Map customizing particular types avoid delays due casting Objects. To reach even higher levels performance, speed enthusiasts use Donald Knuth’s The Art Computer Programming, Volume 3: Sorting Searching, Second Edition, replace overflow bucket lists arrays two additional benefits: optimized disk storage characteristics save time creating garbage collecting individual records. Containers Depth 599 speed. The implementations emphasize characteristics, thus fast HashMap. HashMap* Implementation based hash table. (Use class instead Hashtable.) Provides constant-time performance inserting locating pairs. Performance adjusted via constructors allow set capacity load factor hash table. LinkedHashMap Like HashMap, iterate it, get pairs insertion order, least-recently-used (LRU) order. Only slightly slower HashMap, except iterating, faster due linked list used maintain internal ordering. TreeMap Implementation based red-black tree. When view keys pairs, sorted order (determined Comparable Comparator). The point TreeMap get results sorted order. TreeMap Map subMap( ) method, allows return portion tree. WeakHashMap A map weak keys allow objects referred map released; designed solve certain types problems. If references particular key held outside map, key may garbage collected. ConcurrentHashMap A thread-safe Map involve synchronization locking. This discussed Concurrency chapter. IdentityHashMap A hash map uses == instead equals( ) compare keys. Only solving special types problems; general use. Hashing commonly used way store elements map. Later, you’ll learn hashing works. The requirements keys used Map elements Set. You saw demonstrated TypesForSets.java. Any key must equals( ) method. If key used hashed Map, must also proper hashCode( ). If key used TreeMap, must implement Comparable. The following example shows operations available Map interface, using previously defined CountingMapData test data set: //: containers/Maps.java // Things Maps. import java.util.concurrent.*; import java.util.*; 600 Thinking Java Bruce Eckel import net.mindview.util.*; import static net.mindview.util.Print.*; public class Maps { public static void printKeys(Map<Integer,String> map) { printnb("Size = " + map.size() + ", "); printnb("Keys: "); print(map.keySet()); // Produce Set keys } public static void test(Map<Integer,String> map) { print(map.getClass().getSimpleName()); map.putAll(new CountingMapData(25)); // Map ‘Set’ behavior keys: map.putAll(new CountingMapData(25)); printKeys(map); // Producing Collection values: printnb("Values: "); print(map.values()); print(map); print("map.containsKey(11): " + map.containsKey(11)); print("map.get(11): " + map.get(11)); print("map.containsValue(\"F0\"): " + map.containsValue("F0")); Integer key = map.keySet().iterator().next(); print("First key map: " + key); map.remove(key); printKeys(map); map.clear(); print("map.isEmpty(): " + map.isEmpty()); map.putAll(new CountingMapData(25)); // Operations Set change Map: map.keySet().removeAll(map.keySet()); print("map.isEmpty(): " + map.isEmpty()); } public static void main(String[] args) { test(new HashMap<Integer,String>()); test(new TreeMap<Integer,String>()); test(new LinkedHashMap<Integer,String>()); test(new IdentityHashMap<Integer,String>()); test(new ConcurrentHashMap<Integer,String>()); test(new WeakHashMap<Integer,String>()); } } /* Output: HashMap Size = 25, Keys: [15, 8, 23, 16, 7, 22, 9, 21, 6, 1, 14, 24, 4, 19, 11, 18, 3, 12, 17, 2, 13, 20, 10, 5, 0] Values: [P0, I0, X0, Q0, H0, W0, J0, V0, G0, B0, O0, Y0, E0, T0, L0, S0, D0, M0, R0, C0, N0, U0, K0, F0, A0] {15=P0, 8=I0, 23=X0, 16=Q0, 7=H0, 22=W0, 9=J0, 21=V0, 6=G0, 1=B0, 14=O0, 24=Y0, 4=E0, 19=T0, 11=L0, 18=S0, 3=D0, 12=M0, 17=R0, 2=C0, 13=N0, 20=U0, 10=K0, 5=F0, 0=A0} map.containsKey(11): true map.get(11): L0 map.containsValue("F0"): true First key map: 15 Size = 24, Keys: [8, 23, 16, 7, 22, 9, 21, 6, 1, 14, 24, 4, 19, 11, 18, 3, 12, 17, 2, 13, 20, 10, 5, 0] map.isEmpty(): true map.isEmpty(): true ... *///:~ Containers Depth 601 The printKeys( ) method demonstrates produce Collection view Map. The keySet( ) method produces Set backed keys Map. Because improved printing support Java SE5, simply print result values( ) method, produces Collection containing values Map. (Note keys must unique, values may contain duplicates.) Since Collections backed Map, changes Collection reflected associated Map. The rest program provides simple examples Map operation tests basic type Map. Exercise 14: (3) Show java.util.Properties works program. SortedMap If SortedMap (of TreeMap one available), keys guaranteed sorted order, allows additional functionality provided methods SortedMap interface: Comparator comparator( ): Produces comparator used Map, null natural ordering. T firstKey( ): Produces lowest key. T lastKey( ): Produces highest key. SortedMap subMap(fromKey, toKey): Produces view Map keys fromKey, inclusive, toKey, exclusive. SortedMap headMap(toKey): Produces view Map keys less toKey. SortedMap tailMap(fromKey): Produces view Map keys greater equal fromKey. Here’s example that’s similar SortedSetDemo.java shows additional behavior TreeMaps: //: containers/SortedMapDemo.java // What TreeMap. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class SortedMapDemo { public static void main(String[] args) { TreeMap<Integer,String> sortedMap = new TreeMap<Integer,String>(new CountingMapData(10)); print(sortedMap); Integer low = sortedMap.firstKey(); Integer high = sortedMap.lastKey(); print(low); print(high); Iterator<Integer> = sortedMap.keySet().iterator(); for(int = 0; <= 6; i++) { 602 Thinking Java Bruce Eckel if(i == 3) low = it.next(); if(i == 6) high = it.next(); else it.next(); } print(low); print(high); print(sortedMap.subMap(low, high)); print(sortedMap.headMap(high)); print(sortedMap.tailMap(low)); } } /* Output: {0=A0, 1=B0, 0 9 3 7 {3=D0, 4=E0, {0=A0, 1=B0, {3=D0, 4=E0, *///:~ 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 7=H0, 8=I0, 9=J0} 5=F0, 6=G0} 2=C0, 3=D0, 4=E0, 5=F0, 6=G0} 5=F0, 6=G0, 7=H0, 8=I0, 9=J0} Here, pairs stored key-sorted order. Because sense order TreeMap, concept "location" makes sense, first last elements submaps. LinkedHashMap The LinkedHashMap hashes everything speed, also produces pairs insertion order traversal (System.out.println( ) iterates map, see results traversal). In addition, LinkedHashMap configured constructor use leastrecently- used (LRU) algorithm based accesses, elements haven’t accessed (and thus candidates removal) appear front list. This allows easy creation programs periodic cleanup order save space. Here’s simple example showing features: //: containers/LinkedHashMapDemo.java // What LinkedHashMap. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class LinkedHashMapDemo { public static void main(String[] args) { LinkedHashMap<Integer,String> linkedMap = new LinkedHashMap<Integer,String>( new CountingMapData(9)); print(linkedMap); // Least-recently-used order: linkedMap = new LinkedHashMap<Integer,String>(16, 0.75f, true); linkedMap.putAll(new CountingMapData(9)); print(linkedMap); for(int = 0; < 6; i++) // Cause accesses: linkedMap.get(i); print(linkedMap); linkedMap.get(0); print(linkedMap); } } /* Output: {0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 7=H0, 8=I0} Containers Depth 603 {0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 6=G0, 7=H0, 8=I0} {6=G0, 7=H0, 8=I0, 0=A0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0} {6=G0, 7=H0, 8=I0, 1=B0, 2=C0, 3=D0, 4=E0, 5=F0, 0=A0} *///:~ You see output pairs indeed traversed insertion order, even LRU version. However, first six items (only) accessed LRU version, last three items move front list. Then, "o" accessed again, moves back list. 604 Thinking Java Bruce Eckel Hashing hash codes The examples Holding Your Objects chapter used predefined classes HashMap keys. These examples worked predefined classes necessary wiring make behave correctly keys. A common pitfall occurs create classes used keys HashMaps, forget put necessary wiring. For example, consider weather predicting system matches Groundhog objects Prediction objects. This seems fairly straightforward—you create two classes, use Groundhog key Prediction value: //: containers/Groundhog.java // Looks plausible, doesn’t work HashMap key. public class Groundhog { protected int number; public Groundhog(int n) { number = n; } public String toString() { return "Groundhog #" + number; } } ///:~ //: containers/Prediction.java // Predicting weather groundhogs. import java.util.*; public class Prediction { private static Random rand = new Random(47); private boolean shadow = rand.nextDouble() > 0.5; public String toString() { if(shadow) return "Six weeks Winter!"; else return "Early Spring!"; } } ///:~ //: containers/SpringDetector.java // What weather be? import java.lang.reflect.*; import java.util.*; import static net.mindview.util.Print.*; public class SpringDetector { // Uses Groundhog class derived Groundhog: public static <T extends Groundhog> void detectSpring(Class<T> type) throws Exception { Constructor<T> ghog = type.getConstructor(int.class); Map<Groundhog,Prediction> map = new HashMap<Groundhog,Prediction>(); for(int = 0; < 10; i++) map.put(ghog.newInstance(i), new Prediction()); print("map = " + map); Groundhog gh = ghog.newInstance(3); print("Looking prediction " + gh); if(map.containsKey(gh)) print(map.get(gh)); else print("Key found: " + gh); } public static void main(String[] args) throws Exception { detectSpring(Groundhog.class); Containers Depth 605 } } /* Output: map = {Groundhog #3=Early Spring!, Groundhog #7=Early Spring!, Groundhog #5=Early Spring!, Groundhog #9=Six weeks Winter!, Groundhog #8=Six weeks Winter!, Groundhog #0=Six weeks Winter!, Groundhog #6=Early Spring!, Groundhog #4=Six weeks Winter!, Groundhog #1=Six weeks Winter!, Groundhog #2=Early Spring!} Looking prediction Groundhog #3 Key found: Groundhog #3 *///:~ Each Groundhog given identity number, look Prediction HashMap saying, "Give Prediction associated Groundhog #3." The Prediction class contains boolean initialized using java.util.random( ) toString( ) interprets result you. The detectSpring( ) method created using reflection instantiate use class Groundhog class derived Groundhog. This come handy later, inherit new type Groundhog solve problem demonstrated here. A HashMap filled Groundhogs associated Predictions. The HashMap printed see filled. Then Groundhog identity number 3 used key look prediction Groundhog #3 (which see must Map). It seems simple enough, doesn’t work—it can’t find key #3. The problem Groundhog automatically inherited common root class Object, Object’s hashCode( ) method used generate hash code object. By default uses address object. Thus, first instance Groundhog(3) produce hash code equal hash code second instance Groundhog(3) tried use lookup. You might think need write appropriate override hashCode( ). But still won’t work you’ve done one thing: override equals( ) also part Object.equals( ) used HashMap trying determine key equal keys table. A proper equals( ) must satisfy following five conditions: 1. Reflexive: For x, x.equals(x) return true. 2. Symmetric: For x y, x.equals(y) return true y.equals(x) returns true. 3. Transitive: For x, y, z, x.equals(y) returns true y.equals(z) returns true, x.equals(z) return true. 4. Consistent: For x y, multiple invocations x.equals(y) consistently return true consistently return false, provided information used equals comparisons object modified. 5. For non-null x, x.equals(null) return false. Again, default Object.equals( ) simply compares object addresses, one Groundhog(3) equal another Groundhog(3). Thus, use classes keys HashMap, must override hashCode( ) equals( ), shown following solution groundhog problem: //: containers/Groundhog2.java 606 Thinking Java Bruce Eckel // A class that’s used key HashMap // must override hashCode() equals(). public class Groundhog2 extends Groundhog { public Groundhog2(int n) { super(n); } public int hashCode() { return number; } public boolean equals(Object o) { return instanceof Groundhog2 && (number == ((Groundhog2)o).number); } } ///:~ //: containers/SpringDetector2.java // A working key. public class SpringDetector2 { public static void main(String[] args) throws Exception { SpringDetector.detectSpring(Groundhog2.class); } } /* Output: map = {Groundhog #2=Early Spring!, Groundhog #4=Six weeks Winter!, Groundhog #9=Six weeks Winter!, Groundhog #8=Six weeks Winter!, Groundhog #6=Early Spring!, Groundhog #1=Six weeks Winter!, Groundhog #3=Early Spring!, Groundhog #7=Early Spring!, Groundhog #5=Early Spring!, Groundhog #0=Six weeks Winter!} Looking prediction Groundhog #3 Early Spring! *///:~ Groundhog2.hashCode( ) returns groundhog number hash value. In example, programmer responsible ensuring two groundhogs exist ID number. The hashCode( ) required return unique identifier (something you’ll understand better later chapter), equals( ) method must strictly determine whether two objects equivalent. Here, equals( ) based groundhog number, two Groundhog2 objects exist keys HashMap groundhog number, fail. Even though appears equals( ) method checking see whether argument instance Groundhog2 (using instanceof keyword, explained Type Information chapter), instanceof actually quietly second sanity check see object null, since instanceof produces false left-hand argument null. Assuming it’s correct type null, comparison based actual number values object. You see output behavior correct. When creating class use HashSet, must pay attention issues used key HashMap. Understanding hashCodeQ The preceding example start toward solving problem correctly. It shows override hashCode( ) equals( ) key, hashed data structure (HashSet, HashMap, LinkedHashSet, LinkedHashMap) probably won’t deal key properly. For good solution problem, however, need understand what’s going inside hashed data structure. First, consider motivation behind hashing: You want look object using another object. But also accomplish TreeMap, even implement Containers Depth 607 Map. In contrast hashed implementation, following example implements Map using pair ArrayLists. Unlike AssociativeArray.java, includes full implementation Map interface, accounts entrySet( ) method: //: containers/SlowMap.java // A Map implemented ArrayLists. import java.util.*; import net.mindview.util.*; public class SlowMap<K,V> extends AbstractMap<K,V> { private List<K> keys = new ArrayList<K>(); private List<V> values = new ArrayList<V>(); public V put(K key, V value) { V oldValue = get(key); // The old value null if(!keys.contains(key)) { keys.add(key); values.add(value); } else values.set(keys.indexOf(key), value); return oldValue; } public V get(Object key) { // key type Object, K if(!keys.contains(key)) return null; return values.get(keys.indexOf(key)); } public Set<Map.Entry<K,V>> entrySet() { Set<Map.Entry<K,V>> set= new HashSet<Map.Entry<K,V>>(); Iterator<K> ki = keys.iterator(); Iterator<V> vi = values.iterator(); while(ki.hasNext()) set.add(new MapEntry<K,V>(ki.next(), vi.next())); return set; } public static void main(String[] args) { SlowMap<String,String> m= new SlowMap<String,String>(); m.putAll(Countries.capitals(15)); System.out.println(m); System.out.println(m.get("BULGARIA")); System.out.println(m.entrySet()); } } /* Output: {CAMEROON=Yaounde, CHAD=N’djamena, CONGO=Brazzaville, CAPE VERDE=Praia, ALGERIA=Algiers, COMOROS=Moroni, CENTRAL AFRICAN REPUBLIC=Bangui, BOTSWANA=Gaberone, BURUNDI=Bujumbura, BENIN=Porto-Novo, BULGARIA=Sofia, EGYPT=Cairo, ANGOLA=Luanda, BURKINA FASO=Ouagadougou, DJIBOUTI=Dijibouti} Sofia [CAMEROON=Yaounde, CHAD=N’djamena, CONGO=Brazzaville, CAPE VERDE=Praia, ALGERIA=Algiers, COMOROS=Moroni, CENTRAL AFRICAN REPUBLIC=Bangui, BOTSWANA=Gaberone, BURUNDI=Bujumbura, BENIN=Porto-Novo, BULGARIA=Sofia, EGYPT=Cairo, ANGOLA=Luanda, BURKINA FASO=Ouagadougou, DJIBOUTI=Dijibouti] *///:~ The put( ) method simply places keys values corresponding ArrayLists. In accordance Map interface, must return old key null old key. Also following specifications Map, get( ) produces null key SlowMap. If key exists, used look numerical index indicating location keys List, number used index produce associated value values List. Notice type key Object get( ), rather 608 Thinking Java Bruce Eckel parameterized type K might expect (and indeed used AssociativeArray.java). This result injection generics Java language late date—if generics original feature language, get( ) could specified type parameter. The Map.entrySet( ) method must produce set Map.Entry objects. However, Map.Entry interface describing implementationdependent structure, want make type Map, must also define implementation Map.Entry: //: containers/MapEntry.java // A simple Map.Entry sample Map implementations. import java.util.*; public class MapEntry<K,V> implements Map.Entry<K,V> { private K key; private V value; public MapEntry(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } public V setValue(V v) { V result = value; value = v; return result; } public int hashCode() { return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); } public boolean equals(Object o) { if(!(o instanceof MapEntry)) return false; MapEntry = (MapEntry)o; return (key == null ? me.getKey() == null : key.equals(me.getKey())) && (value == null ? me.getValue()== null : value.equals(me.getValue())); } public String toString() { return key + "=" + value; } } ///:~ Here, simple class called MapEntry holds retrieves keys values. This used entrySet( ) produce Set key-value pairs. Notice entrySet( ) uses HashSet hold pairs, MapEntry takes simple approach using key’s hashCode( ). Although solution simple, appears work trivial test SlowMap.main( ), correct implementation copy keys values made. A correct implementation entrySet( ) provide view Map, rather copy, view allow modification original map (which copy doesn’t). Exercise 16 provides opportunity repair problem. Note equals( ) method MapEntry must check keys values. The meaning hashCode( ) method described shortly. The String representation contents SlowMap automatically produced toString( ) method defined AbstractMap. In SlowMap.main( ), SlowMap loaded contents displayed. A call get( ) shows works. Containers Depth 609 Exercise 15: (1) Repeat Exercise 13 using SlowMap. Exercise 16: (7) Apply tests Maps.java SlowMap verify works. Fix anything SlowMap doesn’t work correctly. Exercise 17: (2) Implement rest Map interface SlowMap. Exercise 18: (3) Using SlowMap.java inspiration, create SlowSet. Hashing speed SlowMap.java shows it’s hard produce new type Map. But name suggests, SlowMap isn’t fast, probably wouldn’t use alternative available. The problem lookup key; keys kept particular order, simple linear search used. A linear search slowest way find something. The whole point hashing speed: Hashing allows lookup happen quickly. Since bottleneck speed key lookup, one solutions problem keep keys sorted use Collections.binarySearch( ) perform lookup (an exercise walk process). Hashing goes saying want store key somewhere way found quickly. The fastest structure store group elements array, used representing key information (note I said "key information," key itself). But array cannot resized, problem: We want store indeterminate number values Map, number keys fixed array size, be? The answer array hold keys. From key object, number derived index array. This number hash code, produced hashCode( ) method (in computer science parlance, hash function) defined Object presumably overridden class. To solve problem fixed-size array, one key may produce index. That is, may collisions. Because this, doesn’t matter big array is; key object’s hash code land somewhere array. So process looking value starts computing hash code using index array. If could guarantee collisions (which possible fixed number values), you’d perfect hashing junction, that’s special case 7 In cases, collisions handled external chaining: The array doesn’t point directly value, instead list values. These values searched linear fashion using equals( ) method. Of course, aspect search much slower, hash function good, values slot. So instead searching entire list, quickly jump slot compare entries find value. This much faster, HashMap quick. Knowing basics hashing, implement simple hashed Map: //: containers/SimpleHashMap.java // A demonstration hashed Map. import java.util.*; import net.mindview.util.*; 7 The case perfect hashing function implemented Java SE5 EnumMap EnumSet, enum defines fixed number instances. See Enumerated Types chapter. 610 Thinking Java Bruce Eckel public class SimpleHashMap<K,V> extends AbstractMap<K,V> { // Choose prime number hash table // size, achieve uniform distribution: static final int SIZE = 997; // You can’t physical array generics, // upcast one: @SuppressWarnings("unchecked") LinkedList<MapEntry<K,V>>[] buckets = new LinkedList[SIZE]; public V put(K key, V value) { V oldValue = null; int index = Math.abs(key.hashCode()) % SIZE; if(buckets[index] == null) buckets[index] = new LinkedList<MapEntry<K,V>>(); LinkedList<MapEntry<K,V>> bucket = buckets[index]; MapEntry<K,V> pair = new MapEntry<K,V>(key, value); boolean found = false; ListIterator<MapEntry<K,V>> = bucket.listIterator(); while(it.hasNext()) { MapEntry<K,V> iPair = it.next(); if(iPair.getKey().equals(key)) { oldValue = iPair.getValue(); it.set(pair); // Replace old new found = true; break; } } if(!found) buckets[index].add(pair); return oldValue; } public V get(Object key) { int index = Math.abs(key.hashCode()) % SIZE; if(buckets[index] == null) return null; for(MapEntry<K,V> iPair : buckets[index]) if(iPair.getKey().equals(key)) return iPair.getValue(); return null; } public Set<Map.Entry<K,V>> entrySet() { Set<Map.Entry<K,V>> set= new HashSet<Map.Entry<K,V>>(); for(LinkedList<MapEntry<K,V>> bucket : buckets) { if(bucket == null) continue; for(MapEntry<K,V> mpair : bucket) set.add(mpair); } return set; } public static void main(String[] args) { SimpleHashMap<String,String> = new SimpleHashMap<String,String>(); m.putAll(Countries.capitals(25)); System.out.println(m); System.out.println(m.get("ERITREA")); System.out.println(m.entrySet()); } } /* Output: {CAMEROON=Yaounde, CONGO=Brazzaville, CHAD=N’djamena, COTE D’IVOIR (IVORY COAST)=Yamoussoukro, CENTRAL AFRICAN REPUBLIC=Bangui, GUINEA=Conakry, BOTSWANA=Gaberone, BISSAU=Bissau, EGYPT=Cairo, ANGOLA=Luanda, BURKINA FASO=Ouagadougou, ERITREA=Asmara, THE GAMBIA=Banjul, KENYA=Nairobi, GABON=Libreville, CAPE VERDE=Praia, Containers Depth 611 ALGERIA=Algiers, COMOROS=Moroni, EQUATORIAL GUINEA=Malabo, BURUNDI=Bujumbura, BENIN=Porto-Novo, BULGARIA=Sofia, GHANA=Accra, DJIBOUTI=Dijibouti, ETHIOPIA=Addis Ababa} Asmara [CAMEROON=Yaounde, CONGO=Brazzaville, CHAD=N’djamena, COTE D’IVOIR (IVORY COAST)=Yamoussoukro, CENTRAL AFRICAN REPUBLIC=Bangui, GUINEA=Conakry, BOTSWANA=Gaberone, BISSAU=Bissau, EGYPT=Cairo, ANGOLA=Luanda, BURKINA FASO=Ouagadougou, ERITREA=Asmara, THE GAMBIA=Banjul, KENYA=Nairobi, GABON=Libreville, CAPE VERDE=Praia, ALGERIA=Algiers, COMOROS=Moroni, EQUATORIAL GUINEA=Malabo, BURUNDI=Bujumbura, BENIN=Porto-Novo, BULGARIA=Sofia, GHANA=Accra, DJIBOUTI=Dijibouti, ETHIOPIA=Addis Ababa] *///:~ Because "slots" hash table often referred buckets, array represents actual table called buckets. To promote even distribution, number buckets typically prime number. 8 Notice array LinkedList, automatically provides collisions: Each new item simply added end list particular bucket. Even though Java let create array generics, possible make reference array. Here, convenient upcast array, prevent extra casting later code. For put( ), hashCode( ) called key result forced positive number. To fit resulting number buckets array, modulus operator used size array. If location null, means elements hash location, new LinkedList created hold object hash location. However, normal process look list see duplicates, are, old value put oldValue new value replaces old. The found flag keeps track whether old key-value pair found and, not, new pair appended end list. The get( ) calculates index buckets array fashion put( ) (this important order guarantee end spot). If LinkedList exists, searched match. Note implementation meant tuned performance; intended show operations performed hash map. If look source code java.util.HashMap, you’ll see tuned implementation. Also, simplicity SimpleHashMap uses approach entrySet( ) SlowMap, oversimplified work general-purpose Map. Exercise 19: (1) Repeat Exercise 13 using SimpleHashMap. Exercise 20: (3) Modify SimpleHashMap reports collisions, test adding data set twice see collisions. Exercise 21: (2) Modify SimpleHashMap reports number "probes" necessary collisions occur. That is, many calls next( ) must made Iterators walk LinkedLists looking matches? Exercise 22: (4) Implement clear( ) remove( ) methods SimpleHashMap. As turns out, prime number actually ideal size hash buckets, recent hashed implementations Java use power-of-two size (after extensive testing). Division remainder slowest operation modern processor. With power-of-two hash table length, masking used instead division. Since get( ) far common operation, % large part cost, power-of-two approach eliminates (but may also affect hashCode( ) methods). 8 612 Thinking Java Bruce Eckel Exercise 23: (3) Implement rest Map interface SimpleHashMap. Exercise 24: (5) Following example SimpleHashMap.java, create test SimpleHashSet. Exercise 25: (6) Instead using Listlterator bucket, modify MapEntry self-contained singly linked list (each MapEntry forward link next MapEntry). Modify rest code SimpleHashMap.java new approach works correctly. Overriding hashCode() Now understand hashing works, writing hashCode( ) method make sense. First all, don’t control creation actual value that’s used index array buckets. That dependent capacity particular HashMap object, capacity changes depending full container is, load factor (this term described later). Thus, value produced hashCode( ) processed order create bucket index (in SimpleHashMap, calculation modulo size bucket array). The important factor creating hashCode( ) that, regardless hashCode( ) called, produces value particular object every time called. If end object produces one hashCode( ) value put( ) HashMap another get( ), won’t able retrieve objects. So hashCode( ) depends mutable data object, user must made aware changing data produce different key generates different hashCode( ). In addition, probably want generate hashCode( ) based unique object information—in particular, value makes bad hashCode( ) can’t generate new key identical one used put( ) original key-value pair. This problem occurred SpringDetector.java, default implementation hashCode( ) use object address. So you’ll want use information object identifies object meaningful way. One example seen String class. Strings special characteristic program several String objects contain identical character sequences, String objects map memory. So makes sense hashCode( ) produced two separate instances String "hello" identical. You see following program: //: containers/StringHashCode.java public class StringHashCode { public static void main(String[] args) { String[] hellos = "Hello Hello".split(" "); System.out.println(hellos[0].hashCode()); System.out.println(hellos[1].hashCode()); } } /* Output: (Sample) 69609650 69609650 *///:~ The hashCode( ) String clearly based contents String. Containers Depth 613 So, hashCode( ) effective, must fast must meaningful; is, must generate value based contents object. Remember value doesn’t unique—you lean toward speed rather uniqueness—but hashCode( ) equals( ), identity object must completely resolved. Because hashCode( ) processed bucket index produced, range values important; needs generate int. There’s one factor: A good hashCode( ) result even distribution values. If values tend cluster, HashMap HashSet heavily loaded areas fast evenly distributed hashing function. In Effective Java™ Programming Language Guide (Addison-Wesley, 2001), Joshua Bloch gives basic recipe generating decent hashCode( ): 1. Store constant nonzero value, say 17, int variable called result. 2. For significant field fin object (that is, field taken account equals( ) method), calculate int hash code c field: Field type Calculation boolean c = ( f ? 0 : 1) byte, char, short, int c = (int)f long c = (int)(f ^ (f>>>32)) float c = Float.floatToIntBits(f); double long l = Double.doubleToLongBits(f); c = (int)(1 ^ (l>>>32)) Object, equals( ) calls equals( ) field c = f.hashCode( ) Array Apply rules element 3. Combine hash code(s) computed above: result = 37 * result + c; 4. Return result. 5. Look resulting hashCode( ) make sure equal instances equal hash codes. Here’s example follows guidelines: //: containers/CountedString.java // Creating good hashCode(). import java.util.*; import static net.mindview.util.Print.*; public class CountedString { private static List<String> created = new ArrayList<String>(); 614 Thinking Java Bruce Eckel private String s; private int id = 0; public CountedString(String str) { = str; created.add(s); // id total number instances // string use CountedString: for(String s2 : created) if(s2.equals(s)) id++; } public String toString() { return "String: " + + " id: " + id + " hashCode(): " + hashCode(); } public int hashCode() { // The simple approach: // return s.hashCode() * id; // Using Joshua Bloch’s recipe: int result = 17; result = 37 * result + s.hashCode(); result = 37 * result + id; return result; } public boolean equals(Object o) { return instanceof CountedString && s.equals(((CountedString)o).s) && id == ((CountedString)o).id; } public static void main(String[] args) { Map<CountedString,Integer> map = new HashMap<CountedString,Integer>(); CountedString[] cs = new CountedString[5]; for(int = 0; < cs.length; i++) { cs[i] = new CountedString("hi"); map.put(cs[i], i); // Autobox int -> Integer } print(map); for(CountedString cstring : cs) { print("Looking " + cstring); print(map.get(cstring)); } } } /* Output: (Sample) {String: hi id: 4 hashCode(): 146450=3, String: hi id: 1 hashCode(): 146447=0, String: hi id: 3 hashCode(): 146449=2, String: hi id: 5 hashCode(): 146451=4, String: hi id: 2 hashCode(): 146448=1} Looking String: hi id: 1 hashCode(): 146447 0 Looking String: hi id: 2 hashCode(): 146448 1 Looking String: hi id: 3 hashCode(): 146449 2 Looking String: hi id: 4 hashCode(): 146450 3 Looking String: hi id: 5 hashCode(): 146451 4 *///:~ CountedString includes String id represents number CountedString objects contain identical String. The counting accomplished constructor iterating static ArrayList Strings stored. Containers Depth 615 Both hashCode( ) equals( ) produce results based fields; based String alone id alone, would duplicate matches distinct values. In main( ), several CountedString objects created using String, show duplicates create unique values count id. The HashMap displayed see stored internally (no discernible orders), key looked individually demonstrate lookup mechanism working properly. As second example, consider Individual class used base class typeinfo.pet library defined Type Information chapter. The Individual class used chapter definition delayed chapter could properly understand implementation: //: typeinfo/pets/Individual.java package typeinfo.pets; public class Individual implements Comparable<Individual> { private static long counter = 0; private final long id = counter++; private String name; public Individual(String name) { this.name = name; } // ‘name’ optional: public Individual() {} public String toString() { return getClass().getSimpleName() + (name == null ? "" : " " + name); } public long id() { return id; } public boolean equals(Object o) { return instanceof Individual && id == ((Individual)o).id; } public int hashCode() { int result = 17; if(name != null) result = 37 * result + name.hashCode(); result = 37 * result + (int)id; return result; } public int compareTo(Individual arg) { // Compare class name first: String first = getClass().getSimpleName(); String argFirst = arg.getClass().getSimpleName(); int firstCompare = first.compareTo(argFirst); if(firstCompare != 0) return firstCompare; if(name != null && arg.name != null) { int secondCompare = name.compareTo(arg.name); if(secondCompare != 0) return secondCompare; } return (arg.id < id ? -1 : (arg.id == id ? 0 : 1)); } } ///:~ The compareTo( ) method hierarchy comparisons, produce sequence sorted first actual type, name one, finally falls back creation order. Here’s example shows works: //: containers/IndividualTest.java 616 Thinking Java Bruce Eckel import holding.MapOfList; import typeinfo.pets.*; import java.util.*; public class IndividualTest { public static void main(String[] args) { Set<Individual> pets = new TreeSet<Individual>(); for(List<? extends Pet> lp : MapOfList.petPeople.values()) for(Pet p : lp) pets.add(p); System.out.println(pets); } } /* Output: [Cat Elsie May, Cat Pinkola, Cat Shackleton, Cat Stanford aka Stinky el Negro, Cymric Molly, Dog Margrett, Mutt Spot, Pug Louie aka Louis Snorkelstein Dupree, Rat Fizzy, Rat Freckly, Rat Fuzzy] *///:~ Since pets names, sorted first type, name within type. Writing proper hashCode( ) equals( ) new class tricky. You find tools help Apache’s "Jakarta Commons" project atjakarta.apache.org/commons, "lang" (this project also many potentially useful libraries, appears Java community’s answer C++ community’s www.boost.org). Exercise 26: (2) Add char field CountedString also initialized constructor, modify hashCode( ) equals( ) methods include value char. Exercise 27: (3) Modify hashCode( ) CountedString.java removing combination id, demonstrate CountedString still works key. What problem approach? Exercise 28: (4) Modify net/mindview/util/Tuple.java make general-purpose class adding hashCode( ), equals( ), implementing Comparable type Tuple. Choosing implementation By understand although four fundamental container types—Map, List, Set, Queue—there one implementation interface. If need use functionality offered particular interface, decide implementation use? Each different implementation features, strengths, weaknesses. For example, see figure beginning chapter "feature" Hashtable, Vector, Stack legacy classes, old code doesn’t break (it’s best don’t use new code). The different types Queues Java library differentiated way accept produce values (you’ll see importance Concurrency chapter). The distinction containers often comes "backed by"—that is, data structures physically implement desired interface. For example, ArrayList LinkedList implement List interface, basic List operations Containers Depth 617 regardless one use. However, ArrayList backed array, LinkedList implemented usual way doubly linked list, individual objects containing data along references previous next elements list. Because this, want many insertions removals middle list, LinkedList appropriate choice. (LinkedList also additional functionality established AbstractSequentialList.) If not, ArrayList typically faster. As another example, Set implemented either TreeSet, HashSet, LinkedHashSet. 9 Each one different behaviors: HashSet typical use provides raw speed lookup, LinkedHashSet keeps pairs insertion order, TreeSet backed TreeMap designed produce constantly sorted set. You choose implementation based behavior need. Sometimes different implementations particular container operations common, performance operations different. In case, you’ll choose implementations based often use particular operation, fast need be. For cases like this, one way look differences container implementations performance test. A performance test framework To prevent code duplication provide consistency among tests, I’ve put basic functionality test process framework. The following code establishes base class create list anonymous inner classes, one different test. Each inner classes called part testing process. This approach allows easily add remove new kinds tests. This another example Template Method design pattern. Although follow typical Template Method approach overriding method Test.test( ) particular test, case core code (that doesn’t change) separate Tester class. 10 The type container test generic parameter C: //: containers/Test.java // Framework performing timed tests containers. public abstract class Test<C> { String name; public Test(String name) { this.name = name; } // Override method different tests. // Returns actual number repetitions test. abstract int test(C container, TestParam tp); } ///:~ Each Test object stores name test. When call test( ) method, must given container tested along "messenger" "data transfer object" holds various parameters particular test. The parameters include size, indicating number elements container, loops, controls number iterations test. These parameters may may used every test. Each container undergo sequence calls test( ), different TestParam, TestParam also contains static array( ) methods make easy create arrays TestParam objects. The first version array( ) takes variable argument list containing alternating size loops values, second version takes kind list except Or EnumSet CopyOnWriteArraySet, special cases. While acknowledging maybe additional specialized implementations various container interfaces, section attempts look general cases. 9 10 618 Krzysztof Sobolewski assisted figuring generics example. Thinking Java Bruce Eckel values inside Strings—this way, used parse commandline arguments: //: containers/TestParam.java // A "data transfer object." public class TestParam { public final int size; public final int loops; public TestParam(int size, int loops) { this.size = size; this.loops = loops; } // Create array TestParam varargs sequence: public static TestParam[] array(int... values) { int size = values.length/2; TestParam[] result = new TestParam[size]; int n = 0; for(int = 0; < size; i++) result[i] = new TestParam(values[n++], values[n++]); return result; } // Convert String array TestParam array: public static TestParam[] array(String[] values) { int[] vals = new int[values.length]; for(int = 0; < vals.length; i++) vals[i] = Integer.decode(values[i]); return array(vals); } } ///:~ To use framework, pass container tested along List Test objects Tester.run( ) method (these overloaded generic convenience methods reduce amount typing necessary use them). Tester.run( ) calls appropriate overloaded constructor, calls timedTest( ), executes test list container. timedTest( ) repeats test TestParam objects paramList. Because paramList initialized static defaultParams array, change paramList tests reassigning defaultParams, change paramList one test passing custom paramList test: //: containers/Tester.java // Applies Test objects lists different containers. import java.util.*; public class Tester<C> { public static int fieldWidth = 8; public static TestParam[] defaultParams= TestParam.array( 10, 5000, 100, 5000, 1000, 5000, 10000, 500); // Override modify pre-test initialization: protected C initialize(int size) { return container; } protected C container; private String headline = ""; private List<Test<C>> tests; private static String stringField() { return "%" + fieldWidth + "s"; } private static String numberField() { return "%" + fieldWidth + "d"; } private static int sizeWidth = 5; private static String sizeField = "%" + sizeWidth + "s"; private TestParam[] paramList = defaultParams; Containers Depth 619 public Tester(C container, List<Test<C>> tests) { this.container = container; this.tests = tests; if(container != null) headline = container.getClass().getSimpleName(); } public Tester(C container, List<Test<C>> tests, TestParam[] paramList) { this(container, tests); this.paramList = paramList; } public void setHeadline(String newHeadline) { headline = newHeadline; } // Generic methods convenience : public static <C> void run(C cntnr, List<Test<C>> tests){ new Tester<C>(cntnr, tests).timedTest(); } public static <C> void run(C cntnr, List<Test<C>> tests, TestParam[] paramList) { new Tester<C>(cntnr, tests, paramList).timedTest(); } private void displayHeader() { // Calculate width pad ‘-’: int width = fieldWidth * tests.size() + sizeWidth; int dashLength = width - headline.length() - 1; StringBuilder head = new StringBuilder(width); for(int = 0; < dashLength/2; i++) head.append(‘-’); head.append(‘ ‘); head.append(headline); head.append(‘ ‘); for(int = 0; < dashLength/2; i++) head.append(‘-’); System.out.println(head); // Print column headers: System.out.format(sizeField, "size"); for(Test test : tests) System.out.format(stringField(), test.name); System.out.println(); } // Run tests container: public void timedTest() { displayHeader(); for(TestParam param : paramList) { System.out.format(sizeField, param.size); for(Test<C> test : tests) { C kontainer = initialize(param.size); long start = System.nanoTime(); // Call overriden method: int reps = test.test(kontainer, param); long duration = System.nanoTime() - start; long timePerRep = duration / reps; // Nanoseconds System.out.format(numberField(), timePerRep); } System.out.println(); } } } ///:~ The stringField( ) numberField( ) methods produce formatting strings outputting results. The standard width formatting changed modifying 620 Thinking Java Bruce Eckel static fieldWidth value. The displayHeader( ) method formats prints header information test. If need perform special initialization, override initialize( ) method. This produces initialized container object appropriate size—you either modify existing container object create new one. You see test( ) result captured local reference called kontainer, allows replace stored member container completely different initialized container. The return value Test.test( ) method must number operations performed test, used calculate number nanoseconds required operation. You aware System.nanoTime( ) typically produces values granularity greater one (and granularity vary machines operating systems), produce certain amount rattle results. The results may vary machine machine; tests intended compare performance different containers. Choosing Lists Here performance test essential List operations. For comparison, also shows important Queue operations. Two separate lists tests created testing class container. In case, Queue operations apply LinkedLists. //: containers/ListPerformance.java // Demonstrates performance differences Lists. // {Args: 100 500} Small keep build testing short import java.util.*; import net.mindview.util.*; public class ListPerformance { static Random rand = new Random(); static int reps = 1000; static List<Test<List<Integer>>> tests = new ArrayList<Test<List<Integer>>>(); static List<Test<LinkedList<Integer>>> qTests = new ArrayList<Test<LinkedList<Integer>>>(); static { tests.add(new Test<List<Integer>>("add") { int test(List<Integer> list, TestParam tp) { int loops = tp.loops; int listSize = tp.size; for(int = 0; < loops; i++) { list.clear(); for(int j = 0; j < listSize; j++) list.add(j); } return loops * listSize; } }); tests.add(new Test<List<Integer>>("get") { int test(List<Integer> list, TestParam tp) { int loops = tp.loops * reps; int listSize = list.size(); for(int = 0; < loops; i++) list.get(rand.nextInt(listSize)); return loops; } }); tests.add(new Test<List<Integer>>("set") { Containers Depth 621 int test(List<Integer> list, TestParam tp) { int loops = tp.loops * reps; int listSize = list.size(); for(int = 0; < loops; i++) list.set(rand.nextInt(listSize), 47); return loops; } }); tests.add(new Test<List<Integer>>("iteradd") { int test(List<Integer> list, TestParam tp) { final int LOOPS = 1000000; int half = list.size() / 2; ListIterator<Integer> = list.listIterator(half); for(int = 0; < LOOPS; i++) it.add(47); return LOOPS; } }); tests.add(new Test<List<Integer>>("insert") { int test(List<Integer> list, TestParam tp) { int loops = tp.loops; for(int = 0; < loops; i++) list.add(5, 47); // Minimize random-access cost return loops; } }); tests.add(new Test<List<Integer>>("remove") { int test(List<Integer> list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int = 0; < loops; i++) { list.clear(); list.addAll(new CountingIntegerList(size)); while(list.size() > 5) list.remove(5); // Minimize random-access cost } return loops * size; } }); // Tests queue behavior: qTests.add(new Test<LinkedList<Integer>>("addFirst") { int test(LinkedList<Integer> list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int = 0; < loops; i++) { list.clear(); for(int j = 0; j < size; j++) list.addFirst(47); } return loops * size; } }); qTests.add(new Test<LinkedList<Integer>>("addLast") { int test(LinkedList<Integer> list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int = 0; < loops; i++) { list.clear(); for(int j = 0; j < size; j++) list.addLast(47); } return loops * size; } 622 Thinking Java Bruce Eckel }); qTests.add( new Test<LinkedList<Integer>>("rmFirst") { int test(LinkedList<Integer> list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int = 0; < loops; i++) { list.clear(); list.addAll(new CountingIntegerList(size)); while(list.size() > 0) list.removeFirst(); } return loops * size; } }); qTests.add(new Test<LinkedList<Integer>>("rmLast") { int test(LinkedList<Integer> list, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int = 0; < loops; i++) { list.clear(); list.addAll(new CountingIntegerList(size)); while(list.size() > 0) list.removeLast(); } return loops * size; } }); } static class ListTester extends Tester<List<Integer>> { public ListTester(List<Integer> container, List<Test<List<Integer>>> tests) { super(container, tests); } // Fill appropriate size test: @Override protected List<Integer> initialize(int size){ container.clear(); container.addAll(new CountingIntegerList(size)); return container; } // Convenience method: public static void run(List<Integer> list, List<Test<List<Integer>>> tests) { new ListTester(list, tests).timedTest(); } } public static void main(String[] args) { if(args.length > 0) Tester.defaultParams = TestParam.array(args); // Can two tests array: Tester<List<Integer>> arrayTest = new Tester<List<Integer>>(null, tests.subList(1, 3)){ // This called test. It // produces non-resizeable array-backed list: @Override protected List<Integer> initialize(int size) { Integer[] ia = Generated.array(Integer.class, new CountingGenerator.Integer(), size); return Arrays.asList(ia); } }; arrayTest.setHeadline("Array List"); arrayTest.timedTest(); Containers Depth 623 Tester.defaultParams= TestParam.array( 10, 5000, 100, 5000, 1000, 1000, 10000, 200); if(args.length > 0) Tester.defaultParams = TestParam.array(args); ListTester.run(new ArrayList<Integer>(), tests); ListTester.run(new LinkedList<Integer>(), tests); ListTester.run(new Vector<Integer>(), tests); Tester.fieldWidth = 12; Tester<LinkedList<Integer>> qTest = new Tester<LinkedList<Integer>>( new LinkedList<Integer>(), qTests); qTest.setHeadline("Queue tests"); qTest.timedTest(); } } /* Output: (Sample) --- Array List --size get set 10 130 183 100 130 164 1000 129 165 10000 129 165 --------------------- ArrayList --------------------size add get set iteradd insert remove 10 121 139 191 435 3952 446 100 72 141 191 247 3934 296 1000 98 141 194 839 2202 923 10000 122 144 190 6880 14042 7333 --------------------- LinkedList --------------------size add get set iteradd insert remove 10 182 164 198 658 366 262 100 106 202 230 457 108 201 1000 133 1289 1353 430 136 239 10000 172 13648 13187 435 255 239 ----------------------- Vector ----------------------size add get set iteradd insert remove 10 129 145 187 290 3635 253 100 72 144 190 263 3691 292 1000 99 145 193 846 2162 927 10000 108 145 186 6871 14730 7135 -------------------- Queue tests -------------------size addFirst addLast rmFirst rmLast 10 199 163 251 253 100 98 92 180 179 1000 99 93 216 212 10000 111 109 262 384 *///:~ Each test requires careful thought ensure producing meaningful results. For example, "add" test clears List refills specified list size. The call clear( ) thus part test, may impact time, especially small tests. Although results seem fairly reasonable, could imagine rewriting test framework call preparation method (which would, case, include clear( ) call) outside timing loop. Note test, must accurately calculate number operations occur return value test( ), timing correct. The "get" "set" tests use random number generator perform random accesses List. In output, see that, List backed array ArrayList, accesses fast consistent regardless list size, whereas 624 Thinking Java Bruce Eckel LinkedList, access times grow significantly larger lists. Clearly, linked lists good choice performing many random accesses. The "iteradd" test uses iterator middle list insert new elements. For ArrayList gets expensive list gets bigger, LinkedList relatively cheap, constant regardless size. This makes sense ArrayList must create space copy references forward insertion. This becomes expensive ArrayList gets bigger. A LinkedList needs link new element, doesn’t modify rest list, expect cost roughly regardless list size. The "insert" "remove" tests use location number 5 point insertion removal, rather either end List. A LinkedList treats endpoints List specially—this improves speed using LinkedList Queue. However, add remove elements middle list, include cost random access, we’ve already seen varies different List implementations. By performing insertions removals location 5, cost random access negligible see cost insertion removal, see specialized optimization end LinkedList. You see output cost insertion removal LinkedList quite cheap doesn’t vary list size, ArrayList, insertions especially expensive, cost increases list size. From Queue tests, see quickly LinkedList insert remove elements endpoints list, optimal Queue behavior. Normally, call Tester.run( ), passing container tests list. Here, however, must override initialize( ) method List cleared refilled test—otherwise List control size List would lost various tests. ListTester inherits Tester performs initialization using CountingIntegerList. The run( ) convenience method also overridden. We’d also like compare array access container access (primarily ArrayList). In first test main( ), special Test object created using anonymous inner class. The initialize( ) method overridden create new object time called (ignoring stored container object, null container argument Tester constructor). The new object created using Generated.array( ) (which defined Arrays chapter) Arrays.asList( ). Only two tests performed case, cannot insert remove elements using List backed array, List.subList( ) method used select desired tests tests list. For random-access get( ) set( ) operations, List backed array slightly faster ArrayList, operations dramatically expensive LinkedList designed randomaccess operations. Vector avoided; it’s library legacy code support (the reason works program adapted List forward compatibility). The best approach probably choose ArrayList default change LinkedList need extra functionality discover performance problems due many insertions removals middle list. If working fixedsized group elements, either use List backed array (as produced Arrays.asList( )), necessary, actual array. CopyOnWriteArrayList special implementation List used concurrent programming, discussed Concurrency chapter. Exercise 29: (2) Modify ListPerformance.java Lists hold String objects instead Integers. Use Generator Arrays chapter create test values. Containers Depth 625 Exercise 30: (3) Compare performance Collections.sort( ) ArrayList LinkedList. Exercise 31: (5) Create container encapsulates array String, allows adding Strings getting Strings, casting issues use. If internal array isn’t big enough next add, container automatically resize it. In main( ), compare performance container ArrayList<String>. Exercise 32: (2) Repeat previous exercise container int, compare performance ArrayList<Integer>. In performance comparison, include process incrementing object container. Exercise 33: (5) Create FastTraversalLinkedList internally uses LinkedList rapid insertions removals, ArrayList rapid traversals get( ) operations. Test modifying ListPerformance.java. Microbenchmarking dangers When writing so-called microbenchmarks, must careful assume much, narrow tests much possible timing items interest. You must also careful ensure tests run long enough produce interesting data, take account Java HotSpot technologies kick program runs certain time (this important consider short-running programs, well). Results different according computer JVM using, run tests verify results similar shown book. You concerned absolute numbers performance comparisons one type container another. Also, profiler may better job performance analysis can. Java comes profiler (see supplement http://MindView.net/Books/BetterJava) thirdparty profilers available, free/open-source commercial. A related example concerns Math.random( ). Does produce value zero one, inclusive exclusive value "1"? In math lingo, (0,1), [0,1], (0,1] [0,1)? (The square bracket means "includes," whereas parenthesis means "doesn’t include.") A test program might provide answer: //: containers/RandomBounds.java // Does Math.random() produce 0.0 1.0? // {RunByHand} import static net.mindview.util.Print.*; public class RandomBounds { static void usage() { print("Usage:"); print("\tRandomBounds lower"); print("\tRandomBounds upper"); System.exit(1); } public static void main(String[] args) { if(args.length != 1) usage(); if(args[0].equals("lower")) { while(Math.random() != 0.0) ; // Keep trying 626 Thinking Java Bruce Eckel print("Produced 0.0!"); } else if(args[0].equals("upper")) { while(Math.random() != 1.0) ; // Keep trying print("Produced 1.0!"); } else usage(); } } ///:~ To run program, type command line either: java RandomBounds lower java RandomBounds upper In cases, forced break program manually, would appear Math.random( ) never produces either o.o l.o. But experiment deceiving. If consider 262 different double fractions 1, likelihood reaching one value experimentally might exceed lifetime one computer, even one experimenter. It turns 0.0 included output Math.random( ). Or, math lingo, [0,1). Thus, must careful analyze experiments understand limitations. Choosing Sets Depending behavior desire, choose TreeSet, HashSet, LinkedHashSet. The following test program gives indication performance tradeoff implementations: //: containers/SetPerformance.java // Demonstrates performance differences Sets. // {Args: 100 5000} Small keep build testing short import java.util.*; public class SetPerformance { static List<Test<Set<Integer>>> tests = new ArrayList<Test<Set<Integer>>>(); static { tests.add(new Test<Set<Integer>>("add") { int test(Set<Integer> set, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int = 0; < loops; i++) { set.clear(); for(int j = 0; j < size; j++) set.add(j); } return loops * size; } }); tests.add(new Test<Set<Integer>>("contains") { int test(Set<Integer> set, TestParam tp) { int loops = tp.loops; Containers Depth 627 int span = tp.size * 2; for(int = 0; < loops; i++) for(int j = 0; j < span; j++) set.contains(j); return loops * span; } }); tests.add(new Test<Set<Integer>>("iterate") { int test(Set<Integer> set, TestParam tp) { int loops = tp.loops * 10; for(int = 0; < loops; i++) { Iterator<Integer> = set.iterator(); while(it.hasNext()) it.next(); } return loops * set.size(); } }); } public static void main(String[] args) { if(args.length > 0) Tester.defaultParams = TestParam.array(args); Tester.fieldWidth = 10; Tester.run(new TreeSet<Integer>(), tests); Tester.run(new HashSet<Integer>(), tests); Tester.run(new LinkedHashSet<Integer>(), tests); } } /* Output: (Sample) ------------- TreeSet ------------size add contains iterate 10 746 173 89 100 501 264 68 1000 714 410 69 10000 1975 552 69 ------------- HashSet ------------size add contains iterate 10 308 91 94 100 178 75 73 1000 216 110 72 10000 711 215 100 ---------- LinkedHashSet ---------size add contains iterate 10 350 65 83 100 270 74 55 1000 303 111 54 10000 1615 256 58 *///:~ The performance HashSet generally superior TreeSet, especially adding elements looking up, two important operations. TreeSet exists maintains elements sorted order, use need sorted Set. Because internal structure necessary support sorting iteration something you’re likely do, iteration usually faster TreeSet HashSet. Note LinkedHashSet expensive insertions HashSet; extra cost maintaining linked list along hashed container. Exercise 34: (1) Modify SetPerformance.java Sets hold String objects instead Integers. Use Generator Arrays chapter create test values. 628 Thinking Java Bruce Eckel Choosing Maps This program gives indication trade-off Map implementations: //: containers/MapPerformance.java // Demonstrates performance differences Maps. // {Args: 100 5000} Small keep build testing short import java.util.*; public class MapPerformance { static List<Test<Map<Integer,Integer>>> tests = new ArrayList<Test<Map<Integer,Integer>>>(); static { tests.add(new Test<Map<Integer,Integer>>("put") { int test(Map<Integer,Integer> map, TestParam tp) { int loops = tp.loops; int size = tp.size; for(int = 0; < loops; i++) { map.clear(); for(int j = 0; j < size; j++) map.put(j, j); } return loops * size; } }); tests.add(new Test<Map<Integer,Integer>>("get") { int test(Map<Integer,Integer> map, TestParam tp) { int loops = tp.loops; int span = tp.size * 2; for(int = 0; < loops; i++) for(int j = 0; j < span; j++) map.get(j); return loops * span; } }); tests.add(new Test<Map<Integer,Integer>>("iterate") { int test(Map<Integer,Integer> map, TestParam tp) { int loops = tp.loops * 10; for(int = 0; < loops; ++) { Iterator = map.entrySet().iterator(); while(it.hasNext()) it.next(); } return loops * map.size(); } }); } public static void main(String[] args) { if(args.length > 0) Tester.defaultParams = TestParam.array(args); Tester.run(new TreeMap<Integer,Integer>(), tests); Tester.run(new HashMap<Integer,Integer>(), tests); Tester.run(new LinkedHashMap<Integer,Integer>(),tests); Tester.run( new IdentityHashMap<Integer,Integer>(), tests); Tester.run(new WeakHashMap<Integer,Integer>(), tests); Tester.run(new Hashtable<Integer,Integer>(), tests); } } /* Output: (Sample) ---------- TreeMap ---------size put get iterate Containers Depth 629 10 748 168 100 100 506 264 76 1000 771 450 78 10000 2962 561 83 ---------- HashMap ---------size put get iterate 10 281 76 93 100 179 70 73 1000 267 102 72 10000 1305 265 97 ------- LinkedHashMap ------size put get iterate 10 354 100 72 100 273 89 50 1000 385 222 56 10000 2787 341 56 ------ IdentityHashMap -----size put get iterate 10 290 144 101 100 204 287 132 1000 508 336 77 10000 767 266 56 -------- WeakHashMap -------size put get iterate 10 484 146 151 100 292 126 117 1000 411 136 152 10000 2165 138 555 --------- Hashtable --------size put get iterate 10 264 113 113 100 181 105 76 1000 260 201 80 10000 1245 134 77 *///:~ Insertions Map implementations except IdentityHashMap get significantly slower size Map gets large. In general, however, lookup much cheaper insertion, good you’ll typically looking items much often insert them. Hashtable performance roughly HashMap. Since HashMap intended replace Hashtable, thus uses underlying storage lookup mechanism (which learn later), surprising. A TreeMap generally slower HashMap. As TreeSet, TreeMap way create ordered list. The behavior tree it’s always order doesn’t specially sorted. Once fill TreeMap, call keySet( ) get Set view keys, toArray( ) produce array keys. You use static method Arrays.binarySearch( ) rapidly find objects sorted array. Of course, makes sense behavior HashMap unacceptable, since HashMap designed rapidly find keys. Also, easily create HashMap TreeMap single object creation call putAll( ). In end, you’re using Map, first choice HashMap, need constantly sorted Map need TreeMap. LinkedHashMap tends slower HashMap insertions maintains linked list (to preserve insertion order) addition hashed data structure. Because list, iteration faster. 630 Thinking Java Bruce Eckel IdentityHashMap different performance uses == rather equals( ) comparisons. WeakHashMap described later chapter. Exercise 35: (1) Modify MapPerformance.java include tests SlowMap. Exercise 36: (5) Modify SlowMap instead two ArrayLists, holds single ArrayList MapEntry objects. Verify modified version works correctly. Using MapPerformance.java, test speed new Map. Now change put( ) method performs sort( ) pair entered, modify get( ) use Collections.binarySearch( ) look key. Compare performance new version old ones. Exercise 37: (2) Modify SimpleHashMap use ArrayLists instead LinkedLists. Modify MapPerformance.java compare performance two implementations. HashMap performance factors It’s possible hand-tune HashMap increase performance particular application. So understand performance issues tuning HashMap, terminology necessary: Capacity: The number buckets table. Initial capacity: The number buckets table created. HashMap HashSet constructors allow specify initial capacity. Size: The number entries currently table. Load factor: Size/capacity. A load factor empty table, 0.5 half-full table, etc. A lightly loaded table collisions optimal insertions lookups (but slow process traversing iterator). HashMap HashSet constructors allow specify load factor, means load factor reached, container automatically increase capacity (the number buckets) roughly doubling redistribute existing objects new set buckets (this called rehashing). The default load factor used HashMap 0.75 (it doesn’t rehash table threefourths full). This seems good trade-off time space costs. A higher load factor decreases space required table increases lookup cost, important lookup time (including get( ) put( )). If know you’ll storing many entries HashMap, creating appropriately large initial capacity prevent overhead automatic rehashing. 11 Exercise 38: (3) Look HashMap class JDK documentation. Create HashMap, fill elements, determine load factor. Test lookup speed map, attempt increase speed making new HashMap larger initial capacity copying old map new one, run lookup speed test new map. 11 In private message, Joshua Bloch wrote: "... I believe erred allowing implementation details (such hash table size load factor) APIs. The client perhaps tell us maximum expected size collection, take there. Clients easily harm good choosing values parameters. As extreme example, consider Vector’s capacitylncrement. No one ever set this, shouldn’t provided it. If set nonzero value, asymptotic cost sequence appends goes linear quadratic. In words, destroys performance. Over time, we’re beginning wise sort thing. If look IdentityHashMap, you’ll see low-level tuning parameters." Containers Depth 631 Exercise 39: (6) Add private rehash( ) method SimpleHashMap invoked load factor exceeds 0.75. During rehashing, double number buckets, search first prime number greater determine new number buckets. Utilities There number standalone utilities containers, expressed static methods inside java.util.Collections class. You’ve already seen these, addAll( ), reverseOrder( ) binarySearch( ). Here others (the synchronized unmodifiable utilities covered sections follow). In table, generics used relevant: 632 checkedCollection( Collection<T>, Class<T> type) checkedList( List<T>, Class<T> type) checkedMap(Map<K,V>, Class <K> keyType, Class <V> valueType) checkedSet(Set<T>, Class<T> type) checkedSortedMap( SortedMap<K,V>, Class<K> keyType, Class <V> valueType) checkedSortedSet( SortedSet<T>, Class<T> type) Produces dynamically type-safe view Collection, specific subtype Collection. Use it’s possible use statically checked version. max(Collection) min(Collection) Produces maximum minimum element argument using natural comparison method objects Collection. max(Collection, Comparator) min(Collection, Comparator) Produces maximum minimum element Collection using Comparator. indexOfSubList(List source, List target) Produces starting index first place target appears inside source, -1 none occurs. lastIndexOfSubList(List source, List target) Produces starting index last place target appears inside source, -1 none occurs. replaceAll(List<T>, T oldVal, T newVal) Replaces oldVal newVal. reverse(List) Reverses elements place. reverseOrder( ) reverseOrder( Comparator<T>) Returns Comparator reverses natural ordering collection objects implement Comparable<T>. The second version reverses order supplied Comparator. These shown Generics chapter heading "Dynamic type safety." Thinking Java Bruce Eckel rotate(List, int distance) Moves elements forward distance, taking ones end placing beginning. shuffle(List) shuffle(List, Random) Randomly permutes specified list. The first form provides randomization source, may provide second form. sort(List<T>) sort(List<T>, Comparator<? super T> c) Sorts List<T> using natural ordering. The second form allows provide Comparator sorting. copy(List<? super T> dest, List<? extends T> src) Copies elements src dest. swap(List, int i, int j) Swaps elements locations j List. Probably faster you’d write hand. fill(List<? super T>, T x) Replaces elements list x. nCopies(int n, T x) Returns immutable List<T> size n whose references point x. disjoint(Collection, Collection) Returns true two collections elements common. frequency(Collection, Object x) Returns number elements Collection equal x. emptyList( ) emptyMap( ) emptySet( ) Returns immutable empty List, Map, Set. These generic, resulting Collection parameterized desired type. singleton(T x) singletonList(T x) singletonMap(K key, V value) Produces immutable Set<T>, List<T>, Map<K,V> containing single entry based given argument(s). list(Enumeration<T> e) Produces ArrayList<T> containing elements order returned (old-style) Enumeration (predecessor Iterator). For converting legacy code. enumeration(Collection<T>) Produces old-style Enumeration<T> argument. Note min( ) max( ) work Collection objects, Lists, don’t need worry whether Collection sorted not. (As mentioned earlier, need sort( ) List array performing binarySearch( ).) Here’s example showing basic use utilities table: Containers Depth 633 //: containers/Utilities.java // Simple demonstrations Collections utilities. import java.util.*; import static net.mindview.util.Print.*; public class Utilities { static List<String> list = Arrays.asList( "one Two three Four five six one".split(" ")); public static void main(String[] args) { print(list); print("‘list’ disjoint (Four)?: " + Collections.disjoint(list, Collections.singletonList("Four"))); print("max: " + Collections.max(list)); print("min: " + Collections.min(list)); print("max w/ comparator: " + Collections.max(list, String.CASE_INSENSITIVE_ORDER)); print("min w/ comparator: " + Collections.min(list, String.CASE_INSENSITIVE_ORDER)); List<String> sublist = Arrays.asList("Four five six".split(" ")); print("indexOfSubList: " + Collections.indexOfSubList(list, sublist)); print("lastIndexOfSubList: " + Collections.lastIndexOfSubList(list, sublist)); Collections.replaceAll(list, "one", "Yo"); print("replaceAll: " + list); Collections.reverse(list); print("reverse: " + list); Collections.rotate(list, 3); print("rotate: " + list); List<String> source = Arrays.asList("in matrix".split(" ")); Collections.copy(list, source); print("copy: " + list); Collections.swap(list, 0, list.size() - 1); print("swap: " + list); Collections.shuffle(list, new Random(47)); print("shuffled: " + list); Collections.fill(list, "pop"); print("fill: " + list); print("frequency ‘pop’: " + Collections.frequency(list, "pop")); List<String> dups = Collections.nCopies(3, "snap"); print("dups: " + dups); print("‘list’ disjoint ‘dups’?: " + Collections.disjoint(list, dups)); // Getting old-style Enumeration: Enumeration<String> e = Collections.enumeration(dups); Vector<String> v = new Vector<String>(); while(e.hasMoreElements()) v.addElement(e.nextElement()); // Converting old-style Vector // List via Enumeration: ArrayList<String> arrayList = Collections.list(v.elements()); print("arrayList: " + arrayList); } } /* Output: [one, Two, three, Four, five, six, one] ‘list’ disjoint (Four)?: false max: three min: Four 634 Thinking Java Bruce Eckel max w/ comparator: Two min w/ comparator: five indexOfSubList: 3 lastIndexOfSubList: 3 replaceAll: [Yo, Two, three, Four, five, six, Yo] reverse: [Yo, six, five, Four, three, Two, Yo] rotate: [three, Two, Yo, Yo, six, five, Four] copy: [in, the, matrix, Yo, six, five, Four] swap: [Four, the, matrix, Yo, six, five, in] shuffled: [six, matrix, the, Four, Yo, five, in] fill: [pop, pop, pop, pop, pop, pop, pop] frequency ‘pop’: 7 dups: [snap, snap, snap] ‘list’ disjoint ‘dups’?: true arrayList: [snap, snap, snap] *///:~ The output explains behavior utility method. Note difference min( ) max( ) String.CASE_INSENSITIVE_ORDER Comparator capitalization. Sorting searching Lists Utilities perform sorting searching Lists names signatures sorting arrays objects, static methods Collections instead Arrays. Here’s example uses list data Utilities.java: //: containers/ListSortSearch.java // Sorting searching Lists Collections utilities. import java.util.*; import static net.mindview.util.Print.*; public class ListSortSearch { public static void main(String[] args) { List<String> list = new ArrayList<String>(Utilities.list); list.addAll(Utilities.list); print(list); Collections.shuffle(list, new Random(47)); print("Shuffled: " + list); // Use ListIterator trim last elements: ListIterator<String> = list.listIterator(10); while(it.hasNext()) { it.next(); it.remove(); } print("Trimmed: " + list); Collections.sort(list); print("Sorted: " + list); String key = list.get(7); int index = Collections.binarySearch(list, key); print("Location " + key + " " + index + ", list.get(" + index + ") = " + list.get(index)); Collections.sort(list, String.CASE_INSENSITIVE_ORDER); print("Case-insensitive sorted: " + list); key = list.get(7); index = Collections.binarySearch(list, key, String.CASE_INSENSITIVE_ORDER); print("Location " + key + " " + index + ", list.get(" + index + ") = " + list.get(index)); } Containers Depth 635 } /* Output: [one, Two, three, Four, five, six, one, one, Two, three, Four, five, six, one] Shuffled: [Four, five, one, one, Two, six, six, three, three, five, Four, Two, one, one] Trimmed: [Four, five, one, one, Two, six, six, three, three, five] Sorted: [Four, Two, five, five, one, one, six, six, three, three] Location six 7, list.get(7) = six Case-insensitive sorted: [five, five, Four, one, one, six, six, three, three, Two] Location three 7, list.get(7) = three *///:~ Just searching sorting arrays, sort using Comparator, must binarySearch( ) using Comparator. This program also demonstrates shuffle( ) method Collections, randomizes order List. A ListIterator created particular location shuffled list, used remove elements location end list. Exercise 40: (5) Create class containing two String objects make Comparable comparison cares first String. Fill array ArrayList objects class, using RandomGenerator generator. Demonstrate sorting works properly. Now make Comparator cares second String, demonstrate sorting works properly. Also perform binary search using Comparator. Exercise 41: (3) Modify class previous exercise work HashSets key HashMaps. Exercise 42: (2) Modify Exercise 40 alphabetic sort used. Making Collection Map unmodifiable Often convenient create read-only version Collection Map. The Collections class allows passing original container method hands back read-only version. There number variations method, Collections (if can’t treat Collection specific type), Lists, Sets, Maps. This example shows proper way build read-only versions each: //: containers/ReadOnly.java // Using Collections.unmodifiable methods. import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class ReadOnly { static Collection<String> data = new ArrayList<String>(Countries.names(6)); public static void main(String[] args) { Collection<String> c = Collections.unmodifiableCollection( new ArrayList<String>(data)); print(c); // Reading OK //! c.add("one"); // Can’t change List<String> = Collections.unmodifiableList( 636 Thinking Java Bruce Eckel new ArrayList<String>(data)); ListIterator<String> lit = a.listIterator(); print(lit.next()); // Reading OK //! lit.add("one"); // Can’t change Set<String> = Collections.unmodifiableSet( new HashSet<String>(data)); print(s); // Reading OK //! s.add("one"); // Can’t change // For SortedSet: Set<String> ss = Collections.unmodifiableSortedSet( new TreeSet<String>(data)); Map<String,String> = Collections.unmodifiableMap( new HashMap<String,String>(Countries.capitals(6))); print(m); // Reading OK //! m.put("Ralph", "Howdy!"); // For SortedMap: Map<String,String> sm = Collections.unmodifiableSortedMap( new TreeMap<String,String>(Countries.capitals(6))); } } /* Output: [ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO] ALGERIA [BULGARIA, BURKINA FASO, BOTSWANA, BENIN, ANGOLA, ALGERIA] {BULGARIA=Sofia, BURKINA FASO=Ouagadougou, BOTSWANA=Gaberone, BENIN=Porto-Novo, ANGOLA=Luanda, ALGERIA=Algiers} *///:~ Calling "unmodifiable" method particular type cause compile-time checking, transformation occurred, calls methods modify contents particular container produce UnsupportedOperationException. In case, must fill container meaningful data make read-only. Once loaded, best approach replace existing reference reference produced "unmodifiable" call. That way, don’t run risk accidentally trying change contents you’ve made unmodifiable. On hand, tool also allows keep modifiable container private within class return read-only reference container method call. So, change within class, everyone else read it. Synchronizing Collection Map The synchronized keyword important part subject multithreading, complicated topic introduced Concurrency chapter. Here, I shall note Collections class contains way automatically synchronize entire container. The syntax similar "unmodifiable" methods: //: containers/Synchronization.java // Using Collections.synchronized methods. import java.util.*; public class Synchronization { public static void main(String[] args) { Collection<String> c = Collections.synchronizedCollection( new ArrayList<String>()); Containers Depth 637 List<String> list = Collections.synchronizedList( new ArrayList<String>()); Set<String> = Collections.synchronizedSet( new HashSet<String>()); Set<String> ss = Collections.synchronizedSortedSet( new TreeSet<String>()); Map<String,String> = Collections.synchronizedMap( new HashMap<String,String>()); Map<String,String> sm = Collections.synchronizedSortedMap( new TreeMap<String,String>()); } } ///:~ It best immediately pass new container appropriate "synchronized" method, shown above. That way, there’s chance accidentally exposing unsynchronized version. Fail fast The Java containers also mechanism prevent one process modifying contents container. The problem occurs you’re middle iterating container, process steps inserts, removes, changes object container. Maybe you’ve already passed element container, maybe it’s ahead you, maybe size container shrinks call size( )—there many scenarios disaster. The Java containers library uses fail-fast mechanism looks changes container ones process personally responsible for. If detects someone else modifying container, immediately produces ConcurrentModification- Exception. This "fail-fast" aspect—it doesn’t try detect problem later using complex algorithm. It’s quite easy see fail-fast mechanism operation—all must create iterator add something collection iterator pointing to, like this: //: containers/FailFast.java // Demonstrates "fail-fast" behavior. import java.util.*; public class FailFast { public static void main(String[] args) { Collection<String> c = new ArrayList<String>(); Iterator<String> = c.iterator(); c.add("An object"); try { String = it.next(); } catch(ConcurrentModificationException e) { System.out.println(e); } } } /* Output: java.util.ConcurrentModificationException *///:~ The exception happens something placed container iterator acquired container. The possibility two parts program might modify container produces uncertain state, exception notifies change code—in case, acquire iterator added elements container. 638 Thinking Java Bruce Eckel The ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteArraySet use techniques avoid ConcurrentModificationExceptions. Holding references The java.lang.ref library contains set classes allow greater flexibility garbage collection. These classes especially useful large objects may cause memory exhaustion. There three classes inherited abstract class Reference: SoftReference, WeakReference, PhantomReference. Each provides different level indirection garbage collector object question reachable one Reference objects. If object reachable, means somewhere program object found. This could mean ordinary reference stack goes right object, might also reference object reference object question; many intermediate links. If object reachable, garbage collector cannot release it’s still use program. If object isn’t reachable, there’s way program use it, it’s safe garbage collect object. You use Reference objects want continue hold reference object—you want reach object—but also want allow garbage collector release object. Thus, way use object, memory exhaustion imminent, allow object released. You accomplish using Reference object intermediary (a proxy) ordinary reference. In addition, must ordinary references object (ones wrapped inside Reference objects). If garbage collector discovers object reachable ordinary reference, release object. In order SoftReference, WeakReference, PhantomReference, one "weaker" last corresponds different level reachability. Soft references implementing memory-sensitive caches. Weak references implementing "canonicalizing mappings"—where instances objects simultaneously used multiple places program, save storage—that prevent keys (or values) reclaimed. Phantom references scheduling pre-mortem cleanup actions flexible way possible Java finalization mechanism. With SoftReferences WeakReferences, choice whether place ReferenceQueue (the device used premortem cleanup actions), PhantomReference built ReferenceQueue. Here’s simple demonstration: //: containers/References.java // Demonstrates Reference objects import java.lang.ref.*; import java.util.*; class VeryBig { private static final int SIZE = 10000; private long[] la = new long[SIZE]; private String ident; public VeryBig(String id) { ident = id; } public String toString() { return ident; } protected void finalize() { System.out.println("Finalizing " + ident); } } Containers Depth 639 public class References { private static ReferenceQueue<VeryBig> rq = new ReferenceQueue<VeryBig>(); public static void checkQueue() { Reference<? extends VeryBig> inq = rq.poll(); if(inq != null) System.out.println("In queue: " + inq.get()); } public static void main(String[] args) { int size = 10; // Or, choose size via command line: if(args.length > 0) size = new Integer(args[0]); LinkedList<SoftReference<VeryBig>> sa = new LinkedList<SoftReference<VeryBig>>(); for(int = 0; < size; i++) { sa.add(new SoftReference<VeryBig>( new VeryBig("Soft " + i), rq)); System.out.println("Just created: " + sa.getLast()); checkQueue(); } LinkedList<WeakReference<VeryBig>> wa = new LinkedList<WeakReference<VeryBig>>(); for(int = 0; < size; i++) { wa.add(new WeakReference<VeryBig>( new VeryBig("Weak " + i), rq)); System.out.println("Just created: " + wa.getLast()); checkQueue(); } SoftReference<VeryBig> = new SoftReference<VeryBig>(new VeryBig("Soft")); WeakReference<VeryBig> w = new WeakReference<VeryBig>(new VeryBig("Weak")); System.gc(); LinkedList<PhantomReference<VeryBig>> pa = new LinkedList<PhantomReference<VeryBig>>(); for(int = 0; < size; i++) { pa.add(new PhantomReference<VeryBig>( new VeryBig("Phantom " + i), rq)); System.out.println("Just created: " + pa.getLast()); checkQueue(); } } } /* (Execute see output) *///:~ When run program (you’ll want redirect output text file view output pages), you’ll see objects garbage collected, even though still access Reference object (to get actual object reference, use get( )). You’ll also see ReferenceQueue always produces Reference containing null object. To use this, inherit particular Reference class add useful methods new class. The WeakHashMap The containers library special Map hold weak references: WeakHashMap. This class designed make creation canonicalized mappings easier. In mapping, saving storage creating one instance particular value. When program needs value, looks existing object mapping uses (rather creating one scratch). The mapping may make values part initialization, it’s likely values made demand. 640 Thinking Java Bruce Eckel Since storage-saving technique, it’s convenient WeakHashMap allows garbage collector automatically clean keys values. You don’t anything special keys values want place WeakHashMap; automatically wrapped WeakReferences map. The trigger allow cleanup key longer use, demonstrated here: //: containers/CanonicalMapping.java // Demonstrates WeakHashMap. import java.util.*; class Element { private String ident; public Element(String id) { ident = id; } public String toString() { return ident; } public int hashCode() { return ident.hashCode(); } public boolean equals(Object r) { return r instanceof Element && ident.equals(((Element)r).ident); } protected void finalize() { System.out.println("Finalizing " + getClass().getSimpleName() + " " + ident); } } class Key extends Element { public Key(String id) { super(id); } } class Value extends Element { public Value(String id) { super(id); } } public class CanonicalMapping { public static void main(String[] args) { int size = 1000; // Or, choose size via command line: if(args.length > 0) size = new Integer(args[0]); Key[] keys = new Key[size]; WeakHashMap<Key,Value> map = new WeakHashMap<Key,Value>(); for(int = 0; < size; i++) { Key k = new Key(Integer.toString(i)); Value v = new Value(Integer.toString(i)); if(i % 3 == 0) keys[i] = k; // Save "real" references map.put(k, v); } System.gc(); } } /* (Execute see output) *///:~ The Key class must hashCode( ) equals( ) since used key hashed data structure. The subject hashCode( ) described earlier chapter. When run program, you’ll see garbage collector skip every third key, ordinary reference key also placed keys array, thus objects cannot garbage collected. Containers Depth 641 Java 1.0/1.1 containers Unfortunately, lot code written using Java 1.0/1.1 containers, even new code sometimes written using classes. So although never use old containers writing new code, you’ll still need aware them. However, old containers quite limited, there’s much say them, since anachronistic, I try refrain overemphasizing hideous design decisions. Vector & Enumeration The self-expanding sequence Java 1.0/1.1 Vector, saw lot use. Its flaws numerous describe (see 1st edition book, available free download www.MindView.net). Basically, think ArrayList long, awkward method names. In revised Java container library, Vector adapted could work Collection List. This turns bit perverse, may confuse people thinking Vector gotten better, actually included support older Java code. The Java 1.0/1.1 version iterator chose invent new name, "enumeration," instead using term everyone already familiar ("iterator"). The Enumeration interface smaller Iterator, two methods, uses longer method names: boolean hasMoreElements( ) produces true enumeration contains elements, Object nextElement( ) returns next element enumeration (otherwise throws exception). Enumeration interface, implementation, even new libraries sometimes still use old Enumeration, unfortunate generally harmless. Even though always use Iterator code, must prepared libraries want hand Enumeration. In addition, produce Enumeration Collection using Collections.enumeration( ) method, seen example: //: containers/Enumerations.java // Java 1.0/1.1 Vector Enumeration. import java.util.*; import net.mindview.util.*; public class Enumerations { public static void main(String[] args) { Vector<String> v = new Vector<String>(Countries.names(10)); Enumeration<String> e = v.elements(); while(e.hasMoreElements()) System.out.print(e.nextElement() + ", "); // Produce Enumeration Collection: e = Collections.enumeration(new ArrayList<String>()); } } /* Output: ALGERIA, ANGOLA, BENIN, BOTSWANA, BULGARIA, BURKINA FASO, BURUNDI, CAMEROON, CAPE VERDE, CENTRAL AFRICAN REPUBLIC, *///:~ To produce Enumeration, call elements( ), use perform forward iteration. 642 Thinking Java Bruce Eckel The last line creates ArrayList uses enumeration( ) adapt Enumeration ArrayList Iterator. Thus, old code wants Enumeration, still use new containers. Hashtable As you’ve seen performance comparison chapter, basic Hashtable similar HashMap, even method names. There’s reason use Hashtable instead HashMap new code. Stack The concept stack introduced earlier, LinkedList. What’s rather odd Java 1.0/1.1 Stack instead using Vector composition, Stack inherited Vector. So characteristics behaviors Vector plus extra Stack behaviors. It’s difficult know whether designers consciously thought especially useful way things, whether naive design; event clearly reviewed rushed distribution, bad design still hanging around (but shouldn’t use it). Here’s simple demonstration Stack pushes String representation enum. It also shows easily use LinkedList stack, Stack class created Holding Your Objects chapter: //: containers/Stacks.java // Demonstration Stack Class. import java.util.*; import static net.mindview.util.Print.*; enum Month { JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER } public class Stacks { public static void main(String[] args) { Stack<String> stack = new Stack<String>(); for(Month : Month.values()) stack.push(m.toString()); print("stack = " + stack); // Treating stack Vector: stack.addElement("The last line"); print("element 5 = " + stack.elementAt(5)); print("popping elements:"); while(!stack.empty()) printnb(stack.pop() + " "); // Using LinkedList Stack: LinkedList<String> lstack = new LinkedList<String>(); for(Month : Month.values()) lstack.addFirst(m.toString()); print("lstack = " + lstack); while(!lstack.isEmpty()) printnb(lstack.removeFirst() + " "); // Using Stack class // Holding Your Objects Chapter: net.mindview.util.Stack<String> stack2 = new net.mindview.util.Stack<String>(); for(Month : Month.values()) stack2.push(m.toString()); Containers Depth 643 print("stack2 = " + stack2); while(!stack2.empty()) printnb(stack2.pop() + " "); } } /* Output: stack = [JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER] element 5 = JUNE popping elements: The last line NOVEMBER OCTOBER SEPTEMBER AUGUST JULY JUNE MAY APRIL MARCH FEBRUARY JANUARY lstack = [NOVEMBER, OCTOBER, SEPTEMBER, AUGUST, JULY, JUNE, MAY, APRIL, MARCH, FEBRUARY, JANUARY] NOVEMBER OCTOBER SEPTEMBER AUGUST JULY JUNE MAY APRIL MARCH FEBRUARY JANUARY stack2 = [NOVEMBER, OCTOBER, SEPTEMBER, AUGUST, JULY, JUNE, MAY, APRIL, MARCH, FEBRUARY, JANUARY] NOVEMBER OCTOBER SEPTEMBER AUGUST JULY JUNE MAY APRIL MARCH FEBRUARY JANUARY *///:~ A String representation generated Month enum constants, inserted Stack push( ), later fetched top stack pop( ). To make point, Vector operations also performed Stack object. This possible because, virtue inheritance, Stack Vector. Thus, operations performed Vector also performed Stack, elementAt( ). As mentioned earlier, use LinkedList want stack behavior, net.mindview.util.Stack class created LinkedList class. BitSet A BitSet used want efficiently store lot on-off information. It’s efficient standpoint size; you’re looking efficient access, slightly slower using native array. In addition, minimum size BitSet long: 64 bits. This implies you’re storing anything smaller, like 8 bits, BitSet wasteful; you’re better creating class, array, hold flags size issue. (This case you’re creating lot objects containing lists on-off information, decided based profiling metrics. If make decision think something big, end creating needless complexity wasting lot time.) A normal container expands add elements, BitSet well. The following example shows BitSet works: //: containers/Bits.java // Demonstration BitSet. import java.util.*; import static net.mindview.util.Print.*; public class Bits { public static void printBitSet(BitSet b) { print("bits: " + b); StringBuilder bbits = new StringBuilder(); for(int j = 0; j < b.size() ; j++) bbits.append(b.get(j) ? "1" : "0"); print("bit pattern: " + bbits); } 644 Thinking Java Bruce Eckel public static void main(String[] args) { Random rand = new Random(47); // Take LSB nextInt(): byte bt = (byte)rand.nextInt(); BitSet bb = new BitSet(); for(int = 7; >= 0; i--) if(((1 << i) & bt) != 0) bb.set(i); else bb.clear(i); print("byte value: " + bt); printBitSet(bb); short st = (short)rand.nextInt(); BitSet bs = new BitSet(); for(int = 15; >= 0; i--) if(((1 << i) & st) != 0) bs.set(i); else bs.clear(i); print("short value: " + st); printBitSet(bs); int = rand.nextInt(); BitSet bi = new BitSet(); for(int = 31; >= 0; i--) if(((1 << i) & it) != 0) bi.set(i); else bi.clear(i); print("int value: " + it); printBitSet(bi); // Test bitsets >= 64 bits: BitSet b127 = new BitSet(); b127.set(127); print("set bit 127: " + b127); BitSet b255 = new BitSet(65); b255.set(255); print("set bit 255: " + b255); BitSet b1023 = new BitSet(512); b1023.set(1023); b1023.set(1024); print("set bit 1023: " + b1023); } } /* Output: byte value: -107 bits: {0, 2, 4, 7} bit pattern: 1010100100000000000000000000000000000000000000000000000000000000 short value: 1302 bits: {1, 2, 4, 8, 10} bit pattern: 0110100010100000000000000000000000000000000000000000000000000000 int value: -2014573909 bits: {0, 1, 3, 5, 7, 9, 11, 18, 19, 21, 22, 23, 24, 25, 26, 31} bit pattern: 1101010101010000001101111110000100000000000000000000000000000000 set bit 127: {127} set bit 255: {255} set bit 1023: {1023, 1024} *///:~ Containers Depth 645 The random number generator used create random byte, short, int, one transformed corresponding bit pattern BitSet. This works fine BitSet 64 bits, none cause increase size. Then larger BitSets created. You see BitSet expanded necessary. An EnumSet (see Enumerated Types chapter) usually better choice BitSet fixed set flags name, EnumSet allows manipulate names rather numerical bit locations, thus reduces errors. EnumSet also prevents accidentally adding new flag locations, could cause serious, difficult-to-find bugs. The reasons use BitSet instead EnumSet don’t know many flags need run time, unreasonable assign names flags, need one special operations BitSet (see JDK documentation BitSet EnumSet). Summary The containers library arguably important library objectoriented language. Most programming use containers library components. Some languages (Python, example) even include fundamental container components (lists, maps sets) built-ins. As saw Holding Your Objects chapter, it’s possible number interesting things using containers, without much effort. However, point you’re forced know containers order use properly—in particular, must know enough hashing operations write hashCode( ) method (and must know necessary), must know enough various container implementations choose appropriate one needs. This chapter covered concepts discussed additional useful details container library. At point reasonably well prepared use Java containers everyday programming tasks. The design containers library difficult (this true library design problems). In C++, container classes covered bases many different classes. This better available prior C++ container classes (nothing), didn’t translate well Java. At extreme, I’ve seen containers library consists single class, "container," acts like linear sequence associative array time. The Java container library strikes balance: full functionality expect mature container library, easier learn use C++ container classes similar container libraries. The result seem bit odd places. Unlike decisions made early Java libraries, oddities accidents, carefully considered decisions based trade-offs complexity. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. 646 Thinking Java Bruce Eckel I/O Creating good input/output (I/O) system one difficult tasks language designer. This evidenced number different approaches. The challenge seems covering possibilities. Not different sources sinks I/O want communicate (files, console, network connections, etc.), need talk wide variety ways (sequential, random-access, buffered, binary, character, lines, words, etc.). The Java library designers attacked problem creating lots classes. In fact, many classes Java’s I/O system intimidating first (ironically, Java I/O design actually prevents explosion classes). There also significant change I/O library Java i.o, original byte-oriented library supplemented char-oriented, Unicodebased I/O classes. The nio classes (for "new I/O," name we’ll still using years even though introduced JDK 1.4 already "old") added improved performance functionality. As result, fair number classes learn understand enough Java’s I/O picture use properly. In addition, it’s rather important understand evolution I/O library, even first reaction "Don’t bother history, show use it!" The problem without historical perspective, rapidly become confused classes shouldn’t use them. This chapter give introduction variety I/O classes standard Java library use them. The File class Before getting classes actually read write data streams, we’ll look library utility assists file directory issues. The File class deceiving name; might think refers file, doesn’t. In fact, "FilePath" would better name class. It represent either name particular file names set files directory. If it’s set files, ask set using list( ) method, returns array String. It makes sense return array rather one flexible container classes, number elements fixed, want different directory listing, create different File object. This section shows example use class, including associated FilenameFilter interface. A directory lister Suppose you’d like see directory listing. The File object used two ways. If call list( ) arguments, you’ll get full list File object contains. However, want restricted list—for example, want files extension .Java— use "directory filter," class tells select File objects display. Here’s example. Note result effortlessly sorted (alphabetically) using java.util.Arrays.sort( ) method String.CASE_INSENSITIVE_ORDER Comparator: //: io/DirList.java // Display directory listing using regular expressions. // {Args: "D.*\.java"} import java.util.regex.*; import java.io.*; import java.util.*; public class DirList { public static void main(String[] args) { File path = new File("."); String[] list; if(args.length == 0) list = path.list(); else list = path.list(new DirFilter(args[0])); Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirItem : list) System.out.println(dirItem); } } class DirFilter implements FilenameFilter { private Pattern pattern; public DirFilter(String regex) { pattern = Pattern.compile(regex); } public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } } /* Output: DirectoryDemo.java DirList.java DirList2.java DirList3.java *///:~ The DirFilter class implements interface FilenameFilter. Notice simple FilenameFilter interface is: public interface FilenameFilter { boolean accept(File dir, String name); } DirFilter’s sole reason existence provide accept( ) method list( ) method list( ) "call back" accept( ) determine file names included list. Thus, structure often referred callback. More specifically, example Strategy design pattern, list( ) implements basic functionality, provide Strategy form FilenameFilter order complete algorithm necessary list( ) provide service. Because list( ) takes FilenameFilter object argument, means pass object class implements FilenameFilter choose (even run time) list( ) method behave. The purpose Strategy provide flexibility behavior code. The accept( ) method must accept File object representing directory particular file found in, String containing name file. Remember list( ) method calling accept( ) file names directory object see one included; indicated boolean result returned accept( ). accept( ) uses regular expression matcher object see regular expression regex matches name file. Using accept( ), list( ) method returns array. 648 Thinking Java Bruce Eckel Anonymous inner classes This example ideal rewriting using anonymous inner class (described Inner Classes). As first cut, method filter( ) created returns reference FilenameFilter: //: io/DirList2.java // Uses anonymous inner classes. // {Args: "D.*\.java"} import java.util.regex.*; import java.io.*; import java.util.*; public class DirList2 { public static FilenameFilter filter(final String regex) { // Creation anonymous inner class: return new FilenameFilter() { private Pattern pattern = Pattern.compile(regex); public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } }; // End anonymous inner class } public static void main(String[] args) { File path = new File("."); String[] list; if(args.length == 0) list = path.list(); else list = path.list(filter(args[0])); Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirItem : list) System.out.println(dirItem); } } /* Output: DirectoryDemo.java DirList.java DirList2.java DirList3.java *///:~ Note argument filter( ) must final. This required anonymous inner class use object outside scope. This design improvement FilenameFilter class tightly bound DirList2. However, take approach one step define anonymous inner class argument list(), case it’s even smaller: //: io/DirList3.java // Building anonymous inner class "in-place." // {Args: "D.*\.java"} import java.util.regex.*; import java.io.*; import java.util.*; public class DirList3 { public static void main(final String[] args) { File path = new File("."); String[] list; if(args.length == 0) list = path.list(); else I/O 649 list = path.list(new FilenameFilter() { private Pattern pattern = Pattern.compile(args[0]); public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } }); Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirItem : list) System.out.println(dirItem); } } /* Output: DirectoryDemo.java DirList.java DirList2.java DirList3.java *///:~ The argument main( ) final, since anonymous inner class uses args[0] directly. This shows anonymous inner classes allow creation specific, one-off classes solve problems. One benefit approach keeps code solves particular problem isolated one spot. On hand, always easy read, must use judiciously. Exercise 1: (3) Modify DirList.java (or one variants) FilenameFilter opens reads file (using net.mindview.util.TextFile utility) accepts file based whether trailing arguments command line exist file. Exercise 2: (2) Create class called SortedDirList constructor takes File object builds sorted directory list files File. Add class two overloaded list( ) methods: first produces whole list, second produces subset list matches argument (which regular expression). Exercise 3: (3) Modify DirList.java (or one variants) sums file sizes selected files. Directory utilities A common task programming perform operations sets files, either local directory walking entire directory tree. It useful tool produce set files you. The following utility class produces either array File objects local directory using local( ) method, List<File> entire directory tree starting given directory using walk( ) (File objects useful file names File objects contain information). The files chosen based regular expression provide: //: net/mindview/util/Directory.java // Produce sequence File objects match // regular expression either local directory, // walking directory tree. package net.mindview.util; import java.util.regex.*; import java.io.*; import java.util.*; public final class Directory { public static File[] 650 Thinking Java Bruce Eckel local(File dir, final String regex) { return dir.listFiles(new FilenameFilter() { private Pattern pattern = Pattern.compile(regex); public boolean accept(File dir, String name) { return pattern.matcher( new File(name).getName()).matches(); } }); } public static File[] local(String path, final String regex) { // Overloaded return local(new File(path), regex); } // A two-tuple returning pair objects: public static class TreeInfo implements Iterable<File> { public List<File> files = new ArrayList<File>(); public List<File> dirs = new ArrayList<File>(); // The default iterable element file list: public Iterator<File> iterator() { return files.iterator(); } void addAll(TreeInfo other) { files.addAll(other.files); dirs.addAll(other.dirs); } public String toString() { return "dirs: " + PPrint.pformat(dirs) + "\n\nfiles: " + PPrint.pformat(files); } } public static TreeInfo walk(String start, String regex) { // Begin recursion return recurseDirs(new File(start), regex); } public static TreeInfo walk(File start, String regex) { // Overloaded return recurseDirs(start, regex); } public static TreeInfo walk(File start) { // Everything return recurseDirs(start, ".*"); } public static TreeInfo walk(String start) { return recurseDirs(new File(start), ".*"); } static TreeInfo recurseDirs(File startDir, String regex){ TreeInfo result = new TreeInfo(); for(File item : startDir.listFiles()) { if(item.isDirectory()) { result.dirs.add(item); result.addAll(recurseDirs(item, regex)); } else // Regular file if(item.getName().matches(regex)) result.files.add(item); } return result; } // Simple validation test: public static void main(String[] args) { if(args.length == 0) System.out.println(walk(".")); else for(String arg : args) System.out.println(walk(arg)); I/O 651 } } ///:~ The local( ) method uses variant File.list( ) called listFiles( ) produces array File. You see also uses FilenameFilter. If need List instead array, convert result using Arrays.asList( ). The walk( ) method converts name starting directory File object calls recurseDirs( ), performs recursive directory walk, collecting information recursion. To distinguish ordinary files directories, return value effectively "tuple" objects—a List holding ordinary files, another holding directories. The fields intentionally made public here, point Treelnfo simply collect objects together—if returning List, wouldn’t make private, returning pair objects, doesn’t mean need make private. Note Treelnfo implements Iterable<File>, produces files, "default iteration" file list, whereas specify directories saying ".dirs". The Treelnfo.toString( ) method uses "pretty printer" class output easer view. The default toString( ) methods containers print elements container single line. For large collections become difficult read, may want use alternate formatting. Here’s tool adds newlines indents element: //: net/mindview/util/PPrint.java // Pretty-printer collections package net.mindview.util; import java.util.*; public class PPrint { public static String pformat(Collection<?> c) { if(c.size() == 0) return "[]"; StringBuilder result = new StringBuilder("["); for(Object elem : c) { if(c.size() != 1) result.append("\n "); result.append(elem); } if(c.size() != 1) result.append("\n"); result.append("]"); return result.toString(); } public static void pprint(Collection<?> c) { System.out.println(pformat(c)); } public static void pprint(Object[] c) { System.out.println(pformat(Arrays.asList(c))); } } ///:~ The pformat( ) method produces formatted String Collection, pprint( ) method uses pformat( ) job. Note special cases elements single element handled differently. There’s also version pprint( ) arrays. The Directory utility placed net.mindview.util package easily available. Here’s sample use it: //: io/DirectoryDemo.java // Sample use Directory utilities. import java.io.*; 652 Thinking Java Bruce Eckel import net.mindview.util.*; import static net.mindview.util.Print.*; public class DirectoryDemo { public static void main(String[] args) { // All directories: PPrint.pprint(Directory.walk(".").dirs); // All files beginning ‘T’ for(File file : Directory.local(".", "T.*")) print(file); print("----------------------"); // All Java files beginning ‘T’: for(File file : Directory.walk(".", "T.*\\.java")) print(file); print("======================"); // Class files containing "Z" "z": for(File file : Directory.walk(".",".*[Zz].*\\.class")) print(file); } } /* Output: (Sample) [.\xfiles] .\TestEOF.class .\TestEOF.java .\TransferTo.class .\TransferTo.java ---------------------.\TestEOF.java .\TransferTo.java .\xfiles\ThawAlien.java ====================== .\FreezeAlien.class .\GZIPcompress.class .\ZipCompress.class *///:~ You may need refresh knowledge regular expressions Strings chapter order understand second arguments local( ) walk( ). We take step create tool walk directories process files within according Strategy object (this another example Strategy design pattern): //: net/mindview/util/ProcessFiles.java package net.mindview.util; import java.io.*; public class ProcessFiles { public interface Strategy { void process(File file); } private Strategy strategy; private String ext; public ProcessFiles(Strategy strategy, String ext) { this.strategy = strategy; this.ext = ext; } public void start(String[] args) { try { if(args.length == 0) processDirectoryTree(new File(".")); else for(String arg : args) { I/O 653 File fileArg = new File(arg); if(fileArg.isDirectory()) processDirectoryTree(fileArg); else { // Allow user leave extension: if(!arg.endsWith("." + ext)) arg += "." + ext; strategy.process( new File(arg).getCanonicalFile()); } } } catch(IOException e) { throw new RuntimeException(e); } } public void processDirectoryTree(File root) throws IOException { for(File file : Directory.walk( root.getAbsolutePath(), ".*\\." + ext)) strategy.process(file.getCanonicalFile()); } // Demonstration use it: public static void main(String[] args) { new ProcessFiles(new ProcessFiles.Strategy() { public void process(File file) { System.out.println(file); } }, "java").start(args); } } /* (Execute see output) *///:~ The Strategy interface nested within ProcessFiles, want implement must implement ProcessFiles.Strategy, provides context reader. ProcessFiles work finding files particular extension (the ext argument constructor), finds matching file, simply hands Strategy object (which also argument constructor). If don’t give arguments, ProcessFiles assumes want traverse directories current directory. You also specify particular file, without extension (it add extension necessary), one directories. In main( ) see basic example use tool; prints names Java source files according command line provide. Exercise 4: (2) Use Directory.walk( ) sum sizes files directory tree whose names match particular regular expression. Exercise 5: (1) Modify ProcessFiles.java matches regular expression rather fixed extension. Checking creating directories The File class representation existing file directory. You also use File object create new directory entire directory path doesn’t exist. You also look characteristics files (size, last modification date, read/write), see whether File object represents file directory, delete file. The following example shows methods available File class (see JDK documentation http://java.sun.com full set): 654 Thinking Java Bruce Eckel //: io/MakeDirectories.java // Demonstrates use File class // create directories manipulate files. // {Args: MakeDirectoriesTest} import java.io.*; public class MakeDirectories { private static void usage() { System.err.println( "Usage:MakeDirectories path1 ...\n" + "Creates path\n" + "Usage:MakeDirectories -d path1 ...\n" + "Deletes path\n" + "Usage:MakeDirectories -r path1 path2\n" + "Renames path1 path2"); System.exit(1); } private static void fileData(File f) { System.out.println( "Absolute path: " + f.getAbsolutePath() + "\n Can read: " + f.canRead() + "\n Can write: " + f.canWrite() + "\n getName: " + f.getName() + "\n getParent: " + f.getParent() + "\n getPath: " + f.getPath() + "\n length: " + f.length() + "\n lastModified: " + f.lastModified()); if(f.isFile()) System.out.println("It’s file"); else if(f.isDirectory()) System.out.println("It’s directory"); } public static void main(String[] args) { if(args.length < 1) usage(); if(args[0].equals("-r")) { if(args.length != 3) usage(); File old = new File(args[1]), rname = new File(args[2]); old.renameTo(rname); fileData(old); fileData(rname); return; // Exit main } int count = 0; boolean del = false; if(args[0].equals("-d")) { count++; del = true; } count--; while(++count < args.length) { File f = new File(args[count]); if(f.exists()) { System.out.println(f + " exists"); if(del) { System.out.println("deleting..." + f); f.delete(); } } else { // Doesn’t exist if(!del) { f.mkdirs(); I/O 655 } System.out.println("created " + f); } fileData(f); } } } /* Output: (80% match) created MakeDirectoriesTest Absolute path: d:\aaa-TIJ4\code\io\MakeDirectoriesTest Can read: true Can write: true getName: MakeDirectoriesTest getParent: null getPath: MakeDirectoriesTest length: 0 lastModified: 1101690308831 It’s directory *///:~ In fileData( ) see various file investigation methods used display information file directory path. The first method that’s exercised main( ) renameTo( ), allows rename (or move) file entirely new path represented argument, another File object. This also works directories length. If experiment preceding program, you’ll find make directory path complexity, mkdirs( ) work you. Exercise 6: (5) Use ProcessFiles find Java source-code files particular directory subtree modified particular date. Input output Programming language I/O libraries often use abstraction stream, represents data source sink object capable producing receiving pieces data. The stream hides details happens data inside actual I/O device. The Java library classes I/O divided input output, see looking class hierarchy JDK documentation. Through inheritance, everything derived InputStream Reader classes basic methods called read( ) reading single byte array bytes. Likewise, everything derived OutputStream Writer classes basic methods called write( ) writing single byte array bytes. However, won’t generally use methods; exist classes use them—these classes provide useful interface. Thus, you’ll rarely create stream object using single class, instead layer multiple objects together provide desired functionality (this Decorator design pattern, shall see section). The fact create one object produce single stream primary reason Java’s I/O library confusing. It’s helpful categorize classes functionality. In Java l.o, library designers started deciding classes anything input would inherited InputStream, classes associated output would inherited OutputStream. 656 Thinking Java Bruce Eckel As practice book, I attempt provide overview classes, assume use JDK documentation determine details, exhaustive list methods particular class. Types InputStream InputStream’s job represent classes produce input different sources. These sources be: 1. An array bytes. 2. A String obj ect. 3. A file. 4. A "pipe," works like physical pipe: You put things one end come other. 5. A sequence streams, collect together single stream. 6. Other sources, Internet connection. (This covered Thinking Enterprise Java, available www.MindView.net.) Each associated subclass InputStream. In addition, FilterInputStream also type InputStream, provide base class "decorator" classes attach attributes useful interfaces input streams. This discussed later. Table I/O-1. Types InputStream Class Function Constructor arguments How use ByteArrayInputStream StringBufferInputStream Allows buffer memory used InputStream. The buffer extract bytes. Converts String InputStream. A String. The underlying implementation actually uses StringBuffer. As source data: Connect FilterlnputStream object provide useful interface. As source data: Connect FilterlnputStream object provide useful interface. FileInputStream For reading information file. A String representing file name, File FileDescriptor object. As source data: Connect FilterlnputStream object provide useful interface. I/O 657 Class Function Constructor arguments How use PipedInputStream Produces data that’s written associated PipedOutputStream. Implements "piping" concept. PipedOutputStream SequenceInputStream Converts two InputStream objects single InputStream. Two InputStream objects Enumeration container InputStream objects. Abstract class interface decorators provide useful functionality InputStream classes. See Table I/O-3. See Table I/O-3. FilterInputStream As source data multithreading: Connect FilterlnputStream object provide useful interface. As source data: Connect FilterlnputStream object provide useful interface. See Table I/O-3. Types OutputStream This category includes classes decide output go: array bytes (but String—presumably, create one using array bytes), file, "pipe." In addition, FilterOutputStream provides base class "decorator" classes attach attributes useful interfaces output streams. This discussed later. Table I/O-2. Types OutputStream Class Function Constructor arguments How use ByteArrayOutputStream FileOutputStream 658 Creates buffer memory. All data send stream placed buffer. Optional initial size buffer. For sending information file. A String representing file name, File FileDescriptor object. To designate destination data: Connect FilterOutputStream object provide useful interface. Thinking Java Bruce Eckel Class Function Constructor arguments How use To designate destination data: Connect FilterOutputStream object provide useful interface. PipedOutputStream FilterOutputStream Any information write automatically ends input associated PipedlnputStream. Implements "piping" concept. PipedlnputStream Abstract class interface decorators provide useful functionality OutputStream classes. See Table 1/O-4- See Table I/O-4. To designate destination data multithreading: Connect FilterOutputStream object provide useful interface. See Table I/O-4. Adding attributes useful interfaces Decorators introduced Generics chapter, page 717. The Java I/O library requires many different combinations features, justification using Decorator design pattern. 1 The reason existence "filter" classes Java I/O library abstract "filter" class base class decorators. A decorator must interface object decorates, decorator also extend interface, occurs several "filter" classes. There drawback Decorator, however. Decorators give much flexibility you’re writing program (since easily mix match attributes), add complexity code. The reason Java I/O library awkward use must create many classes—the "core" I/O type plus decorators—in order get single I/O object want. The classes provide decorator interface control particular InputStream OutputStream FilterlnputStream FilterOutputStream, don’t intuitive names. FilterlnputStream FilterOutputStream derived base classes I/O library, InputStream OutputStream, key requirement decorator (so provides common interface objects decorated). It’s clear good design decision, especially compared simplicity I/O libraries languages. But it’s justification decision. 1 I/O 659 Reading InputStream FilterlnputStream The FilterlnputStream classes accomplish two significantly different things. DatalnputStream allows read different types primitive data well String objects. (All methods start "read," readByte( ), readFloat( ), etc.) This, along companion DataOutputStream, allows move primitive data one place another via stream. These "places" determined classes Table I/O-1. The remaining FilterlnputStream classes modify way InputStream behaves internally: whether it’s buffered unbuffered, whether keeps track lines it’s reading (allowing ask line numbers set line number), whether push back single character. The last two classes look lot like support building compiler (they probably added support experiment "building Java compiler Java"), probably won’t use general programming. You’ll need buffer input almost every time, regardless I/O device you’re connecting to, would made sense I/O library special case (or simply method call) unbuffered input rather buffered input. Table I/O-3. Types FilterlnputStream Class Function Constructor arguments How use DataInputStream BufferedInputStream LineNumberInputStream PushbackInputStream Used concert DataOutputStream, read primitives (int, char, long, etc.) stream portable fashion. InputStream Use prevent physical read every time want data. You’re saying, "Use buffer." InputStream, optional buffer size. Keeps track line numbers input stream; call getLineNumber( ) setLineNumber (int). InputStream Has one-byte pushback buffer push back last character read. InputStream Contains full interface allow read primitive types. This doesn’t provide interface per se. It adds buffering process. Attach interface object. This adds line numbering, you’ll probably attach interface object. Generally used 660 Thinking Java Bruce Eckel Class Function Constructor arguments How use scanner compiler. You probably won’t use this. Writing OutputStream FilterOutputStream The complement DatalnputStream DataOutputStream, formats primitive types String objects onto stream way DatalnputStream, machine, read them. All methods start "write," writeByte( ), writeFloat( ), etc. The original intent PrintStream print primitive data types String objects viewable format. This different DataOutputStream, whose goal put data elements stream way DatalnputStream portably reconstruct them. The two important methods PrintStream print( ) println( ), overloaded print various types. The difference print( ) println( ) latter adds newline it’s done. PrintStream problematic traps IOExceptions (you must explicitly test error status checkError( ), returns true error occurred). Also, PrintStream doesn’t internationalize properly doesn’t handle line breaks platformindependent way. These problems solved PrintWriter, described later. BufferedOutputStream modifier tells stream use buffering don’t get physical write every time write stream. You’ll probably always want use output. Table I/O-4. Types FilterOutputStream Class Function Constructor arguments How use DataOutputStream PrintStream I/O Used concert DataInputStream write primitives (int, char, long, etc.) stream portable fashion. For producing formatted output. While DataOutputStream handles storage data, PrintStream handles display. OutputStream Contains full interface allow write primitive types. OutputStream, optional boolean indicating buffer flushed every newline. Should "final" 661 Class Function Constructor arguments How use wrapping OutputStream object. You’ll probably use lot. BufferedOutputStream Use prevent physical write every time send piece data. You’re saying, "Use buffer." You call flush( ) flush buffer. OutputStream, optional buffer size. This doesn’t provide interface per se. It adds buffering process. Attach interface object. Readers & Writers Java 1.1 made significant modifications fundamental I/O stream library. When see Reader Writer classes, first thought (like mine) might meant replace InputStream OutputStream classes. But that’s case. Although aspects original streams library deprecated (if use receive warning compiler), InputStream OutputStream classes still provide valuable functionality form byte-oriented I/O, whereas Reader Writer classes provide Unicode-compliant, character-based I/O. In addition: 1. Java 1.1 added new classes InputStream OutputStream hierarchy, it’s obvious hierarchies weren’t replaced. 2. There times must use classes "byte" hierarchy combination classes "character" hierarchy. To accomplish this, "adapter" classes: InputStreamReader converts InputStream Reader, OutputStreamWriter converts OutputStream Writer. The important reason Reader Writer hierarchies internationalization. The old I/O stream hierarchy supports 8-bit byte streams doesn’t handle 16-bit Unicode characters well. Since Unicode used internationalization (and Java’s native char 16-bit Unicode), Reader Writer hierarchies added support Unicode I/O operations. In addition, new libraries designed faster operations old. Sources sinks data Almost original Java I/O stream classes corresponding Reader Writer classes provide native Unicode manipulation. However, places byte-oriented InputStreams OutputStreams correct solution; particular, thejava.util.zip libraries byte-oriented rather char-oriented. So sensible approach take try use Reader Writer classes whenever can. You’ll discover situations use byte-oriented libraries code won’t compile. Here table shows correspondence sources sinks information (that is, data physically comes goes to) two hierarchies. 662 Thinking Java Bruce Eckel Sources & sinks: Java 1.0 class Corresponding Java 1.1 class InputStream Reader adapter: InputStreamReader OutputStream Writer adapter: OutputStreamWriter FilelnputStream FileReader FileOutputStream FileWriter StringBufferlnputStream (deprecated) StringReader (no corresponding class) StringWriter ByteArrayInputStream CharArrayReader ByteArrayOutputStream CharArrayWriter PipedInputStream PipedReader PipedOutputStream PipedWriter In general, you’ll find interfaces two different hierarchies similar, identical. Modifying stream behavior For InputStreams OutputStreams, streams adapted particular needs using "decorator" subclasses FilterInputStream FilterOutputStream. The Reader Writer class hierarchies continue use idea—but exactly. In following table, correspondence rougher approximation previous table. The difference class organization; although BufferedOutputStream subclass FilterOutputStream, BufferedWriter subclass FilterWriter (which, even though abstract, subclasses appears put either placeholder simply don’t wonder is). However, interfaces classes quite close match. I/O Filters: Java 1.0 class Corresponding Java 1.1 class FilterInputStream FilterReader FilterOutputStream FilterWriter (abstract class subclasses) BufferedInputStream BufferedReader (also readLine( )) BufferedOutputStream BufferedWriter DataInputStream Use DataInputStream (except need use readLine( ), use 663 Filters: Java 1.0 class Corresponding Java 1.1 class BufferedReader) PrintStream PrintWriter LineNumberInputStream (deprecated) LineNumberReader StreamTokenizer StreamTokenizer (Use constructor takes Reader instead) PushbacklnputStream PushbackReader There’s one direction that’s quite clear: Whenever want use readLine( ), shouldn’t DataInputStream (this met deprecation message compile time), instead use BufferedReader. Other this, DataInputStream still "preferred" member I/O library. To make transition using PrintWriter easier, constructors take OutputStream object well Writer objects. PrintWriter’s formatting interface virtually PrintStream. In Java SE5, PrintWriter constructors added simplify creation files writing output, shall see shortly. One PrintWriter constructor also option perform automatic flushing, happens every println( ) constructor flag set. Unchanged classes Some classes left unchanged Java 1.0 Java 1.1: Java 1.0 classes without corresponding Java 1.1 classes DataOutputStream File RandomAccessFile SequenceInputStream DataOutputStream, particular, used without change, storing retrieving data transportable format, use InputStream OutputStream hierarchies. 664 Thinking Java Bruce Eckel Off itself: RandomAccessFile RandomAccessFile used files containing records known size move one record another using seek( ), read change records. The records don’t size; determine big placed file. At first it’s little bit hard believe RandomAccessFile part InputStream OutputStream hierarchy. However, association hierarchies happens implement DataInput DataOutput interfaces (which also implemented DataInputStream DataOutputStream). It doesn’t even use functionality existing InputStream OutputStream classes; it’s completely separate class, written scratch, (mostly native) methods. The reason may RandomAccessFile essentially different behavior I/O types, since move forward backward within file. In event, stands alone, direct descendant Object. Essentially, RandomAccessFile works like DataInputStream pasted together DataOutputStream, along methods getFilePointer( ) find file, seek( ) move new point file, length( ) determine maximum size file. In addition, constructors require second argument (identical fopen( ) C) indicating whether randomly reading ("r") reading writing ("rw"). There’s support write-only files, could suggest RandomAccessFile might worked well inherited DataInputStream. The seeking methods available RandomAccessFile, works files only. BufferedInputStream allow mark( ) position (whose value held single internal variable) reset( ) position, limited useful. Most, all, RandomAccessFile functionality superseded JDK 1.4 nio memory-mapped files, described later chapter. Typical uses I/O streams Although combine I/O stream classes many different ways, you’ll probably use combinations. The following examples used basic reference typical I/O usage. In examples, exception handing simplified passing exceptions console, appropriate small examples utilities. In code you’ll want consider sophisticated error-handling approaches. Buffered input file To open file character input, use FileInputReader String File object file name. For speed, you’ll want file buffered give resulting reference constructor BufferedReader. Since BufferedReader also provides readLine( ) method, final object interface read from. When readLine( ) returns null, you’re end file. //: io/BufferedInputFile.java import java.io.*; I/O 665 public class BufferedInputFile { // Throw exceptions console: public static String read(String filename) throws IOException { // Reading input lines: BufferedReader = new BufferedReader( new FileReader(filename)); String s; StringBuilder sb = new StringBuilder(); while((s = in.readLine())!= null) sb.append(s + "\n"); in.close(); return sb.toString(); } public static void main(String[] args) throws IOException { System.out.print(read("BufferedInputFile.java")); } } /* (Execute see output) *///:~ The StringBuilder sb used accumulate entire contents file (including newlines must added since readLine( ) strips off). Finally, close( ) called close file. 2 Exercise 7: (2) Open text file read file one line time. Read line String place String object LinkedList. Print lines LinkedList reverse order. Exercise 8: (1) Modify Exercise 7 name file read provided command-line argument. Exercise 9: (1) Modify Exercise 8 force lines LinkedList uppercase send results System.out. Exercise 10: (2) Modify Exercise 8 take additional command-line arguments words find file. Print lines words match. Exercise 11: (2) In innerclasses/GreenhouseController.java example, GreenhouseController contains hard-coded set events. Change program reads events relative times text file, ((difficulty level 8): Use Factory Method design pattern build events—see Thinking Patterns (with Java) www.MindView.net.) Input memory Here, String result BufferedInputFile.read( ) used create StringReader. Then read( ) used read character one time send console: //: io/MemoryInput.java import java.io.*; In original design, close( ) supposed called finalize( ) ran, see finalize( ) defined way I/O classes. However, discussed elsewhere book, finalize( ) feature didn’t work way Java designers originally envisioned (that say, it’s irreparably broken), safe approach explicitly call close( ) files. 2 666 Thinking Java Bruce Eckel public class MemoryInput { public static void main(String[] args) throws IOException { StringReader = new StringReader( BufferedInputFile.read("MemoryInput.java")); int c; while((c = in.read()) != -1) System.out.print((char)c); } } /* (Execute see output) *///:~ Note read( ) returns next character int thus must cast char print properly. Formatted memory input To read "formatted" data, use DataInputStream, byteoriented I/O class (rather char-oriented). Thus must use InputStream classes rather Reader classes. Of course, read anything (such file) bytes using InputStream classes, String used: //: io/FormattedMemoryInput.java import java.io.*; public class FormattedMemoryInput { public static void main(String[] args) throws IOException { try { DataInputStream = new DataInputStream( new ByteArrayInputStream( BufferedInputFile.read( "FormattedMemoryInput.java").getBytes())); while(true) System.out.print((char)in.readByte()); } catch(EOFException e) { System.err.println("End stream"); } } } /* (Execute see output) *///:~ A ByteArrayInputStream must given array bytes. To produce this, String getBytes( ) method. The resulting ByteArrayInputStream appropriate InputStream hand DataInputStream. If read characters DataInputStream one byte time using readByte( ), byte value legitimate result, return value cannot used detect end input. Instead, use available( ) method find many characters available. Here’s example shows read file one byte time: //: io/TestEOF.java // Testing end file reading byte time. import java.io.*; public class TestEOF { public static void main(String[] args) throws IOException { DataInputStream = new DataInputStream( new BufferedInputStream( new FileInputStream("TestEOF.java"))); while(in.available() != 0) I/O 667 System.out.print((char)in.readByte()); } } /* (Execute see output) *///:~ Note available( ) works differently depending sort medium you’re reading from; it’s literally "the number bytes read without blocking." With file, means whole file, different kind stream might true, use thoughtfully. You could also detect end input cases like catching exception. However, use exceptions control flow considered misuse feature. Basic file output A FileWriter object writes data file. You’ll virtually always want buffer output wrapping BufferedWriter (try removing wrapping see impact performance—buffering tends dramatically increase performance I/O operations). In example, it’s decorated PrintWriter provide formatting. The data file created way readable ordinary text file: //: io/BasicFileOutput.java import java.io.*; public class BasicFileOutput { static String file = "BasicFileOutput.out"; public static void main(String[] args) throws IOException { BufferedReader = new BufferedReader( new StringReader( BufferedInputFile.read("BasicFileOutput.java"))); PrintWriter = new PrintWriter( new BufferedWriter(new FileWriter(file))); int lineCount = 1; String s; while((s = in.readLine()) != null ) out.println(lineCount++ + ": " + s); out.close(); // Show stored file: System.out.println(BufferedInputFile.read(file)); } } /* (Execute see output) *///:~ As lines written file, line numbers added. Note LineNumberReader used, it’s silly class don’t need it. You see example it’s trivial keep track line numbers. When input stream exhausted, readLine( ) returns null. You’ll see explicit close( ) out, don’t call close( ) output files, might discover buffers don’t get flushed, file incomplete. Text file output shortcut Java SE5 added helper constructor PrintWriter don’t decoration hand every time want create text file write it. Here’s BasicFileOutput.java rewritten use shortcut: //: io/FileOutputShortcut.java import java.io.*; 668 Thinking Java Bruce Eckel public class FileOutputShortcut { static String file = "FileOutputShortcut.out"; public static void main(String[] args) throws IOException { BufferedReader = new BufferedReader( new StringReader( BufferedInputFile.read("FileOutputShortcut.java"))); // Here’s shortcut: PrintWriter = new PrintWriter(file); int lineCount = 1; String s; while((s = in.readLine()) != null ) out.println(lineCount++ + ": " + s); out.close(); // Show stored file: System.out.println(BufferedInputFile.read(file)); } } /* (Execute see output) *///:~ You still get buffering, don’t yourself. Unfortunately, commonly written tasks given shortcuts, typical I/O still involve lot redundant text. However, TextFile utility used book, defined little later chapter, simplify common tasks. Exercise 12: (3) Modify Exercise 8 also open text file write text it. Write lines LinkedList, along line numbers (do attempt use "LineNumber" classes), file. Exercise 13: (3) Modify BasicFileOutput.java uses LineNumberReader keep track line count. Note it’s much easier keep track programmatically. Exercise 14: (2) Starting BasicFileOutput.java, write program compares performance writing file using buffered unbuffered I/O. Storing recovering data A PrintWriter formats data it’s readable human. However, output data recovery another stream, use DataOutputStream write data DataInputStream recover data. Of course, streams anything, following example uses file, buffered reading writing. DataOutputStream DataInputStream byte-oriented thus require InputStreams OutputStreams: //: io/StoringAndRecoveringData.java import java.io.*; public class StoringAndRecoveringData { public static void main(String[] args) throws IOException { DataOutputStream = new DataOutputStream( new BufferedOutputStream( new FileOutputStream("Data.txt"))); out.writeDouble(3.14159); out.writeUTF("That pi"); out.writeDouble(1.41413); out.writeUTF("Square root 2"); out.close(); DataInputStream = new DataInputStream( I/O 669 new BufferedInputStream( new FileInputStream("Data.txt"))); System.out.println(in.readDouble()); // Only readUTF() recover // Java-UTF String properly: System.out.println(in.readUTF()); System.out.println(in.readDouble()); System.out.println(in.readUTF()); } } /* Output: 3.14159 That pi 1.41413 Square root 2 *///:~ If use DataOutputStream write data, Java guarantees accurately recover data using DataInputStream— regardless different platforms write read data. This incredibly valuable, anyone knows spent time worrying platform-specific data issues. That problem vanishes Java platforms. 3 When using DataOutputStream, reliable way write String recovered DataInputStream use UTF-8 encoding, accomplished example using writeUTF( ) readUTF( ). UTF-8 multi-byte format, length encoding varies according actual character set use. If you’re working ASCII mostly ASCII characters (which occupy seven bits), Unicode tremendous waste space and/or bandwidth, UTF-8 encodes ASCII characters single byte, non-ASCII characters two three bytes. In addition, length string stored first two bytes UTF-8 string. However, writeUTF( ) readUTF( ) use special variation UTF-8 Java (which completely described JDK documentation methods), read string written writeUTF( ) using non-Java program, must write special code order read string properly. With writeUTF( ) readUTF( ), intermingle Strings types data using DataOutputStream, knowledge Strings properly stored Unicode easily recoverable DataInputStream. The writeDouble( ) method stores double number stream, complementary readDouble( ) method recovers (there similar methods reading writing types). But reading methods work correctly, must know exact placement data item stream, since would equally possible read stored double simple sequence bytes, char, etc. So must either fixed format data file, extra information must stored file parse determine data located. Note object serialization XML (both described later chapter) may easier ways store retrieve complex data structures. Exercise 15: (4) Look DataOutputStream DataInputStream JDK documentation. Starting StoringAndRecoveringData.java, create program stores retrieves different possible types provided DataOutputStream DataInputStream classes. Verify values stored retrieved accurately. Reading writing 3 XML another way solve problem moving data across different computing platforms, depend Java platforms. XML introduced later chapter. 670 Thinking Java Bruce Eckel random-access files Using RandomAccessFile like using combined DataInputStream DataOutputStream (because implements interfaces: DataInput DataOutput). In addition, use seek( ) move file change values. When using RandomAccessFile, must know layout file manipulate properly. RandomAccessFile specific methods read write primitives UTF-8 strings. Here’s example: //: io/UsingRandomAccessFile.java import java.io.*; public class UsingRandomAccessFile { static String file = "rtest.dat"; static void display() throws IOException { RandomAccessFile rf = new RandomAccessFile(file, "r"); for(int = 0; < 7; i++) System.out.println( "Value " + + ": " + rf.readDouble()); System.out.println(rf.readUTF()); rf.close(); } public static void main(String[] args) throws IOException { RandomAccessFile rf = new RandomAccessFile(file, "rw"); for(int = 0; < 7; i++) rf.writeDouble(i*1.414); rf.writeUTF("The end file"); rf.close(); display(); rf = new RandomAccessFile(file, "rw"); rf.seek(5*8); rf.writeDouble(47.0001); rf.close(); display(); } } /* Output: Value 0: 0.0 Value 1: 1.414 Value 2: 2.828 Value 3: 4.242 Value 4: 5.656 Value 5: 7.069999999999999 Value 6: 8.484 The end file Value 0: 0.0 Value 1: 1.414 Value 2: 2.828 Value 3: 4.242 Value 4: 5.656 Value 5: 47.0001 Value 6: 8.484 The end file *///:~ The display( ) method opens file displays seven elements within double values. In main( ), file created, opened modified. Since double always eight bytes long, seek( ) double number 5 multiply 5*8 produce seek value. I/O 671 As previously noted, RandomAccessFile effectively separate rest I/O hierarchy, save fact implements DataInput DataOutput interfaces. It doesn’t support decoration, cannot combine aspects InputStream OutputStream subclasses. You must assume RandomAccessFile properly buffered since cannot add that. The one option second constructor argument: You open RandomAccessFile read ("r") read write ("rw"). You may want consider using nio memory-mapped files instead RandomAccessFile. Exercise 16: (2) Look RandomAccessFile JDK documentation. Starting UsingRandomAccessFile.java, create program stores retrieves different possible types provided RandomAccessFile class. Verify values stored retrieved accurately. Piped streams The PipedInputStream, PipedOutputStream, PipedReader PipedWriter mentioned briefly chapter. This suggest aren’t useful, value apparent begin understand concurrency, since piped streams used communicate tasks. This covered along example Concurrency chapter. File reading & writing utilities A common programming task read file memory, modify it, write again. One problems Java I/O library requires write quite bit code order perform common operations—there basic helper functions you. What’s worse, decorators make rather hard remember open files. Thus, makes sense add helper classes library easily perform basic tasks you. Java SE5 added convenience constructor PrintWriter easily open text file writing. However, many common tasks want over, makes sense eliminate redundant code associated tasks. Here’s TextFile class used previous examples book simplify reading writing files. It contains static methods read write text files single string, create TextFile object holds lines file ArrayList (so ArrayList functionality manipulating file contents): //: net/mindview/util/TextFile.java // Static functions reading writing text files // single string, treating file ArrayList. package net.mindview.util; import java.io.*; import java.util.*; public class TextFile extends ArrayList<String> { // Read file single string: public static String read(String fileName) { StringBuilder sb = new StringBuilder(); try { BufferedReader in= new BufferedReader(new FileReader( new File(fileName).getAbsoluteFile())); try { String s; 672 Thinking Java Bruce Eckel while((s = in.readLine()) != null) { sb.append(s); sb.append("\n"); } } finally { in.close(); } } catch(IOException e) { throw new RuntimeException(e); } return sb.toString(); } // Write single file one method call: public static void write(String fileName, String text) { try { PrintWriter = new PrintWriter( new File(fileName).getAbsoluteFile()); try { out.print(text); } finally { out.close(); } } catch(IOException e) { throw new RuntimeException(e); } } // Read file, split regular expression: public TextFile(String fileName, String splitter) { super(Arrays.asList(read(fileName).split(splitter))); // Regular expression split() often leaves empty // String first position: if(get(0).equals("")) remove(0); } // Normally read lines: public TextFile(String fileName) { this(fileName, "\n"); } public void write(String fileName) { try { PrintWriter = new PrintWriter( new File(fileName).getAbsoluteFile()); try { for(String item : this) out.println(item); } finally { out.close(); } } catch(IOException e) { throw new RuntimeException(e); } } // Simple test: public static void main(String[] args) { String file = read("TextFile.java"); write("test.txt", file); TextFile text = new TextFile("test.txt"); text.write("test2.txt"); // Break unique sorted list words: TreeSet<String> words = new TreeSet<String>( new TextFile("TextFile.java", "\\W+")); // Display capitalized words: System.out.println(words.headSet("a")); } I/O 673 } /* Output: [0, ArrayList, Arrays, Break, BufferedReader, BufferedWriter, Clean, Display, File, FileReader, FileWriter, IOException, Normally, Output, PrintWriter, Read, Regular, RuntimeException, Simple, Static, String, StringBuilder, System, TextFile, Tools, TreeSet, W, Write] *///:~ read( ) appends line StringBuilder, followed newline, stripped reading. Then returns String containing whole file. write( ) opens writes text String file. Notice code opens file guards file’s close( ) call finally clause guarantee file properly closed. The constructor uses read( ) method turn file String, uses String.split( ) divide result lines along newline boundaries (if use class lot, may want rewrite constructor improve efficiency). Alas, corresponding "join" method, non-static write( ) method must write lines hand. Because class intended trivialize process reading writing files, IOExceptions converted RuntimeExceptions, user doesn’t use trycatch blocks. However, may need create another version passes IOExceptions caller. In main( ), basic test performed ensure methods work. Although utility require much code create, using save lot time make life easier, you’ll see examples later chapter. Another way solve problem reading text files use java.util.Scanner class introduced Java SE5. However, reading files, writing them, tool (which you’ll notice java.io) primarily designed creating programminglanguage scanners "little languages." Exercise 17: (4) Using TextFile Map<Character,Integer>, create program counts occurrence different characters file. (So 12 occurrences letter ‘a’ file, Integer associated Character containing ‘a’ Map contains ‘12’). Exercise 18: (1) Modify TextFile.java passes IOExceptions caller. Reading binary files This utility similar TextFile.java simplifies process reading binary files: //: net/mindview/util/BinaryFile.java // Utility reading files binary form. package net.mindview.util; import java.io.*; public class BinaryFile { public static byte[] read(File bFile) throws IOException{ BufferedInputStream bf = new BufferedInputStream( new FileInputStream(bFile)); try { byte[] data = new byte[bf.available()]; 674 Thinking Java Bruce Eckel bf.read(data); return data; } finally { bf.close(); } } public static byte[] read(String bFile) throws IOException { return read(new File(bFile).getAbsoluteFile()); } } ///:~ One overloaded method takes File argument; second takes String argument, file name. Both return resulting byte array. The available( ) method used produce appropriate array size, particular version overloaded read( ) method fills array. Exercise 19: (2) Using BinaryFile Map<Byte,Integer>, create program counts occurrence different bytes file. Exercise 20: (4) Using Directory.walk( ) BinaryFile, verify .class files directory tree begin hex characters ‘CAFEBABE’. Standard I/O The term standard I/O refers Unix concept single stream information used program (this idea reproduced form Windows many operating systems). All program’s input come standard input, output go standard output, error messages sent standard error. The value standard I/O programs easily chained together, one program’s standard output become standard input another program. This powerful tool. Reading standard input Following standard I/O model, Java System.in, System.out, System.err. Throughout book, you’ve seen write standard output using System.out, already pre-wrapped PrintStream object. System.err likewise PrintStream, System.in raw InputStream wrapping. This means although use System.out System.err right away, System.in must wrapped read it. You’ll typically read input line time using readLine( ). To this, wrap System.in BufferedReader, requires convert System.in Reader using InputStreamReader. Here’s example simply echoes line type in: //: io/Echo.java // How read standard input. // {RunByHand} import java.io.*; public class Echo { public static void main(String[] args) throws IOException { BufferedReader stdin = new BufferedReader( new InputStreamReader(System.in)); String s; I/O 675 while((s = stdin.readLine()) != null && s.length()!= 0) System.out.println(s); // An empty line Ctrl-Z terminates program } } ///:~ The reason exception specification readLine( ) throw IOException. Note System.in usually buffered, streams. Exercise 21: (1) Write program takes standard input capitalizes characters, puts results standard output. Redirect contents file program (the process redirection vary depending operating system). Changing System.out PrintWriter System.out PrintStream, OutputStream. PrintWriter constructor takes OutputStream argument. Thus, want, convert System.out PrintWriter using constructor: //: io/ChangeSystemOut.java // Turn System.out PrintWriter. import java.io.*; public class ChangeSystemOut { public static void main(String[] args) { PrintWriter = new PrintWriter(System.out, true); out.println("Hello, world"); } } /* Output: Hello, world *///:~ It’s important use two-argument version PrintWriter constructor set second argument true order enable automatic flushing; otherwise, may see output. Redirecting standard I/O The Java System class allows redirect standard input, output, error I/O streams using simple static method calls: setIn(InputStream) setOut(PrintStream) setErr(PrintStream) Redirecting output especially useful suddenly start creating large amount output screen, it’s scrolling past faster read it. 4 Redirecting input valuable command-line program want test particular user-input sequence repeatedly. Here’s simple example shows use methods: //: io/Redirecting.java // Demonstrates standard I/O redirection. 4 The Graphical User Interfaces chapter shows even convenient solution this: GUI program scrolling text area. 676 Thinking Java Bruce Eckel import java.io.*; public class Redirecting { public static void main(String[] args) throws IOException { PrintStream console = System.out; BufferedInputStream = new BufferedInputStream( new FileInputStream("Redirecting.java")); PrintStream = new PrintStream( new BufferedOutputStream( new FileOutputStream("test.out"))); System.setIn(in); System.setOut(out); System.setErr(out); BufferedReader br = new BufferedReader( new InputStreamReader(System.in)); String s; while((s = br.readLine()) != null) System.out.println(s); out.close(); // Remember this! System.setOut(console); } } ///:~ This program attaches standard input file redirects standard output standard error another file. Notice stores reference original System.out object beginning program, restores system output object end. I/O redirection manipulates streams bytes, streams characters; thus, InputStreams OutputStreams used rather Readers Writers. Process control You often need execute operating system programs inside Java, control input output programs. The Java library provides classes perform operations. A common task run program send resulting output console. This section contains utility simplify task. Two types errors occur utility: normal errors result exceptions— rethrow runtime exception—and errors execution process itself. We want report errors separate exception: //: net/mindview/util/OSExecuteException.java package net.mindview.util; public class OSExecuteException extends RuntimeException { public OSExecuteException(String why) { super(why); } } ///:~ To run program, pass OSExecute.command( ) command string, command would type run program console. This command passed java.lang.ProcessBuilder constructor (which requires sequence String objects), resulting ProcessBuilder object started: //: net/mindview/util/OSExecute.java // Run operating system command I/O 677 // send output console. package net.mindview.util; import java.io.*; public class OSExecute { public static void command(String command) { boolean err = false; try { Process process = new ProcessBuilder(command.split(" ")).start(); BufferedReader results = new BufferedReader( new InputStreamReader(process.getInputStream())); String s; while((s = results.readLine())!= null) System.out.println(s); BufferedReader errors = new BufferedReader( new InputStreamReader(process.getErrorStream())); // Report errors return nonzero value // calling process problems: while((s = errors.readLine())!= null) { System.err.println(s); err = true; } } catch(Exception e) { // Compensate Windows 2000, throws // exception default command line: if(!command.startsWith("CMD /C")) command("CMD /C " + command); else throw new RuntimeException(e); } if(err) throw new OSExecuteException("Errors executing " + command); } } ///:~ To capture standard output stream program executes, call getInputStream( ). This InputStream something read from. The results program arrive line time, read using readLine( ). Here lines simply printed, may also want capture return command( ). The program’s errors sent standard error stream, captured calling getErrorStream( ). If errors, printed OSExecuteException thrown calling program handle problem. Here’s example shows use OSExecute: //: io/OSExecuteDemo.java // Demonstrates standard I/O redirection. import net.mindview.util.*; public class OSExecuteDemo { public static void main(String[] args) { OSExecute.command("javap OSExecuteDemo"); } } /* Output: Compiled "OSExecuteDemo.java" public class OSExecuteDemo extends java.lang.Object{ 678 Thinking Java Bruce Eckel public OSExecuteDemo(); public static void main(java.lang.String[]); } *///:~ This uses javap decompiler (that comes JDK) decompile program. Exercise 22: (5) Modify OSExecute.java that, instead printing standard output stream, returns results executing program List Strings. Demonstrate use new version utility. New I/O The Java "new" I/O library, introduced JDK 1.4 java.nio.* packages, one goal: speed. In fact, "old" I/O packages reimplemented using nio order take advantage speed increase, benefit even don’t explicitly write code nio. The speed increase occurs file I/O, explored here, network I/O, covered Thinking Enterprise Java. The speed comes using structures closer operating system’s way performing I/O: channels buffers. You could think coal mine; channel mine containing seam coal (the data), buffer cart send mine. The cart comes back full coal, get coal cart. That is, don’t interact directly channel; interact buffer send buffer channel. The channel either pulls data buffer, puts data buffer. The kind buffer communicates directly channel ByteBuffer—that is, buffer holds raw bytes. If look JDK documentation java.nio.ByteBuffer, you’ll see it’s fairly basic: You create one telling much storage allocate, methods put get data, either raw byte form primitive data types. But there’s way put get object, even String. It’s fairly low-level, precisely makes efficient mapping operating systems. Three classes "old" I/O modified produce FileChannel: FileInputStream, FileOutputStream, and, reading writing, RandomAccessFile. Notice byte manipulation streams, keeping low-level nature nio. The Reader Writer character-mode classes produce channels, java.nio.channels.Channels class utility methods produce Readers Writers channels. Here’s simple example exercises three types stream produce channels writeable, read/writeable, readable: //: io/GetChannel.java // Getting channels streams import java.nio.*; import java.nio.channels.*; import java.io.*; public class GetChannel { private static final int BSIZE = 1024; public static void main(String[] args) throws Exception { // Write file: FileChannel fc = new FileOutputStream("data.txt").getChannel(); fc.write(ByteBuffer.wrap("Some text ".getBytes())); I/O 679 fc.close(); // Add end file: fc = new RandomAccessFile("data.txt", "rw").getChannel(); fc.position(fc.size()); // Move end fc.write(ByteBuffer.wrap("Some more".getBytes())); fc.close(); // Read file: fc = new FileInputStream("data.txt").getChannel(); ByteBuffer buff = ByteBuffer.allocate(BSIZE); fc.read(buff); buff.flip(); while(buff.hasRemaining()) System.out.print((char)buff.get()); } } /* Output: Some text Some *///:~ For stream classes shown here, getChannel( ) produce FileChannel. A channel fairly basic: You hand ByteBuffer reading writing, lock regions file exclusive access (this described later). One way put bytes ByteBuffer stuff directly using one "put" methods, put one bytes, values primitive types. However, seen here, also "wrap" existing byte array ByteBuffer using wrap( ) method. When this, underlying array copied, instead used storage generated ByteBuffer. We say ByteBuffer "backed by" array. The data.txt file reopened using RandomAccessFile. Notice move FileChannel around file; here, moved end additional writes appended. For read-only access, must explicitly allocate ByteBuffer using static allocate( ) method. The goal nio rapidly move large amounts data, size ByteBuffer significant—in fact, lK used probably quite bit smaller you’d normally want use (you’ll experiment working application find best size). It’s also possible go even speed using allocateDirect( ) instead allocate( ) produce "direct" buffer may even higher coupling operating system. However, overhead allocation greater, actual implementation varies one operating system another, again, must experiment working application discover whether direct buffers buy advantage speed. Once call read( ) tell FileChannel store bytes ByteBuffer, must call flip( ) buffer tell get ready bytes extracted (yes, seems bit crude, remember it’s low-level done maximum speed). And use buffer read( ) operations, we’d also call clear( ) prepare read( ). You see simple file-copying program: //: io/ChannelCopy.java // Copying file using channels buffers // {Args: ChannelCopy.java test.txt} import java.nio.*; import java.nio.channels.*; import java.io.*; public class ChannelCopy { 680 Thinking Java Bruce Eckel private static final int BSIZE = 1024; public static void main(String[] args) throws Exception { if(args.length != 2) { System.out.println("arguments: sourcefile destfile"); System.exit(1); } FileChannel = new FileInputStream(args[0]).getChannel(), = new FileOutputStream(args[1]).getChannel(); ByteBuffer buffer = ByteBuffer.allocate(BSIZE); while(in.read(buffer) != -1) { buffer.flip(); // Prepare writing out.write(buffer); buffer.clear(); // Prepare reading } } } ///:~ You see one FileChannel opened reading, one writing. A ByteBuffer allocated, FileChannel.read( ) returns -1 (a holdover, doubt, Unix C), means you’ve reached end input. After read( ), puts data buffer, flip( ) prepares buffer information extracted write( ). After write( ), information still buffer, clear( ) resets internal pointers it’s ready accept data another read( ). The preceding program ideal way handle kind operation, however. Special methods transferTo( ) transferFrom( ) allow connect one channel directly another: //: io/TransferTo.java // Using transferTo() channels // {Args: TransferTo.java TransferTo.txt} import java.nio.channels.*; import java.io.*; public class TransferTo { public static void main(String[] args) throws Exception { if(args.length != 2) { System.out.println("arguments: sourcefile destfile"); System.exit(1); } FileChannel = new FileInputStream(args[0]).getChannel(), = new FileOutputStream(args[1]).getChannel(); in.transferTo(0, in.size(), out); // Or: // out.transferFrom(in, 0, in.size()); } } ///:~ You won’t kind thing often, it’s good know about. Converting data If look back GetChannel.java, you’ll notice that, print information file, pulling data one byte time casting byte char. This seems bit primitive—if look java.nio.CharBuffer class, you’ll see toString( ) method says, "Returns string containing characters buffer." Since ByteBuffer viewed CharBuffer asCharBuffer( ) method, I/O 681 use that? As see first line output statement below, doesn’t work out: //: io/BufferToText.java // Converting text ByteBuffers import java.nio.*; import java.nio.channels.*; import java.nio.charset.*; import java.io.*; public class BufferToText { private static final int BSIZE = 1024; public static void main(String[] args) throws Exception { FileChannel fc = new FileOutputStream("data2.txt").getChannel(); fc.write(ByteBuffer.wrap("Some text".getBytes())); fc.close(); fc = new FileInputStream("data2.txt").getChannel(); ByteBuffer buff = ByteBuffer.allocate(BSIZE); fc.read(buff); buff.flip(); // Doesn’t work: System.out.println(buff.asCharBuffer()); // Decode using system’s default Charset: buff.rewind(); String encoding = System.getProperty("file.encoding"); System.out.println("Decoded using " + encoding + ": " + Charset.forName(encoding).decode(buff)); // Or, could encode something print: fc = new FileOutputStream("data2.txt").getChannel(); fc.write(ByteBuffer.wrap( "Some text".getBytes("UTF-16BE"))); fc.close(); // Now try reading again: fc = new FileInputStream("data2.txt").getChannel(); buff.clear(); fc.read(buff); buff.flip(); System.out.println(buff.asCharBuffer()); // Use CharBuffer write through: fc = new FileOutputStream("data2.txt").getChannel(); buff = ByteBuffer.allocate(24); // More needed buff.asCharBuffer().put("Some text"); fc.write(buff); fc.close(); // Read display: fc = new FileInputStream("data2.txt").getChannel(); buff.clear(); fc.read(buff); buff.flip(); System.out.println(buff.asCharBuffer()); } } /* Output: ???? Decoded using Cp1252: Some text Some text Some text *///:~ The buffer contains plain bytes, turn characters, must either encode put (so meaningful come out) decode come buffer. This accomplished using 682 Thinking Java Bruce Eckel java.nio.charset.Charset class, provides tools encoding many different types character sets: //: io/AvailableCharSets.java // Displays Charsets aliases import java.nio.charset.*; import java.util.*; import static net.mindview.util.Print.*; public class AvailableCharSets { public static void main(String[] args) { SortedMap<String,Charset> charSets = Charset.availableCharsets(); Iterator<String> = charSets.keySet().iterator(); while(it.hasNext()) { String csName = it.next(); printnb(csName); Iterator aliases = charSets.get(csName).aliases().iterator(); if(aliases.hasNext()) printnb(": "); while(aliases.hasNext()) { printnb(aliases.next()); if(aliases.hasNext()) printnb(", "); } print(); } } } /* Output: Big5: csBig5 Big5-HKSCS: big5-hkscs, big5hk, big5-hkscs:unicode3.0, big5hkscs, Big5_HKSCS EUC-JP: eucjis, x-eucjp, csEUCPkdFmtjapanese, eucjp, Extended_UNIX_Code_Packed_Format_for_Japanese, x-euc-jp, euc_jp EUC-KR: ksc5601, 5601, ksc5601_1987, ksc_5601, ksc5601-1987, euc_kr, ks_c_5601-1987, euckr, csEUCKR GB18030: gb18030-2000 GB2312: gb2312-1980, gb2312, EUC_CN, gb2312-80, euc-cn, euccn, x-EUC-CN GBK: windows-936, CP936 ... *///:~ So, returning BufferToText.java, rewind( ) buffer (to go back beginning data) use platform’s default character set decode( ) data, resulting CharBuffer print console fine. To discover default character set, use System.getProperty(“file.encoding"), produces string names character set. Passing Charset.forName( ) produces Charset object used decode string. Another alternative encode( ) using character set result something printable file read, see third part BufferToText.java. Here, UTF-16BE used write text file, read, must convert CharBuffer, produces expected text. Finally, see happens write ByteBuffer CharBuffer (you’ll learn later). Note 24 bytes allocated ByteBuffer. Since char requires two bytes, enough 12 chars, "Some text" 9. The remaining zero bytes still appear representation CharBuffer produced toString( ), see output. I/O 683 Exercise 23: (6) Create test utility method print contents CharBuffer point characters longer printable. Fetching primitives Although ByteBuffer holds bytes, contains methods produce different types primitive values bytes contains. This example shows insertion extraction various values using methods: //: io/GetData.java // Getting different representations ByteBuffer import java.nio.*; import static net.mindview.util.Print.*; public class GetData { private static final int BSIZE = 1024; public static void main(String[] args) { ByteBuffer bb = ByteBuffer.allocate(BSIZE); // Allocation automatically zeroes ByteBuffer: int = 0; while(i++ < bb.limit()) if(bb.get() != 0) print("nonzero"); print("i = " + i); bb.rewind(); // Store read char array: bb.asCharBuffer().put("Howdy!"); char c; while((c = bb.getChar()) != 0) printnb(c + " "); print(); bb.rewind(); // Store read short: bb.asShortBuffer().put((short)471142); print(bb.getShort()); bb.rewind(); // Store read int: bb.asIntBuffer().put(99471142); print(bb.getInt()); bb.rewind(); // Store read long: bb.asLongBuffer().put(99471142); print(bb.getLong()); bb.rewind(); // Store read float: bb.asFloatBuffer().put(99471142); print(bb.getFloat()); bb.rewind(); // Store read double: bb.asDoubleBuffer().put(99471142); print(bb.getDouble()); bb.rewind(); } } /* Output: = 1025 H w ! 12390 99471142 99471142 9.9471144E7 9.9471142E7 684 Thinking Java Bruce Eckel *///:~ After ByteBuffer allocated, values checked see whether buffer allocation automatically zeroes contents—and does. All 1.024 values checked (up limit( ) buffer), zero. The easiest way insert primitive values ByteBuffer get appropriate "view" buffer using asCharBuffer( ), asShortBuffer( ), etc., use view’s put( ) method. You see process used primitive data types. The one little odd put( ) ShortBuffer, requires cast (note cast truncates changes resulting value). All view buffers require casting put( ) methods. View buffers A "view buffer" allows look underlying ByteBuffer window particular primitive type. The ByteBuffer still actual storage that’s "backing" view, changes make view reflected modifications data ByteBuffer. As seen previous example, allows conveniently insert primitive types ByteBuffer. A view also allows read primitive values ByteBuffer, either one time (as ByteBuffer allows) batches (into arrays). Here’s example manipulates ints ByteBuffer via IntBuffer: //: io/IntBufferDemo.java // Manipulating ints ByteBuffer IntBuffer import java.nio.*; public class IntBufferDemo { private static final int BSIZE = 1024; public static void main(String[] args) { ByteBuffer bb = ByteBuffer.allocate(BSIZE); IntBuffer ib = bb.asIntBuffer(); // Store array int: ib.put(new int[]{ 11, 42, 47, 99, 143, 811, 1016 }); // Absolute location read write: System.out.println(ib.get(3)); ib.put(3, 1811); // Setting new limit rewinding buffer. ib.flip(); while(ib.hasRemaining()) { int = ib.get(); System.out.println(i); } } } /* Output: 99 11 42 47 1811 143 811 1016 *///:~ The overloaded put( ) method first used store array int. The following get( ) put( ) method calls directly access int location underlying ByteBuffer. Note absolute location accesses available primitive types talking directly ByteBuffer, well. I/O 685 Once underlying ByteBuffer filled ints primitive type via view buffer, ByteBuffer written directly channel. You easily read channel use view buffer convert everything particular type primitive. Here’s example interprets sequence bytes short, int, float, long, double producing different view buffers ByteBuffer: //: io/ViewBuffers.java import java.nio.*; import static net.mindview.util.Print.*; public class ViewBuffers { public static void main(String[] args) { ByteBuffer bb = ByteBuffer.wrap( new byte[]{ 0, 0, 0, 0, 0, 0, 0, ‘a’ }); bb.rewind(); printnb("Byte Buffer "); while(bb.hasRemaining()) printnb(bb.position()+ " -> " + bb.get() + ", "); print(); CharBuffer cb = ((ByteBuffer)bb.rewind()).asCharBuffer(); printnb("Char Buffer "); while(cb.hasRemaining()) printnb(cb.position() + " -> " + cb.get() + ", "); print(); FloatBuffer fb = ((ByteBuffer)bb.rewind()).asFloatBuffer(); printnb("Float Buffer "); while(fb.hasRemaining()) printnb(fb.position()+ " -> " + fb.get() + ", "); print(); IntBuffer ib = ((ByteBuffer)bb.rewind()).asIntBuffer(); printnb("Int Buffer "); while(ib.hasRemaining()) printnb(ib.position()+ " -> " + ib.get() + ", "); print(); LongBuffer lb = ((ByteBuffer)bb.rewind()).asLongBuffer(); printnb("Long Buffer "); while(lb.hasRemaining()) printnb(lb.position()+ " -> " + lb.get() + ", "); print(); ShortBuffer sb = ((ByteBuffer)bb.rewind()).asShortBuffer(); printnb("Short Buffer "); while(sb.hasRemaining()) printnb(sb.position()+ " -> " + sb.get() + ", "); print(); DoubleBuffer db = ((ByteBuffer)bb.rewind()).asDoubleBuffer(); printnb("Double Buffer "); while(db.hasRemaining()) printnb(db.position()+ " -> " + db.get() + ", "); } } /* Output: Byte Buffer 0 -> 0, 1 -> 0, 2 -> 0, 3 -> 0, 4 -> 0, 5 -> 0, 6 -> 0, 7 -> 97, Char Buffer 0 -> , 1 -> , 2 -> , 3 -> a, Float Buffer 0 -> 0.0, 1 -> 1.36E-43, Int Buffer 0 -> 0, 1 -> 97, Long Buffer 0 -> 97, 686 Thinking Java Bruce Eckel Short Buffer 0 -> 0, 1 -> 0, 2 -> 0, 3 -> 97, Double Buffer 0 -> 4.8E-322, *///:~ The ByteBuffer produced "wrapping" eight-byte array, displayed via view buffers different primitive types. You see following diagram way data appears differently read different types buffers: This corresponds output program. Exercise 24: (1) Modify IntBufferDemo.java use doubles. Endians Different machines may use different byte-ordering approaches store data. "Big endian" places significant byte lowest memory address, "little endian" places significant byte highest memory address. When storing quantity greater one byte, like int, float, etc., may need consider byte ordering. A ByteBuffer stores data big endian form, data sent network always uses big endian order. You change endian-ness ByteBuffer using order( ) argument ByteOrder.BIG_ENDIAN ByteOrder.LITTLE_ENDIAN. Consider ByteBuffer containing following two bytes: If read data short (ByteBuffer.asShortBuffer( )), get number 97 (00000000 01100001), change little endian, get number 24832 (01100001 00000000). Here’s example shows byte ordering changed characters depending endian setting: I/O 687 //: io/Endians.java // Endian differences data storage. import java.nio.*; import java.util.*; import static net.mindview.util.Print.*; public class Endians { public static void main(String[] args) { ByteBuffer bb = ByteBuffer.wrap(new byte[12]); bb.asCharBuffer().put("abcdef"); print(Arrays.toString(bb.array())); bb.rewind(); bb.order(ByteOrder.BIG_ENDIAN); bb.asCharBuffer().put("abcdef"); print(Arrays.toString(bb.array())); bb.rewind(); bb.order(ByteOrder.LITTLE_ENDIAN); bb.asCharBuffer().put("abcdef"); print(Arrays.toString(bb.array())); } } /* Output: [0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102] [0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102] [97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102, 0] *///:~ The ByteBuffer given enough space hold bytes charArray external buffer array( ) method called display underlying bytes. The array( ) method "optional," call buffer backed array; otherwise, you’ll get UnsupportedOperationException. charArray inserted ByteBuffer via CharBuffer view. When underlying bytes displayed, see default ordering subsequent big endian order, whereas little endian order swaps bytes. Data manipulation buffers The following diagram illustrates relationships nio classes, see move convert data. For example, wish write byte array file, wrap byte array using ByteBuffer.wrap( ) method, open channel FileOutputStream using getChannel( ) method, write data FileChannel ByteBuffer. 688 Thinking Java Bruce Eckel Note ByteBuffer way move data channels, create standalone primitive-typed buffer, get one ByteBuffer using "as" method. That is, cannot convert primitive-typed buffer ByteBuffer. However, since able move primitive data ByteBuffer via view buffer, really restriction. Buffer details I/O 689 A Buffer consists data four indexes access manipulate data efficiently: mark, position, limit capacity. There methods set reset indexes query value. capacity( ) Returns buffer’s capacity. clear( ) Clears buffer, sets position zero, limit capacity. You call method overwrite existing buffer. flip( ) Sets limit position position zero. This method used prepare buffer read data written it. limit( ) Returns value limit. limit(int lim) Sets value limit. mark( ) Sets mark position. position( ) Returns value position. position(int pos) Sets value position. remaining( ) Returns (limit - position). hasRemaining( ) Returns true elements position limit. Methods insert extract data buffer update indexes reflect changes. This example uses simple algorithm (swapping adjacent characters) scramble unscramble characters CharBuffer: //: io/UsingBuffers.java import java.nio.*; import static net.mindview.util.Print.*; public class UsingBuffers { private static void symmetricScramble(CharBuffer buffer){ while(buffer.hasRemaining()) { buffer.mark(); char c1 = buffer.get(); char c2 = buffer.get(); buffer.reset(); buffer.put(c2).put(c1); } } public static void main(String[] args) { char[] data = "UsingBuffers".toCharArray(); ByteBuffer bb = ByteBuffer.allocate(data.length * 2); CharBuffer cb = bb.asCharBuffer(); cb.put(data); print(cb.rewind()); symmetricScramble(cb); print(cb.rewind()); symmetricScramble(cb); print(cb.rewind()); } } /* Output: UsingBuffers sUniBgfuefsr 690 Thinking Java Bruce Eckel UsingBuffers *///:~ Although could produce CharBuffer directly calling wrap( ) char array, underlying ByteBuffer allocated instead, CharBuffer produced view ByteBuffer. This emphasizes goal always manipulate ByteBuffer, since interacts channel. Here’s buffer looks like entrance symmetricScramble( ) method: The position points first element buffer, capacity limit point last element. In symmetricScramble( ), loop iterates position equivalent limit. The position buffer changes relative get( ) put( ) function called it. You also call absolute get( ) put( ) methods include index argument, location get( ) put( ) takes place. These methods modify value buffer’s position. When control enters loop, value mark set using mark( ) call. The state buffer then: The two relative get( ) calls save value first two characters variables c1 c2. After two calls, buffer looks like this: To perform swap, need write c2 position = 0 c1 position = 1. We either use absolute put method achieve this, set value position mark, reset( ) does: I/O 691 The two put( ) methods write c2 c1: During next iteration loop, mark set current value position: The process continues entire buffer traversed. At end loop, position end buffer. If print buffer, characters position limit printed. Thus, want show entire contents buffer, must set position start buffer using rewind( ). Here state buffer rewind( ) call (the value mark becomes undefined): When function symmetricScramble( ) called again, CharBuffer undergoes process restored original state. Memory-mapped files Memory-mapped files allow create modify files big bring memory. With memory-mapped file, pretend entire file memory access simply treating large array. This approach greatly simplifies code write order modify file. Here’s small example: //: io/LargeMappedFiles.java // Creating large file using mapping. // {RunByHand} import java.nio.*; import java.nio.channels.*; 692 Thinking Java Bruce Eckel import java.io.*; import static net.mindview.util.Print.*; public class LargeMappedFiles { static int length = 0x8FFFFFF; // 128 MB public static void main(String[] args) throws Exception { MappedByteBuffer = new RandomAccessFile("test.dat", "rw").getChannel() .map(FileChannel.MapMode.READ_WRITE, 0, length); for(int = 0; < length; i++) out.put((byte)’x’); print("Finished writing"); for(int = length/2; < length/2 + 6; i++) printnb((char)out.get(i)); } } ///:~ To writing reading, start RandomAccessFile, get channel file, call map( ) produce MappedByteBuffer, particular kind direct buffer. Note must specify starting point length region want map file; means option map smaller regions large file. MappedByteBuffer inherited ByteBuffer, ByteBuffer’s methods. Only simple uses put( ) get( ) shown here, also use methods like asCharBuffer( ), etc. The file created preceding program 128 MB long, probably larger OS allow memory one time. The file appears accessible portions brought memory, parts swapped out. This way large file (up 2 GB) easily modified. Note file-mapping facilities underlying operating system used maximize performance. Performance Although performance "old" stream I/O improved implementing nio, mapped file access tends dramatically faster. This program simple performance comparison: //: io/MappedIO.java import java.nio.*; import java.nio.channels.*; import java.io.*; public class MappedIO { private static int numOfInts = 4000000; private static int numOfUbuffInts = 200000; private abstract static class Tester { private String name; public Tester(String name) { this.name = name; } public void runTest() { System.out.print(name + ": "); try { long start = System.nanoTime(); test(); double duration = System.nanoTime() - start; System.out.format("%.2f\n", duration/1.0e9); } catch(IOException e) { throw new RuntimeException(e); } I/O 693 } public abstract void test() throws IOException; } private static Tester[] tests = { new Tester("Stream Write") { public void test() throws IOException { DataOutputStream dos = new DataOutputStream( new BufferedOutputStream( new FileOutputStream(new File("temp.tmp")))); for(int = 0; < numOfInts; i++) dos.writeInt(i); dos.close(); } }, new Tester("Mapped Write") { public void test() throws IOException { FileChannel fc = new RandomAccessFile("temp.tmp", "rw") .getChannel(); IntBuffer ib = fc.map( FileChannel.MapMode.READ_WRITE, 0, fc.size()) .asIntBuffer(); for(int = 0; < numOfInts; i++) ib.put(i); fc.close(); } }, new Tester("Stream Read") { public void test() throws IOException { DataInputStream dis = new DataInputStream( new BufferedInputStream( new FileInputStream("temp.tmp"))); for(int = 0; < numOfInts; i++) dis.readInt(); dis.close(); } }, new Tester("Mapped Read") { public void test() throws IOException { FileChannel fc = new FileInputStream( new File("temp.tmp")).getChannel(); IntBuffer ib = fc.map( FileChannel.MapMode.READ_ONLY, 0, fc.size()) .asIntBuffer(); while(ib.hasRemaining()) ib.get(); fc.close(); } }, new Tester("Stream Read/Write") { public void test() throws IOException { RandomAccessFile raf = new RandomAccessFile( new File("temp.tmp"), "rw"); raf.writeInt(1); for(int = 0; < numOfUbuffInts; i++) { raf.seek(raf.length() - 4); raf.writeInt(raf.readInt()); } raf.close(); } }, new Tester("Mapped Read/Write") { public void test() throws IOException { 694 Thinking Java Bruce Eckel FileChannel fc = new RandomAccessFile( new File("temp.tmp"), "rw").getChannel(); IntBuffer ib = fc.map( FileChannel.MapMode.READ_WRITE, 0, fc.size()) .asIntBuffer(); ib.put(0); for(int = 1; < numOfUbuffInts; i++) ib.put(ib.get(i - 1)); fc.close(); } } }; public static void main(String[] args) { for(Tester test : tests) test.runTest(); } } /* Output: (90% match) Stream Write: 0.56 Mapped Write: 0.12 Stream Read: 0.80 Mapped Read: 0.07 Stream Read/Write: 5.32 Mapped Read/Write: 0.02 *///:~ As seen earlier examples book, runTest( ) used Template Method create testing framework various implementations test( ) defined anonymous inner subclasses. Each subclasses performs one kind test, test( ) methods also give prototype performing various I/O activities. Although mapped write would seem use FileOutputStream, output file mapping must use RandomAccessFile, read/write preceding code. Note test( ) methods include time initialization various I/O objects, even though setup mapped files expensive, overall gain compared stream I/O significant. Exercise 25: (6) Experiment changing ByteBuffer.allocate( ) statements examples chapter ByteBuffer.allocateDirect( ). Demonstrate performance differences, also notice whether startup time programs noticeably changes. Exercise 26: (3) Modify strings/JGrep.java use Java nio memorymapped files. File locking File locking allows synchronize access file shared resource. However, two threads contend file may different JVMs, one may Java thread native thread operating system. The file locks visible operating system processes Java file locking maps directly native operating system locking facility. Here simple example file locking. //: io/FileLocking.java import java.nio.channels.*; import java.util.concurrent.*; import java.io.*; public class FileLocking { I/O 695 public static void main(String[] args) throws Exception { FileOutputStream fos= new FileOutputStream("file.txt"); FileLock fl = fos.getChannel().tryLock(); if(fl != null) { System.out.println("Locked File"); TimeUnit.MILLISECONDS.sleep(100); fl.release(); System.out.println("Released Lock"); } fos.close(); } } /* Output: Locked File Released Lock *///:~ You get FileLock entire file calling either tryLock( ) lock( ) FileChannel. (SocketChannel, DatagramChannel, ServerSocketChannel need locking since inherently singleprocess entities; don’t generally share network socket two processes.) tryLock( ) non-blocking. It tries grab lock, cannot (when process already holds lock shared), simply returns method call. lock( ) blocks lock acquired, thread invoked lock( ) interrupted, channel lock( ) method called closed. A lock released using FileLock.release( ). It also possible lock part file using tryLock(long position, long size, boolean shared) lock(long position, long size, boolean shared) locks region (size - position). The third argument specifies whether lock shared. Although zero-argument locking methods adapt changes size file, locks fixed size change file size changes. If lock acquired region position position+size file increases beyond position+size, section beyond position+size locked. The zero-argument locking methods lock entire file, even grows. Support exclusive shared locks must provided underlying operating system. If operating system support shared locks request made one, exclusive lock used instead. The type lock (shared exclusive) queried using FileLock.isShared( ). Locking portions mapped file As mentioned earlier, file mapping typically used large files. You may need lock portions large file processes may modify unlocked parts file. This something happens, example, database, available many users once. Here’s example two threads, locks distinct portion file: //: io/LockingMappedFiles.java // Locking portions mapped file. 696 Thinking Java Bruce Eckel // {RunByHand} import java.nio.*; import java.nio.channels.*; import java.io.*; public class LockingMappedFiles { static final int LENGTH = 0x8FFFFFF; // 128 MB static FileChannel fc; public static void main(String[] args) throws Exception { fc = new RandomAccessFile("test.dat", "rw").getChannel(); MappedByteBuffer = fc.map(FileChannel.MapMode.READ_WRITE, 0, LENGTH); for(int = 0; < LENGTH; i++) out.put((byte)’x’); new LockAndModify(out, 0, 0 + LENGTH/3); new LockAndModify(out, LENGTH/2, LENGTH/2 + LENGTH/4); } private static class LockAndModify extends Thread { private ByteBuffer buff; private int start, end; LockAndModify(ByteBuffer mbb, int start, int end) { this.start = start; this.end = end; mbb.limit(end); mbb.position(start); buff = mbb.slice(); start(); } public void run() { try { // Exclusive lock overlap: FileLock fl = fc.lock(start, end, false); System.out.println("Locked: "+ start +" "+ end); // Perform modification: while(buff.position() < buff.limit() - 1) buff.put((byte)(buff.get() + 1)); fl.release(); System.out.println("Released: "+start+" "+ end); } catch(IOException e) { throw new RuntimeException(e); } } } } ///:~ The LockAndModify thread class sets buffer region creates slice( ) modified, run( ), lock acquired file channel (you can’t acquire lock buffer—only channel). The call lock( ) similar acquiring threading lock object—you "critical section" exclusive access portion file. 5 The locks automatically released JVM exits, channel acquired closed, also explicitly call release( ) FileLock object, shown here. 5 I/O More details threads found Concurrency chapter. 697 Compression The Java I/O library contains classes support reading writing streams compressed format. You wrap around I/O classes provide compression functionality. These classes derived Reader Writer classes, instead part InputStream OutputStream hierarchies. This compression library works bytes, characters. However, might sometimes forced mix two types streams. (Remember use InputStreamReader OutputStream Writer provide easy conversion one type another.) Compression class Function CheckedInputStream GetCheckSum( ) produces checksum InputStream (not decompression). CheckedOutputStream GetCheckSum( ) produces checksum OutputStream (not compression). DeflaterOutputStream Base class compression classes. ZipOutputStream A DeflaterOutputStream compresses data Zip file format. GZIPOutputStream A DeflaterOutputStream compresses data GZIP file format. InflaterInputStream Base class decompression classes. ZipInputStream An InflaterInputStream decompresses data stored Zip file format. GZIPInputStream An InflaterInputStream decompresses data stored GZIP file format. Although many compression algorithms, Zip GZIP possibly commonly used. Thus easily manipulate compressed data many tools available reading writing formats. Simple compression GZIP The GZIP interface simple thus probably appropriate single stream data want compress (rather container dissimilar pieces data). Here’s example compresses single file: //: io/GZIPcompress.java // {Args: GZIPcompress.java} import java.util.zip.*; import java.io.*; public class GZIPcompress { public static void main(String[] args) throws IOException { if(args.length == 0) { 698 Thinking Java Bruce Eckel System.out.println( "Usage: \nGZIPcompress file\n" + "\tUses GZIP compression compress " + "the file test.gz"); System.exit(1); } BufferedReader = new BufferedReader( new FileReader(args[0])); BufferedOutputStream = new BufferedOutputStream( new GZIPOutputStream( new FileOutputStream("test.gz"))); System.out.println("Writing file"); int c; while((c = in.read()) != -1) out.write(c); in.close(); out.close(); System.out.println("Reading file"); BufferedReader in2 = new BufferedReader( new InputStreamReader(new GZIPInputStream( new FileInputStream("test.gz")))); String s; while((s = in2.readLine()) != null) System.out.println(s); } } /* (Execute see output) *///:~ The use compression classes straightforward; simply wrap output stream GZIPOutputStream ZipOutputStream, input stream GZIPInputStream ZipInputStream. All else ordinary I/O reading writing. This example mixing char-oriented streams byte-oriented streams; uses Reader classes, whereas GZIPOutputStream’s constructor accept OutputStream object, Writer object. When file opened, GZIPInputStream converted Reader. Multifile storage Zip The library supports Zip format extensive. With easily store multiple files, there’s even separate class make process reading Zip file easy. The library uses standard Zip format works seamlessly Zip tools currently downloadable Internet. The following example form previous example, handles many command-line arguments want. In addition, shows use Checksum classes calculate verify checksum file. There two Checksum types: Adler32 (which faster) CRC32 (which slower slightly accurate). //: io/ZipCompress.java // Uses Zip compression compress // number files given command line. // {Args: ZipCompress.java} import java.util.zip.*; import java.io.*; import java.util.*; import static net.mindview.util.Print.*; public class ZipCompress { public static void main(String[] args) throws IOException { FileOutputStream f = new FileOutputStream("test.zip"); CheckedOutputStream csum = I/O 699 new CheckedOutputStream(f, new Adler32()); ZipOutputStream zos = new ZipOutputStream(csum); BufferedOutputStream = new BufferedOutputStream(zos); zos.setComment("A test Java Zipping"); // No corresponding getComment(), though. for(String arg : args) { print("Writing file " + arg); BufferedReader = new BufferedReader(new FileReader(arg)); zos.putNextEntry(new ZipEntry(arg)); int c; while((c = in.read()) != -1) out.write(c); in.close(); out.flush(); } out.close(); // Checksum valid file closed! print("Checksum: " + csum.getChecksum().getValue()); // Now extract files: print("Reading file"); FileInputStream fi = new FileInputStream("test.zip"); CheckedInputStream csumi = new CheckedInputStream(fi, new Adler32()); ZipInputStream in2 = new ZipInputStream(csumi); BufferedInputStream bis = new BufferedInputStream(in2); ZipEntry ze; while((ze = in2.getNextEntry()) != null) { print("Reading file " + ze); int x; while((x = bis.read()) != -1) System.out.write(x); } if(args.length == 1) print("Checksum: " + csumi.getChecksum().getValue()); bis.close(); // Alternative way open read Zip files: ZipFile zf = new ZipFile("test.zip"); Enumeration e = zf.entries(); while(e.hasMoreElements()) { ZipEntry ze2 = (ZipEntry)e.nextElement(); print("File: " + ze2); // ... extract data } /* if(args.length == 1) */ } } /* (Execute see output) *///:~ For file add archive, must call putNextEntry( ) pass ZipEntry object. The ZipEntry object contains extensive interface allows get set data available particular entry Zip file: name, compressed uncompressed sizes, date, CRC checksum, extra field data, comment, compression method, whether it’s directory entry. However, even though Zip format way set password, supported Java’s Zip library. And although CheckedInputStream CheckedOutputStream support Adler32 CRC32 checksums, ZipEntry class supports interface CRC. This restriction underlying Zip format, might limit using faster Adler32. To extract files, ZipInputStream getNextEntry( ) method returns next ZipEntry one. As succinct alternative, read file using 700 Thinking Java Bruce Eckel ZipFile object, method entries( ) return Enumeration ZipEntries. In order read checksum, must somehow access associated Checksum object. Here, reference CheckedOutputStream CheckedInputStream objects retained, could also hold reference Checksum object. A baffling method Zip streams setComment( ). As shown ZipCompress.java, set comment you’re writing file, there’s way recover comment ZipInputStream. Comments appear supported fully entry-by-entry basis via ZipEntry. Of course, limited files using GZIP Zip libraries— compress anything, including data sent network connection. Java ARchives (JARs) The Zip format also used JAR (Java ARchive) file format, way collect group files single compressed file, like Zip. However, like everything else Java, JAR files cross-platform, don’t need worry platform issues. You also include audio image files well class files. JAR files particularly helpful deal Internet. Before JAR files, Web browser would make repeated requests Web server order download files made applet. In addition, files uncompressed. By combining files particular applet single JAR file, one server request necessary transfer faster compression. And entry JAR file digitally signed security. A JAR file consists single file containing collection zipped files along "manifest" describes them. (You create manifest file; otherwise, jar program you.) You find JAR manifests JDK documentation. The jar utility comes Sun’s JDK automatically compresses files choice. You invoke command line: jar [options] destination [manifest] inputfile(s) The options simply collection letters (no hyphen indicator necessary). Unix/Linux users note similarity tar options. These are: I/O c Creates new empty archive. Lists table contents. x Extracts files. x file Extracts named file. f Says, "I’m going give name file." If don’t use this, jar assumes input come standard input, or, creating file, output go standard output. Says first argument name usercreated manifest file. v Generates verbose output describing jar doing. 701 Only stores files; doesn’t compress files (use create JAR file put classpath). M Doesn’t automatically create manifest file. If subdirectory included files put JAR file, subdirectory automatically added, including subdirectories, etc. Path information also preserved. Here typical ways invoke jar. The following command creates JAR file called myJarFile.jar contains class files current directory, along automatically generated manifest file: jar cf myJarFile.jar *.class The next command like previous example, adds user-created manifest file called myManifestFile.mf: jar cmf myJarFile.jar myManifestFile.mf *.class This produces table contents files myJarFile.jar: jar tf myJarFile.jar This adds "verbose" flag give detailed information files myJarFile.jar: jar tvf myJarFile.jar Assuming audio, classes, image subdirectories, combines subdirectories file myApp.jar. The "verbose" flag also included give extra feedback jar program working: jar cvf myApp.jar audio classes image If create JAR file using (zero) option, file placed CLASSPATH: CLASSPATH="libl.jar;lib2.jar;" Then Java search lib1.jar lib2.jar class files. The jar tool isn’t general-purpose Zip utility. For example, can’t add update files existing JAR file; create JAR files scratch. Also, can’t move files JAR file, erasing moved. However, JAR file created one platform transparently readable jar tool platform (a problem sometimes plagues Zip utilities). As see Graphical User Interfaces chapter, JAR files also used package JavaBeans. 702 Thinking Java Bruce Eckel Object serialization When create object, exists long need it, circumstances exist program terminates. While makes sense first, situations would incredibly useful object could exist hold information even program wasn’t running. Then, next time started program, object would would information previous time program running. Of course, get similar effect writing information file database, spirit making everything object, would quite convenient declare object "persistent," details taken care you. Java’s object serialization allows take object implements Serializable interface turn sequence bytes later fully restored regenerate original object. This even true across network, means serialization mechanism automatically compensates differences operating systems. That is, create object Windows machine, serialize it, send across network Unix machine, correctly reconstructed. You don’t worry data representations different machines, byte ordering, details. By itself, object serialization interesting allows implement lightweight persistence. Persistence means object’s lifetime determined whether program executing; object lives invocations program. By taking serializable object writing disk, restoring object program reinvoked, you’re able produce effect persistence. The reason it’s called "lightweight" can’t simply define object using kind "persistent" keyword let system take care details (perhaps happen future). Instead, must explicitly serialize deserialize objects program. If need serious persistence mechanism, consider tool like Hibernate (http://hibernate.sourceforge.net). For details, see Thinking Enterprise Java, downloadable www.MindView.net. Object serialization added language support two major features. Java’s Remote Method Invocation (RMI) allows objects live machines behave live machine. When messages sent remote objects, object serialization necessary transport arguments return values. RMI discussed Thinking Enterprise Java. Object serialization also necessary JavaBeans, described Graphical User Interfaces chapter. When Bean used, state information generally configured design time. This state information must stored later recovered program started; object serialization performs task. Serializing object quite simple long object implements Serializable interface (this tagging interface methods). When serialization added language, many standard library classes changed make serializable, including wrappers primitive types, container classes, many others. Even Class objects serialized. To serialize object, create sort OutputStream object wrap inside ObjectOutputStream object. At point need call writeObject( ), object serialized sent OutputStream (object serialization byte-oriented, thus uses InputStream OutputStream hierarchies). To reverse process, wrap InputStream inside ObjectlnputStream call readObject( ). What comes back is, usual, reference upcast Object, must downcast set things straight. A particularly clever aspect object serialization saves image object, also follows references contained object saves objects, follows references objects, etc. This sometimes referred I/O 703 "web objects" single object connected to, includes arrays references objects well member objects. If maintain object serialization scheme, maintaining code follow links could mindboggling. However, Java object serialization seems pull flawlessly, doubt using optimized algorithm traverses web objects. The following example tests serialization mechanism making "worm" linked objects, link next segment worm well array references objects different class, Data: //: io/Worm.java // Demonstrates object serialization. import java.io.*; import java.util.*; import static net.mindview.util.Print.*; class Data implements Serializable { private int n; public Data(int n) { this.n = n; } public String toString() { return Integer.toString(n); } } public class Worm implements Serializable { private static Random rand = new Random(47); private Data[] = { new Data(rand.nextInt(10)), new Data(rand.nextInt(10)), new Data(rand.nextInt(10)) }; private Worm next; private char c; // Value == number segments public Worm(int i, char x) { print("Worm constructor: " + i); c = x; if(--i > 0) next = new Worm(i, (char)(x + 1)); } public Worm() { print("Default constructor"); } public String toString() { StringBuilder result = new StringBuilder(":"); result.append(c); result.append("("); for(Data dat : d) result.append(dat); result.append(")"); if(next != null) result.append(next); return result.toString(); } public static void main(String[] args) throws ClassNotFoundException, IOException { Worm w = new Worm(6, ‘a’); print("w = " + w); ObjectOutputStream = new ObjectOutputStream( new FileOutputStream("worm.out")); out.writeObject("Worm storage\n"); out.writeObject(w); out.close(); // Also flushes output ObjectInputStream = new ObjectInputStream( new FileInputStream("worm.out")); String = (String)in.readObject(); 704 Thinking Java Bruce Eckel Worm w2 = (Worm)in.readObject(); print(s + "w2 = " + w2); ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream out2 = new ObjectOutputStream(bout); out2.writeObject("Worm storage\n"); out2.writeObject(w); out2.flush(); ObjectInputStream in2 = new ObjectInputStream( new ByteArrayInputStream(bout.toByteArray())); = (String)in2.readObject(); Worm w3 = (Worm)in2.readObject(); print(s + "w3 = " + w3); } } /* Output: Worm constructor: 6 Worm constructor: 5 Worm constructor: 4 Worm constructor: 3 Worm constructor: 2 Worm constructor: 1 w = :a(853):b(119):c(802):d(788):e(199):f(881) Worm storage w2 = :a(853):b(119):c(802):d(788):e(199):f(881) Worm storage w3 = :a(853):b(119):c(802):d(788):e(199):f(881) *///:~ To make things interesting, array Data objects inside Worm initialized random numbers. (This way, don’t suspect compiler keeping kind metainformation.) Each Worm segment labeled char that’s automatically generated process recursively generating linked list Worms. When create Worm, tell constructor long want be. To make next reference, calls Worm constructor length one less, etc. The final next reference left null, indicating end Worm. The point make something reasonably complex couldn’t easily serialized. The act serializing, however, quite simple. Once ObjectOutputStream created stream, writeObject( ) serializes object. Notice call writeObject( ) String, well. You also write primitive data types using methods DataOutputStream (they share interface). There two separate code sections look similar. The first writes reads file, second, variety, writes reads ByteArray. You read write object using serialization DataInputStream DataOutputStream, including, see Thinking Enterprise Java, network. You see output deserialized object really contain links original object. Note constructor, even default constructor, called process deserializing Serializable object. The entire object restored recovering data InputStream. Exercise 27: (1) Create Serializable class containing reference object second Serializable class. Create instance class, serialize disk, restore verify process worked correctly. I/O 705 Finding class You might wonder what’s necessary object recovered serialized state. For example, suppose serialize object send file network another machine. Could program machine reconstruct object using contents file? The best way answer question (as usual) performing experiment. The following file goes subdirectory chapter: //: io/Alien.java // A serializable class. import java.io.*; public class Alien implements Serializable {} ///:~ The file creates serializes Alien object goes directory: //: io/FreezeAlien.java // Create serialized output file. import java.io.*; public class FreezeAlien { public static void main(String[] args) throws Exception { ObjectOutput = new ObjectOutputStream( new FileOutputStream("X.file")); Alien quellek = new Alien(); out.writeObject(quellek); } } ///:~ Rather catching handling exceptions, program takes quickand- dirty approach passing exceptions main( ), they’ll reported console. Once program compiled run, produces file called X.file io directory. The following code subdirectory called xfiles: //: io/xfiles/ThawAlien.java // Try recover serialized file without // class object that’s stored file. // {RunByHand} import java.io.*; public class ThawAlien { public static void main(String[] args) throws Exception { ObjectInputStream = new ObjectInputStream( new FileInputStream(new File("..", "X.file"))); Object mystery = in.readObject(); System.out.println(mystery.getClass()); } } /* Output: class Alien *///:~ Even opening file reading object mystery requires Class object Alien; JVM cannot find Alien.class (unless happens classpath, shouldn’t example). You’ll get ClassNotFoundException. (Once again, evidence alien life vanishes proof existence verified!) The JVM must able find associated .class file. 706 Thinking Java Bruce Eckel Controlling serialization As see, default serialization mechanism trivial use. But special needs? Perhaps special security issues don’t want serialize portions object, perhaps doesn’t make sense one subobject serialized part needs created anew object recovered. You control process serialization implementing Externalizable interface instead Serializable interface. The Externalizable interface extends Serializable interface adds two methods, writeExternal( ) readExternal( ), automatically called object serialization deserialization perform special operations. The following example shows simple implementations Externalizable interface methods. Note Blip1 Blip2 nearly identical except subtle difference (see discover looking code): //: io/Blips.java // Simple use Externalizable & pitfall. import java.io.*; import static net.mindview.util.Print.*; class Blip1 implements Externalizable { public Blip1() { print("Blip1 Constructor"); } public void writeExternal(ObjectOutput out) throws IOException { print("Blip1.writeExternal"); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { print("Blip1.readExternal"); } } class Blip2 implements Externalizable { Blip2() { print("Blip2 Constructor"); } public void writeExternal(ObjectOutput out) throws IOException { print("Blip2.writeExternal"); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { print("Blip2.readExternal"); } } public class Blips { public static void main(String[] args) throws IOException, ClassNotFoundException { print("Constructing objects:"); Blip1 b1 = new Blip1(); Blip2 b2 = new Blip2(); ObjectOutputStream = new ObjectOutputStream( new FileOutputStream("Blips.out")); print("Saving objects:"); o.writeObject(b1); I/O 707 o.writeObject(b2); o.close(); // Now get back: ObjectInputStream = new ObjectInputStream( new FileInputStream("Blips.out")); print("Recovering b1:"); b1 = (Blip1)in.readObject(); // OOPS! Throws exception: //! print("Recovering b2:"); //! b2 = (Blip2)in.readObject(); } } /* Output: Constructing objects: Blip1 Constructor Blip2 Constructor Saving objects: Blip1.writeExternal Blip2.writeExternal Recovering b1: Blip1 Constructor Blip1.readExternal *///:~ The reason Blip2 object recovered trying causes exception. Can see difference Blip1 Blip2? The constructor Blip1 public, constructor Blip2 not, causes exception upon recovery. Try making Blip2’s constructor public removing //! comments see correct results. When b1 recovered, Blip1 default constructor called. This different recovering Serializable object, object constructed entirely stored bits, constructor calls. With Externalizable object, normal default construction behavior occurs (including initializations point field definition), readExternal( ) called. You need aware this—in particular, fact default construction always takes place—to produce correct behavior Externalizable objects. Here’s example shows must fully store retrieve Externalizable object: //: io/Blip3.java // Reconstructing externalizable object. import java.io.*; import static net.mindview.util.Print.*; public class Blip3 implements Externalizable { private int i; private String s; // No initialization public Blip3() { print("Blip3 Constructor"); // s, initialized } public Blip3(String x, int a) { print("Blip3(String x, int a)"); = x; = a; // & initialized non-default constructor. } public String toString() { return + i; } public void writeExternal(ObjectOutput out) throws IOException { 708 Thinking Java Bruce Eckel print("Blip3.writeExternal"); // You must this: out.writeObject(s); out.writeInt(i); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { print("Blip3.readExternal"); // You must this: = (String)in.readObject(); = in.readInt(); } public static void main(String[] args) throws IOException, ClassNotFoundException { print("Constructing objects:"); Blip3 b3 = new Blip3("A String ", 47); print(b3); ObjectOutputStream = new ObjectOutputStream( new FileOutputStream("Blip3.out")); print("Saving object:"); o.writeObject(b3); o.close(); // Now get back: ObjectInputStream = new ObjectInputStream( new FileInputStream("Blip3.out")); print("Recovering b3:"); b3 = (Blip3)in.readObject(); print(b3); } } /* Output: Constructing objects: Blip3(String x, int a) A String 47 Saving object: Blip3.writeExternal Recovering b3: Blip3 Constructor Blip3.readExternal A String 47 *///:~ The fields initialized second constructor, default constructor. This means don’t initialize readExternal( ), null zero (since storage object gets wiped zero first step object creation). If comment two lines code following phrases "You must this:" run program, you’ll see object recovered, null zero. If inheriting Externalizable object, you’ll typically call base-class versions writeExternal( ) readExternal( ) provide proper storage retrieval base-class components. So make things work correctly, must write important data object writeExternal( ) method (there default behavior writes member objects Externalizable object), must also recover data readExternal( ) method. This bit confusing first default construction behavior Externalizable object make seem like kind storage retrieval takes place automatically. It not. Exercise 28 : (2) In Blips.java, copy file rename BlipCheck.java rename class Blip2 BlipCheck (making public removing public scope class Blips process). Remove //! marks file execute I/O 709 program, including offending lines. Next, comment default constructor BlipCheck. Run explain works. Note compiling, must execute program "Java Blips" main( ) method still class Blips. Exercise 29: (2) In Blip3.java, comment two lines phrases "You must this:" run program. Explain result differs two lines program. The transient keyword When you’re controlling serialization, might particular subobject don’t want Java’s serialization mechanism automatically save restore. This commonly case subobject represents sensitive information don’t want serialize, password. Even information private object, serialized, it’s possible someone access reading file intercepting network transmission. One way prevent sensitive parts object serialized implement class Externalizable, shown previously. Then nothing automatically serialized, explicitly serialize necessary parts inside writeExternal( ). If you’re working Serializable object, however, serialization happens automatically. To control this, turn serialization field-by-field basis using transient keyword, says, "Don’t bother saving restoring this—I’ll take care it." For example, consider Logon object keeps information particular login session. Suppose that, verify login, want store data, without password. The easiest way implementing Serializable marking password field transient. Here’s looks like: //: io/Logon.java // Demonstrates "transient" keyword. import java.util.concurrent.*; import java.io.*; import java.util.*; import static net.mindview.util.Print.*; public class Logon implements Serializable { private Date date = new Date(); private String username; private transient String password; public Logon(String name, String pwd) { username = name; password = pwd; } public String toString() { return "logon info: \n username: " + username + "\n date: " + date + "\n password: " + password; } public static void main(String[] args) throws Exception { Logon = new Logon("Hulk", "myLittlePony"); print("logon = " + a); ObjectOutputStream = new ObjectOutputStream( new FileOutputStream("Logon.out")); o.writeObject(a); o.close(); TimeUnit.SECONDS.sleep(1); // Delay // Now get back: ObjectInputStream = new ObjectInputStream( new FileInputStream("Logon.out")); 710 Thinking Java Bruce Eckel print("Recovering object " + new Date()); = (Logon)in.readObject(); print("logon = " + a); } } /* Output: (Sample) logon = logon info: username: Hulk date: Sat Nov 19 15:03:26 MST 2005 password: myLittlePony Recovering object Sat Nov 19 15:03:28 MST 2005 logon = logon info: username: Hulk date: Sat Nov 19 15:03:26 MST 2005 password: null *///:~ You see date username fields ordinary (not transient), thus automatically serialized. However, password transient, stored disk; also, serialization mechanism makes attempt recover it. When object recovered, password field null. Note toString( ) assembles String object using overloaded’+’ operator, null reference automatically converted string "null." You also see date field stored recovered disk generated anew. Since Externalizable objects store fields default, transient keyword use Serializable objects only. An alternative Externalizable If you’re keen implementing Externalizable interface, there’s another approach. You implement Serializable interface add (notice I say "add" "override" "implement") methods called writeObject( ) readObject( ) automatically called object serialized deserialized, respectively. That is, provide two methods, used instead default serialization. The methods must exact signatures: private void writeObject(ObjectOutputStream stream) throws IOException; private void readObject(ObjectlnputStream stream) throws IOException, ClassNotFoundException From design standpoint, things get really weird here. First all, might think methods part base class Serializable interface, ought defined interface(s). But notice defined private, means called members class. However, don’t actually call members class, instead writeObject( ) readObject( ) methods ObjectOutputStream ObjectInputStream objects call object’s writeObject( ) readObject( ) methods. (Notice tremendous restraint launching long diatribe using method names here. In word: confusing.) You might wonder ObjectOutputStream I/O 711 ObjectInputStream objects access private methods class. We assume part serialization magic. 6 Anything defined interface automatically public, writeObject( ) readObject( ) must private, can’t part interface. Since must follow signatures exactly, effect you’re implementing interface. It would appear call ObjectOutputStream.writeObject( ), Serializable object pass interrogated (using reflection, doubt) see implements writeObject( ). If so, normal serialization process skipped custom writeObject( ) called. The situation exists readObject( ). There’s one twist. Inside writeObject( ), choose perform default writeObject( ) action calling defaultWriteObject( ). Likewise, inside readObject( ) call defaultReadObject( ). Here simple example demonstrates control storage retrieval Serializable object: //: io/SerialCtl.java // Controlling serialization adding // writeObject() readObject() methods. import java.io.*; public class SerialCtl implements Serializable { private String a; private transient String b; public SerialCtl(String aa, String bb) { = "Not Transient: " + aa; b = "Transient: " + bb; } public String toString() { return + "\n" + b; } private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); stream.writeObject(b); } private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject(); b = (String)stream.readObject(); } public static void main(String[] args) throws IOException, ClassNotFoundException { SerialCtl sc = new SerialCtl("Test1", "Test2"); System.out.println("Before:\n" + sc); ByteArrayOutputStream buf= new ByteArrayOutputStream(); ObjectOutputStream = new ObjectOutputStream(buf); o.writeObject(sc); // Now get back: ObjectInputStream = new ObjectInputStream( new ByteArrayInputStream(buf.toByteArray())); SerialCtl sc2 = (SerialCtl)in.readObject(); System.out.println("After:\n" + sc2); } } /* Output: Before: Not Transient: Test1 Transient: Test2 After: 6 The section "Interfaces type information" end Type Information chapter shows it’s possible access private methods outside class. 712 Thinking Java Bruce Eckel Not Transient: Test1 Transient: Test2 *///:~ In example, one String field ordinary transient, prove non-transient field saved defaultWriteObject( ) method transient field saved restored explicitly. The fields initialized inside constructor rather point definition prove initialized automatic mechanism deserialization. If use default mechanism write non-transient parts object, must call defaultWriteObject( ) first operation writeObject( ), defaultReadObject( ) first operation readObject( ). These strange method calls. It would appear, example, calling defaultWriteObject( ) ObjectOutputStream passing arguments, yet somehow turns around knows reference object write non-transient parts. Spooky. The storage retrieval transient objects uses familiar code. And yet, think happens here. In main( ), SerialCtl object created, it’s serialized ObjectOutputStream. (Notice case buffer used instead file—it’s ObjectOutputStream.) The serialization occurs line: o.writeObject(sc); The writeObject( ) method must examining sc see writeObject( ) method. (Not checking interface—there isn’t one—or class type, actually hunting method using reflection.) If does, uses that. A similar approach holds true readObject( ). Perhaps practical way could solve problem, it’s certainly strange. Versioning It’s possible might want change version serializable class (objects original class might stored database, example). This supported, you’ll probably special cases, requires extra depth understanding attempt achieve here. The JDK documents downloadable http://java.sun.com cover topic quite thoroughly. You also notice JDK documentation many comments begin with: Warning: Serialized objects class compatible future Swing releases. The current serialization support appropriate short term storage RMI applications ... This versioning mechanism simple work reliably situations, especially JavaBeans. They’re working correction design, that’s warning about. Using persistence It’s quite appealing use serialization technology store state program easily restore program current state later. But this, questions must answered. What happens serialize two objects reference third object? When restore two objects serialized state, get one occurrence third object? What serialize two objects separate files deserialize different parts code? I/O 713 Here’s example shows problem: //: io/MyWorld.java import java.io.*; import java.util.*; import static net.mindview.util.Print.*; class House implements Serializable {} class Animal implements Serializable { private String name; private House preferredHouse; Animal(String nm, House h) { name = nm; preferredHouse = h; } public String toString() { return name + "[" + super.toString() + "], " + preferredHouse + "\n"; } } public class MyWorld { public static void main(String[] args) throws IOException, ClassNotFoundException { House house = new House(); List<Animal> animals = new ArrayList<Animal>(); animals.add(new Animal("Bosco dog", house)); animals.add(new Animal("Ralph hamster", house)); animals.add(new Animal("Molly cat", house)); print("animals: " + animals); ByteArrayOutputStream buf1 = new ByteArrayOutputStream(); ObjectOutputStream o1 = new ObjectOutputStream(buf1); o1.writeObject(animals); o1.writeObject(animals); // Write 2nd set // Write different stream: ByteArrayOutputStream buf2 = new ByteArrayOutputStream(); ObjectOutputStream o2 = new ObjectOutputStream(buf2); o2.writeObject(animals); // Now get back: ObjectInputStream in1 = new ObjectInputStream( new ByteArrayInputStream(buf1.toByteArray())); ObjectInputStream in2 = new ObjectInputStream( new ByteArrayInputStream(buf2.toByteArray())); List animals1 = (List)in1.readObject(), animals2 = (List)in1.readObject(), animals3 = (List)in2.readObject(); print("animals1: " + animals1); print("animals2: " + animals2); print("animals3: " + animals3); } } /* Output: (Sample) animals: [Bosco dog[Animal@addbf1], House@42e816 , Ralph hamster[Animal@9304b1], House@42e816 , Molly cat[Animal@190d11], House@42e816 ] animals1: [Bosco dog[Animal@de6f34], House@156ee8e , Ralph hamster[Animal@47b480], House@156ee8e , Molly cat[Animal@19b49e6], House@156ee8e ] 714 Thinking Java Bruce Eckel animals2: [Bosco dog[Animal@de6f34], House@156ee8e , Ralph hamster[Animal@47b480], House@156ee8e , Molly cat[Animal@19b49e6], House@156ee8e ] animals3: [Bosco dog[Animal@10d448], House@e0e1c6 , Ralph hamster[Animal@6ca1c], House@e0e1c6 , Molly cat[Animal@1bf216a], House@e0e1c6 ] *///:~ One thing that’s interesting it’s possible use object serialization byte array way "deep copy" object that’s Serializable. (A deep copy means you’re duplicating entire web objects, rather basic object references.) Object copying covered depth online supplements book. Animal objects contain fields type House. In main( ), List Animals created serialized twice one stream separate stream. When deserialized printed, see output shown one run (the objects different memory locations run). Of course, expect deserialized objects different addresses originals. But notice animals1 animals2, addresses appear, including references House object share. On hand, animals3 recovered, system way knowing objects stream aliases objects first stream, makes completely different web objects. As long you’re serializing everything single stream, you’ll recover web objects wrote, accidental duplication objects. Of course, change state objects time write first last, that’s responsibility; objects written whatever state (and whatever connections objects) time serialize them. The safest thing want save state system serialize "atomic" operation. If serialize things, work, serialize more, etc., storing system safely. Instead, put objects comprise state system single container simply write container one operation. Then restore single method call well. The following example imaginary computer-aided design (CAD) system demonstrates approach. In addition, throws issue static fields; look JDK documentation, you’ll see Class Serializable, easy store static fields simply serializing Class object. That seems like sensible approach, anyway. //: io/StoreCADState.java // Saving state pretend CAD system. import java.io.*; import java.util.*; abstract class Shape implements Serializable { public static final int RED = 1, BLUE = 2, GREEN = 3; private int xPos, yPos, dimension; private static Random rand = new Random(47); private static int counter = 0; public abstract void setColor(int newColor); public abstract int getColor(); public Shape(int xVal, int yVal, int dim) { xPos = xVal; yPos = yVal; dimension = dim; I/O 715 } } public String toString() { return getClass() + "color[" + getColor() + "] xPos[" + xPos + "] yPos[" + yPos + "] dim[" + dimension + "]\n"; } public static Shape randomFactory() { int xVal = rand.nextInt(100); int yVal = rand.nextInt(100); int dim = rand.nextInt(100); switch(counter++ % 3) { default: case 0: return new Circle(xVal, yVal, dim); case 1: return new Square(xVal, yVal, dim); case 2: return new Line(xVal, yVal, dim); } } class Circle extends Shape { private static int color = RED; public Circle(int xVal, int yVal, int dim) { super(xVal, yVal, dim); } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } class Square extends Shape { private static int color; public Square(int xVal, int yVal, int dim) { super(xVal, yVal, dim); color = RED; } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } class Line extends Shape { private static int color = RED; public static void serializeStaticState(ObjectOutputStream os) throws IOException { os.writeInt(color); } public static void deserializeStaticState(ObjectInputStream os) throws IOException { color = os.readInt(); } public Line(int xVal, int yVal, int dim) { super(xVal, yVal, dim); } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } public class StoreCADState { public static void main(String[] args) throws Exception { List<Class<? extends Shape>> shapeTypes = new ArrayList<Class<? extends Shape>>(); // Add references class objects: shapeTypes.add(Circle.class); shapeTypes.add(Square.class); shapeTypes.add(Line.class); List<Shape> shapes = new ArrayList<Shape>(); // Make shapes: 716 Thinking Java Bruce Eckel for(int = 0; < 10; i++) shapes.add(Shape.randomFactory()); // Set static colors GREEN: for(int = 0; < 10; i++) ((Shape)shapes.get(i)).setColor(Shape.GREEN); // Save state vector: ObjectOutputStream = new ObjectOutputStream( new FileOutputStream("CADState.out")); out.writeObject(shapeTypes); Line.serializeStaticState(out); out.writeObject(shapes); // Display shapes: System.out.println(shapes); } } /* Output: [class Circlecolor[3] xPos[58] yPos[55] dim[93] , class Squarecolor[3] xPos[61] yPos[61] dim[29] , class Linecolor[3] xPos[68] yPos[0] dim[22] , class Circlecolor[3] xPos[7] yPos[88] dim[28] , class Squarecolor[3] xPos[51] yPos[89] dim[9] , class Linecolor[3] xPos[78] yPos[98] dim[61] , class Circlecolor[3] xPos[20] yPos[58] dim[16] , class Squarecolor[3] xPos[40] yPos[11] dim[22] , class Linecolor[3] xPos[4] yPos[83] dim[6] , class Circlecolor[3] xPos[75] yPos[10] dim[42] ] *///:~ The Shape class implements Serializable, anything inherited Shape automatically Serializable well. Each Shape contains data, derived Shape class contains static field determines color types Shapes. (Placing static field base class would result one field, since static fields duplicated derived classes.) Methods base class overridden set color various types (static methods dynamically bound, normal methods). The randomFactory( ) method creates different Shape time call it, using random values Shape data. Circle Square straightforward extensions Shape; difference Circle initializes color point definition Square initializes constructor. We’ll leave discussion Line later. In main( ), one ArrayList used hold Class objects hold shapes. Recovering objects fairly straightforward: //: io/RecoverCADState.java // Restoring state pretend CAD system. // {RunFirst: StoreCADState} import java.io.*; import java.util.*; public class RecoverCADState { @SuppressWarnings("unchecked") public static void main(String[] args) throws Exception { ObjectInputStream = new ObjectInputStream( new FileInputStream("CADState.out")); // Read order written: List<Class<? extends Shape>> shapeTypes = (List<Class<? extends Shape>>)in.readObject(); Line.deserializeStaticState(in); I/O 717 List<Shape> shapes = (List<Shape>)in.readObject(); System.out.println(shapes); } } /* Output: [class Circlecolor[1] xPos[58] yPos[55] dim[93] , class Squarecolor[0] xPos[61] yPos[61] dim[29] , class Linecolor[3] xPos[68] yPos[0] dim[22] , class Circlecolor[1] xPos[7] yPos[88] dim[28] , class Squarecolor[0] xPos[51] yPos[89] dim[9] , class Linecolor[3] xPos[78] yPos[98] dim[61] , class Circlecolor[1] xPos[20] yPos[58] dim[16] , class Squarecolor[0] xPos[40] yPos[11] dim[22] , class Linecolor[3] xPos[4] yPos[83] dim[6] , class Circlecolor[1] xPos[75] yPos[10] dim[42] ] *///:~ You see values xPos, yPos, dim stored recovered successfully, there’s something wrong retrieval static information. It’s "3" going in, doesn’t come way. Circles value 1 (RED, definition), Squares value 0 (remember, initialized constructor). It’s statics didn’t get serialized all! That’s right—even though class Class Serializable, doesn’t expect. So want serialize statics, must yourself. This serializeStaticState( ) deserializeStaticState( ) static methods Line for. You see explicitly called part storage retrieval process. (Note order writing serialize file reading back must maintained.) Thus make programs run correctly, must: 1. Add serializeStaticState( ) deserializeStaticState( ) shapes. 2. Remove ArrayList shapeTypes code related it. 3. Add calls new serialize deserialize static methods shapes. Another issue might think security, since serialization also saves private data. If security issue, fields marked transient. But design secure way store information restore, reset private variables. Exercise 30: (1) Repair program CADState.java described text. XML An important limitation object serialization Java-only solution: Only Java programs deserialize objects. A interoperable solution convert data XML format, allows consumed large variety platforms languages. Because popularity, confusing number options programming XML, including javax.xml.* libraries distributed JDK. I’ve chosen use Elliotte Rusty Harold’s open-source XOM library (downloads documentation www.xom.nu) seems simplest straightforward way produce modify XML using Java. In addition, XOM emphasizes XML correctness. As example, suppose Person objects containing first last names you’d like serialize XML. The following Person class getXML( ) method uses 718 Thinking Java Bruce Eckel XOM produce Person data converted XML Element object, constructor takes Element extracts appropriate Person data (notice XML examples subdirectory): //: xml/Person.java // Use XOM library write read XML // {Requires: nu.xom.Node; You must install // XOM library http://www.xom.nu } import nu.xom.*; import java.io.*; import java.util.*; public class Person { private String first, last; public Person(String first, String last) { this.first = first; this.last = last; } // Produce XML Element Person object: public Element getXML() { Element person = new Element("person"); Element firstName = new Element("first"); firstName.appendChild(first); Element lastName = new Element("last"); lastName.appendChild(last); person.appendChild(firstName); person.appendChild(lastName); return person; } // Constructor restore Person XML Element: public Person(Element person) { first= person.getFirstChildElement("first").getValue(); last = person.getFirstChildElement("last").getValue(); } public String toString() { return first + " " + last; } // Make human-readable: public static void format(OutputStream os, Document doc) throws Exception { Serializer serializer= new Serializer(os,"ISO-8859-1"); serializer.setIndent(4); serializer.setMaxLength(60); serializer.write(doc); serializer.flush(); } public static void main(String[] args) throws Exception { List<Person> people = Arrays.asList( new Person("Dr. Bunsen", "Honeydew"), new Person("Gonzo", "The Great"), new Person("Phillip J.", "Fry")); System.out.println(people); Element root = new Element("people"); for(Person p : people) root.appendChild(p.getXML()); Document doc = new Document(root); format(System.out, doc); format(new BufferedOutputStream(new FileOutputStream( "People.xml")), doc); } } /* Output: [Dr. Bunsen Honeydew, Gonzo The Great, Phillip J. Fry] <?xml version="1.0" encoding="ISO-8859-1"?> <people> <person> I/O 719 <first>Dr. Bunsen</first> <last>Honeydew</last> </person> <person> <first>Gonzo</first> <last>The Great</last> </person> <person> <first>Phillip J.</first> <last>Fry</last> </person> </people> *///:~ The XOM methods fairly self-explanatory found XOM documentation. XOM also contains Serializer class see used format( ) method turn XML readable form. If call toXML( ) you’ll get everything run together, Serializer convenient tool. Deserializing Person objects XML file also simple: //: xml/People.java // {Requires: nu.xom.Node; You must install // XOM library http://www.xom.nu } // {RunFirst: Person} import nu.xom.*; import java.util.*; public class People extends ArrayList<Person> { public People(String fileName) throws Exception { Document doc = new Builder().build(fileName); Elements elements = doc.getRootElement().getChildElements(); for(int = 0; < elements.size(); i++) add(new Person(elements.get(i))); } public static void main(String[] args) throws Exception { People p = new People("People.xml"); System.out.println(p); } } /* Output: [Dr. Bunsen Honeydew, Gonzo The Great, Phillip J. Fry] *///:~ The People constructor opens reads file using XOM’s Builder.build( ) method, getChildElements( ) method produces Elements list (not standard Java List, object size( ) get( ) method—Harold want force people use Java SE5, still wanted type-safe container). Each Element list represents Person object, handed second Person constructor. Note requires know ahead time exact structure XML file, often true kinds problems. If structure doesn’t match expect, XOM throw exception. It’s also possible write complex code explore XML document rather making assumptions it, cases less concrete information incoming XML structure. In order get examples compile, put JAR files XOM distribution classpath. This brief introduction XML programming Java XOM library; information see www.xom.nu. 720 Thinking Java Bruce Eckel Exercise 31: (2) Add appropriate address information Person.java People.java. Exercise 32: (4) Using Map<String,Integer> net.mindview.util.TextFile utility, write program counts occurrence words file (use "\\W+" second argument TextFile constructor). Store results XML file. Preferences The Preferences API much closer persistence object serialization, automatically stores retrieves information. However, use restricted small limited data sets—you hold primitives Strings, length stored String can’t longer 8K (not tiny, don’t want build anything serious it, either). As name suggests, Preferences API designed store retrieve user preferences program-configuration settings. Preferences key-value sets (like Maps) stored hierarchy nodes. Although node hierarchy used create complicated structures, it’s typical create single node named class store information there. Here’s simple example: //: io/PreferencesDemo.java import java.util.prefs.*; import static net.mindview.util.Print.*; public class PreferencesDemo { public static void main(String[] args) throws Exception { Preferences prefs = Preferences .userNodeForPackage(PreferencesDemo.class); prefs.put("Location", "Oz"); prefs.put("Footwear", "Ruby Slippers"); prefs.putInt("Companions", 4); prefs.putBoolean("Are witches?", true); int usageCount = prefs.getInt("UsageCount", 0); usageCount++; prefs.putInt("UsageCount", usageCount); for(String key : prefs.keys()) print(key + ": "+ prefs.get(key, null)); // You must always provide default value: print("How many companions Dorothy have? " + prefs.getInt("Companions", 0)); } } /* Output: (Sample) Location: Oz Footwear: Ruby Slippers Companions: 4 Are witches?: true UsageCount: 53 How many companions Dorothy have? 4 *///:~ Here, userNodeForPackage( ) used, could also choose systemNodeForPackage( ); choice somewhat arbitrary, idea "user" individual user preferences, "system" general installation configuration. Since main( ) static, PreferencesDemo.class used identify node, inside nonstatic method, you’ll usually use getClass( ). You don’t need use current class node identifier, that’s usual practice. I/O 721 Once create node, it’s available either loading reading data. This example loads node various types items gets keys( ). These come back String[], might expect you’re used keys( ) method collections library. Notice second argument get( ). This default value produced isn’t entry key value. While iterating set keys, always know there’s entry, using null default safe, normally you’ll fetching named key, in: prefs.getInt("Companions", 0)); In normal case, you’ll want provide reasonable default value. In fact, typical idiom seen lines: int usageCount = prefs.getInt("UsageCount", 0); usageCount++; prefs.putInt("UsageCount", usageCount); This way, first time run program, UsageCount zero, subsequent invocations nonzero. When run PreferencesDemo.java you’ll see UsageCount indeed increment every time run program, data stored? There’s local file appears program run first time. The Preferences API uses appropriate system resources accomplish task, vary depending OS. In Windows, registry used (since it’s already hierarchy nodes key-value pairs). But whole point information magically stored don’t worry works one system another. There’s Preferences API shown here. Consult JDK documentation, fairly understandable, details. Exercise 33: (2) Write program displays current value directory called "base directory" prompts new value. Use Preferences API store value. Summary The Java I/O stream library satisfy basic requirements: You perform reading writing console, file, block memory, even across Internet. With inheritance, create new types input output objects. And even add simple extensibility kinds objects stream accept redefining toString( ) method that’s automatically called pass object method that’s expecting String (Java’s limited "automatic type conversion"). There questions left unanswered documentation design I/O stream library. For example, would nice could say want exception thrown try overwrite file opening output—some programming systems allow specify want open output file, doesn’t already exist. In Java, appears supposed use File object determine whether file exists, open FileOutputStream FileWriter, always get overwritten. The I/O stream library brings mixed feelings; much job it’s portable. But don’t already understand Decorator design pattern, design intuitive, there’s extra overhead learning teaching it. It’s also incomplete; example, I shouldn’t write utilities like TextFile (the new Java SE5 PrintWriter step right direction here, partial solution). There big improvement 722 Thinking Java Bruce Eckel Java SE5: They’ve finally added kind output formatting virtually every language always supported. Once understand Decorator pattern begin using library situations require flexibility, begin benefit design, point cost extra lines code may bother much. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. I/O 723 Enumerated Types The enum keyword allows create new type restricted set named values, treat values regular program components. This turns useful. 1 Enumerations introduced briefly end Initialization & Cleanup. However, understand deeper issues Java, take detailed look Java SE5 enumeration feature. You’ll see interesting things enums, chapter also give insight language features you’ve seen, generics reflection. You’ll also learn design patterns. Basic enum features As shown Initialization & Cleanup, step list enum constants calling values( ) enum. The values( ) method produces array enum constants order declared, use resulting array (for example) foreach loop. When create enum, associated class produced compiler. This class automatically inherited java.lang.Enum, provides certain capabilities see example: //: enumerated/EnumClass.java // Capabilities Enum class import static net.mindview.util.Print.*; enum Shrubbery { GROUND, CRAWLING, HANGING } public class EnumClass { public static void main(String[] args) { for(Shrubbery : Shrubbery.values()) { print(s + " ordinal: " + s.ordinal()); printnb(s.compareTo(Shrubbery.CRAWLING) + " "); printnb(s.equals(Shrubbery.CRAWLING) + " "); print(s == Shrubbery.CRAWLING); print(s.getDeclaringClass()); print(s.name()); print("----------------------"); } // Produce enum value string name: for(String : "HANGING CRAWLING GROUND".split(" ")) { Shrubbery shrub = Enum.valueOf(Shrubbery.class, s); print(shrub); } } } /* Output: GROUND ordinal: 0 -1 false false class Shrubbery 1 Joshua Bloch extremely helpful developing chapter. GROUND ---------------------CRAWLING ordinal: 1 0 true true class Shrubbery CRAWLING ---------------------HANGING ordinal: 2 1 false false class Shrubbery HANGING ---------------------HANGING CRAWLING GROUND *///:~ The ordinal( ) method produces int indicating declaration order enum instance, starting zero. You always safely compare enum instances using ==, equals( ) hashCode( ) automatically created you. The Enum class Comparable, there’s compareTo( ) method, also Serializable. If call getDeclaringClass( ) enum instance, you’ll find enclosing enum class. The name( ) method produces name exactly declared, get toString( ), well. valueOf( ) static member Enum, produces enum instance corresponds String name pass it, throws exception there’s match. Using static imports enums Consider variation Burrito.java Initialization & Cleanup chapter: //: enumerated/Spiciness.java package enumerated; public enum Spiciness { NOT, MILD, MEDIUM, HOT, FLAMING } ///:~ //: enumerated/Burrito.java package enumerated; import static enumerated.Spiciness.*; public class Burrito { Spiciness degree; public Burrito(Spiciness degree) { this.degree = degree;} public String toString() { return "Burrito "+ degree;} public static void main(String[] args) { System.out.println(new Burrito(NOT)); System.out.println(new Burrito(MEDIUM)); System.out.println(new Burrito(HOT)); } } /* Output: Burrito NOT Burrito MEDIUM Burrito HOT *///:~ 726 Thinking Java Bruce Eckel The static import brings enum instance identifiers local namespace, don’t need qualified. Is good idea, better explicit qualify enum instances? It probably depends complexity code. The compiler certainly won’t let use wrong type, concern whether code confusing reader. In many situations probably fine evaluate individual basis. Note possible use technique enum defined file default package (apparently arguments within Sun whether allow this). Adding methods enum Except fact can’t inherit it, enum treated much like regular class. This means add methods enum. It’s even possible enum main( ). You may want produce different descriptions enumeration default toString( ), simply produces name enum instance, you’ve seen. To this, provide constructor capture extra information, additional methods provide extended description, like this: //: enumerated/OzWitch.java // The witches land Oz. import static net.mindview.util.Print.*; public enum OzWitch { // Instances must defined first, methods: WEST("Miss Gulch, aka Wicked Witch West"), NORTH("Glinda, Good Witch North"), EAST("Wicked Witch East, wearer Ruby " + "Slippers, crushed Dorothy’s house"), SOUTH("Good inference, missing"); private String description; // Constructor must package private access: private OzWitch(String description) { this.description = description; } public String getDescription() { return description; } public static void main(String[] args) { for(OzWitch witch : OzWitch.values()) print(witch + ": " + witch.getDescription()); } } /* Output: WEST: Miss Gulch, aka Wicked Witch West NORTH: Glinda, Good Witch North EAST: Wicked Witch East, wearer Ruby Slippers, crushed Dorothy’s house SOUTH: Good inference, missing *///:~ Notice going define methods must end sequence enum instances semicolon. Also, Java forces define instances first thing enum. You’ll get compile-time error try define methods fields. The constructor methods form regular class, restrictions regular class. So pretty much anything want enums (although you’ll usually keep pretty ordinary). Enumerated Types 727 Although constructor made private example, doesn’t make much difference access use—the constructor used create enum instances declare inside enum definition; compiler won’t let use create new instances enum definition complete. Overriding enum methods Here’s another approach producing different string values enumerations. In case, instance names OK want reformat display. Overriding toString( ) method enum overriding regular class: //: enumerated/SpaceShip.java public enum SpaceShip { SCOUT, CARGO, TRANSPORT, CRUISER, BATTLESHIP, MOTHERSHIP; public String toString() { String id = name(); String lower = id.substring(1).toLowerCase(); return id.charAt(0) + lower; } public static void main(String[] args) { for(SpaceShip : values()) { System.out.println(s); } } } /* Output: Scout Cargo Transport Cruiser Battleship Mothership *///:~ The toString( ) method gets Spaceship name calling name( ), modifies result first letter capitalized. enums switch statements One convenient capability enums way used switch statements. Ordinarily, switch works integral value, since enums established integral order order instance produced ordinal( ) method (apparently compiler something like this), enums used switch statements. Although normally must qualify enum instance type, case statement. Here’s example uses enum create little state machine: //: enumerated/TrafficLight.java // Enums switch statements. import static net.mindview.util.Print.*; // Define enum type: enum Signal { GREEN, YELLOW, RED, } public class TrafficLight { Signal color = Signal.RED; public void change() { 728 Thinking Java Bruce Eckel switch(color) { // Note don’t say Signal.RED // case statement: case RED: color = Signal.GREEN; break; case GREEN: color = Signal.YELLOW; break; case YELLOW: color = Signal.RED; break; } } public String toString() { return "The traffic light " + color; } public static void main(String[] args) { TrafficLight = new TrafficLight(); for(int = 0; < 7; i++) { print(t); t.change(); } } } /* Output: The traffic light RED The traffic light GREEN The traffic light YELLOW The traffic light RED The traffic light GREEN The traffic light YELLOW The traffic light RED *///:~ The compiler complain default statement inside switch, that’s notices case statements Signal instance. If comment one case statements still won’t complain. This means pay attention ensure cover cases own. On hand, calling return case statements, compiler complain don’t default—even you’ve covered possible values enum. Exercise 1: (2) Use static import modify TrafficLight.java don’t qualify enum instances. The mystery values() As noted earlier, enum classes created compiler extend Enum class. However, look Enum, you’ll see values( ) method, even though we’ve using it. Are "hidden" methods? We write small reflection program find out: //: enumerated/Reflection.java // Analyzing enums using reflection. import java.lang.reflect.*; import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; enum Explore { HERE, THERE } public class Reflection { public static Set<String> analyze(Class<?> enumClass) { print("----- Analyzing " + enumClass + " -----"); Enumerated Types 729 print("Interfaces:"); for(Type : enumClass.getGenericInterfaces()) print(t); print("Base: " + enumClass.getSuperclass()); print("Methods: "); Set<String> methods = new TreeSet<String>(); for(Method : enumClass.getMethods()) methods.add(m.getName()); print(methods); return methods; } public static void main(String[] args) { Set<String> exploreMethods = analyze(Explore.class); Set<String> enumMethods = analyze(Enum.class); print("Explore.containsAll(Enum)? " + exploreMethods.containsAll(enumMethods)); printnb("Explore.removeAll(Enum): "); exploreMethods.removeAll(enumMethods); print(exploreMethods); // Decompile code enum: OSExecute.command("javap Explore"); } } /* Output: ----- Analyzing class Explore ----Interfaces: Base: class java.lang.Enum Methods: [compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, values, wait] ----- Analyzing class java.lang.Enum ----Interfaces: java.lang.Comparable<E> interface java.io.Serializable Base: class java.lang.Object Methods: [compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, wait] Explore.containsAll(Enum)? true Explore.removeAll(Enum): [values] Compiled "Reflection.java" final class Explore extends java.lang.Enum{ public static final Explore HERE; public static final Explore THERE; public static final Explore[] values(); public static Explore valueOf(java.lang.String); static {}; } *///:~ So answer values( ) static method added compiler. You see valueOf( ) also added Explore process creating enum. This slightly confusing, there’s also valueOf( ) part Enum class, method two arguments added method one. However, use Set method looking method names, signatures, calling Explore.removeAll(Enum), thing remains [values]. In output, see Explore made final compiler, cannot inherit enum. There’s also static initialization clause, you’ll see later redefined. 730 Thinking Java Bruce Eckel Because erasure (described Generics chapter), decompiler full information Enum, shows base class Explore raw Enum rather actual Enum<Explore>. Because values( ) static method inserted enum definition compiler, upcast enum type Enum, values( ) method available. Notice, however, getEnumConstants( ) method Class, even values( ) part interface Enum, still get enum instances via Class object: //: enumerated/UpcastEnum.java // No values() method upcast enum enum Search { HITHER, YON } public class UpcastEnum { public static void main(String[] args) { Search[] vals = Search.values(); Enum e = Search.HITHER; // Upcast // e.values(); // No values() Enum for(Enum en : e.getClass().getEnumConstants()) System.out.println(en); } } /* Output: HITHER YON *///:~ Because getEnumConstants( ) method Class, call class enumerations: //: enumerated/NonEnum.java public class NonEnum { public static void main(String[] args) { Class<Integer> intClass = Integer.class; try { for(Object en : intClass.getEnumConstants()) System.out.println(en); } catch(Exception e) { System.out.println(e); } } } /* Output: java.lang.NullPointerException *///:~ However, method returns null, get exception try use result. Enumerated Types 731 Implements, inherits We’ve established enums extend java.lang.Enum. Since Java support multiple inheritance, means cannot create enum via inheritance: enum NotPossible extends Pet { ... // Won’t work However, possible create enum implements one interfaces: //: enumerated/cartoons/EnumImplementation.java // An enum implement interface package enumerated.cartoons; import java.util.*; import net.mindview.util.*; enum CartoonCharacter implements Generator<CartoonCharacter> { SLAPPY, SPANKY, PUNCHY, SILLY, BOUNCY, NUTTY, BOB; private Random rand = new Random(47); public CartoonCharacter next() { return values()[rand.nextInt(values().length)]; } } public class EnumImplementation { public static <T> void printNext(Generator<T> rg) { System.out.print(rg.next() + ", "); } public static void main(String[] args) { // Choose instance: CartoonCharacter cc = CartoonCharacter.BOB; for(int = 0; < 10; i++) printNext(cc); } } /* Output: BOB, PUNCHY, BOB, SPANKY, NUTTY, PUNCHY, SLAPPY, NUTTY, NUTTY, SLAPPY, *///:~ The result slightly odd, call method must instance enum call on. However, CartoonCharacter accepted method takes Generator; example, printNext( ). Exercise 2: (2) Instead implementing interface, make next( ) static method. What benefits drawbacks approach? Random selection Many examples chapter require random selection among enum instances, saw CartoonCharacter.next( ). It’s possible generalize task using generics put result common library: //: net/mindview/util/Enums.java package net.mindview.util; import java.util.*; public class Enums { private static Random rand = new Random(47); 732 Thinking Java Bruce Eckel public static <T extends Enum<T>> T random(Class<T> ec) { return random(ec.getEnumConstants()); } public static <T> T random(T[] values) { return values[rand.nextInt(values.length)]; } } ///:~ The rather odd syntax <T extends Enum<T>> describes T enum instance. By passing Class<T>, make class object available, array enum instances thus produced. The overloaded random( ) method needs know getting T[] doesn’t need perform Enum operations; needs select array element random. The return type exact type enum. Here’s simple test random( ) method: //: enumerated/RandomTest.java import net.mindview.util.*; enum Activity { SITTING, LYING, STANDING, HOPPING, RUNNING, DODGING, JUMPING, FALLING, FLYING } public class RandomTest { public static void main(String[] args) { for(int = 0; < 20; i++) System.out.print(Enums.random(Activity.class) + " "); } } /* Output: STANDING FLYING RUNNING STANDING RUNNING STANDING LYING DODGING SITTING RUNNING HOPPING HOPPING HOPPING RUNNING STANDING LYING FALLING RUNNING FLYING LYING *///:~ Although Enums small class, you’ll see prevents fair amount duplication chapter. Duplication tends produce mistakes, eliminating duplication useful pursuit. Enumerated Types 733 Using interfaces organization The inability inherit enum bit frustrating times. The motivation inheriting enum comes partly wanting extend number elements original enum, partly wanting create subcategories using subtypes. You achieve categorization grouping elements together inside interface creating enumeration based interface. For example, suppose different classes food you’d like create enums, you’d still like one type Food. Here’s looks like: //: enumerated/menu/Food.java // Subcategorization enums within interfaces. package enumerated.menu; public interface Food { enum Appetizer implements Food { SALAD, SOUP, SPRING_ROLLS; } enum MainCourse implements Food { LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO; } enum Dessert implements Food { TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL; } enum Coffee implements Food { BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA; } } ///:~ Since subtyping available enum interface implementation, nested enum implements surrounding interface Food. Now it’s possible say "everything type Food" see here: //: enumerated/menu/TypeOfFood.java package enumerated.menu; import static enumerated.menu.Food.*; public class TypeOfFood { public static void main(String[] args) { Food food = Appetizer.SALAD; food = MainCourse.LASAGNE; food = Dessert.GELATO; food = Coffee.CAPPUCCINO; } } ///:~ The upcast Food works enum type implements Food, types Food. An interface, however, useful enum want deal set types. If want "enum enums" create surrounding enum one instance enum Food: //: enumerated/menu/Course.java package enumerated.menu; 734 Thinking Java Bruce Eckel import net.mindview.util.*; public enum Course { APPETIZER(Food.Appetizer.class), MAINCOURSE(Food.MainCourse.class), DESSERT(Food.Dessert.class), COFFEE(Food.Coffee.class); private Food[] values; private Course(Class<? extends Food> kind) { values = kind.getEnumConstants(); } public Food randomSelection() { return Enums.random(values); } } ///:~ Each enums takes corresponding Class object constructor argument, extract store enum instances using getEnumConstants( ). These instances later used randomSelection( ), create randomly generated meal selecting one Food item Course: //: enumerated/menu/Meal.java package enumerated.menu; public class Meal { public static void main(String[] args) { for(int = 0; < 5; i++) { for(Course course : Course.values()) { Food food = course.randomSelection(); System.out.println(food); } System.out.println("---"); } } } /* Output: SPRING_ROLLS VINDALOO FRUIT DECAF_COFFEE --SOUP VINDALOO FRUIT TEA --SALAD BURRITO FRUIT TEA --SALAD BURRITO CREME_CARAMEL LATTE --SOUP BURRITO TIRAMISU ESPRESSO --*///:~ Enumerated Types 735 In case, value creating enum enums iterate Course. Later, VendingMachine.java example, you’ll see another approach categorization dictated different constraints. Another, compact, approach problem categorization nest enums within enums, like this: //: enumerated/SecurityCategory.java // More succinct subcategorization enums. import net.mindview.util.*; enum SecurityCategory { STOCK(Security.Stock.class), BOND(Security.Bond.class); Security[] values; SecurityCategory(Class<? extends Security> kind) { values = kind.getEnumConstants(); } interface Security { enum Stock implements Security { SHORT, LONG, MARGIN } enum Bond implements Security { MUNICIPAL, JUNK } } public Security randomSelection() { return Enums.random(values); } public static void main(String[] args) { for(int = 0; < 10; i++) { SecurityCategory category = Enums.random(SecurityCategory.class); System.out.println(category + ": " + category.randomSelection()); } } } /* Output: BOND: MUNICIPAL BOND: MUNICIPAL STOCK: MARGIN STOCK: MARGIN BOND: JUNK STOCK: SHORT STOCK: LONG STOCK: LONG BOND: MUNICIPAL BOND: JUNK *///:~ The Security interface necessary collect contained enums together common type. These categorized enums within SecurityCategory. If take approach Food example, result is: //: enumerated/menu/Meal2.java package enumerated.menu; import net.mindview.util.*; public enum Meal2 { APPETIZER(Food.Appetizer.class), MAINCOURSE(Food.MainCourse.class), DESSERT(Food.Dessert.class), COFFEE(Food.Coffee.class); private Food[] values; private Meal2(Class<? extends Food> kind) { 736 Thinking Java Bruce Eckel values = kind.getEnumConstants(); } public interface Food { enum Appetizer implements Food { SALAD, SOUP, SPRING_ROLLS; } enum MainCourse implements Food { LASAGNE, BURRITO, PAD_THAI, LENTILS, HUMMOUS, VINDALOO; } enum Dessert implements Food { TIRAMISU, GELATO, BLACK_FOREST_CAKE, FRUIT, CREME_CARAMEL; } enum Coffee implements Food { BLACK_COFFEE, DECAF_COFFEE, ESPRESSO, LATTE, CAPPUCCINO, TEA, HERB_TEA; } } public Food randomSelection() { return Enums.random(values); } public static void main(String[] args) { for(int = 0; < 5; i++) { for(Meal2 meal : Meal2.values()) { Food food = meal.randomSelection(); System.out.println(food); } System.out.println("---"); } } } /* Same output Meal.java *///:~ In end, it’s reorganization code may produce clearer structure cases. Exercise 3: (1) Add new Course Course.java demonstrate works Meal.java. Exercise 4: (1) Repeat exercise Meal2.java. Exercise 5: (4) Modify control/VowelsAndConsonants.java uses three enum types: VOWEL, SOMETIMES_A_VOWEL, CONSONANT. The enum constructor take various letters describe particular category. Hint: Use varargs, remember varargs automatically creates array you. Exercise 6: (3) Is special benefit nesting Appetizer, MainCourse, Dessert, Coffee inside Food rather making standalone enums happen implement Food? Using EnumSet instead flags A Set kind collection allows one type object added. Of course, enum requires members unique, would seem set behavior, since can’t add remove elements it’s useful set. The EnumSet added Java SE5 work concert enums create replacement traditional int-based "bit flags." Such flags used indicate kind on-off information, end manipulating bits rather concepts, it’s easy write confusing code. Enumerated Types 737 The EnumSet designed speed, must compete effectively bit flags (operations typically much faster HashSet). Internally, represented (if possible) single long treated bit-vector, it’s extremely fast efficient. The benefit much expressive way indicate presence absence binary feature, without worry performance. The elements EnumSet must come single enum. A possible example uses enum positions building alarm sensors present: //: enumerated/AlarmPoints.java package enumerated; public enum AlarmPoints { STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY, KITCHEN } ///:~ The EnumSet used keep track alarm status: //: enumerated/EnumSets.java // Operations EnumSets package enumerated; import java.util.*; import static enumerated.AlarmPoints.*; import static net.mindview.util.Print.*; public class EnumSets { public static void main(String[] args) { EnumSet<AlarmPoints> points = EnumSet.noneOf(AlarmPoints.class); // Empty set points.add(BATHROOM); print(points); points.addAll(EnumSet.of(STAIR1, STAIR2, KITCHEN)); print(points); points = EnumSet.allOf(AlarmPoints.class); points.removeAll(EnumSet.of(STAIR1, STAIR2, KITCHEN)); print(points); points.removeAll(EnumSet.range(OFFICE1, OFFICE4)); print(points); points = EnumSet.complementOf(points); print(points); } } /* Output: [BATHROOM] [STAIR1, STAIR2, BATHROOM, KITCHEN] [LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY] [LOBBY, BATHROOM, UTILITY] [STAIR1, STAIR2, OFFICE1, OFFICE2, OFFICE3, OFFICE4, KITCHEN] *///:~ A static import used simplify use enum constants. The method names fairly self-explanatory, find full details JDK documentation. When look documentation, you’ll see something interesting—the of( ) method overloaded varargs individual methods taking two five explicit arguments. This indication concern performance EnumSet, single of( ) method using varargs could solved problem, it’s slightly less efficient explicit arguments. Thus, call of( ) two five arguments get explicit (slightly faster) method calls, call one argument five, get varargs version of( ). Notice call one argument, compiler construct varargs array extra overhead calling version single argument. 738 Thinking Java Bruce Eckel EnumSets built top longs, long 64 bits, enum instance requires one bit indicate presence absence. This means EnumSet enum 64 elements without going beyond use single long. What happens 64 elements enum? //: enumerated/BigEnumSet.java import java.util.*; public class BigEnumSet { enum Big { A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34, A35, A36, A37, A38, A39, A40, A41, A42, A43, A44, A45, A46, A47, A48, A49, A50, A51, A52, A53, A54, A55, A56, A57, A58, A59, A60, A61, A62, A63, A64, A65, A66, A67, A68, A69, A70, A71, A72, A73, A74, A75 } public static void main(String[] args) { EnumSet<Big> bigEnumSet = EnumSet.allOf(Big.class); System.out.println(bigEnumSet); } } /* Output: [A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34, A35, A36, A37, A38, A39, A40, A41, A42, A43, A44, A45, A46, A47, A48, A49, A50, A51, A52, A53, A54, A55, A56, A57, A58, A59, A60, A61, A62, A63, A64, A65, A66, A67, A68, A69, A70, A71, A72, A73, A74, A75] *///:~ The EnumSet clearly problem enum 64 elements, may presume adds another long necessary. Exercise 7: (3) Find source code EnumSet explain works. Using EnumMap An EnumMap specialized Map requires keys single enum. Because constraints enum, EnumMap implemented internally array. Thus extremely fast, freely use EnumMaps enum-based lookups. You call put( ) keys enum, it’s like using ordinary Map. Here’s example demonstrates use Command design pattern. This pattern starts interface containing (typically) single method, creates multiple implementations different behavior method. You install Command objects, program calls necessary: //: enumerated/EnumMaps.java // Basics EnumMaps. package enumerated; import java.util.*; import static enumerated.AlarmPoints.*; import static net.mindview.util.Print.*; interface Command { void action(); } public class EnumMaps { Enumerated Types 739 public static void main(String[] args) { EnumMap<AlarmPoints,Command> em = new EnumMap<AlarmPoints,Command>(AlarmPoints.class); em.put(KITCHEN, new Command() { public void action() { print("Kitchen fire!"); } }); em.put(BATHROOM, new Command() { public void action() { print("Bathroom alert!"); } }); for(Map.Entry<AlarmPoints,Command> e : em.entrySet()) { printnb(e.getKey() + ": "); e.getValue().action(); } try { // If there’s value particular key: em.get(UTILITY).action(); } catch(Exception e) { print(e); } } } /* Output: BATHROOM: Bathroom alert! KITCHEN: Kitchen fire! java.lang.NullPointerException *///:~ Just EnumSet, order elements EnumMap determined order definition enum. The last part main( ) shows always key entry enums, value null unless called put( ) key. One advantage EnumMap constant-specific methods (described next) EnumMap allows change value objects, whereas you’ll see constant-specific methods fixed compile time. As you’ll see later chapter, EnumMaps used perform multiple dispatching situations multiple types enums interacting other. Constant-specific methods Java enums interesting feature allows give enum instance different behavior creating methods one. To this, define one abstract methods part enum, define methods enum instance. For example: //: enumerated/ConstantSpecificMethod.java import java.util.*; import java.text.*; public enum ConstantSpecificMethod { DATE_TIME { String getInfo() { return DateFormat.getDateInstance().format(new Date()); } }, CLASSPATH { String getInfo() { return System.getenv("CLASSPATH"); 740 Thinking Java Bruce Eckel } }, VERSION { String getInfo() { return System.getProperty("java.version"); } }; abstract String getInfo(); public static void main(String[] args) { for(ConstantSpecificMethod csm : values()) System.out.println(csm.getInfo()); } } /* (Execute see output) *///:~ You look call methods via associated enum instance. This often called table-driven code (and note similarity aforementioned Command pattern). In object-oriented programming, different behavior associated different classes. Because instance enum behavior via constant-specific methods, suggests instance distinct type. In example, enum instance treated "base type" ConstantSpecificMethod get polymorphic behavior method call getInfo( ). However, take similarity far. You cannot treat enum instances class types: //: enumerated/NotClasses.java // {Exec: javap -c LikeClasses} import static net.mindview.util.Print.*; enum LikeClasses { WINKEN { void behavior() { print("Behavior1"); } }, BLINKEN { void behavior() { print("Behavior2"); } }, NOD { void behavior() { print("Behavior3"); } }; abstract void behavior(); } public class NotClasses { // void f1(LikeClasses.WINKEN instance) {} // Nope } /* Output: Compiled "NotClasses.java" abstract class LikeClasses extends java.lang.Enum{ public static final LikeClasses WINKEN; public static final LikeClasses BLINKEN; public static final LikeClasses NOD; ... *///:~ In f1( ), see compiler doesn’t allow use enum instance class type, makes sense consider code generated compiler—each enum element static final instance LikeClasses. Also, static, enum instances inner enums behave like ordinary inner classes; cannot access non-static fields methods outer class. As interesting example, consider car wash. Each customer given menu choices wash, option performs different action. A constant-specific method associated option, EnumSet used hold customer’s selections: Enumerated Types 741 //: enumerated/CarWash.java import java.util.*; import static net.mindview.util.Print.*; public class CarWash { public enum Cycle { UNDERBODY { void action() { print("Spraying underbody"); } }, WHEELWASH { void action() { print("Washing wheels"); } }, PREWASH { void action() { print("Loosening dirt"); } }, BASIC { void action() { print("The basic wash"); } }, HOTWAX { void action() { print("Applying hot wax"); } }, RINSE { void action() { print("Rinsing"); } }, BLOWDRY { void action() { print("Blowing dry"); } }; abstract void action(); } EnumSet<Cycle> cycles = EnumSet.of(Cycle.BASIC, Cycle.RINSE); public void add(Cycle cycle) { cycles.add(cycle); } public void washCar() { for(Cycle c : cycles) c.action(); } public String toString() { return cycles.toString(); } public static void main(String[] args) { CarWash wash = new CarWash(); print(wash); wash.washCar(); // Order addition unimportant: wash.add(Cycle.BLOWDRY); wash.add(Cycle.BLOWDRY); // Duplicates ignored wash.add(Cycle.RINSE); wash.add(Cycle.HOTWAX); print(wash); wash.washCar(); } } /* Output: [BASIC, RINSE] The basic wash Rinsing [BASIC, HOTWAX, RINSE, BLOWDRY] The basic wash Applying hot wax Rinsing Blowing dry *///:~ The syntax defining constant-specific method effectively anonymous inner class, succinct. 742 Thinking Java Bruce Eckel This example also shows characteristics EnumSets. Since it’s set, hold one item, duplicate calls add( ) argument ignored (this makes sense, since flip bit "on" once). Also, order add enum instances unimportant—the output order determined declaration order enum. Is possible override constant-specific methods, instead implementing abstract method? Yes, see here: //: enumerated/OverrideConstantSpecific.java import static net.mindview.util.Print.*; public enum OverrideConstantSpecific { NUT, BOLT, WASHER { void f() { print("Overridden method"); } }; void f() { print("default behavior"); } public static void main(String[] args) { for(OverrideConstantSpecific ocs : values()) { printnb(ocs + ": "); ocs.f(); } } } /* Output: NUT: default behavior BOLT: default behavior WASHER: Overridden method *///:~ Although enums prevent certain types code, general experiment classes. Chain Responsibility enums In Chain Responsibility design pattern, create number different ways solve problem chain together. When request occurs, passed along chain one solutions handle request. You easily implement simple Chain Responsibility constantspecific methods. Consider model post office, tries deal piece mail general way possible, keep trying ends treating mail dead letter. Each attempt thought Strategy (another design pattern), entire list together Chain Responsibility. We start describing piece mail. All different characteristics interest expressed using enums. Because Mail objects randomly generated, easiest way reduce probability (for example) piece mail given YES GeneralDelivery create non-YES instances, enum definitions look little funny first. Within Mail, you’ll see randomMail( ), creates random pieces test mail. The generator( ) method produces Iterable object uses randomMail( ) produce number mail objects, one time call next( ) via iterator. This construct allows simple creation foreach loop calling Mail.generator( ): //: enumerated/PostOffice.java // Modeling post office. Enumerated Types 743 import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; class Mail { // The NO’s lower probability random selection: enum GeneralDelivery {YES,NO1,NO2,NO3,NO4,NO5} enum Scannability {UNSCANNABLE,YES1,YES2,YES3,YES4} enum Readability {ILLEGIBLE,YES1,YES2,YES3,YES4} enum Address {INCORRECT,OK1,OK2,OK3,OK4,OK5,OK6} enum ReturnAddress {MISSING,OK1,OK2,OK3,OK4,OK5} GeneralDelivery generalDelivery; Scannability scannability; Readability readability; Address address; ReturnAddress returnAddress; static long counter = 0; long id = counter++; public String toString() { return "Mail " + id; } public String details() { return toString() + ", General Delivery: " + generalDelivery + ", Address Scanability: " + scannability + ", Address Readability: " + readability + ", Address Address: " + address + ", Return address: " + returnAddress; } // Generate test Mail: public static Mail randomMail() { Mail = new Mail(); m.generalDelivery= Enums.random(GeneralDelivery.class); m.scannability = Enums.random(Scannability.class); m.readability = Enums.random(Readability.class); m.address = Enums.random(Address.class); m.returnAddress = Enums.random(ReturnAddress.class); return m; } public static Iterable<Mail> generator(final int count) { return new Iterable<Mail>() { int n = count; public Iterator<Mail> iterator() { return new Iterator<Mail>() { public boolean hasNext() { return n-- > 0; } public Mail next() { return randomMail(); } public void remove() { // Not implemented throw new UnsupportedOperationException(); } }; } }; } } public class PostOffice { enum MailHandler { GENERAL_DELIVERY { boolean handle(Mail m) { switch(m.generalDelivery) { case YES: print("Using general delivery " + m); return true; default: return false; } 744 Thinking Java Bruce Eckel } }, MACHINE_SCAN { boolean handle(Mail m) { switch(m.scannability) { case UNSCANNABLE: return false; default: switch(m.address) { case INCORRECT: return false; default: print("Delivering "+ + " automatically"); return true; } } } }, VISUAL_INSPECTION { boolean handle(Mail m) { switch(m.readability) { case ILLEGIBLE: return false; default: switch(m.address) { case INCORRECT: return false; default: print("Delivering " + + " normally"); return true; } } } }, RETURN_TO_SENDER { boolean handle(Mail m) { switch(m.returnAddress) { case MISSING: return false; default: print("Returning " + + " sender"); return true; } } }; abstract boolean handle(Mail m); } static void handle(Mail m) { for(MailHandler handler : MailHandler.values()) if(handler.handle(m)) return; print(m + " dead letter"); } public static void main(String[] args) { for(Mail mail : Mail.generator(10)) { print(mail.details()); handle(mail); print("*****"); } } } /* Output: Mail 0, General Delivery: NO2, Address Scanability: UNSCANNABLE, Address Readability: YES3, Address Address: OK1, Return address: OK1 Delivering Mail 0 normally ***** Mail 1, General Delivery: NO5, Address Scanability: YES3, Address Readability: ILLEGIBLE, Address Address: OK5, Return address: OK1 Delivering Mail 1 automatically Enumerated Types 745 ***** Mail 2, General Delivery: YES, Address Scanability: YES3, Address Readability: YES1, Address Address: OK1, Return address: OK5 Using general delivery Mail 2 ***** Mail 3, General Delivery: NO4, Address Scanability: YES3, Address Readability: YES1, Address Address: INCORRECT, Return address: OK4 Returning Mail 3 sender ***** Mail 4, General Delivery: NO4, Address Scanability: UNSCANNABLE, Address Readability: YES1, Address Address: INCORRECT, Return address: OK2 Returning Mail 4 sender ***** Mail 5, General Delivery: NO3, Address Scanability: YES1, Address Readability: ILLEGIBLE, Address Address: OK4, Return address: OK2 Delivering Mail 5 automatically ***** Mail 6, General Delivery: YES, Address Scanability: YES4, Address Readability: ILLEGIBLE, Address Address: OK4, Return address: OK4 Using general delivery Mail 6 ***** Mail 7, General Delivery: YES, Address Scanability: YES3, Address Readability: YES4, Address Address: OK2, Return address: MISSING Using general delivery Mail 7 ***** Mail 8, General Delivery: NO3, Address Scanability: YES1, Address Readability: YES3, Address Address: INCORRECT, Return address: MISSING Mail 8 dead letter ***** Mail 9, General Delivery: NO1, Address Scanability: UNSCANNABLE, Address Readability: YES2, Address Address: OK1, Return address: OK4 Delivering Mail 9 normally ***** *///:~ The Chain Responsibility expressed enum MailHandler, order enum definitions determines order strategies attempted piece mail. Each strategy tried turn one succeeds fail, case dead letter. Exercise 8: (6) Modify PostOffice.java ability forward mail. Exercise 9: (5) Modify class PostOffice uses EnumMap. Project: 2 Specialized languages like Prolog use backward chaining order solve problems like this. Using PostOffice.java inspiration, research languages develop program allows new "rules" easily added system. State machines enums Enumerated types ideal creating state machines. A state machine finite number specific states. The machine normally moves one state next based input, also transient states; machine moves soon task performed. 2 Projects suggestions used (for example) term projects. Solutions projects included solution guide. 746 Thinking Java Bruce Eckel There certain allowable inputs state, different inputs change state machine different new states. Because enums restrict set possible cases, quite useful enumerating different states inputs. Each state also typically kind associated output. A vending machine good example state machine. First, define various inputs enum: //: enumerated/Input.java package enumerated; import java.util.*; public enum Input { NICKEL(5), DIME(10), QUARTER(25), DOLLAR(100), TOOTHPASTE(200), CHIPS(75), SODA(100), SOAP(50), ABORT_TRANSACTION { public int amount() { // Disallow throw new RuntimeException("ABORT.amount()"); } }, STOP { // This must last instance. public int amount() { // Disallow throw new RuntimeException("SHUT_DOWN.amount()"); } }; int value; // In cents Input(int value) { this.value = value; } Input() {} int amount() { return value; }; // In cents static Random rand = new Random(47); public static Input randomSelection() { // Don’t include STOP: return values()[rand.nextInt(values().length - 1)]; } } ///:~ Note two Inputs associated amount, amount( ) defined interface. However, inappropriate call amount( ) two Input types, throw exception call amount( ). Although bit odd setup (define method interface, throw exception call certain implementations), imposed upon us constraints enums. The VendingMachine react inputs first categorizing via Category enum, switch categories. This example shows enums make code clearer easier manage: //: enumerated/VendingMachine.java // {Args: VendingMachineInput.txt} package enumerated; import java.util.*; import net.mindview.util.*; import static enumerated.Input.*; import static net.mindview.util.Print.*; enum Category { MONEY(NICKEL, DIME, QUARTER, DOLLAR), ITEM_SELECTION(TOOTHPASTE, CHIPS, SODA, SOAP), QUIT_TRANSACTION(ABORT_TRANSACTION), SHUT_DOWN(STOP); private Input[] values; Enumerated Types 747 } Category(Input... types) { values = types; } private static EnumMap<Input,Category> categories = new EnumMap<Input,Category>(Input.class); static { for(Category c : Category.class.getEnumConstants()) for(Input type : c.values) categories.put(type, c); } public static Category categorize(Input input) { return categories.get(input); } public class VendingMachine { private static State state = State.RESTING; private static int amount = 0; private static Input selection = null; enum StateDuration { TRANSIENT } // Tagging enum enum State { RESTING { void next(Input input) { switch(Category.categorize(input)) { case MONEY: amount += input.amount(); state = ADDING_MONEY; break; case SHUT_DOWN: state = TERMINAL; default: } } }, ADDING_MONEY { void next(Input input) { switch(Category.categorize(input)) { case MONEY: amount += input.amount(); break; case ITEM_SELECTION: selection = input; if(amount < selection.amount()) print("Insufficient money " + selection); else state = DISPENSING; break; case QUIT_TRANSACTION: state = GIVING_CHANGE; break; case SHUT_DOWN: state = TERMINAL; default: } } }, DISPENSING(StateDuration.TRANSIENT) { void next() { print("here " + selection); amount -= selection.amount(); state = GIVING_CHANGE; } }, GIVING_CHANGE(StateDuration.TRANSIENT) { void next() { if(amount > 0) { 748 Thinking Java Bruce Eckel print("Your change: " + amount); amount = 0; } state = RESTING; } }, TERMINAL { void output() { print("Halted"); } }; private boolean isTransient = false; State() {} State(StateDuration trans) { isTransient = true; } void next(Input input) { throw new RuntimeException("Only call " + "next(Input input) non-transient states"); } void next() { throw new RuntimeException("Only call next() " + "StateDuration.TRANSIENT states"); } void output() { print(amount); } } static void run(Generator<Input> gen) { while(state != State.TERMINAL) { state.next(gen.next()); while(state.isTransient) state.next(); state.output(); } } public static void main(String[] args) { Generator<Input> gen = new RandomInputGenerator(); if(args.length == 1) gen = new FileInputGenerator(args[0]); run(gen); } } // For basic sanity check: class RandomInputGenerator implements Generator<Input> { public Input next() { return Input.randomSelection(); } } // Create Inputs file ‘;’-separated strings: class FileInputGenerator implements Generator<Input> { private Iterator<String> input; public FileInputGenerator(String fileName) { input = new TextFile(fileName, ";").iterator(); } public Input next() { if(!input.hasNext()) return null; return Enum.valueOf(Input.class, input.next().trim()); } } /* Output: 25 50 75 CHIPS 0 100 200 TOOTHPASTE 0 25 Enumerated Types 749 35 Your change: 0 25 35 Insufficient 35 60 70 75 Insufficient 75 Your change: 0 Halted *///:~ 35 money SODA money SODA 75 Because selecting among enum instances often accomplished switch statement (notice extra effort language goes order make switch enums easy), one common questions ask organizing multiple enums "What I want switch on?" Here, it’s easiest work back VendingMachine noting State, need switch basic categories input action: money inserted, item selected, transaction aborted, machine turned off. However, within categories, different types money inserted different items selected. The Category enum groups different types Input categorize( ) method produce appropriate Category inside switch. This method uses EnumMap efficiently safely perform lookup. If study class VendingMachine, see state different, responds differently input. Also note two transient states; run( ) machine waits Input doesn’t stop moving states longer transient state. The VendingMachine tested two ways, using two different Generator objects. The RandomInputGenerator keeps producing inputs, everything except SHUT_DOWN. By running long time get kind sanity check help ensure machine wander bad state. The FilelnputGenerator takes file describing inputs text form, turns enum instances, creates Input objects. Here’s text file used produce output shown above: QUARTER; QUARTER; QUARTER; CHIPS; DOLLAR; DOLLAR; TOOTHPASTE; QUARTER; DIME; ABORT_TRANSACTION; QUARTER; DIME; SODA; QUARTER; DIME; NICKEL; SODA; ABORT_TRANSACTION; STOP; ///:~ One limitation design fields VendingMachine accessed enum State instances must static, means single VendingMachine instance. This may big issue think actual (embedded Java) implementation, since likely one application per machine. Exercise 10: (7) Modify class VendingMachine (only) using EnumMap one program multiple instances VendingMachine. 750 Thinking Java Bruce Eckel Exercise 11: (7) In real vending machine want easily add change type vended items, limits imposed enum Input impractical (remember enums restricted set types). Modify VendingMachine.java vended items represented class instead part Input, initialize Array List objects text file (using net.mindview.util.TextFile). Project 3 Design vending machine using internationalization, one machine easily adapted countries. Multiple dispatching When dealing multiple interacting types, program get particularly messy. For example, consider system parses executes mathematical expressions. You want say Number.plus(Number), Number.multiply(Number), etc., Number base class family numerical objects. But say a.plus(b), don’t know exact type either b, get interact properly? The answer starts something probably don’t think about: Java performs single dispatching. That is, performing operation one object whose type unknown, Java invoke dynamic binding mechanism one types. This doesn’t solve problem described here, end detecting types manually effectively producing dynamic binding behavior. The solution called multiple dispatching. (In case, two dispatches, referred double dispatching.) Polymorphism occur via method calls, want double dispatching, must two method calls: first determine first unknown type, second determine second unknown type. With multiple dispatching, must virtual call types—if working two different type hierarchies interacting, you’ll need virtual call hierarchy. Generally, you’ll set configuration single method call produces one virtual method call thus services one type process. To get effect, need work one method: You’ll need method call dispatch. The methods following example (which implements "paper, scissors, rock" game, traditionally called RoShamBo) called compete( ) eval( ) members type. They produce one three possible outcomes: 4 //: enumerated/Outcome.java package enumerated; public enum Outcome { WIN, LOSE, DRAW } ///:~ //: enumerated/RoShamBo1.java // Demonstration multiple dispatching. package enumerated; import java.util.*; import static enumerated.Outcome.*; interface Outcome Outcome Outcome Outcome Item { compete(Item it); eval(Paper p); eval(Scissors s); eval(Rock r); 3 Projects suggestions used (for example) term projects. Solutions projects included solution guide. 4 This example existed number years C++ Java (in Thinking Patterns) www.MindView.net appeared, without attribution, book authors. Enumerated Types 751 } class Paper implements Item { public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return DRAW; } public Outcome eval(Scissors s) { return WIN; } public Outcome eval(Rock r) { return LOSE; } public String toString() { return "Paper"; } } class Scissors implements Item { public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return LOSE; } public Outcome eval(Scissors s) { return DRAW; } public Outcome eval(Rock r) { return WIN; } public String toString() { return "Scissors"; } } class Rock implements Item { public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return WIN; } public Outcome eval(Scissors s) { return LOSE; } public Outcome eval(Rock r) { return DRAW; } public String toString() { return "Rock"; } } public class RoShamBo1 { static final int SIZE = 20; private static Random rand = new Random(47); public static Item newItem() { switch(rand.nextInt(3)) { default: case 0: return new Scissors(); case 1: return new Paper(); case 2: return new Rock(); } } public static void match(Item a, Item b) { System.out.println( + " vs. " + b + ": " + a.compete(b)); } public static void main(String[] args) { for(int = 0; < SIZE; i++) match(newItem(), newItem()); } } /* Output: Rock vs. Rock: DRAW Paper vs. Rock: WIN Paper vs. Rock: WIN Paper vs. Rock: WIN Scissors vs. Paper: WIN Scissors vs. Scissors: DRAW Scissors vs. Paper: WIN Rock vs. Paper: LOSE Paper vs. Paper: DRAW Rock vs. Paper: LOSE Paper vs. Scissors: LOSE Paper vs. Scissors: LOSE Rock vs. Scissors: WIN Rock vs. Paper: LOSE Paper vs. Rock: WIN Scissors vs. Paper: WIN Paper vs. Scissors: LOSE 752 Thinking Java Bruce Eckel Paper vs. Scissors: LOSE Paper vs. Scissors: LOSE Paper vs. Scissors: LOSE *///:~ Item interface types multiply dispatched. RoShamBo1.match( ) takes two Item objects begins doubledispatching process calling Item.compete( ) function. The virtual mechanism determines type a, wakes inside compete( ) function a’s concrete type. The compete( ) function performs second dispatch calling eval( ) remaining type. Passing (this) argument eval( ) produces call overloaded eval( ) function, thus preserving type information first dispatch. When second dispatch completed, know exact types Item objects. It requires lot ceremony set multiple dispatching, keep mind benefit syntactic elegance achieved making callinstead writing awkward code determine type one objects call, simply say, "You two! I don’t care types are, interact properly other!" Make sure kind elegance important embarking multiple dispatching, however. Dispatching enums Performing straight translation RoShamBo1.java enum-based solution problematic enum instances types, overloaded eval( ) methods won’t work—you can’t use enum instances argument types. However, number different approaches implementing multiple dispatching benefit enums. One approach uses constructor initialize e n um instance "row" outcomes; taken together produces kind lookup table: //: enumerated/RoShamBo2.java // Switching one enum another. package enumerated; import static enumerated.Outcome.*; public enum RoShamBo2 implements Competitor<RoShamBo2> { PAPER(DRAW, LOSE, WIN), SCISSORS(WIN, DRAW, LOSE), ROCK(LOSE, WIN, DRAW); private Outcome vPAPER, vSCISSORS, vROCK; RoShamBo2(Outcome paper,Outcome scissors,Outcome rock) { this.vPAPER = paper; this.vSCISSORS = scissors; this.vROCK = rock; } public Outcome compete(RoShamBo2 it) { switch(it) { default: case PAPER: return vPAPER; case SCISSORS: return vSCISSORS; case ROCK: return vROCK; } } public static void main(String[] args) { RoShamBo.play(RoShamBo2.class, 20); } } /* Output: ROCK vs. ROCK: DRAW SCISSORS vs. ROCK: LOSE SCISSORS vs. ROCK: LOSE Enumerated Types 753 SCISSORS vs. ROCK: LOSE PAPER vs. SCISSORS: LOSE PAPER vs. PAPER: DRAW PAPER vs. SCISSORS: LOSE ROCK vs. SCISSORS: WIN SCISSORS vs. SCISSORS: DRAW ROCK vs. SCISSORS: WIN SCISSORS vs. PAPER: WIN SCISSORS vs. PAPER: WIN ROCK vs. PAPER: LOSE ROCK vs. SCISSORS: WIN SCISSORS vs. ROCK: LOSE PAPER vs. SCISSORS: LOSE SCISSORS vs. PAPER: WIN SCISSORS vs. PAPER: WIN SCISSORS vs. PAPER: WIN SCISSORS vs. PAPER: WIN *///:~ Once types determined compete( ), action return resulting Outcome. However, could also call another method, even (for example) via Command object assigned constructor. RoShamBo2.java much smaller straightforward original example, thus easier keep track of. Notice you’re still using two dispatches determine type objects. In RoShamBo1.java, dispatches performed using virtual method calls, here, first dispatch uses virtual method call. The second dispatch uses switch, safe enum limits choices switch statement. The code drives enum separated used examples. First, Competitor interface defines type competes another Competitor: //: enumerated/Competitor.java // Switching one enum another. package enumerated; public interface Competitor<T extends Competitor<T>> { Outcome compete(T competitor); } ///:~ Then define two static methods (static avoid specify parameter type explicitly). First, match( ) calls compete( ) one Competitor vs. another, see case type parameter needs Competitor<T>. But play( ), type parameter must Enum<T> used Enums.random( ), Competitor<T> passed match( ): //: enumerated/RoShamBo.java // Common tools RoShamBo examples. package enumerated; import net.mindview.util.*; public class RoShamBo { public static <T extends Competitor<T>> void match(T a, T b) { System.out.println( + " vs. " + b + ": " + a.compete(b)); } public static <T extends Enum<T> & Competitor<T>> void play(Class<T> rsbClass, int size) { for(int = 0; < size; i++) 754 Thinking Java Bruce Eckel match( Enums.random(rsbClass),Enums.random(rsbClass)); } } ///:~ The play( ) method return value involves type parameter T, seems like might use wildcards inside Class<T> type instead using leading parameter description. However, wildcards cannot extend one base type, must use expression. Using constant-specific methods Because constant-specific methods allow provide different method implementations enum instance, might seem like perfect solution setting multiple dispatching. But even though given different behavior way, enum instances types, cannot use argument types method signatures. The best example set switch statement: //: enumerated/RoShamBo3.java // Using constant-specific methods. package enumerated; import static enumerated.Outcome.*; public enum RoShamBo3 implements Competitor<RoShamBo3> { PAPER { public Outcome compete(RoShamBo3 it) { switch(it) { default: // To placate compiler case PAPER: return DRAW; case SCISSORS: return LOSE; case ROCK: return WIN; } } }, SCISSORS { public Outcome compete(RoShamBo3 it) { switch(it) { default: case PAPER: return WIN; case SCISSORS: return DRAW; case ROCK: return LOSE; } } }, ROCK { public Outcome compete(RoShamBo3 it) { switch(it) { default: case PAPER: return LOSE; case SCISSORS: return WIN; case ROCK: return DRAW; } } }; public abstract Outcome compete(RoShamBo3 it); public static void main(String[] args) { RoShamBo.play(RoShamBo3.class, 20); } } /* Same output RoShamBo2.java *///:~ Enumerated Types 755 Although functional unreasonable, solution RoShamBo2.java seems require less code adding new type, thus seems straightforward. However, RoShamBo3.java simplified compressed: //: enumerated/RoShamBo4.java package enumerated; public enum RoShamBo4 implements Competitor<RoShamBo4> { ROCK { public Outcome compete(RoShamBo4 opponent) { return compete(SCISSORS, opponent); } }, SCISSORS { public Outcome compete(RoShamBo4 opponent) { return compete(PAPER, opponent); } }, PAPER { public Outcome compete(RoShamBo4 opponent) { return compete(ROCK, opponent); } }; Outcome compete(RoShamBo4 loser, RoShamBo4 opponent) { return ((opponent == this) ? Outcome.DRAW : ((opponent == loser) ? Outcome.WIN : Outcome.LOSE)); } public static void main(String[] args) { RoShamBo.play(RoShamBo4.class, 20); } } /* Same output RoShamBo2.java *///:~ Here, second dispatch performed two-argument version compete( ), performs sequence comparisons thus similar action switch. It’s smaller, bit confusing. For large system confusion become debilitating. Dispatching EnumMaps It’s possible perform "true" double dispatch using EnumMap class, specifically designed work efficiently enums. Since goal switch two unknown types, EnumMap EnumMaps used produce double dispatch: //: enumerated/RoShamBo5.java // Multiple dispatching using EnumMap EnumMaps. package enumerated; import java.util.*; import static enumerated.Outcome.*; enum RoShamBo5 implements Competitor<RoShamBo5> { PAPER, SCISSORS, ROCK; static EnumMap<RoShamBo5,EnumMap<RoShamBo5,Outcome>> table = new EnumMap<RoShamBo5, EnumMap<RoShamBo5,Outcome>>(RoShamBo5.class); static { for(RoShamBo5 : RoShamBo5.values()) table.put(it, new EnumMap<RoShamBo5,Outcome>(RoShamBo5.class)); initRow(PAPER, DRAW, LOSE, WIN); 756 Thinking Java Bruce Eckel initRow(SCISSORS, WIN, DRAW, LOSE); initRow(ROCK, LOSE, WIN, DRAW); } static void initRow(RoShamBo5 it, Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK) { EnumMap<RoShamBo5,Outcome> row = RoShamBo5.table.get(it); row.put(RoShamBo5.PAPER, vPAPER); row.put(RoShamBo5.SCISSORS, vSCISSORS); row.put(RoShamBo5.ROCK, vROCK); } public Outcome compete(RoShamBo5 it) { return table.get(this).get(it); } public static void main(String[] args) { RoShamBo.play(RoShamBo5.class, 20); } } /* Same output RoShamBo2.java *///:~ The EnumMap initialized using static clause; see table-like structure calls initRow( ). Notice compete( ) method, see dispatches happening single statement. Using 2-D array We simplify solution even noting enum instance fixed value (based declaration order) ordinal( ) produces value. A two-dimensional array mapping competitors onto outcomes produces smallest straightforward solution (and possibly fastest, although remember EnumMap uses internal array): //: enumerated/RoShamBo6.java // Enums using "tables" instead multiple dispatch. package enumerated; import static enumerated.Outcome.*; enum RoShamBo6 implements Competitor<RoShamBo6> { PAPER, SCISSORS, ROCK; private static Outcome[][] table = { { DRAW, LOSE, WIN }, // PAPER { WIN, DRAW, LOSE }, // SCISSORS { LOSE, WIN, DRAW }, // ROCK }; public Outcome compete(RoShamBo6 other) { return table[this.ordinal()][other.ordinal()]; } public static void main(String[] args) { RoShamBo.play(RoShamBo6.class, 20); } } ///:~ The table exactly order calls initRow( ) previous example. The small size code holds great appeal previous examples, partly seems much easier understand modify also seems straightforward. However, it’s quite "safe" previous examples uses array. With larger array, might get size wrong, tests cover possibilities something could slip cracks. Enumerated Types 757 All solutions different types tables, it’s worth exploring expression tables find one fits best. Note even though solution compact, also fairly rigid produce constant output given constant inputs. However, there’s nothing prevents table produce function object. For certain types problems, concept "table-driven code" powerful. 758 Thinking Java Bruce Eckel Summary Even though enumerated types terribly complex themselves, chapter postponed later book enums combination features like polymorphism, generics, reflection. Although significantly sophisticated enums C C++, enums still "small" feature, something language survived (a bit awkwardly) without many years. And yet chapter shows valuable impact "small" feature have— sometimes gives right leverage solve problem elegantly clearly, I saying throughout book, elegance important, clarity may make difference successful solution one fails others cannot understand it. On subject clarity, unfortunate source confusion comes poor choice Java 1.0 term "enumeration" instead common well-accepted term "iterator" indicate object selects element sequence (as shown Collections). Some languages even refer enumerated data types "enumerators!" This mistake since rectified Java, Enumeration interface could not, course, simply removed still hanging around old (and sometimes new!) code, library, documentation. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Enumerated Types 759 Annotations Annotations (also known metadata) provide formalized way add information code easily use data later point. 1 Annotations partly motivated general trend toward combining metadata source-code files, instead keeping external documents. They also response feature pressure languages like C#. Annotations one fundamental language changes introduced Java SE5. They provide information need fully describe program, cannot expressed Java. Thus, annotations allow store extra information program format tested verified compiler. Annotations used generate descriptor files even new class definitions help ease burden writing "boilerplate" code. Using annotations, keep metadata Java source code, advantage cleaner looking code, compile-time type checking annotation API help build processing tools annotations. Although types metadata come predefined Java SE5, general kind annotations add entirely you. The syntax annotations reasonably simple consists mainly addition @ symbol language. Java SE5 contains three generalpurpose built-in annotations, defined java.lang: • @Override, indicate method definition intended override method base class. This generates compiler error accidentally misspell method name give improper signature. 2 • @Deprecated, produce compiler warning element used. • @SuppressWarnings, turn inappropriate compiler warnings. This annotation allowed supported earlier releases Java SE5 (it ignored). Four additional annotation types support creation new annotations; learn chapter. Anytime create descriptor classes interfaces involve repetitive work, usually use annotations automate simplify process. Much extra work Enterprise JavaBeans (EJBs), example, eliminated use annotations EJB3.0. Annotations replace existing systems like XDoclet, independent doclet tool (see supplement http://MindView.net/Books/BetterJava) specifically designed creating annotation-style doclets. In contrast, annotations true language constructs hence structured, type-checked compile time. Keeping information actual source code comments makes code neater easier maintain. By using extending annotation API tools, external bytecode manipulation 1 Jeremy Meyer came Crested Butte spent two weeks working chapter. His help invaluable. This doubt inspired similar feature C#. The C# feature keyword annotation, enforced compiler. That is, override method C#, must use override keyword, whereas Java (©Override annotation optional. 2 libraries see chapter, perform powerful inspection manipulation source code well bytecode. Basic syntax In example below, method testExecute( ) annotated @Test. This doesn’t anything itself, compiler ensure definition @Test annotation build path. As see later chapter, create tool runs method via reflection. //: annotations/Testable.java package annotations; import net.mindview.atunit.*; public class Testable { public void execute() { System.out.println("Executing.."); } @Test void testExecute() { execute(); } } ///:~ Annotated methods different methods. The @Test annotation example used combination modifiers like public static void. Syntactically, annotations used much way modifiers. Defining annotations Here definition annotation above. You see annotation definitions look lot like interface definitions. In fact, compile class files like Java interface: //: net/mindview/atunit/Test.java // The @Test tag. package net.mindview.atunit; import java.lang.annotation.*; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test {} ///:~ Apart @ symbol, definition @Test much like empty interface. An annotation definition also requires meta-annotations @Target (@Retention. @Target defines apply annotation (a method field, example). @Retention defines whether annotations available source code (SOURCE), class files (CLASS), run time (RUNTIME). Annotations usually contain elements specify values annotations. A program tool use parameters processing annotations. Elements look like interface methods, except declare default values. An annotation without elements, @Test above, called marker annotation. Here simple annotation tracks use cases project. Programmers annotate method set methods fulfill requirements particular use case. A project manager get idea project progress counting implemented use cases, developers maintaining project easily find use cases need update debug business rules within system. 762 Thinking Java Bruce Eckel //: annotations/UseCase.java import java.lang.annotation.*; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface UseCase { public int id(); public String description() default "no description"; } ///:~ Notice id description resemble method declarations. Because id type-checked compiler, reliable way linking tracking database use case document source code. The element description default value picked annotation processor value specified method annotated. Here class three methods annotated use cases: //: annotations/PasswordUtils.java import java.util.*; public class PasswordUtils { @UseCase(id = 47, description = "Passwords must contain least one numeric") public boolean validatePassword(String password) { return (password.matches("\\w*\\d\\w*")); } @UseCase(id = 48) public String encryptPassword(String password) { return new StringBuilder(password).reverse().toString(); } @UseCase(id = 49, description = "New passwords can’t equal previously used ones") public boolean checkForNewPassword( List<String> prevPasswords, String password) { return !prevPasswords.contains(password); } } ///:~ The values annotation elements expressed name-value pairs parentheses @UseCase declaration. The annotation encryptPassword( ) passed value description element here, default value defined ©interface UseCase appear class run annotation processor. You could imagine using system like order "sketch" system, filling functionality build it. Meta-annotations There currently three standard annotations (described earlier) four metaannotations defined Java language. The meta-annotations annotating annotations: @Target Annotations Where annotation applied. The possible ElementType arguments are: CONSTRUCTOR: Constructor declaration FIELD: Field declaration (includes enum constants) LOCAL_VARIABLE: Local variable declaration METHOD: Method declaration 763 PACKAGE: Package declaration PARAMETER: Parameter declaration TYPE: Class, interface (including annotation type), enum declaration @Retention How long annotation information kept. The possible RetentionPolicy arguments are: SOURCE: Annotations discarded compiler. CLASS: Annotations available class file compiler discarded VM. RUNTIME: Annotations retained VM run time, may read reflectively. @Documented Include annotation Javadocs. @Inherited Allow subclasses inherit parent annotations. Most time, defining annotations writing processors deal them. 764 Thinking Java Bruce Eckel Writing annotation processors Without tools read them, annotations hardly useful comments. An important part process using annotations create use annotation processors. Java SE5 provides extensions reflection API help create tools. It also provides external tool called apt help parse Java source code annotations. Here simple annotation processor reads annotated PasswordUtils class uses reflection look @UseCase tags. Given list id values, lists use cases finds reports missing: //: annotations/UseCaseTracker.java import java.lang.reflect.*; import java.util.*; public class UseCaseTracker { public static void trackUseCases(List<Integer> useCases, Class<?> cl) { for(Method : cl.getDeclaredMethods()) { UseCase uc = m.getAnnotation(UseCase.class); if(uc != null) { System.out.println("Found Use Case:" + uc.id() + " " + uc.description()); useCases.remove(new Integer(uc.id())); } } for(int : useCases) { System.out.println("Warning: Missing use case-" + i); } } public static void main(String[] args) { List<Integer> useCases = new ArrayList<Integer>(); Collections.addAll(useCases, 47, 48, 49, 50); trackUseCases(useCases, PasswordUtils.class); } } /* Output: Found Use Case:47 Passwords must contain least one numeric Found Use Case:48 description Found Use Case:49 New passwords can’t equal previously used ones Warning: Missing use case-50 *///:~ This uses reflection method getDeclaredMethods( ) method getAnnotation( ), comes AnnotatedElement interface (classes like Class, Method Field implement interface). This method returns annotation object specified type, case "UseCase." If annotations particular type annotated method, null value returned. The element values extracted calling id( ) description( ). Remember description specified annotation encryptPassword( ) method, processor finds default value "no description" calls description( ) method particular annotation. Annotation elements The @UseCase tag defined UseCase.java contains int element id String element description. Here list allowed types annotation elements: Annotations 765 • All primitives (int, float, boolean etc.) • String • Class • Enums • Annotations • Arrays The compiler report error try use types. Note allowed use wrapper classes, autoboxing isn’t really limitation. You also elements annotations. As see bit later, nested annotations helpful. Default value constraints The compiler quite picky default element values. No element unspecified value. This means elements must either default values values provided class uses annotation. There another restriction, none non-primitive type elements allowed take null value, either declared source code defined default value annotation interface. This makes hard write processor acts presence absence element, every element effectively present every annotation declaration. You get around checking specific values, like empty strings negative values: //: annotations/SimulatingNull.java import java.lang.annotation.*; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface SimulatingNull { public int id() default -1; public String description() default ""; } ///:~ This typical idiom annotation definitions. Generating external files Annotations especially useful working frameworks require sort additional information accompany source code. Technologies like Enterprise JavaBeans (prior EJB3) require numerous interfaces deployment descriptors "boilerplate" code, defined way every bean. Web services, custom tag libraries object/relational mapping tools like Toplink Hibernate often require XML descriptors external code. After defining Java class, programmer must undergo tedium respecifying information like name, package on— information already exists original class. Whenever use external descriptor file, end two separate sources information class, usually leads code synchronization problems. This also requires programmers working project must know editing descriptor well write Java programs. 766 Thinking Java Bruce Eckel Suppose want provide basic object/relational mapping functionality automate creation database table order store JavaBean. You could use XML descriptor file specify name class, member, information database mapping. Using annotations, however, keep information JavaBean source file. To this, need annotations define name database table associated bean, columns, SQL types map bean’s properties. Here annotation bean tells annotation processor create database table: //: annotations/database/DBTable.java package annotations.database; import java.lang.annotation.*; @Target(ElementType.TYPE) // Applies classes @Retention(RetentionPolicy.RUNTIME) public @interface DBTable { public String name() default ""; } ///:~ Each ElementType specify @Target annotation restriction tells compiler annotation applied particular type. You specify single value enum ElementType, specify comma-separated list combination values. If want apply annotation ElementType, leave @Target annotation altogether, although uncommon. Note @DBTable name( ) element annotation supply name database table processor create. Here annotations JavaBean fields: //: annotations/database/Constraints.java package annotations.database; import java.lang.annotation.*; @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface Constraints { boolean primaryKey() default false; boolean allowNull() default true; boolean unique() default false; } ///:~ //: annotations/database/SQLString.java package annotations.database; import java.lang.annotation.*; @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface SQLString { int value() default 0; String name() default ""; Constraints constraints() default @Constraints; } ///:~ //: annotations/database/SQLInteger.java package annotations.database; import java.lang.annotation.*; @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) Annotations 767 public @interface SQLInteger { String name() default ""; Constraints constraints() default @Constraints; } ///:~ The @Constraints annotation allows processor extract metadata database table. This represents small subset constraints generally offered databases, gives general idea. The elements primaryKey( ), allowNull( ) unique( ) given sensible default values cases user annotation won’t type much. The two (@interfaces define SQL types. Again, framework useful, need define annotation additional SQL type. Here, two types enough. These types name( ) element constraints( ) element. The latter makes use nested annotation feature embed information column type’s database constraints. Note default value contraints( ) element @Constraints. Since element values specified parentheses annotation type, default value constraints( ) actually @Constraints annotation default values set. To make nested @Constraints annotation uniqueness set true default, define element like this: //: annotations/database/Uniqueness.java // Sample nested annotations package annotations.database; public @interface Uniqueness { Constraints constraints() default @Constraints(unique=true); } ///:~ Here simple bean uses annotations: //: annotations/database/Member.java package annotations.database; @DBTable(name = "MEMBER") public class Member { @SQLString(30) String firstName; @SQLString(50) String lastName; @SQLInteger Integer age; @SQLString(value = 30, constraints = @Constraints(primaryKey = true)) String handle; static int memberCount; public String getHandle() { return handle; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public String toString() { return handle; } public Integer getAge() { return age; } } ///:~ The @DBTable class annotation given value "MEMBER", used table name. The bean properties, firstName lastName, annotated @SQLStrings element values 30 50, respectively. These annotations interesting two reasons: First, use default value nested (@Constraints annotation, second, use shortcut feature. If define element annotation name value, long element type specified don’t need use name-value pair syntax; specify value parentheses. 768 Thinking Java Bruce Eckel This applied legal element types. Of course limits naming element "value" case above, allow semantically meaningful easyto-read annotation specification: @SQLString(30) The processor use value set size SQL column create. As neat default-value syntax is, quickly becomes complex. Look annotation field handle. This @SQLString annotation, also needs primary key database, element type primaryKey must set nested @Constraint annotation. This gets messy. You forced use rather long-winded namevalue pair form nested annotation, respecifying element name @interface name. But specially named element value longer element value specified, can’t use shortcut form. As see, result pretty. Alternative solutions There ways creating annotations task. You could, example, single annotation class called @TableColumn enum element defines values like STRING, INTEGER, FLOAT, etc. This eliminates need @interface SQL type, makes impossible qualify types additional elements like size, precision, probably useful. You could also use String element describe actual SQL type, e.g., "VARCHAR(30)" "INTEGER". This allow qualify types, ties mapping Java type SQL type code, good design. You don’t want recompile classes change databases; would elegant tell annotation processor using different "flavor" SQL, let take account processing annotations. A third workable solution use two annotation types together, @Constraints relevant SQL type (for example, @SQLInteger), annotate desired field. This slightly messy compiler allows many different annotations like annotation target. Note using multiple annotations, cannot use annotation twice. Annotations don’t support inheritance You cannot use extends keyword @interfaces. This pity, elegant solution would define annotation @TableColumn, suggested above, nested annotation type @SQLType. That way, could inherit SQL types, like @SQLInteger @SQLString, @SQLType. This would reduce typing neaten syntax. There doesn’t seem suggestion annotations supporting inheritance future releases, examples seem best circumstances. Implementing processor Here example annotation processor reads class file, checks database annotations generates SQL command making database: //: annotations/database/TableCreator.java // Reflection-based annotation processor. // {Args: annotations.database.Member} Annotations 769 package annotations.database; import java.lang.annotation.*; import java.lang.reflect.*; import java.util.*; public class TableCreator { public static void main(String[] args) throws Exception { if(args.length < 1) { System.out.println("arguments: annotated classes"); System.exit(0); } for(String className : args) { Class<?> cl = Class.forName(className); DBTable dbTable = cl.getAnnotation(DBTable.class); if(dbTable == null) { System.out.println( "No DBTable annotations class " + className); continue; } String tableName = dbTable.name(); // If name empty, use Class name: if(tableName.length() < 1) tableName = cl.getName().toUpperCase(); List<String> columnDefs = new ArrayList<String>(); for(Field field : cl.getDeclaredFields()) { String columnName = null; Annotation[] anns = field.getDeclaredAnnotations(); if(anns.length < 1) continue; // Not db table column if(anns[0] instanceof SQLInteger) { SQLInteger sInt = (SQLInteger) anns[0]; // Use field name name specified if(sInt.name().length() < 1) columnName = field.getName().toUpperCase(); else columnName = sInt.name(); columnDefs.add(columnName + " INT" + getConstraints(sInt.constraints())); } if(anns[0] instanceof SQLString) { SQLString sString = (SQLString) anns[0]; // Use field name name specified. if(sString.name().length() < 1) columnName = field.getName().toUpperCase(); else columnName = sString.name(); columnDefs.add(columnName + " VARCHAR(" + sString.value() + ")" + getConstraints(sString.constraints())); } StringBuilder createCommand = new StringBuilder( "CREATE TABLE " + tableName + "("); for(String columnDef : columnDefs) createCommand.append("\n " + columnDef + ","); // Remove trailing comma String tableCreate = createCommand.substring( 0, createCommand.length() - 1) + ");"; System.out.println("Table Creation SQL " + className + " :\n" + tableCreate); } } } private static String getConstraints(Constraints con) { 770 Thinking Java Bruce Eckel String constraints = ""; if(!con.allowNull()) constraints += " NOT NULL"; if(con.primaryKey()) constraints += " PRIMARY KEY"; if(con.unique()) constraints += " UNIQUE"; return constraints; } } /* Output: Table Creation SQL annotations.database.Member CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30)); Table Creation SQL annotations.database.Member CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30), LASTNAME VARCHAR(50)); Table Creation SQL annotations.database.Member CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30), LASTNAME VARCHAR(50), AGE INT); Table Creation SQL annotations.database.Member CREATE TABLE MEMBER( FIRSTNAME VARCHAR(30), LASTNAME VARCHAR(50), AGE INT, HANDLE VARCHAR(30) PRIMARY KEY); *///:~ : : : : The main( ) method cycles class names command line. Each class loaded using forName( ) checked see @DBTable annotation getAnnotation(DBTable.class). If does, table name found stored. All fields class loaded checked using getDeclaredAnnotations( ). This method returns array defined annotations particular method. The instanceof operator used determine annotations type @SQLInteger @SQLString, case relevant String fragment created name table column. Note inheritance annotation interfaces, using getDeclaredAnnotations( ) way approximate polymorphic behavior. The nested @Constraint annotation passed getConstraints( ) builds String containing SQL constraints. It worth mentioning technique shown somewhat naive way defining object/relational mapping. Having annotation type @DBTable takes table name parameter forces recompile Java code want change table name. This might desirable. There many available frameworks mapping objects relational databases, making use annotations. Exercise 1: (2) Implement SQL types database example. Project 3 Modify database example connects interacts real database using JDBC. Project: Modify database example creates conformant XML files rather writing SQL code. 3 Projects suggestions used (for example) term projects. Solutions projects included solution guide. Annotations 771 Using apt process annotations The annotation processing tool apt Sun’s first version tool aids processing annotations. Because early incarnation, tool still little primitive, features make life easier. Like javac, apt designed run Java source files rather compiled classes. By default, apt compiles source files finished processing them. This useful automatically creating new source files part build process. In fact, apt checks newly created source files annotations compiles pass. When annotation processor creates new source file, file checked annotations new round (as referred documentation) processing. The tool continue round round processing source files created. It compiles source files. Each annotation write need processor, apt tool easily group several annotation processors together. It allows specify multiple classes processed, lot easier iterate File classes yourself. You also add listeners receive notification annotation processing round complete. At time writing, apt available Ant task (see supplement http://MindView.net/Books/BetterJava), obviously run external task Ant meantime. In order compile annotation processors section must tools.jar classpath; library also contains com.sun.mirror.* interfaces. apt works using AnnotationProcessorFactory create right kind annotation processor annotation finds. When run apt, specify either factory class classpath find factories needs. If don’t this, apt embark arcane discovery process, details found Developing Annotation Processor section Sun’s documentation. When create annotation processor use apt, can’t use reflection features Java working source code, compiled classes. 4 The mirror API 5 solves problem allowing view methods, fields types uncompiled source code. Here annotation used extract public methods class turn interface: //: annotations/ExtractInterface.java // APT-based annotation processing. package annotations; import java.lang.annotation.*; @Target(ElementType.TYPE) @Retention(RetentionPolicy.SOURCE) public @interface ExtractInterface { public String value(); } ///:~ However, using non-standard -XclassesAsDecls option, may work annotations compiled classes. 4 5 772 The Java designers coyly suggest mirror find reflection. Thinking Java Bruce Eckel The RetentionPolicy SOURCE point keeping annotation class file extracted interface class. The following class provides public method become part useful interface: //: annotations/Multiplier.java // APT-based annotation processing. package annotations; @ExtractInterface("IMultiplier") public class Multiplier { public int multiply(int x, int y) { int total = 0; for(int = 0; < x; i++) total = add(total, y); return total; } private int add(int x, int y) { return x + y; } public static void main(String[] args) { Multiplier = new Multiplier(); System.out.println("11*16 = " + m.multiply(11, 16)); } } /* Output: 11*16 = 176 *///:~ The Multiplier class (which works positive integers) multiply( ) method calls private add( ) method numerous times perform multiplication. The add( ) method public, part interface. The annotation given value IMultiplier, name interface create. Now need processor extraction: //: annotations/InterfaceExtractorProcessor.java // APT-based annotation processing. // {Exec: apt -factory // annotations.InterfaceExtractorProcessorFactory // Multiplier.java -s ../annotations} package annotations; import com.sun.mirror.apt.*; import com.sun.mirror.declaration.*; import java.io.*; import java.util.*; public class InterfaceExtractorProcessor implements AnnotationProcessor { private final AnnotationProcessorEnvironment env; private ArrayList<MethodDeclaration> interfaceMethods = new ArrayList<MethodDeclaration>(); public InterfaceExtractorProcessor( AnnotationProcessorEnvironment env) { this.env = env; } public void process() { for(TypeDeclaration typeDecl : env.getSpecifiedTypeDeclarations()) { ExtractInterface annot = typeDecl.getAnnotation(ExtractInterface.class); if(annot == null) break; for(MethodDeclaration : typeDecl.getMethods()) if(m.getModifiers().contains(Modifier.PUBLIC) && !(m.getModifiers().contains(Modifier.STATIC))) interfaceMethods.add(m); if(interfaceMethods.size() > 0) { Annotations 773 try { PrintWriter writer = env.getFiler().createSourceFile(annot.value()); writer.println("package " + typeDecl.getPackage().getQualifiedName() +";"); writer.println("public interface " + annot.value() + " {"); for(MethodDeclaration : interfaceMethods) { writer.print(" public "); writer.print(m.getReturnType() + " "); writer.print(m.getSimpleName() + " ("); int = 0; for(ParameterDeclaration parm : m.getParameters()) { writer.print(parm.getType() + " " + parm.getSimpleName()); if(++i < m.getParameters().size()) writer.print(", "); } writer.println(");"); } writer.println("}"); writer.close(); } catch(IOException ioe) { throw new RuntimeException(ioe); } } } } } ///:~ The process( ) method work done. The MethodDeclaration class getModifiers( ) method used identify public methods (but ignore static ones) class processed. If found, stored ArrayList used create methods new interface definition .java file. Notice AnnotationProcessorEnvironment object passed constructor. You query object types (class definitions) apt tool processing, use get Messager object Filer object. The Messager enables report messages user, e.g., errors might occurred processing source code. The Filer kind PrintWriter create new files. The main reason use Filer object, rather plain PrintWriter, allows apt keep track new files create, check annotations compile needs to. You also see method createSourceFile( ) opens ordinary output stream correct name Java class interface. There isn’t support creating Java language constructs, generate Java source code using somewhat primitive print( ) println( ) methods. This means making sure brackets match code syntactically correct. process( ) called apt tool, needs factory provide right processor: //: annotations/InterfaceExtractorProcessorFactory.java // APT-based annotation processing. package annotations; import com.sun.mirror.apt.*; import com.sun.mirror.declaration.*; import java.util.*; public class InterfaceExtractorProcessorFactory 774 Thinking Java Bruce Eckel implements AnnotationProcessorFactory { public AnnotationProcessor getProcessorFor( Set<AnnotationTypeDeclaration> atds, AnnotationProcessorEnvironment env) { return new InterfaceExtractorProcessor(env); } public Collection<String> supportedAnnotationTypes() { return Collections.singleton("annotations.ExtractInterface"); } public Collection<String> supportedOptions() { return Collections.emptySet(); } } ///:~ There three methods AnnotationProcessorFactory interface. As see, one provides processor getProcessorFor( ), takes Set type declarations (the Java classes apt tool run against), AnnotationProcessorEnvironment object, already seen passed processor. The two methods, supportedAnnotationTypes( ) supportedOptions( ), check processors annotations found apt support options specified command prompt. The getProcessorFor( ) method particularly important don’t return full class name annotation type String collection, apt warn relevant processor exit without anything. The processor factory package annotations, directory structure above, command line embedded ‘Exec’ comment tag beginning InterfaceExtractorProcessor.java. This tells apt use factory class defined process file Multiplier.java. The -s option specifies new files must created directory annotations. The generated IMultiplier.java file, might guess looking println( ) statements processor above, looks like this: package annotations; public interface IMultiplier { public int multiply (int x, int y); } This file also compiled apt, see file IMultiplier.class directory. Exercise 2: (3) Add support division interface extractor. Using Visitor pattern apt Processing annotations become complex. The example relatively simple annotation processor interprets one annotation, still requires fair amount complexity make work. To prevent complexity scaling badly annotations processors, mirror API provides classes support Visitor design pattern. Visitor one classic design patterns book Design Patterns Gamma et al., also find detailed explanation Thinking Patterns. A Visitor traverses data structure collection objects, performing operation one. The data structure need ordered, operation perform object specific type. This decouples operations objects themselves, meaning add new operations without adding methods class definitions. Annotations 775 This makes useful processing annotations, Java class thought collection objects TypeDeclarations, FieldDeclarations, MethodDeclarations, on. When use apt tool Visitor pattern, provide Visitor class method handling type declaration visit. Thus implement appropriate behavior annotations methods, classes, fields on. Here SQL table generator again, time using factory processor makes use Visitor pattern: //: annotations/database/TableCreationProcessorFactory.java // The database example using Visitor. // {Exec: apt -factory // annotations.database.TableCreationProcessorFactory // database/Member.java -s database} package annotations.database; import com.sun.mirror.apt.*; import com.sun.mirror.declaration.*; import com.sun.mirror.util.*; import java.util.*; import static com.sun.mirror.util.DeclarationVisitors.*; public class TableCreationProcessorFactory implements AnnotationProcessorFactory { public AnnotationProcessor getProcessorFor( Set<AnnotationTypeDeclaration> atds, AnnotationProcessorEnvironment env) { return new TableCreationProcessor(env); } public Collection<String> supportedAnnotationTypes() { return Arrays.asList( "annotations.database.DBTable", "annotations.database.Constraints", "annotations.database.SQLString", "annotations.database.SQLInteger"); } public Collection<String> supportedOptions() { return Collections.emptySet(); } private static class TableCreationProcessor implements AnnotationProcessor { private final AnnotationProcessorEnvironment env; private String sql = ""; public TableCreationProcessor( AnnotationProcessorEnvironment env) { this.env = env; } public void process() { for(TypeDeclaration typeDecl : env.getSpecifiedTypeDeclarations()) { typeDecl.accept(getDeclarationScanner( new TableCreationVisitor(), NO_OP)); sql = sql.substring(0, sql.length() - 1) + ");"; System.out.println("creation SQL :\n" + sql); sql = ""; } } private class TableCreationVisitor extends SimpleDeclarationVisitor { public void visitClassDeclaration( ClassDeclaration d) { DBTable dbTable = d.getAnnotation(DBTable.class); 776 Thinking Java Bruce Eckel if(dbTable != null) { sql += "CREATE TABLE "; sql += (dbTable.name().length() < 1) ? d.getSimpleName().toUpperCase() : dbTable.name(); sql += " ("; } } public void visitFieldDeclaration( FieldDeclaration d) { String columnName = ""; if(d.getAnnotation(SQLInteger.class) != null) { SQLInteger sInt = d.getAnnotation( SQLInteger.class); // Use field name name specified if(sInt.name().length() < 1) columnName = d.getSimpleName().toUpperCase(); else columnName = sInt.name(); sql += "\n " + columnName + " INT" + getConstraints(sInt.constraints()) + ","; } if(d.getAnnotation(SQLString.class) != null) { SQLString sString = d.getAnnotation( SQLString.class); // Use field name name specified. if(sString.name().length() < 1) columnName = d.getSimpleName().toUpperCase(); else columnName = sString.name(); sql += "\n " + columnName + " VARCHAR(" + sString.value() + ")" + getConstraints(sString.constraints()) + ","; } } private String getConstraints(Constraints con) { String constraints = ""; if(!con.allowNull()) constraints += " NOT NULL"; if(con.primaryKey()) constraints += " PRIMARY KEY"; if(con.unique()) constraints += " UNIQUE"; return constraints; } } } } ///:~ The output identical previous DBTable example. The processor visitor inner classes example. Note process( ) method adds visitor class initializes SQL string. Both parameters getDeclarationScanner( ) visitors; first used declaration visited second used afterwards. This processor needs previsit visitor, NO_OP given second parameter. This static field DeclarationVisitor interface, DeclarationVisitor doesn’t anything. TableCreationVisitor extends SimpleDeclarationVisitor, overriding two methods visitClassDeclaration( ) visitFieldDeclaration( ). The Annotations 777 SimpleDeclarationVisitor adapter implements methods Declaration Visitor interface, concentrate ones need. In visitClassDeclaration( ), ClassDeclaration object checked DBTable annotation, there, first part SQL creation String initialized. In visitFieldDeclaration( ), field declaration queried field annotations information extracted much way original example, earlier chapter. This may seem like complicated way things, produces scalable solution. If complexity annotation processor increases, writing standalone processor earlier example would soon become quite complicated. Exercise 3: (2) Add support SQL types TableCreationProcessorFactory.java. Annotation-based unit testing Unit testing practice creating one tests method class, order regularly test portions class correct behavior. The popular tool used unit testing Java called JUnit; time writing, JUnit process updated JUnit version 4, order incorporate annotations. 6 One main problems preannotation versions JUnit amount "ceremony" necessary order set run JUnit tests. This reduced time, annotations move testing closer "the simplest unit testing system possibly work." With pre-annotation versions JUnit, must create separate class hold unit tests. With annotations include unit tests inside class tested, thus reduce time trouble unit testing minimum. This approach additional benefit able test private methods easily public ones. Since example test framework annotation-based, it’s called @Unit. The basic form testing, one probably use much time, needs @Test annotation indicate methods tested. One option test methods take arguments return boolean indicate success failure. You use name like test methods. Also, @Unit test methods access you’d like, including private. To use @Unit, need import net.mindview.atunit, 7 mark appropriate methods fields @Unit test tags (which you’ll learn following examples) build system run @Unit resulting class. Here’s simple example: //: annotations/AtUnitExample1.java package annotations; import net.mindview.atunit.*; import net.mindview.util.*; public class AtUnitExample1 { public String methodOne() { return "This methodOne"; } public int methodTwo() { System.out.println("This methodTwo"); return 2; I originally thoughts making "better JUnit" based design shown here. However, appears JUnit4 also includes many ideas presented here, remains easier go along that. 6 7 778 This library part book’s code package, available www.MindView.net. Thinking Java Bruce Eckel } @Test boolean methodOneTest() { return methodOne().equals("This methodOne"); } @Test boolean m2() { return methodTwo() == 2; } @Test private boolean m3() { return true; } // Shows output failure: @Test boolean failureTest() { return false; } @Test boolean anotherDisappointment() { return false; } public static void main(String[] args) throws Exception { OSExecute.command( "java net.mindview.atunit.AtUnit AtUnitExample1"); } } /* Output: annotations.AtUnitExample1 . methodOneTest . m2 This methodTwo . m3 . failureTest (failed) . anotherDisappointment (failed) (5 tests) >>> 2 FAILURES <<< annotations.AtUnitExample1: failureTest annotations.AtUnitExample1: anotherDisappointment *///:~ Classes @Unit tested must placed packages. The @Test annotation preceding methods methodOneTest( ), m2( ), m3( ), failureTest( ) anotherDisappointment( ) tells @Unit run methods unit tests. It also ensure methods take arguments return boolean void. Your responsibility write unit test determine whether test succeeds fails returns true false, respectively (for methods return boolean). If you’re familiar JUnit, you’ll also note @Unit’s informative output—you see test that’s currently run output test useful, end tells classes tests caused failures. You’re forced embed test methods inside classes, doesn’t work you. The easiest way create non-embedded tests inheritance: //: annotations/AtUnitExternalTest.java // Creating non-embedded tests. package annotations; import net.mindview.atunit.*; import net.mindview.util.*; public class AtUnitExternalTest extends AtUnitExample1 { @Test boolean _methodOne() { return methodOne().equals("This methodOne"); } @Test boolean _methodTwo() { return methodTwo() == 2; } public static void main(String[] args) throws Exception { OSExecute.command( "java net.mindview.atunit.AtUnit AtUnitExternalTest"); } } /* Output: annotations.AtUnitExternalTest . _methodOne Annotations 779 . _methodTwo This methodTwo OK (2 tests) *///:~ This example also demonstrates value flexible naming (in contrast JUnit’s requirement start tests word "test"). Here, @Test methods directly testing another method given name method starting underscore (I’m suggesting ideal style, showing possibility). You also use composition create non-embedded tests: //: annotations/AtUnitComposition.java // Creating non-embedded tests. package annotations; import net.mindview.atunit.*; import net.mindview.util.*; public class AtUnitComposition { AtUnitExample1 testObject = new AtUnitExample1(); @Test boolean _methodOne() { return testObject.methodOne().equals("This methodOne"); } @Test boolean _methodTwo() { return testObject.methodTwo() == 2; } public static void main(String[] args) throws Exception { OSExecute.command( "java net.mindview.atunit.AtUnit AtUnitComposition"); } } /* Output: annotations.AtUnitComposition . _methodOne . _methodTwo This methodTwo OK (2 tests) *///:~ A new member testObject created test, since AtUnitComposition object created test. There special "assert" methods JUnit, second form @Test method allows return void (or boolean, still want return true false case). To test success, use Java assert statements. Java assertions normally enabled -ea flag java command line, @Unit automatically enables them. To indicate failure, even use exception. One @Unit design goals require little additional syntax possible, Java’s assert exceptions necessary report errors. A failed assert exception emerges test method treated failed test, @Unit halt case—it continues tests run. Here’s example: //: annotations/AtUnitExample2.java // Assertions exceptions used @Tests. package annotations; import java.io.*; import net.mindview.atunit.*; import net.mindview.util.*; public class AtUnitExample2 { public String methodOne() { 780 Thinking Java Bruce Eckel return "This methodOne"; } public int methodTwo() { System.out.println("This methodTwo"); return 2; } @Test void assertExample() { assert methodOne().equals("This methodOne"); } @Test void assertFailureExample() { assert 1 == 2: "What surprise!"; } @Test void exceptionExample() throws IOException { new FileInputStream("nofile.txt"); // Throws } @Test boolean assertAndReturn() { // Assertion message: assert methodTwo() == 2: "methodTwo must equal 2"; return methodOne().equals("This methodOne"); } public static void main(String[] args) throws Exception { OSExecute.command( "java net.mindview.atunit.AtUnit AtUnitExample2"); } } /* Output: annotations.AtUnitExample2 . assertExample . assertFailureExample java.lang.AssertionError: What surprise! (failed) . exceptionExample java.io.FileNotFoundException: nofile.txt (The system cannot find file specified) (failed) . assertAndReturn This methodTwo (4 tests) >>> 2 FAILURES <<< annotations.AtUnitExample2: assertFailureExample annotations.AtUnitExample2: exceptionExample *///:~ Here’s example using non-embedded tests assertions, performing simple tests java.util.HashSet: //: annotations/HashSetTest.java package annotations; import java.util.*; import net.mindview.atunit.*; import net.mindview.util.*; public class HashSetTest { HashSet<String> testObject = new HashSet<String>(); @Test void initialization() { assert testObject.isEmpty(); } @Test void _contains() { testObject.add("one"); assert testObject.contains("one"); } @Test void _remove() { testObject.add("one"); testObject.remove("one"); Annotations 781 assert testObject.isEmpty(); } public static void main(String[] args) throws Exception { OSExecute.command( "java net.mindview.atunit.AtUnit HashSetTest"); } } /* Output: annotations.HashSetTest . initialization . _remove . _contains OK (3 tests) *///:~ The inheritance approach would seem simpler, absence constraints. Exercise 4: (3) Verify new testObject created test. Exercise 5: (1) Modify example use inheritance approach. Exercise 6: (1) Test LinkedList using approach shown HashSetTest.j ava. Exercise 7: (1) Modify previous exercise use inheritance approach. For unit test, @Unit creates object class test using default constructor. The test called object, object discarded prevent side effects leaking unit tests. This relies default constructor create objects. If don’t default constructor need sophisticated construction objects, create static method build object attach @TestObjectCreate annotation, like this: //: annotations/AtUnitExample3.java package annotations; import net.mindview.atunit.*; import net.mindview.util.*; public class AtUnitExample3 { private int n; public AtUnitExample3(int n) { this.n = n; } public int getN() { return n; } public String methodOne() { return "This methodOne"; } public int methodTwo() { System.out.println("This methodTwo"); return 2; } @TestObjectCreate static AtUnitExample3 create() { return new AtUnitExample3(47); } @Test boolean initialization() { return n == 47; } @Test boolean methodOneTest() { return methodOne().equals("This methodOne"); } @Test boolean m2() { return methodTwo() == 2; } public static void main(String[] args) throws Exception { OSExecute.command( "java net.mindview.atunit.AtUnit AtUnitExample3"); } } /* Output: 782 Thinking Java Bruce Eckel annotations.AtUnitExample3 . initialization . methodOneTest . m2 This methodTwo OK (3 tests) *///:~ The @TestObjectCreate method must static must return object type you’re testing—the @Unit program ensure true. Sometimes need additional fields support unit testing. The @TestProperty annotation used tag fields used unit testing (so removed deliver product client). Here’s example reads values String broken using String.split( ) method. This input used produce test objects: //: annotations/AtUnitExample4.java package annotations; import java.util.*; import net.mindview.atunit.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class AtUnitExample4 { static String theory = "All brontosauruses " + "are thin one end, much MUCH thicker " + "middle, thin far end."; private String word; private Random rand = new Random(); // Time-based seed public AtUnitExample4(String word) { this.word = word; } public String getWord() { return word; } public String scrambleWord() { List<Character> chars = new ArrayList<Character>(); for(Character c : word.toCharArray()) chars.add(c); Collections.shuffle(chars, rand); StringBuilder result = new StringBuilder(); for(char ch : chars) result.append(ch); return result.toString(); } @TestProperty static List<String> input = Arrays.asList(theory.split(" ")); @TestProperty static Iterator<String> words = input.iterator(); @TestObjectCreate static AtUnitExample4 create() { if(words.hasNext()) return new AtUnitExample4(words.next()); else return null; } @Test boolean words() { print("‘" + getWord() + "‘"); return getWord().equals("are"); } @Test boolean scramble1() { // Change specific seed get verifiable results: rand = new Random(47); print("‘" + getWord() + "‘"); String scrambled = scrambleWord(); print(scrambled); Annotations 783 return scrambled.equals("lAl"); } @Test boolean scramble2() { rand = new Random(74); print("‘" + getWord() + "‘"); String scrambled = scrambleWord(); print(scrambled); return scrambled.equals("tsaeborornussu"); } public static void main(String[] args) throws Exception { System.out.println("starting"); OSExecute.command( "java net.mindview.atunit.AtUnit AtUnitExample4"); } } /* Output: starting annotations.AtUnitExample4 . scramble1 ‘All’ lAl . scramble2 ‘brontosauruses’ tsaeborornussu . words ‘are’ OK (3 tests) *///:~ @TestProperty also used tag methods may used testing, tests themselves. Note program relies execution order tests, general good practice. If test object creation performs initialization requires later cleanup, optionally add static @TestObjectCleanup method perform cleanup finished test object. In example, @TestObjectCreate opens file create test object, file must closed test object discarded: //: annotations/AtUnitExample5.java package annotations; import java.io.*; import net.mindview.atunit.*; import net.mindview.util.*; public class AtUnitExample5 { private String text; public AtUnitExample5(String text) { this.text = text; } public String toString() { return text; } @TestProperty static PrintWriter output; @TestProperty static int counter; @TestObjectCreate static AtUnitExample5 create() { String id = Integer.toString(counter++); try { output = new PrintWriter("Test" + id + ".txt"); } catch(IOException e) { throw new RuntimeException(e); } return new AtUnitExample5(id); } @TestObjectCleanup static void cleanup(AtUnitExample5 tobj) { 784 Thinking Java Bruce Eckel System.out.println("Running cleanup"); output.close(); } @Test boolean test1() { output.print("test1"); return true; } @Test boolean test2() { output.print("test2"); return true; } @Test boolean test3() { output.print("test3"); return true; } public static void main(String[] args) throws Exception { OSExecute.command( "java net.mindview.atunit.AtUnit AtUnitExample5"); } } /* Output: annotations.AtUnitExample5 . test1 Running cleanup . test2 Running cleanup . test3 Running cleanup OK (3 tests) *///:~ You see output cleanup method automatically run test. Using @Unit generics Generics pose special problem, can’t "test generically." You must test specific type parameter set parameters. The solution simple: Inherit test class specified version generic class. Here’s simple implementation stack: //: annotations/StackL.java // A stack built linkedList. package annotations; import java.util.*; public class StackL<T> { private LinkedList<T> list = new LinkedList<T>(); public void push(T v) { list.addFirst(v); } public T top() { return list.getFirst(); } public T pop() { return list.removeFirst(); } } ///:~ To test String version, inherit test class StackL<String>: //: annotations/StackLStringTest.java // Applying @Unit generics. package annotations; import net.mindview.atunit.*; import net.mindview.util.*; Annotations 785 public class StackLStringTest extends StackL<String> { @Test void _push() { push("one"); assert top().equals("one"); push("two"); assert top().equals("two"); } @Test void _pop() { push("one"); push("two"); assert pop().equals("two"); assert pop().equals("one"); } @Test void _top() { push("A"); push("B"); assert top().equals("B"); assert top().equals("B"); } public static void main(String[] args) throws Exception { OSExecute.command( "java net.mindview.atunit.AtUnit StackLStringTest"); } } /* Output: annotations.StackLStringTest . _push . _pop . _top OK (3 tests) *///:~ The potential drawback inheritance lose ability access private methods class test. If problem, either make method question protected, add non-private @TestProperty method calls private method (the @TestProperty method stripped production code AtUnitRemover tool shown later chapter). Exercise 8: (2) Create class private method add non-private @TestProperty method described above. Call method test code. Exercise 9: (2) Write basic @Unit tests HashMap. Exercise 10: (2) Select example elsewhere book add @Unit tests. No “suites” necessary One big advantages @Unit JUnit "suites" unnecessary. In JUnit, need somehow tell unit testing tool need test, requires introduction "suites" group tests together JUnit find run tests. @Unit simply searches class files containing appropriate annotations, executes @Test methods. Much goal @Unit testing system make incredibly transparent, people begin using simply adding @Test methods, special code knowledge like required JUnit many unit testing frameworks. It’s hard enough write tests without adding new hurdles, @Unit tries make trivial. This way, you’re likely actually write tests. 786 Thinking Java Bruce Eckel Implementing @Unit First, need define annotation types. These simple tags, fields. The @Test tag defined beginning chapter, rest annotations: //: net/mindview/atunit/TestObjectCreate.java // The @Unit @TestObjectCreate tag. package net.mindview.atunit; import java.lang.annotation.*; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface TestObjectCreate {} ///:~ //: net/mindview/atunit/TestObjectCleanup.java // The @Unit @TestObjectCleanup tag. package net.mindview.atunit; import java.lang.annotation.*; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface TestObjectCleanup {} ///:~ //: net/mindview/atunit/TestProperty.java // The @Unit @TestProperty tag. package net.mindview.atunit; import java.lang.annotation.*; // Both fields methods may tagged properties: @Target({ElementType.FIELD, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface TestProperty {} ///:~ All tests RUNTIME retention @Unit system must discover tests compiled code. To implement system runs tests, use reflection extract annotations. The program uses information decide build test objects run tests them. Because annotations surprisingly small straightforward: //: net/mindview/atunit/AtUnit.java // An annotation-based unit-test framework. // {RunByHand} package net.mindview.atunit; import java.lang.reflect.*; import java.io.*; import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class AtUnit implements ProcessFiles.Strategy { static Class<?> testClass; static List<String> failedTests= new ArrayList<String>(); static long testsRun = 0; static long failures = 0; public static void main(String[] args) throws Exception { ClassLoader.getSystemClassLoader() .setDefaultAssertionStatus(true); // Enable asserts new ProcessFiles(new AtUnit(), "class").start(args); Annotations 787 if(failures == 0) print("OK (" + testsRun + " tests)"); else { print("(" + testsRun + " tests)"); print("\n>>> " + failures + " FAILURE" + (failures > 1 ? "S" : "") + " <<<"); for(String failed : failedTests) print(" " + failed); } } public void process(File cFile) { try { String cName = ClassNameFinder.thisClass( BinaryFile.read(cFile)); if(!cName.contains(".")) return; // Ignore unpackaged classes testClass = Class.forName(cName); } catch(Exception e) { throw new RuntimeException(e); } TestMethods testMethods = new TestMethods(); Method creator = null; Method cleanup = null; for(Method : testClass.getDeclaredMethods()) { testMethods.addIfTestMethod(m); if(creator == null) creator = checkForCreatorMethod(m); if(cleanup == null) cleanup = checkForCleanupMethod(m); } if(testMethods.size() > 0) { if(creator == null) try { if(!Modifier.isPublic(testClass .getDeclaredConstructor().getModifiers())) { print("Error: " + testClass + " default constructor must public"); System.exit(1); } } catch(NoSuchMethodException e) { // Synthesized default constructor; OK } print(testClass.getName()); } for(Method : testMethods) { printnb(" . " + m.getName() + " "); try { Object testObject = createTestObject(creator); boolean success = false; try { if(m.getReturnType().equals(boolean.class)) success = (Boolean)m.invoke(testObject); else { m.invoke(testObject); success = true; // If assert fails } } catch(InvocationTargetException e) { // Actual exception inside e: print(e.getCause()); } print(success ? "" : "(failed)"); testsRun++; if(!success) { 788 Thinking Java Bruce Eckel failures++; failedTests.add(testClass.getName() + ": " + m.getName()); } if(cleanup != null) cleanup.invoke(testObject, testObject); } catch(Exception e) { throw new RuntimeException(e); } } } static class TestMethods extends ArrayList<Method> { void addIfTestMethod(Method m) { if(m.getAnnotation(Test.class) == null) return; if(!(m.getReturnType().equals(boolean.class) || m.getReturnType().equals(void.class))) throw new RuntimeException("@Test method" + " must return boolean void"); m.setAccessible(true); // In case it’s private, etc. add(m); } } private static Method checkForCreatorMethod(Method m) { if(m.getAnnotation(TestObjectCreate.class) == null) return null; if(!m.getReturnType().equals(testClass)) throw new RuntimeException("@TestObjectCreate " + "must return instance Class tested"); if((m.getModifiers() & java.lang.reflect.Modifier.STATIC) < 1) throw new RuntimeException("@TestObjectCreate " + "must static."); m.setAccessible(true); return m; } private static Method checkForCleanupMethod(Method m) { if(m.getAnnotation(TestObjectCleanup.class) == null) return null; if(!m.getReturnType().equals(void.class)) throw new RuntimeException("@TestObjectCleanup " + "must return void"); if((m.getModifiers() & java.lang.reflect.Modifier.STATIC) < 1) throw new RuntimeException("@TestObjectCleanup " + "must static."); if(m.getParameterTypes().length == 0 || m.getParameterTypes()[0] != testClass) throw new RuntimeException("@TestObjectCleanup " + "must take argument tested type."); m.setAccessible(true); return m; } private static Object createTestObject(Method creator) { if(creator != null) { try { return creator.invoke(testClass); } catch(Exception e) { throw new RuntimeException("Couldn’t run " + "@TestObject (creator) method."); } } else { // Use default constructor: try { Annotations 789 return testClass.newInstance(); } catch(Exception e) { throw new RuntimeException("Couldn’t create " + "test object. Try using @TestObject method."); } } } } ///:~ AtUnit.java uses ProcessFiles tool net.mindview.util. The AtUnit class implements ProcessFiles.Strategy, comprises method process( ). This way, instance AtUnit passed ProcessFiles constructor. The second constructor argument tells ProcessFiles look files "class" extensions. If provide command-line argument, program traverse current directory tree. You may also provide multiple arguments either class files (with without .class extension) directories. Since @Unit automatically find testable classes methods, "suite" mechanism necessary. 8 One problems AtUnit.java must solve discovers class files actual qualified class name (including package) evident class file name. In order discover information, class file must analyzed, trivial, impossible, either. 9 So first thing happens .class file found opened binary data read handed ClassNameFinder.thisClass( ). Here, moving realm "bytecode engineering," actually analyzing contents class file: //: net/mindview/atunit/ClassNameFinder.java package net.mindview.atunit; import java.io.*; import java.util.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class ClassNameFinder { public static String thisClass(byte[] classBytes) { Map<Integer,Integer> offsetTable = new HashMap<Integer,Integer>(); Map<Integer,String> classNameTable = new HashMap<Integer,String>(); try { DataInputStream data = new DataInputStream( new ByteArrayInputStream(classBytes)); int magic = data.readInt(); // 0xcafebabe int minorVersion = data.readShort(); int majorVersion = data.readShort(); int constant_pool_count = data.readShort(); int[] constant_pool = new int[constant_pool_count]; for(int = 1; < constant_pool_count; i++) { int tag = data.read(); int tableSize; switch(tag) { case 1: // UTF int length = data.readShort(); char[] bytes = new char[length]; for(int k = 0; k < bytes.length; k++) bytes[k] = (char)data.read(); 8 It clear default constructor class test must public, isn’t, call newlnstance( ) hangs (doesn’t throw exception). 9 790 Jeremy Meyer I spent day figuring out. Thinking Java Bruce Eckel String className = new String(bytes); classNameTable.put(i, className); break; case 5: // LONG case 6: // DOUBLE data.readLong(); // discard 8 bytes i++; // Special skip necessary break; case 7: // CLASS int offset = data.readShort(); offsetTable.put(i, offset); break; case 8: // STRING data.readShort(); // discard 2 bytes break; case 3: // INTEGER case 4: // FLOAT case 9: // FIELD_REF case 10: // METHOD_REF case 11: // INTERFACE_METHOD_REF case 12: // NAME_AND_TYPE data.readInt(); // discard 4 bytes; break; default: throw new RuntimeException("Bad tag " + tag); } } short access_flags = data.readShort(); int this_class = data.readShort(); int super_class = data.readShort(); return classNameTable.get( offsetTable.get(this_class)).replace(‘/’, ‘.’); } catch(Exception e) { throw new RuntimeException(e); } } // Demonstration: public static void main(String[] args) throws Exception { if(args.length > 0) { for(String arg : args) print(thisClass(BinaryFile.read(new File(arg)))); } else // Walk entire tree: for(File klass : Directory.walk(".", ".*\\.class")) print(thisClass(BinaryFile.read(klass))); } } ///:~ Although it’s possible go full detail here, class file follows particular format I’ve tried use meaningful field names pieces data picked ByteArraylnputStream; also see size piece length read performed input stream. For example, first 32 bits class file always "magic number" hex 0xcafebabe, 10 next two shorts version information. The constant pool contains constants program variable size; next short tells big is, appropriate-sized array allocated. Each entry constant pool may fixed-size variablesized value, must examine tag begins one find it—that’s switch statement. Here, trying accurately analyze data class file, merely step store pieces interest, you’ll notice fair amount data discarded. Information Various legends surround meaning this, since Java created nerds make reasonable guess something fantasizing woman coffee shop. 10 Annotations 791 classes stored classNameTable offsetTable. After constant pool read, this_class information found, index offsetTable, produces index classNameTable, produces class name. Back AtUnit.java, process( ) class name look see contains ‘.’, means it’s package. Unpackaged classes ignored. If class package, standard class loader used load class Class.forName( ). Now class analyzed @Unit annotations. We need look three things: @Test methods, stored TestMethods list, whether there’s @TestObjectCreate @TestObjectCleanup method. These discovered associated method calls see code, look annotations. If @Test methods found, name class printed viewer see what’s happening, test executed. This means printing method name, calling createTestObject( ), use @TestObjectCreate method one exists, fall back default constructor otherwise. Once test object created, test method invoked upon object. If test returns boolean, result captured. If not, assume success exception (which would happen case failed assert kind exception). If exception thrown, exception information printed show cause. If failure occurs, failure count increased class name method added failedTests reported end run. Exercise 11: (5) Add @TestNote annotation @Unit, accompanying note simply displayed testing. Removing test code Although many projects won’t make difference leave test code deliverable (especially make test methods private, like), cases want strip test code either keep deliverable small exposed client. This requires sophisticated bytecode engineering comfortable hand. However, open-source Javassist library 11 brings bytecode engineering realm possible. The following program takes optional -r flag first argument; provide flag remove @Test annotations, simply display @Test annotations. ProcessFiles also used traverse files directories choosing: //: net/mindview/atunit/AtUnitRemover.java // Displays @Unit annotations compiled class files. If // first argument "-r", @Unit annotations removed. // {Args: ..} // {Requires: javassist.bytecode.ClassFile; // You must install Javassist library // http://sourceforge.net/projects/jboss/ } package net.mindview.atunit; import javassist.*; import javassist.expr.*; import javassist.bytecode.*; import javassist.bytecode.annotation.*; 11 792 Thanks Dr. Shigeru Chiba creating library, help developing AtUnitRemover.java. Thinking Java Bruce Eckel import import import import java.io.*; java.util.*; net.mindview.util.*; static net.mindview.util.Print.*; public class AtUnitRemover implements ProcessFiles.Strategy { private static boolean remove = false; public static void main(String[] args) throws Exception { if(args.length > 0 && args[0].equals("-r")) { remove = true; String[] nargs = new String[args.length - 1]; System.arraycopy(args, 1, nargs, 0, nargs.length); args = nargs; } new ProcessFiles( new AtUnitRemover(), "class").start(args); } public void process(File cFile) { boolean modified = false; try { String cName = ClassNameFinder.thisClass( BinaryFile.read(cFile)); if(!cName.contains(".")) return; // Ignore unpackaged classes ClassPool cPool = ClassPool.getDefault(); CtClass ctClass = cPool.get(cName); for(CtMethod method : ctClass.getDeclaredMethods()) { MethodInfo mi = method.getMethodInfo(); AnnotationsAttribute attr = (AnnotationsAttribute) mi.getAttribute(AnnotationsAttribute.visibleTag); if(attr == null) continue; for(Annotation ann : attr.getAnnotations()) { if(ann.getTypeName() .startsWith("net.mindview.atunit")) { print(ctClass.getName() + " Method: " + mi.getName() + " " + ann); if(remove) { ctClass.removeMethod(method); modified = true; } } } } // Fields removed version (see text). if(modified) ctClass.toBytecode(new DataOutputStream( new FileOutputStream(cFile))); ctClass.detach(); } catch(Exception e) { throw new RuntimeException(e); } } } ///:~ The ClassPool kind picture classes system modifying. It guarantees consistency modified classes. You must get CtClass ClassPool, similar way class loader Class.forName( ) load classes JVM. The CtClass contains bytecodes class object allows produce information class manipulate code class. Here, call Annotations 793 getDeclaredMethods( ) (just like Java’s reflection mechanism) get MethodInfo object CtMethod object. From this, look annotations. If method annotation net.mindview.atunit package, method removed. If class modified, original class file overwritten new class. At time writing, "remove" functionality Javassist recently added, 12 discovered removing @TestProperty fields turns complex removing methods. Because may static initialization operations refer fields, cannot simply remove them. So version code removes @Unit methods. However, check Javassist Web site updates; field removal eventually possible. In meantime, note external testing method shown AtUnitExternalTest.java allows tests removed simply deleting class file created test code. 12 794 Dr. Shigeru Chiba nicely added CtClass.removeMethod( ) request. Thinking Java Bruce Eckel Summary Annotations welcome addition Java. They structured typechecked means adding metadata code without rendering unreadable messy. They help remove tedium writing deployment descriptors generated files. The fact @deprecated Javadoc tag superseded @Deprecated annotation one indication much better suited annotations describing information classes comments. Only small handful annotations come Java SE5. This means that, can’t find library elsewhere, creating annotations associated logic this. With apt tool, compile newly generated files one step, easing build process, currently little mirror API basic functionality help identify elements Java class definitions. As you’ve seen, Javassist used bytecode engineering, hand-code bytecode manipulation tools. This situation certainly improve, providers APIs frameworks start providing annotations part toolkits. As imagine seeing @Unit system, likely annotations cause significant changes Java programming experience. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Annotations 795 Concurrency Up point, you’ve learning sequential programming. Everything program happens one step time. A large subset programming problems solved using sequential programming. For problems, however, becomes convenient even essential execute several parts program parallel, portions either appear executing concurrently, multiple processors available, actually execute simultaneously. Parallel programming produce great improvements program execution speed, provide easier model designing certain types programs, both. However, becoming adept concurrent programming theory techniques step everything you’ve learned far book, intermediate advanced topic. This chapter serve introduction, means consider good concurrent programmer even understand chapter thoroughly. As shall see, real problem concurrency occurs tasks executing parallel begin interfere other. This happen subtle occasional manner it’s probably fair say concurrency "arguably deterministic effectively nondeterministic." That is, make argument conclude it’s possible write concurrent programs that, care code inspection, work correctly. In practice, however, it’s much easier write concurrent programs appear work, given right conditions, fail. These conditions may never actually occur, occur infrequently never see testing. In fact, may able write test code generate failure conditions concurrent program. The resulting failures often occur occasionally, result appear form customer complaints. This one strongest arguments studying concurrency: If ignore it, you’re likely get bitten. Concurrency thus seems fraught peril, makes bit fearful, probably good thing. Although Java SE5 made significant improvements concurrency, still safety nets like compile-time verification checked exceptions tell make mistake. With concurrency, you’re own, suspicious aggressive write multithreaded code Java reliable. People sometimes suggest concurrency advanced include book introduces language. They argue concurrency discrete topic treated independently, cases appears daily programming (such graphical user interfaces) handled special idioms. Why introduce complex topic avoid it? Alas, so. Unfortunately, don’t get choose threads appear Java programs. Just never start thread doesn’t mean you’ll able avoid writing threaded code. For example, Web systems one common Java applications, basic Web library class, servlet, inherently multithreaded— essential Web servers often contain multiple processors, concurrency ideal way utilize processors. As simple servlet might seem, must understand concurrency issues order use servlets properly. The goes graphical user interface programming, shall see Graphical User Interfaces chapter. Although Swing SWT libraries mechanisms thread safety, it’s hard know use properly without understanding concurrency. Java multithreaded language, concurrency issues present whether aware not. As result, many Java programs use either work accident, work time mysteriously break every undiscovered concurrency flaws. Sometimes breakage benign, sometimes means loss valuable data, aren’t least aware concurrency issues, may end assuming problem somewhere else rather software. These kinds issues also exposed amplified program moved multiprocessor system. Basically, knowing concurrency makes aware apparently correct programs exhibit incorrect behavior. Concurrent programming like stepping new world learning new language, least new set language concepts. Understanding concurrent programming order difficulty understanding object-oriented programming. If apply effort, fathom basic mechanism, generally takes deep study understanding develop true grasp subject. The goal chapter give solid foundation basics concurrency understand concepts write reasonable multithreaded programs. Be aware easily become overconfident. If writing anything complex, need study dedicated books topic. The many faces concurrency A primary reason concurrent programming confusing one problem solve using concurrency, one approach implementing concurrency, clean mapping two issues (and often blurring lines around). As result, you’re forced understand issues special cases order use concurrency effectively. The problems solve concurrency roughly classified "speed" "design manageability." Faster execution The speed issue sounds simple first: If want program run faster, break pieces run piece separate processor. Concurrency fundamental tool multiprocessor programming. Now, Moore’s Law running steam (at least conventional chips), speed improvements appearing form multicore processors rather faster chips. To make programs run faster, you’ll learn take advantage extra processors, that’s one thing concurrency gives you. If multiprocessor machine, multiple tasks distributed across processors, dramatically improve throughput. This often case powerful multiprocessor Web servers, distribute large numbers user requests across CPUs program allocates one thread per request. However, concurrency often improve performance programs running single processor. This sound bit counterintuitive. If think it, concurrent program running single processor actually overhead parts program ran sequentially, added cost so-called context switch (changing one task another). On surface, would appear cheaper run parts program single task save cost context switching. The issue make difference blocking. If one task program unable continue condition outside control program (typically I/O), 798 Thinking Java Bruce Eckel say task thread blocks. Without concurrency, whole program comes stop external condition changes. If program written using concurrency, however, tasks program continue execute one task blocked, program continues move forward. In fact, performance standpoint, makes sense use concurrency single-processor machine unless one tasks might block. A common example performance improvements single-processor systems eventdriven programming. Indeed, one compelling reasons using concurrency produce responsive user interface. Consider program performs long-running operation thus ends ignoring user input unresponsive. If "quit" button, don’t want forced poll every piece code write. This produces awkward code, without guarantee programmer won’t forget perform check. Without concurrency, way produce responsive user interface tasks periodically check user input. By creating separate thread execution respond user input, even though thread blocked time, program guarantees certain level responsiveness. The program needs continue performing operations, time needs return control user interface program respond user. But conventional method cannot continue performing operations time return control rest program. In fact, sounds like impossibility, CPU must two places once, precisely illusion concurrency provides (in case multiprocessor systems, illusion). One straightforward way implement concurrency operating system level, using processes. A process self-contained program running within address space. A multitasking operating system run one process (program) time periodically switching CPU one process another, making look process chugging along own. Processes attractive operating system usually isolates one process another cannot interfere other, makes programming processes relatively easy. In contrast, concurrent systems like one used Java share resources like memory I/O, fundamental difficulty writing multithreaded programs coordinating use resources different thread-driven tasks, cannot accessed one task time. Here’s simple example utilizes operating system processes. While writing book, I regularly make multiple redundant backup copies current state book. I make copy local directory, one onto memory stick, one onto Zip disk, one onto remote FTP site. To automate process, I wrote small program (in Python, concepts same) zips book file version number name performs copies. Initially, I performed copies sequentially, waiting one complete starting next one. But I realized copy operation took different amount time depending I/O speed medium. Since I using multitasking operating system, I could start copy operation separate process let run parallel, speeds execution entire program. While one process blocked, another one moving forward. This ideal example concurrency. Each task executes process address space, there’s possibility interference tasks. More importantly, there’s need tasks communicate they’re completely independent. The operating system minds details ensuring proper file copying. As result, there’s risk get faster program, effectively free. Concurrency 799 Some people go far advocate processes reasonable approach concurrency, 1 unfortunately generally quantity overhead limitations processes prevent applicability across concurrency spectrum. Some programming languages designed isolate concurrent tasks other. These generally called/imcft’onaZ languages, function call produces side effects (and cannot interfere functions) thus driven independent task. Erlang one language, includes safe mechanisms one task communicate another. If find portion program must make heavy use concurrency running excessive problems trying build portion, may want consider creating part program dedicated concurrency language like Erlang. Java took traditional approach adding support threading top sequential language. 2 Instead forking external processes multitasking operating system, threading creates tasks within single process represented executing program. One advantage provided operating system transparency, important design goal Java. For example, pre-OSX versions Macintosh operating system (a reasonably important target first versions Java) support multitasking. Unless multithreading added Java, concurrent Java programs wouldn’t portable Macintosh similar platforms, thus breaking "write once/run everywhere" requirement. 3 Improving code design A program uses multiple tasks single-CPU machine still one thing time, must theoretically possible write program without using tasks. However, concurrency provides important organizational benefit: The design program greatly simplified. Some types problems, simulation, difficult solve without support concurrency. Most people seen least one form simulation, either computer game computer-generated animations within movies. Simulations generally involve many interacting elements, "a mind own." Although may observe that, single-processor machine, simulation element driven forward one processor, programming standpoint it’s much easier pretend simulation element processor independent task. A full-fledged simulation may involve large number tasks, corresponding fact element simulation act independently—this includes doors rocks, elves wizards. Multithreaded systems often relatively small size limit number threads available, sometimes order tens hundreds. This number may vary outside control program—it may depend platform, case Java, version JVM. In Java, generally assume enough threads available provide one element large simulation. A typical approach solving problem use cooperative multithreading. Java’s threading preemptive, means scheduling mechanism provides time slices thread, periodically interrupting thread context switching another thread one given reasonable amount time drive task. In cooperative system, 1 Eric Raymond, example, makes strong case The Art UNIX Programming (Addison-Wesley, 2004). It could argued trying bolt concurrency onto sequential language doomed approach, you’ll draw conclusions. 2 3 This requirement never completely fulfilled longer loudly touted Sun. Ironically, one reason "write once/run everywhere" didn’t completely work may resulted problems threading system—which might actually fixed Java SE5. 800 Thinking Java Bruce Eckel task voluntarily gives control, requires programmer consciously insert kind yielding statement task. The advantage cooperative system twofold: Context switching typically much cheaper preemptive system, theoretically limit number independent tasks running once. When dealing large number simulation elements, ideal solution. Note, however, cooperative systems designed distribute tasks across processors, limiting. At extreme, concurrency useful model—because it’s actually happening—when working modern messaging systems, involve many independent computers distributed across network. In case, processes running completely independently other, there’s even opportunity share resources. However, must still synchronize information transfer processes entire messaging system doesn’t lose information incorporate information incorrect times. Even don’t plan use concurrency much immediate future, it’s helpful understand grasp messaging architectures, becoming predominant ways create distributed systems. Concurrency imposes costs, including complexity costs, usually outweighed improvements program design, resource balancing, user convenience. In general, threads enable create loosely coupled design; otherwise, parts code would forced pay explicit attention tasks would normally handled threads. Basic threading Concurrent programming allows partition program separate, independently running tasks. Using multithreading, independent tasks (also called subtasks) driven thread execution. A thread single sequential flow control within process. A single process thus multiple concurrently executing tasks, program task CPU itself. An underlying mechanism divides CPU time you, general, don’t need think it. The threading model programming convenience simplify juggling several operations time within single program: The CPU pop around give task time. 4 Each task consciousness constantly CPU itself, CPU’s time sliced among tasks (except program actually running multiple CPUs). One great things threading abstracted away layer, code need know whether running single CPU many. Thus, using threads way create transparently scalable programs—if program running slowly, easily speed adding CPUs computer. Multitasking multithreading tend reasonable ways utilize multiprocessor systems. Defining tasks A thread drives task, need way describe task. This provided Runnable interface. To define task, simply implement Runnable write run( ) method make task bidding. For example, following LiftOff task displays countdown liftoff: //: concurrency/LiftOff.java 4 This true system uses time slicing (Windows, example). Solaris uses FIFO concurrency model: Unless higher-priority thread awakened, current thread runs blocks terminates. That means threads priority don’t run current one gives processor. Concurrency 801 // Demonstration Runnable interface. public class LiftOff implements Runnable { protected int countDown = 10; // Default private static int taskCount = 0; private final int id = taskCount++; public LiftOff() {} public LiftOff(int countDown) { this.countDown = countDown; } public String status() { return "#" + id + "(" + (countDown > 0 ? countDown : "Liftoff!") + "), "; } public void run() { while(countDown-- > 0) { System.out.print(status()); Thread.yield(); } } } ///:~ The identifier id distinguishes multiple instances task. It final expected change initialized. A task’s run( ) method usually kind loop continues task longer necessary, must establish condition break loop (one option simply return run( )). Often, run( ) cast form infinite loop, means that, barring factor causes run( ) terminate, continue forever (later chapter you’ll see safely terminate tasks). The call static method Thread.yield( ) inside run( ) suggestion thread scheduler (the part Java threading mechanism moves CPU one thread next) says, "I’ve done important parts cycle would good time switch another task while." It’s completely optional, used tends produce interesting output examples: You’re likely see evidence tasks swapped out. In following example, task’s run( ) driven separate thread; simply called directly main( ) (actually, using thread: one always allocated main( )): //: concurrency/MainThread.java public class MainThread { public static void main(String[] args) { LiftOff launch = new LiftOff(); launch.run(); } } /* Output: #0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!), *///:~ When class derived Runnable, must run( ) method, that’s nothing special—it doesn’t produce innate threading abilities. To achieve threading behavior, must explicitly attach task thread. The Thread class 802 Thinking Java Bruce Eckel The traditional way turn Runnable object working task hand Thread constructor. This example shows drive Liftoff object using Thread: //: concurrency/BasicThreads.java // The basic use Thread class. public class BasicThreads { public static void main(String[] args) { Thread = new Thread(new LiftOff()); t.start(); System.out.println("Waiting LiftOff"); } } /* Output: (90% match) Waiting LiftOff #0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!), *///:~ A Thread constructor needs Runnable object. Calling Thread object’s start( ) perform necessary initialization thread call Runnable’s run( ) method start task new thread. Even though start( ) appears making call long-running method, see output—the "Waiting LiftOff’ message appears countdown completed—that start( ) quickly returns. In effect, made method call LiftOff.run( ), method yet finished, LiftOff.run( ) executed different thread, still perform operations main( ) thread. (This ability restricted main( ) thread—any thread start another thread.) Thus, program running two methods once— main( ) LiftOff.run( ). run( ) code executed "simultaneously" threads program. You easily add threads drive tasks. Here, see tasks run concert one another: 5 //: concurrency/MoreBasicThreads.java // Adding threads. public class MoreBasicThreads { public static void main(String[] args) { for(int = 0; < 5; i++) new Thread(new LiftOff()).start(); System.out.println("Waiting LiftOff"); } } /* Output: (Sample) Waiting LiftOff #0(9), #1(9), #2(9), #3(9), #4(9), #0(8), #1(8), #0(7), #1(7), #2(7), #3(7), #4(7), #0(6), #1(6), #0(5), #1(5), #2(5), #3(5), #4(5), #0(4), #1(4), #0(3), #1(3), #2(3), #3(3), #4(3), #0(2), #1(2), #0(1), #1(1), #2(1), #3(1), #4(1), #0(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!), *///:~ #2(8), #3(8), #2(6), #3(6), #2(4), #3(4), #2(2), #3(2), #1(Liftoff!), #4(8), #4(6), #4(4), #4(2), The output shows execution different tasks mixed together threads swapped out. This swapping automatically controlled thread scheduler. If 5 In case, single thread (main( )), creating LiftOff threads. If multiple threads creating LiftOff threads, however, possible one LiftOff id. You’ll learn later chapter. Concurrency 803 multiple processors machine, thread scheduler quietly distribute threads among processors. 6 The output one run program different another, thread-scheduling mechanism deterministic. In fact, may see dramatic differences output simple program one version JDK next. For example, earlier JDK didn’t timeslice often, thread l might loop extinction first, thread 2 would go loops, etc. This virtually calling routine would loops once, except starting threads expensive. Later JDKs seem produce better time-slicing behavior, thread seems get regular service. Generally, kinds JDK behavioral changes mentioned Sun, cannot plan consistent threading behavior. The best approach conservative possible writing threaded code. When main( ) creates Thread objects, isn’t capturing references them. With ordinary object, would make fair game garbage collection, Thread. Each Thread "registers" actually reference someplace, garbage collector can’t clean task exits run( ) dies. You see output tasks indeed running conclusion, thread creates separate thread execution persists call start( ) completes. Exercise 1: (2) Implement Runnable. Inside run( ), print message, call yield( ). Repeat three times, return run( ). Put startup message constructor shutdown message task terminates. Create number tasks drive using threads. Exercise 2: (2) Following form generics/Fibonacci.java, create task produces sequence n Fibonacci numbers, n provided constructor task. Create number tasks drive using threads. Using Executors Java SE5 java.util.concurrent Executors simplify concurrent programming managing Thread objects you. Executors provide layer indirection client execution task; instead client executing task directly, intermediate object executes task. Executors allow manage execution asynchronous tasks without explicitly manage lifecycle threads. Executors preferred method starting tasks Java SE5/6. We use Executor instead explicitly creating Thread objects MoreBasicThreads.java. A LiftOff object knows run specific task; like Command design pattern, exposes single method executed. An ExecutorService (an Executor service lifecycle—e.g., shutdown) knows build appropriate context execute Runnable objects. In following example, CachedThreadPool creates one thread per task. Note ExecutorService object created using static Executors method determines kind Executor be: //: concurrency/CachedThreadPool.java import java.util.concurrent.*; public class CachedThreadPool { public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < 5; i++) exec.execute(new LiftOff()); 6 804 This true earliest versions Java. Thinking Java Bruce Eckel exec.shutdown(); } } /* Output: (Sample) #0(9), #0(8), #1(9), #2(9), #4(8), #0(6), #1(7), #2(7), #4(6), #0(4), #1(5), #2(5), #4(4), #0(2), #1(3), #2(3), #4(2), #0(Liftoff!), #1(1), #2(Liftoff!), #3(Liftoff!), *///:~ #3(9), #4(9), #3(7), #4(7), #3(5), #4(5), #3(3), #4(3), #2(1), #3(1), #4(Liftoff!), #0(7), #0(5), #0(3), #0(1), #4(1), #1(8), #2(8), #1(6), #2(6), #1(4), #2(4), #1(2), #2(2), #1(Liftoff!), #3(8), #3(6), #3(4), #3(2), Very often, single Executor used create manage tasks system. The call shutdown( ) prevents new tasks submitted Executor. The current thread (in case, one driving main( )) continue run tasks submitted shutdown( ) called. The program exit soon tasks Executor finish. You easily replace CachedThreadPool previous example different type Executor. A FixedThreadPool uses limited set threads execute submitted tasks: //: concurrency/FixedThreadPool.java import java.util.concurrent.*; public class FixedThreadPool { public static void main(String[] args) { // Constructor argument number threads: ExecutorService exec = Executors.newFixedThreadPool(5); for(int = 0; < 5; i++) exec.execute(new LiftOff()); exec.shutdown(); } } /* Output: (Sample) #0(9), #0(8), #1(9), #2(9), #3(9), #4(9), #0(7), #1(8), #2(8), #4(8), #0(6), #1(7), #2(7), #3(7), #4(7), #0(5), #1(6), #2(6), #4(6), #0(4), #1(5), #2(5), #3(5), #4(5), #0(3), #1(4), #2(4), #4(4), #0(2), #1(3), #2(3), #3(3), #4(3), #0(1), #1(2), #2(2), #4(2), #0(Liftoff!), #1(1), #2(1), #3(1), #4(1), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!), *///:~ #3(8), #3(6), #3(4), #3(2), With FixedThreadPool, expensive thread allocation once, front, thus limit number threads. This saves time aren’t constantly paying thread creation overhead every single task. Also, event-driven system, event handlers require threads serviced quickly want simply fetching threads pool. You don’t overrun available resources FixedThreadPool uses bounded number Thread objects. Note thread pools, existing threads automatically reused possible. Although book use CachedThreadPools, consider using FixedThreadPools production code. A CachedThreadPool generally create many threads needs execution program stop creating new threads recycles old ones, it’s reasonable first choice Executor. Only approach causes problems need switch FixedThreadPool. Concurrency 805 A SingleThreadExecutor like FixedThreadPool size one thread. 7 This useful anything want run another thread continually (a long-lived task), task listens incoming socket connections. It also handy short tasks want run thread— example, small tasks update local remote log, eventdispatching thread. If one task submitted SingleThreadExecutor, tasks queued task run completion next task begun, using thread. In following example, you’ll see task completed, order submitted, next one begun. Thus, SingleThreadExecutor serializes tasks submitted it, maintains (hidden) queue pending tasks. //: concurrency/SingleThreadExecutor.java import java.util.concurrent.*; public class SingleThreadExecutor { public static void main(String[] args) { ExecutorService exec = Executors.newSingleThreadExecutor(); for(int = 0; < 5; i++) exec.execute(new LiftOff()); exec.shutdown(); } } /* Output: #0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(Liftoff!), #1(9), #1(8), #1(7), #1(6), #1(5), #1(1), #1(Liftoff!), #2(9), #2(8), #2(7), #2(6), #2(2), #2(1), #2(Liftoff!), #3(9), #3(8), #3(7), #3(3), #3(2), #3(1), #3(Liftoff!), #4(9), #4(8), #4(4), #4(3), #4(2), #4(1), #4(Liftoff!), *///:~ #0(2), #1(4), #2(5), #3(6), #4(7), #0(1), #1(3), #2(4), #3(5), #4(6), #1(2), #2(3), #3(4), #4(5), As another example, suppose number threads running tasks use file system. You run tasks SingleThreadExecutor ensure one task time running thread. This way, don’t need deal synchronizing shared resource (and won’t clobber file system meantime). Sometimes better solution synchronize resource (which you’ll learn later chapter), SingleThreadExecutor lets skip trouble getting coordinated properly prototype something. By serializing tasks, eliminate need serialize objects. Exercise 3: (1) Repeat Exercise 1 using different types executors shown section. Exercise 4: (1) Repeat Exercise 2 using different types executors shown section. Producing return values tasks A Runnable separate task performs work, doesn’t return value. If want task produce value it’s done, implement Callable interface rather Runnable interface. Callable, introduced Java SE5, generic type parameter representing return value method call( ) (instead run( )), must invoked using ExecutorService submit( ) method. Here’s simple example: 7 It also offers important concurrency guarantee others not—no two tasks called concurrently. This changes locking requirements tasks (you’ll learn locking later chapter). 806 Thinking Java Bruce Eckel //: concurrency/CallableDemo.java import java.util.concurrent.*; import java.util.*; class TaskWithResult implements Callable<String> { private int id; public TaskWithResult(int id) { this.id = id; } public String call() { return "result TaskWithResult " + id; } } public class CallableDemo { public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); ArrayList<Future<String>> results = new ArrayList<Future<String>>(); for(int = 0; < 10; i++) results.add(exec.submit(new TaskWithResult(i))); for(Future<String> fs : results) try { // get() blocks completion: System.out.println(fs.get()); } catch(InterruptedException e) { System.out.println(e); return; } catch(ExecutionException e) { System.out.println(e); } finally { exec.shutdown(); } } } /* Output: result TaskWithResult 0 result TaskWithResult 1 result TaskWithResult 2 result TaskWithResult 3 result TaskWithResult 4 result TaskWithResult 5 result TaskWithResult 6 result TaskWithResult 7 result TaskWithResult 8 result TaskWithResult 9 *///:~ The submit( ) method produces Future object, parameterized particular type result returned Callable. You query Future isDone( ) see completed. When task completed result, call get( ) fetch result. You simply call get( ) without checking isDone( ), case get( ) block result ready. You also call get( ) timeout, isDone( ) see task completed, trying call get( ) fetch result. The overloaded Executors.callable( ) method takes Runnable produces Callable. ExecutorService "invoke" methods run collections Callable objects. Exercise 5: (2) Modify Exercise 2 task Callable sums values Fibonacci numbers. Create several tasks display results. Concurrency 807 Sleeping A simple way affect behavior tasks calling sleep( ) cease (block) execution task given time. In LiftOff class, replace call yield( ) call sleep( ), get following: //: concurrency/SleepingTask.java // Calling sleep() pause while. import java.util.concurrent.*; public class SleepingTask extends LiftOff { public void run() { try { while(countDown-- > 0) { System.out.print(status()); // Old-style: // Thread.sleep(100); // Java SE5/6-style: TimeUnit.MILLISECONDS.sleep(100); } } catch(InterruptedException e) { System.err.println("Interrupted"); } } public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < 5; i++) exec.execute(new SleepingTask()); exec.shutdown(); } } /* Output: #0(9), #1(9), #2(9), #3(9), #4(9), #0(8), #1(8), #2(8), #3(8), #0(7), #1(7), #2(7), #3(7), #4(7), #0(6), #1(6), #2(6), #3(6), #0(5), #1(5), #2(5), #3(5), #4(5), #0(4), #1(4), #2(4), #3(4), #0(3), #1(3), #2(3), #3(3), #4(3), #0(2), #1(2), #2(2), #3(2), #0(1), #1(1), #2(1), #3(1), #4(1), #0(Liftoff!), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!), *///:~ #4(8), #4(6), #4(4), #4(2), The call sleep( ) throw InterruptedException, see caught run( ). Because exceptions won’t propagate across threads back main( ), must locally handle exceptions arise within task. Java SE5 introduced explicit version sleep( ) part TimeUnit class, shown example. This provides better readability allowing specify units sleep( ) delay. TimeUnit also used perform conversions, shall see later chapter. Depending platform, may notice tasks run "perfectly distributed" order—zero four, back zero again. This makes sense because, print statement, task goes sleep (it blocks), allows thread scheduler switch another thread, driving another task. However, sequential behavior relies underlying threading mechanism, different one operating system another, cannot rely it. If must control order execution tasks, best bet use synchronization controls (described later) or, cases, use threads all, instead write cooperative routines hand control specified order. 808 Thinking Java Bruce Eckel Exercise 6: (2) Create task sleeps random amount time 1 10 seconds, displays sleep time exits. Create run quantity (given command line) tasks. Priority The priority thread conveys importance thread scheduler. Although order CPU runs set threads indeterminate, scheduler lean toward running waiting thread highest priority first. However, doesn’t mean threads lower priority aren’t run (so can’t get deadlocked priorities). Lower-priority threads tend run less often. The vast majority time, threads run default priority. Trying manipulate thread priorities usually mistake. Here’s example demonstrates priority levels. You read priority existing thread getPriority( ) change time setPriority( ). //: concurrency/SimplePriorities.java // Shows use thread priorities. import java.util.concurrent.*; public class SimplePriorities implements Runnable { private int countDown = 5; private volatile double d; // No optimization private int priority; public SimplePriorities(int priority) { this.priority = priority; } public String toString() { return Thread.currentThread() + ": " + countDown; } public void run() { Thread.currentThread().setPriority(priority); while(true) { // An expensive, interruptable operation: for(int = 1; < 100000; i++) { += (Math.PI + Math.E) / (double)i; if(i % 1000 == 0) Thread.yield(); } System.out.println(this); if(--countDown == 0) return; } } public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < 5; i++) exec.execute( new SimplePriorities(Thread.MIN_PRIORITY)); exec.execute( new SimplePriorities(Thread.MAX_PRIORITY)); exec.shutdown(); } } /* Output: (70% match) Thread[pool-1-thread-6,10,main]: 5 Thread[pool-1-thread-6,10,main]: 4 Thread[pool-1-thread-6,10,main]: 3 Thread[pool-1-thread-6,10,main]: 2 Thread[pool-1-thread-6,10,main]: 1 Concurrency 809 Thread[pool-1-thread-3,1,main]: Thread[pool-1-thread-2,1,main]: Thread[pool-1-thread-1,1,main]: Thread[pool-1-thread-5,1,main]: Thread[pool-1-thread-4,1,main]: ... *///:~ 5 5 5 5 5 toString( ) overridden use Thread.toString( ), prints thread name, priority level, "thread group" thread belongs to. You set thread name via constructor; it’s automatically generated pool-1-thread-1, pool-1thread-2, etc. The overridden toString( ) also shows countdown value task. Notice get reference Thread object driving task, inside task, calling Thread.currentThread( ). You see priority level last thread highest level, rest threads lowest level. Note priority set beginning run( ); setting constructor would good since Executor begun task point. Inside run( ), 100,000 repetitions rather expensive floating point calculation performed, involving double addition division. The variable volatile try ensure compiler optimizations performed. Without calculation, don’t see effect setting priority levels. (Try it: Comment loop containing double calculations.) With calculation, see thread MAX_PRIORITY given higher preference thread scheduler. (At least, behavior Windows XP machine.) Even though printing console also expensive behavior, won’t see priority levels way, console printing doesn’t get interrupted (otherwise, console display would get garbled threading), whereas math calculation interrupted. The calculation takes long enough scheduling mechanism jumps in, swaps tasks, pays attention priorities high-priority threads get preference. However, ensure context switch occurs, yield( ) statements regularly called. Although JDK 10 priority levels, doesn’t map well many operating systems. For example, Windows 7 priority levels fixed, mapping indeterminate. Sun’s Solaris 231 levels. The portable approach stick MAX_PRIORITY, NORM_PRIORITY, MIN_PRIORITY you’re adjusting priority levels. Yielding If know you’ve accomplished need one pass loop run( ) method, give hint threadscheduling mechanism you’ve done enough task might well CPU. This hint (and hint—there’s guarantee implementation listen it) takes form yield( ) method. When call yield( ), suggesting threads priority might run. LiftOff.java uses yield( ) produce well-distributed processing across various LiftOff tasks. Try commenting call Thread.yield( ) LiftOff.run( ) see difference. In general, however, can’t rely yield( ) serious control tuning application. Indeed, yield( ) often used incorrectly. Daemon threads 810 Thinking Java Bruce Eckel A "daemon" thread intended provide general service background long program running, part essence program. Thus, nondaemon threads complete, program terminated, killing daemon threads process. Conversely, non-daemon threads still running, program doesn’t terminate. There is, instance, non-daemon thread runs main( ). //: concurrency/SimpleDaemons.java // Daemon threads don’t prevent program ending. import java.util.concurrent.*; import static net.mindview.util.Print.*; public class SimpleDaemons implements Runnable { public void run() { try { while(true) { TimeUnit.MILLISECONDS.sleep(100); print(Thread.currentThread() + " " + this); } } catch(InterruptedException e) { print("sleep() interrupted"); } } public static void main(String[] args) throws Exception { for(int = 0; < 10; i++) { Thread daemon = new Thread(new SimpleDaemons()); daemon.setDaemon(true); // Must call start() daemon.start(); } print("All daemons started"); TimeUnit.MILLISECONDS.sleep(175); } } /* Output: (Sample) All daemons started Thread[Thread-0,5,main] SimpleDaemons@530daa Thread[Thread-1,5,main] SimpleDaemons@a62fc3 Thread[Thread-2,5,main] SimpleDaemons@89ae9e Thread[Thread-3,5,main] SimpleDaemons@1270b73 Thread[Thread-4,5,main] SimpleDaemons@60aeb0 Thread[Thread-5,5,main] SimpleDaemons@16caf43 Thread[Thread-6,5,main] SimpleDaemons@66848c Thread[Thread-7,5,main] SimpleDaemons@8813f2 Thread[Thread-8,5,main] SimpleDaemons@1d58aae Thread[Thread-9,5,main] SimpleDaemons@83cc67 ... *///:~ You must set thread daemon calling setDaemon( ) started. There’s nothing keep program terminating main( ) finishes job, since nothing daemon threads running. So see results starting daemon threads, main( ) thread briefly put sleep. Without this, see results creation daemon threads. (Try sleep( ) calls various lengths see behavior.) SimpleDaemons.java creates explicit Thread objects order set daemon flag. It possible customize attributes (daemon, priority, name) threads created Executors writing custom ThreadFactory: //: net/mindview/util/DaemonThreadFactory.java package net.mindview.util; import java.util.concurrent.*; Concurrency 811 public class DaemonThreadFactory implements ThreadFactory { public Thread newThread(Runnable r) { Thread = new Thread(r); t.setDaemon(true); return t; } } ///:~ The difference ordinary ThreadFactory one sets daemon status true. You pass new DaemonThreadFactory argument Executors.newCachedThreadPool( ): //: concurrency/DaemonFromFactory.java // Using Thread Factory create daemons. import java.util.concurrent.*; import net.mindview.util.*; import static net.mindview.util.Print.*; public class DaemonFromFactory implements Runnable { public void run() { try { while(true) { TimeUnit.MILLISECONDS.sleep(100); print(Thread.currentThread() + " " + this); } } catch(InterruptedException e) { print("Interrupted"); } } public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool( new DaemonThreadFactory()); for(int = 0; < 10; i++) exec.execute(new DaemonFromFactory()); print("All daemons started"); TimeUnit.MILLISECONDS.sleep(500); // Run } } /* (Execute see output) *///:~ Each static ExecutorService creation methods overloaded take ThreadFactory object use create new threads. We take one step create DaemonThreadPoolExecutor utility: //: net/mindview/util/DaemonThreadPoolExecutor.java package net.mindview.util; import java.util.concurrent.*; public class DaemonThreadPoolExecutor extends ThreadPoolExecutor { public DaemonThreadPoolExecutor() { super(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new DaemonThreadFactory()); } } ///:~ To get values constructor base-class call, I simply looked Executors.java source code. 812 Thinking Java Bruce Eckel You find thread daemon calling isDaemon( ). If thread daemon, threads creates automatically daemons, following example demonstrates: //: concurrency/Daemons.java // Daemon threads spawn daemon threads. import java.util.concurrent.*; import static net.mindview.util.Print.*; class Daemon implements Runnable { private Thread[] = new Thread[10]; public void run() { for(int = 0; < t.length; i++) { t[i] = new Thread(new DaemonSpawn()); t[i].start(); printnb("DaemonSpawn " + + " started, "); } for(int = 0; < t.length; i++) printnb("t[" + + "].isDaemon() = " + t[i].isDaemon() + ", "); while(true) Thread.yield(); } } class DaemonSpawn implements Runnable { public void run() { while(true) Thread.yield(); } } public class Daemons { public static void main(String[] args) throws Exception { Thread = new Thread(new Daemon()); d.setDaemon(true); d.start(); printnb("d.isDaemon() = " + d.isDaemon() + ", "); // Allow daemon threads // finish startup processes: TimeUnit.SECONDS.sleep(1); } } /* Output: (Sample) d.isDaemon() = true, DaemonSpawn 0 started, DaemonSpawn 1 started, DaemonSpawn 2 started, DaemonSpawn 3 started, DaemonSpawn 4 started, DaemonSpawn 5 started, DaemonSpawn 6 started, DaemonSpawn 7 started, DaemonSpawn 8 started, DaemonSpawn 9 started, t[0].isDaemon() = true, t[1].isDaemon() = true, t[2].isDaemon() = true, t[3].isDaemon() = true, t[4].isDaemon() = true, t[5].isDaemon() = true, t[6].isDaemon() = true, t[7].isDaemon() = true, t[8].isDaemon() = true, t[9].isDaemon() = true, *///:~ The Daemon thread set daemon mode. It spawns bunch threads—which explicitly set daemon mode—to show daemons anyway. Then Daemon goes infinite loop calls yield( ) give control processes. You aware daemon threads terminate run( ) methods without executing finally clauses: //: concurrency/DaemonsDontRunFinally.java Concurrency 813 // Daemon threads don’t run finally clause import java.util.concurrent.*; import static net.mindview.util.Print.*; class ADaemon implements Runnable { public void run() { try { print("Starting ADaemon"); TimeUnit.SECONDS.sleep(1); } catch(InterruptedException e) { print("Exiting via InterruptedException"); } finally { print("This always run?"); } } } public class DaemonsDontRunFinally { public static void main(String[] args) throws Exception { Thread = new Thread(new ADaemon()); t.setDaemon(true); t.start(); } } /* Output: Starting ADaemon *///:~ When run program, you’ll see finally clause executed, comment call setDaemon( ), you’ll see finally clause executed. This behavior correct, even don’t expect based previous promises given finally. Daemons terminated "abruptly" last non-daemons terminates. So soon main( ) exits, JVM shuts daemons immediately, without formalities might come expect. Because cannot shut daemons nice fashion, rarely good idea. Non-daemon Executors generally better approach, since tasks controlled Executor shut once. As shall see later chapter, shutdown case proceeds orderly fashion. Exercise 7: (2) Experiment different sleep times Daemons.java see happens. Exercise 8: (1) Modify MoreBasicThreads.java threads daemon threads, verify program ends soon main( ) able exit. Exercise 9: (3) Modify SimplePriorities.java custom ThreadFactory sets priorities threads. Coding variations In examples you’ve seen far, task classes implement Runnable. In simple cases, may want use alternative approach inheriting directly Thread, like this: //: concurrency/SimpleThread.java // Inheriting directly Thread class. public class SimpleThread extends Thread { private int countDown = 5; private static int threadCount = 0; 814 Thinking Java Bruce Eckel public SimpleThread() { // Store thread name: super(Integer.toString(++threadCount)); start(); } public String toString() { return "#" + getName() + "(" + countDown + "), "; } public void run() { while(true) { System.out.print(this); if(--countDown == 0) return; } } public static void main(String[] args) { for(int = 0; < 5; i++) new SimpleThread(); } } /* Output: #1(5), #1(4), #1(3), #1(2), #1(1), #2(5), #2(4), #2(3), #2(2), #2(1), #3(5), #3(4), #3(3), #3(2), #3(1), #4(5), #4(4), #4(3), #4(2), #4(1), #5(5), #5(4), #5(3), #5(2), #5(1), *///:~ You give Thread objects specific names calling appropriate Thread constructor. This name retrieved toString( ) using getName( ). Another idiom may see self-managed Runnable: //: concurrency/SelfManaged.java // A Runnable containing driver Thread. public class SelfManaged implements Runnable { private int countDown = 5; private Thread = new Thread(this); public SelfManaged() { t.start(); } public String toString() { return Thread.currentThread().getName() + "(" + countDown + "), "; } public void run() { while(true) { System.out.print(this); if(--countDown == 0) return; } } public static void main(String[] args) { for(int = 0; < 5; i++) new SelfManaged(); } } /* Output: Thread-0(5), Thread-0(4), Thread-0(3), Thread-0(2), Thread-0(1), Thread1(5), Thread-1(4), Thread-1(3), Thread-1(2), Thread-1(1), Thread-2(5), Thread-2(4), Thread-2(3), Thread-2(2), Thread-2(1), Thread-3(5), Thread3(4), Thread-3(3), Thread-3(2), Thread-3(1), Thread-4(5), Thread-4(4), Thread-4(3), Thread-4(2), Thread-4(1), *///:~ Concurrency 815 This especially different inheriting Thread except syntax slightly awkward. However, implementing interface allow inherit different class, whereas inheriting Thread not. Notice start( ) called within constructor. This example quite simple therefore probably safe, aware starting threads inside constructor quite problematic, another task might start executing constructor completed, means task may able access object unstable state. This yet another reason prefer use Executors explicit creation Thread objects. Sometimes makes sense hide threading code inside class using inner class, shown here: //: concurrency/ThreadVariations.java // Creating threads inner classes. import java.util.concurrent.*; import static net.mindview.util.Print.*; // Using named inner class: class InnerThread1 { private int countDown = 5; private Inner inner; private class Inner extends Thread { Inner(String name) { super(name); start(); } public void run() { try { while(true) { print(this); if(--countDown == 0) return; sleep(10); } } catch(InterruptedException e) { print("interrupted"); } } public String toString() { return getName() + ": " + countDown; } } public InnerThread1(String name) { inner = new Inner(name); } } // Using anonymous inner class: class InnerThread2 { private int countDown = 5; private Thread t; public InnerThread2(String name) { = new Thread(name) { public void run() { try { while(true) { print(this); if(--countDown == 0) return; sleep(10); } } catch(InterruptedException e) { 816 Thinking Java Bruce Eckel } print("sleep() interrupted"); } public String toString() { return getName() + ": " + countDown; } }; t.start(); } } // Using named Runnable implementation: class InnerRunnable1 { private int countDown = 5; private Inner inner; private class Inner implements Runnable { Thread t; Inner(String name) { = new Thread(this, name); t.start(); } public void run() { try { while(true) { print(this); if(--countDown == 0) return; TimeUnit.MILLISECONDS.sleep(10); } } catch(InterruptedException e) { print("sleep() interrupted"); } } public String toString() { return t.getName() + ": " + countDown; } } public InnerRunnable1(String name) { inner = new Inner(name); } } // Using anonymous Runnable implementation: class InnerRunnable2 { private int countDown = 5; private Thread t; public InnerRunnable2(String name) { = new Thread(new Runnable() { public void run() { try { while(true) { print(this); if(--countDown == 0) return; TimeUnit.MILLISECONDS.sleep(10); } } catch(InterruptedException e) { print("sleep() interrupted"); } } public String toString() { return Thread.currentThread().getName() + ": " + countDown; } }, name); Concurrency 817 } t.start(); } // A separate method run code task: class ThreadMethod { private int countDown = 5; private Thread t; private String name; public ThreadMethod(String name) { this.name = name; } public void runTask() { if(t == null) { = new Thread(name) { public void run() { try { while(true) { print(this); if(--countDown == 0) return; sleep(10); } } catch(InterruptedException e) { print("sleep() interrupted"); } } public String toString() { return getName() + ": " + countDown; } }; t.start(); } } } public class ThreadVariations { public static void main(String[] args) { new InnerThread1("InnerThread1"); new InnerThread2("InnerThread2"); new InnerRunnable1("InnerRunnable1"); new InnerRunnable2("InnerRunnable2"); new ThreadMethod("ThreadMethod").runTask(); } } /* (Execute see output) *///:~ InnerThread1 creates named inner class extends Thread, makes instance inner class inside constructor. This makes sense inner class special capabilities (new methods) need access methods. However, time reason creating thread use Thread capabilities, it’s necessary create named inner class. InnerThread2 shows alternative: An anonymous inner subclass Thread created inside constructor upcast Thread reference t. If methods class need access t, Thread interface, don’t need know exact type object. The third fourth classes example repeat first two classes, use Runnable interface rather Thread class. The ThreadMethod class shows creation thread inside method. You call method you’re ready run thread, method returns thread begins. If thread performing auxiliary operation rather fundamental class, probably useful appropriate approach starting thread inside constructor class. 818 Thinking Java Bruce Eckel Exercise 10: (4) Modify Exercise 5 following example ThreadMethod class, runTask( ) takes argument number Fibonacci numbers sum, time call runTask( ) returns Future produced call submit( ). Terminology As previous section shows, choices implement concurrent programs Java, choices confusing. Often problem comes terminology that’s used describing concurrent program technology, especially threads involved. You see there’s distinction task that’s executed thread drives it; distinction especially clear Java libraries don’t really control Thread class (and separation even clearer executors, take care creation management threads you). You create tasks somehow attach thread task thread drive task. In Java, Thread class nothing. It drives task it’s given. Yet threading literature invariably uses language like "the thread performs action." The impression get thread task, I first encountered Java threads, impression strong I saw clear "is-a" relationship, said I obviously inherit task Thread. Add poor choice name Runnable interface, I think would much better named "Task." If interface clearly nothing generic encapsulation methods, "itdoes-this-thing-able" naming approach appropriate, intends express higher concept, like Task, concept name helpful. The problem levels abstraction mixed together. Conceptually, want create task runs independently tasks, ought able define task, say "go," worry details. But physically, threads expensive create, must conserve manage them. Thus makes sense implementation standpoint separate tasks threads. In addition, Java threading based low-level pthreads approach comes C, immersed in, must thoroughly understand, nuts bolts everything that’s going on. Some low-level nature trickled Java implementation, stay higher level abstraction, must use discipline writing code (I try demonstrate discipline chapter). To clarify discussions, I shall attempt use term "task" I describing work done, "thread" I referring specific mechanism that’s driving task. Thus, discussing system conceptual level, could use term "task" without mentioning driving mechanism all. Joining thread One thread may call join( ) another thread wait second thread complete proceeding. If thread calls t.join( ) another thread t, calling thread suspended target thread finishes (when t.isAlive( ) false). You may also call join( ) timeout argument (in either milliseconds milliseconds nanoseconds) target thread doesn’t finish period time, call join( ) returns anyway. The call join( ) may aborted calling interrupt( ) calling thread, trycatch clause required. Concurrency 819 All operations shown following example: //: concurrency/Joining.java // Understanding join(). import static net.mindview.util.Print.*; class Sleeper extends Thread { private int duration; public Sleeper(String name, int sleepTime) { super(name); duration = sleepTime; start(); } public void run() { try { sleep(duration); } catch(InterruptedException e) { print(getName() + " interrupted. " + "isInterrupted(): " + isInterrupted()); return; } print(getName() + " awakened"); } } class Joiner extends Thread { private Sleeper sleeper; public Joiner(String name, Sleeper sleeper) { super(name); this.sleeper = sleeper; start(); } public void run() { try { sleeper.join(); } catch(InterruptedException e) { print("Interrupted"); } print(getName() + " join completed"); } } public class Joining { public static void main(String[] args) { Sleeper sleepy = new Sleeper("Sleepy", 1500), grumpy = new Sleeper("Grumpy", 1500); Joiner dopey = new Joiner("Dopey", sleepy), doc = new Joiner("Doc", grumpy); grumpy.interrupt(); } } /* Output: Grumpy interrupted. isInterrupted(): false Doc join completed Sleepy awakened Dopey join completed *///:~ A Sleeper thread goes sleep time specified constructor. In run( ), call sleep( ) may terminate time expires, may also interrupted. Inside catch clause, interruption reported, along value isInterrupted( ). 820 Thinking Java Bruce Eckel When another thread calls interrupt( ) thread, flag set indicate thread interrupted. However, flag cleared exception caught, result always false inside catch clause. The flag used situations thread may examine interrupted state apart exception. A Joiner task waits Sleeper wake calling join( ) Sleeper object. In main( ), Sleeper Joiner, see output Sleeper either interrupted ends normally, Joiner completes conjunction Sleeper. Note Java SE5 java.util.concurrent libraries contain tools CyclicBarrier (demonstrated later chapter) may appropriate join( ), part original threading library. Creating responsive user interfaces As stated earlier, one motivations using threading create responsive user interface. Although won’t get graphical interfaces Graphical User Interfaces chapter, following example simple mock-up console-based user interface. The example two versions: one gets stuck calculation thus never read console input, second puts calculation inside task thus performing calculation listening console input. //: concurrency/ResponsiveUI.java // User interface responsiveness. // {RunByHand} class UnresponsiveUI { private volatile double = 1; public UnresponsiveUI() throws Exception { while(d > 0) = + (Math.PI + Math.E) / d; System.in.read(); // Never gets } } public class ResponsiveUI extends Thread { private static volatile double = 1; public ResponsiveUI() { setDaemon(true); start(); } public void run() { while(true) { = + (Math.PI + Math.E) / d; } } public static void main(String[] args) throws Exception { //! new UnresponsiveUI(); // Must kill process new ResponsiveUI(); System.in.read(); System.out.println(d); // Shows progress } } ///:~ UnresponsiveUI performs calculation inside infinite loop, obviously never reach console input line (the compiler fooled believing input line reachable conditional). If uncomment line creates UnresponsiveUI, you’ll kill process get out. Concurrency 821 To make program responsive, put calculation inside run( ) method allow preempted, press Enter key, you’ll see calculation indeed running background waiting user input. Thread groups A thread group holds collection threads. The value thread groups summed quote Joshua Bloch, 8 software architect who, Sun, fixed greatly improved Java collections library JDK 1.2 (among contributions): "Thread groups best viewed unsuccessful experiment, may simply ignore existence." If you’ve spent time energy trying figure value thread groups (as I have), may wonder official announcement Sun topic—the question asked number changes happened Java years. The Nobel laureate economist Joseph Stiglitz philosophy life would seem apply here. 9 It’s called The Theory Escalating Commitment: "The cost continuing mistakes borne others, cost admitting mistakes borne yourself." Catching exceptions Because nature threads, can’t catch exception escaped thread. Once exception gets outside task’s run( ) method, propagate console unless take special steps capture errant exceptions. Before Java SE5, used thread groups catch exceptions, Java SE5 solve problem Executors, thus longer need know anything thread groups (except understand legacy code; see Thinking Java, 2ndEdition, downloadable www.MindView.net, details thread groups). Here’s task always throws exception propagates outside run( ) method, main( ) shows happens run it: //: concurrency/ExceptionThread.java // {ThrowsException} import java.util.concurrent.*; public class ExceptionThread implements Runnable { public void run() { throw new RuntimeException(); } public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new ExceptionThread()); } } ///:~ The output (after trimming qualifiers fit): java.lang.RuntimeException 8 Effective Java™ Programming Language Guide, Joshua Bloch (Addison-Wesley, 2001), p. 211. And number places throughout experience Java. Well, stop there? I’ve consulted projects applied. 9 822 Thinking Java Bruce Eckel ExceptionThread.run(ExceptionThread.java:7) ThreadPoolExecutor$Worker.runTask(Unknown Source) ThreadPoolExecutor$Worker.run(Unknown Source) Java.lang.Thread.run(Unknown Source) Encompassing body main within try-catch block unsuccessful: //: concurrency/NaiveExceptionHandling.java // {ThrowsException} import java.util.concurrent.*; public class NaiveExceptionHandling { public static void main(String[] args) { try { ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new ExceptionThread()); } catch(RuntimeException ue) { // This statement NOT execute! System.out.println("Exception handled!"); } } } ///:~ This produces result previous example: uncaught exception. To solve problem, change way Executor produces threads. Thread.UncaughtExceptionHandler new interface Java SE5; allows attach exception handler Thread object. Thread.UncaughtExceptionHandler.uncaughtException( ) automatically called thread die uncaught exception. To use it, create new type ThreadFactory attaches new Thread.UncaughtExceptionHandler new Thread object creates. We pass factory Executors method creates new ExecutorService: //: concurrency/CaptureUncaughtException.java import java.util.concurrent.*; class ExceptionThread2 implements Runnable { public void run() { Thread = Thread.currentThread(); System.out.println("run() " + t); System.out.println( "eh = " + t.getUncaughtExceptionHandler()); throw new RuntimeException(); } } class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler { public void uncaughtException(Thread t, Throwable e) { System.out.println("caught " + e); } } class HandlerThreadFactory implements ThreadFactory { public Thread newThread(Runnable r) { System.out.println(this + " creating new Thread"); Thread = new Thread(r); System.out.println("created " + t); t.setUncaughtExceptionHandler( Concurrency 823 new MyUncaughtExceptionHandler()); System.out.println( "eh = " + t.getUncaughtExceptionHandler()); return t; } } public class CaptureUncaughtException { public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool( new HandlerThreadFactory()); exec.execute(new ExceptionThread2()); } } /* Output: (90% match) HandlerThreadFactory@de6ced creating new Thread created Thread[Thread-0,5,main] eh = MyUncaughtExceptionHandler@1fb8ee3 run() Thread[Thread-0,5,main] eh = MyUncaughtExceptionHandler@1fb8ee3 caught java.lang.RuntimeException *///:~ Additional tracing added verify threads created factory given new UncaughtExceptionHandler. You see uncaught exceptions captured uncaughtException. The example allows set handler case-by-case basis. If know you’re going use exception handler everywhere, even simpler approach set default uncaught exception handler, sets static field inside Thread class: //: concurrency/SettingDefaultHandler.java import java.util.concurrent.*; public class SettingDefaultHandler { public static void main(String[] args) { Thread.setDefaultUncaughtExceptionHandler( new MyUncaughtExceptionHandler()); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new ExceptionThread()); } } /* Output: caught java.lang.RuntimeException *///:~ This handler called per-thread uncaught exception handler. The system checks per-thread version, doesn’t find one checks see thread group specializes uncaughtException( ) method; not, calls defaultUncaughtExceptionHandler. Sharing resources You think single-threaded program one lonely entity moving around problem space one thing time. Because there’s one entity, never think problem two entities trying use resource time: problems two people trying park space, walk door time, even talk time. With concurrency, things aren’t lonely anymore, possibility two tasks interfering other. If don’t prevent collision, you’ll two 824 Thinking Java Bruce Eckel tasks trying access bank account time, print printer, adjust valve, on. Improperly accessing resources Consider following example, one task generates even numbers tasks consume numbers. Here, job consumer tasks check validity even numbers. First we’ll define EvenChecker, consumer task, since reused subsequent examples. To decouple EvenChecker various types generators experiment with, we’ll create abstract class called IntGenerator, contains minimum necessary methods EvenChecker must know about: next( ) method canceled. This class doesn’t implement Generator interface, must produce int, generics don’t support primitive parameters. //: concurrency/IntGenerator.java public abstract class IntGenerator { private volatile boolean canceled = false; public abstract int next(); // Allow canceled: public void cancel() { canceled = true; } public boolean isCanceled() { return canceled; } } ///:~ IntGenerator cancel( ) method change state boolean canceled flag isCanceled( ) see whether object canceled. Because canceled flag boolean, atomic, means simple operations like assignment value return happen without possibility interruption, can’t see field intermediate state midst simple operations. The canceled flag also volatile order ensure visibility. You’ll learn atomicity visibility later chapter. Any IntGenerator tested following EvenChecker class: //: concurrency/EvenChecker.java import java.util.concurrent.*; public class EvenChecker implements Runnable { private IntGenerator generator; private final int id; public EvenChecker(IntGenerator g, int ident) { generator = g; id = ident; } public void run() { while(!generator.isCanceled()) { int val = generator.next(); if(val % 2 != 0) { System.out.println(val + " even!"); generator.cancel(); // Cancels EvenCheckers } } } // Test type IntGenerator: public static void test(IntGenerator gp, int count) { System.out.println("Press Control-C exit"); ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < count; i++) Concurrency 825 exec.execute(new EvenChecker(gp, i)); exec.shutdown(); } // Default value count: public static void test(IntGenerator gp) { test(gp, 10); } } ///:~ Note example class canceled Runnable. Instead, EvenChecker tasks depend IntGenerator object test see whether it’s canceled, see run( ). This way, tasks share common resource (the IntGenerator) watch resource signal terminate. This eliminates so-called race condition, two tasks race respond condition thus collide otherwise produce inconsistent results. You must careful think protect possible ways concurrent system fail. For example, task cannot depend another task, task shutdown order guaranteed. Here, making tasks depend nontask object, eliminate potential race condition. The test( ) method sets performs test type IntGenerator starting number EvenCheckers use IntGenerator. If IntGenerator causes failure, test( ) report return; otherwise, must press Control-C terminate it. EvenChecker tasks constantly read test values associated IntGenerator. Note generator.isCanceled( ) true, run( ) returns, tells Executor EvenChecker.test( ) task complete. Any EvenChecker task call cancel( ) associated IntGenerator, cause EvenCheckers using IntGenerator gracefully shut down. In later sections, you’ll see Java contains general mechanisms termination threads. The first IntGenerator we’ll look next( ) produces series even values: //: concurrency/EvenGenerator.java // When threads collide. public class EvenGenerator extends IntGenerator { private int currentEvenValue = 0; public int next() { ++currentEvenValue; // Danger point here! ++currentEvenValue; return currentEvenValue; } public static void main(String[] args) { EvenChecker.test(new EvenGenerator()); } } /* Output: (Sample) Press Control-C exit 89476993 even! 89476993 even! *///:~ It’s possible one task call next( ) another task performed first increment currentEvenValue second (at place code commented "Danger point here!"). This puts value "incorrect" state. To prove happen, EvenChecker.test( ) creates group EvenChecker objects continually read output EvenGenerator test see one even. If not, error reported program shut down. This program eventually fail EvenChecker tasks able access information EvenGenerator it’s "incorrect" state. However, may detect 826 Thinking Java Bruce Eckel problem EvenGenerator completed many cycles, depending particulars operating system implementation details. If want see fail much faster, try putting call yield( ) first second increments. This part problem multithreaded programs—they appear correct even there’s bug, probability failure low. It’s important note increment operation requires multiple steps, task suspended threading mechanism midst increment—that is, increment atomic operation Java. So even single increment isn’t safe without protecting task. Resolving shared resource contention The previous example shows fundamental problem using threads: You never know thread might run. Imagine sitting table fork, spear last piece food platter, fork reaches it, food suddenly vanishes— thread suspended another diner came ate food. That’s problem you’re dealing writing concurrent programs. For concurrency work, need way prevent two tasks accessing resource, least critical periods. Preventing kind collision simply matter putting lock resource one task using it. The first task accesses resource must lock it, tasks cannot access resource unlocked, time another task locks uses it, on. If front seat car limited resource, child shouts "shotgun!" acquires lock (for duration trip). To solve problem thread collision, virtually concurrency schemes serialize access shared resources. This means one task time allowed access shared resource. This ordinarily accomplished putting clause around piece code allows one task time pass piece code. Because clause produces mutual exclusion, common name mechanism mutex. Consider bathroom house; multiple people (tasks driven threads) may want exclusive use bathroom (the shared resource). To access bathroom, person knocks door see it’s available. If so, enter lock door. Any task wants use bathroom "blocked" using it, tasks wait door bathroom available. The analogy breaks bit bathroom released comes time give access another task. There isn’t actually line people, don’t know sure gets bathroom next, thread scheduler isn’t deterministic way. Instead, it’s group blocked tasks milling front bathroom, task locked bathroom unlocks emerges, one happens nearest door moment goes in. As noted earlier, suggestions made thread scheduler via yield( ) setPriority( ), suggestions may much effect, depending platform JVM implementation. To prevent collisions resources, Java built-in support form synchronized keyword. When task wishes execute piece code guarded synchronized keyword, checks see lock available, acquires it, executes code, releases it. The shared resource typically piece memory form object, may also file, I/O port, something like printer. To control access shared resource, first put inside object. Then method uses resource made synchronized. If task call one synchronized methods, tasks Concurrency 827 blocked entering synchronized methods object first task returns call. In production code, you’ve already seen make data elements class private access memory methods. You prevent collisions declaring methods synchronized, like this: synchronized void f() { /* ... */ } synchronized void g() { /* ... */ } All objects automatically contain single lock (also referred monitor). When call synchronized method, object locked synchronized method object called first one finishes releases lock. For preceding methods, f( ) called object one task, different task cannot call f( ) g( ) object f( ) completed releases lock. Thus, single lock shared synchronized methods particular object, lock used prevent object memory written one task time. Note it’s especially important make fields private working concurrency; otherwise synchronized keyword cannot prevent another task accessing field directly, thus producing collisions. One task may acquire object’s lock multiple times. This happens one method calls second method object, turn calls another method object, etc. The JVM keeps track number times object locked. If object unlocked, count zero. As task acquires lock first time, count goes one. Each time task acquires another lock object, count incremented. Naturally, multiple lock acquisition allowed task acquired lock first place. Each time task leaves synchronized method, count decremented, count goes zero, releasing lock entirely use tasks. There’s also single lock per class (as part Class object class), synchronized static methods lock simultaneous access static data class-wide basis. When synchronize? Apply Brian’s Rule Synchronization: 10 If writing variable might next read another thread, reading variable might last written another thread, must use synchronization, further, reader writer must synchronize using monitor lock. If one method class deals critical data, must synchronize relevant methods. If synchronize one methods, others free ignore object lock called impunity. This important point: Every method accesses critical shared resource must synchronized won’t work right. Synchronizing EvenGenerator By adding synchronized EvenGenerator.java, prevent undesirable thread access: //: concurrency/SynchronizedEvenGenerator.java 10 From Brian Goetz, author Java Concurrency Practice, Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, Doug Lea (Addison-Wesley, 2006). 828 Thinking Java Bruce Eckel // Simplifying mutexes synchronized keyword. // {RunByHand} public class SynchronizedEvenGenerator extends IntGenerator { private int currentEvenValue = 0; public synchronized int next() { ++currentEvenValue; Thread.yield(); // Cause failure faster ++currentEvenValue; return currentEvenValue; } public static void main(String[] args) { EvenChecker.test(new SynchronizedEvenGenerator()); } } ///:~ A call Thread.yield( ) inserted two increments, raise likelihood context switch currentEvenValue odd state. Because mutex prevents one task time critical section, produce failure, calling yield( ) helpful way promote failure it’s going happen. The first task enters next( ) acquires lock, tasks try acquire lock blocked first task releases lock. At point, scheduling mechanism selects another task waiting lock. This way, one task time pass code guarded mutex. Exercise 11: (3) Create class containing two data fields, method manipulates fields multistep process that, execution method, fields "improper state" (according definition establish). Add methods read fields, create multiple threads call various methods show data visible "improper state." Fix problem using synchronized keyword. Using explicit Lock objects The Java SE5 java.util.concurrent library also contains explicit mutex mechanism defined java.util.concurrent.locks. The Lock object must explicitly created, locked unlocked; thus, produces less elegant code built-in form. However, flexible solving certain types problems. Here SynchronizedEvenGenerator.java rewritten use explicit Locks: //: concurrency/MutexEvenGenerator.java // Preventing thread collisions mutexes. // {RunByHand} import java.util.concurrent.locks.*; public class MutexEvenGenerator extends IntGenerator { private int currentEvenValue = 0; private Lock lock = new ReentrantLock(); public int next() { lock.lock(); try { ++currentEvenValue; Thread.yield(); // Cause failure faster ++currentEvenValue; return currentEvenValue; } finally { lock.unlock(); } } Concurrency 829 public static void main(String[] args) { EvenChecker.test(new MutexEvenGenerator()); } } ///:~ MutexEvenGenerator adds mutex called lock uses lock( ) unlock( ) methods create critical section within next( ). When using Lock objects, important internalize idiom shown here: Right call lock( ), must place try-finally statement unlock( ) finally clause—this way guarantee lock always released. Note return statement must occur inside try clause ensure unlock( ) doesn’t happen early expose data second task. Although try-finally requires code using synchronized keyword, also represents one advantages explicit Lock objects. If something fails using synchronized keyword, exception thrown, don’t get chance cleanup order maintain system good state. With explicit Lock objects, maintain proper state system using finally clause. In general, using synchronized, less code write, opportunity user error greatly reduced, you’ll usually use explicit Lock objects you’re solving special problems. For example, synchronized keyword, can’t try fail acquire lock, try acquire lock certain amount time give up—to this, must use concurrent library: //: concurrency/AttemptLocking.java // Locks concurrent library allow // give trying acquire lock. import java.util.concurrent.*; import java.util.concurrent.locks.*; public class AttemptLocking { private ReentrantLock lock = new ReentrantLock(); public void untimed() { boolean captured = lock.tryLock(); try { System.out.println("tryLock(): " + captured); } finally { if(captured) lock.unlock(); } } public void timed() { boolean captured = false; try { captured = lock.tryLock(2, TimeUnit.SECONDS); } catch(InterruptedException e) { throw new RuntimeException(e); } try { System.out.println("tryLock(2, TimeUnit.SECONDS): " + captured); } finally { if(captured) lock.unlock(); } } public static void main(String[] args) { final AttemptLocking al = new AttemptLocking(); al.untimed(); // True -- lock available al.timed(); // True -- lock available 830 Thinking Java Bruce Eckel // Now create separate task grab lock: new Thread() { { setDaemon(true); } public void run() { al.lock.lock(); System.out.println("acquired"); } }.start(); Thread.yield(); // Give 2nd task chance al.untimed(); // False -- lock grabbed task al.timed(); // False -- lock grabbed task } } /* Output: tryLock(): true tryLock(2, TimeUnit.SECONDS): true acquired tryLock(): false tryLock(2, TimeUnit.SECONDS): false *///:~ A ReentrantLock allows try fail acquire lock, someone else already lock, decide go something else rather waiting free, see untimed( ) method. In timed( ), attempt made acquire lock fail 2 seconds (note use Java SE5 TimeUnit class specify units). In main( ), separate Thread created anonymous class, acquires lock untimed( ) timed( ) methods something contend with. The explicit Lock object also gives finer-grained control locking unlocking built-in synchronized lock. This useful implementing specialized synchronization structures, hand-overhand locking (also called lock coupling), used traversing nodes linked list—the traversal code must capture lock next node releases current node’s lock. Atomicity volatility An incorrect piece lore often repeated Java threading discussions is, "Atomic operations need synchronized." An atomic operation one cannot interrupted thread scheduler; operation begins, run completion possibility context switch. Relying atomicity tricky dangerous—you try use atomicity instead synchronization concurrency expert, help expert. If think you’re smart enough play kind fire, take test: The Goetz Test 11 : If write high-performance JVM modern microprocessor, qualified think whether avoid synchronizing. 12 It’s useful know atomicity, know that, along advanced techniques, used implement clever java.util.concurrent library components. But strongly resist urge rely yourself; see Brian’s Rule Synchronization, presented earlier. After previously mentioned Brian Goetz, concurrency expert helped chapter, based partially tongue-in-cheek comments him. 11 A corollary test is, "If someone implies threading easy straightforward, make sure person making important decisions project. If person already is, you’ve got trouble." 12 Concurrency 831 Atomicity applies "simple operations" primitive types except longs doubles. Reading writing primitive variables long double guaranteed go memory indivisible (atomic) operations. However, JVM allowed perform reads writes 64- bit quantities (long double variables) two separate 32-bit operations, raising possibility context switch could happen middle read write, different tasks could see incorrect results (this sometimes called word tearing, might see value part changed). However, get atomicity (for simple assignments returns) use volatile keyword defining long double variable (note volatile working properly Java SE5). Different JVMs free provide stronger guarantees, rely platform-specific features. Atomic operations thus interruptible threading mechanism. Expert programmers take advantage write lock-free code, need synchronized. But even oversimplification. Sometimes, even seems like atomic operation safe, may be. Readers book typically able pass aforementioned Goetz Test, thus qualified try replace synchronization atomic operations. Trying remove synchronization usually sign premature optimization, cause lot trouble, probably without gaining much, anything. On multiprocessor systems (which appearing form multicore processors— multiple CPUs single chip), visibility rather atomicity much issue single-processor systems. Changes made one task, even they’re atomic sense interruptible, might visible tasks (the changes might temporarily stored local processor cache, example), different tasks different view application’s state. The synchronization mechanism, hand, forces changes one task multiprocessor system visible across application. Without synchronization, it’s indeterminate changes become visible. The volatile keyword also ensures visibility across application. If declare field volatile, means soon write occurs field, reads see change. This true even local caches involved—volatile fields immediately written main memory, reads occur main memory. It’s important understand atomicity volatility distinct concepts. An atomic operation non-volatile field necessarily flushed main memory, another task reads field necessarily see new value. If multiple tasks accessing field, field volatile; otherwise, field accessed via synchronization. Synchronization also causes flushing main memory, field completely guarded synchronized methods blocks, necessary make volatile. Any writes task makes visible task, don’t need make field volatile seen within task. volatile doesn’t work value field depends previous value (such incrementing counter), work fields whose values constrained values fields, lower upper bound Range class must obey constraint lower <= upper. It’s typically safe use volatile instead synchronized class one mutable field. Again, first choice use synchronized keyword—that’s safest approach, trying anything else risky. What qualifies atomic operation? Assignment returning value field usually atomic. However, C++ even following might atomic: 832 Thinking Java Bruce Eckel i++; // Might atomic C++ +=2; // Might atomic C++ But C++, depends compiler processor. You’re unable write crossplatform code C++ relies atomicity, C++ doesn’t consistent memory model, Java (in Java SEs). 13 In Java, operations definitely atomic, see JVM instructions produced following methods: //: concurrency/Atomicity.java // {Exec: javap -c Atomicity} public class Atomicity { int i; void f1() { i++; } void f2() { += 3; } } /* Output: (Sample) ... void f1(); Code: 0: aload_0 1: dup 2: getfield 5: iconst_1 6: iadd 7: putfield 10: return void f2(); Code: 0: 1: 2: 5: 6: 7: 10: *///:~ aload_0 dup getfield iconst_3 iadd putfield return #2; //Field i:I #2; //Field i:I #2; //Field i:I #2; //Field i:I Each instruction produces "get" "put," instructions between. So getting putting, another task could modify field, thus operations atomic. If blindly apply idea atomicity, see getValue( ) following program fits description: //: concurrency/AtomicityTest.java import java.util.concurrent.*; public class AtomicityTest implements Runnable { private int = 0; public int getValue() { return i; } private synchronized void evenIncrement() { i++; i++; } public void run() { while(true) evenIncrement(); } 13 This remedied upcoming C++ standard. Concurrency 833 public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); AtomicityTest = new AtomicityTest(); exec.execute(at); while(true) { int val = at.getValue(); if(val % 2 != 0) { System.out.println(val); System.exit(0); } } } } /* Output: (Sample) 191583767 *///:~ However, program find non-even values terminate. Although return indeed atomic operation, lack synchronization allows value read object unstable intermediate state. On top this, since also volatile, visibility problems. Both getValue( ) evenIncrement( ) must synchronized. Only concurrency experts qualified attempt optimizations situations like this; again, apply Brian’s Rule Synchronization. As second example, consider something even simpler: class produces serial numbers. 14 Each time nextSerialNumber( ) called, must return unique value caller: //: concurrency/SerialNumberGenerator.java public class SerialNumberGenerator { private static volatile int serialNumber = 0; public static int nextSerialNumber() { return serialNumber++; // Not thread-safe } } ///:~ SerialNumberGenerator simple class imagine, you’re coming C++ low-level background, might expect increment atomic operation, C++ increment often implemented microprocessor instruction (although reliable, cross-platform fashion). As noted before, however, Java increment atomic involves read write, there’s room threading problems even simple operation. As shall see, volatility isn’t actually issue here; real problem nextSerialNumber( ) accesses shared, mutable value without synchronizing. The serialNumber field volatile possible thread local stack maintain copies variables there. If define variable volatile, tells compiler optimizations would remove reads writes keep field exact synchronization local data threads. In effect, reads writes go directly memory, cached, volatile also restricts compiler reordering accesses optimization. However, volatile doesn’t affect fact increment isn’t atomic operation. Basically, make field volatile field could simultaneously accessed multiple tasks, least one accesses write. For example, field used flag stop task must declared volatile; otherwise, flag could cached 14 834 Inspired Joshua Bloch’s Effective Java™ Programming Language Guide (Addison- Wesley, 2001), p. 190. Thinking Java Bruce Eckel register, make changes flag outside task, cached value wouldn’t changed task wouldn’t know stop. To test SerialNumberGenerator, need set doesn’t run memory, case takes long time detect problem. The CircularSet shown reuses memory used store ints, assumption time wrap around, possibility collision overwritten values minimal. The add( ) contains( ) methods synchronized prevent thread collisions: //: concurrency/SerialNumberChecker.java // Operations may seem safe not, // threads present. // {Args: 4} import java.util.concurrent.*; // Reuses storage don’t run memory: class CircularSet { private int[] array; private int len; private int index = 0; public CircularSet(int size) { array = new int[size]; len = size; // Initialize value produced // SerialNumberGenerator: for(int = 0; < size; i++) array[i] = -1; } public synchronized void add(int i) { array[index] = i; // Wrap index write old elements: index = ++index % len; } public synchronized boolean contains(int val) { for(int = 0; < len; i++) if(array[i] == val) return true; return false; } } public class SerialNumberChecker { private static final int SIZE = 10; private static CircularSet serials = new CircularSet(1000); private static ExecutorService exec = Executors.newCachedThreadPool(); static class SerialChecker implements Runnable { public void run() { while(true) { int serial = SerialNumberGenerator.nextSerialNumber(); if(serials.contains(serial)) { System.out.println("Duplicate: " + serial); System.exit(0); } serials.add(serial); } } } public static void main(String[] args) throws Exception { for(int = 0; < SIZE; i++) exec.execute(new SerialChecker()); Concurrency 835 // Stop n seconds there’s argument: if(args.length > 0) { TimeUnit.SECONDS.sleep(new Integer(args[0])); System.out.println("No duplicates detected"); System.exit(0); } } } /* Output: (Sample) Duplicate: 8468656 *///:~ SerialNumberChecker contains static CircularSet holds serial numbers produced, nested SerialChecker class ensures serial numbers unique. By creating multiple tasks contend serial numbers, you’ll discover tasks eventually get duplicate serial number, let run long enough. To solve problem, add synchronized keyword nextSerialNumber( ). The atomic operations supposed safe reading assignment primitives. However, seen AtomicityTest.java, it’s still easily possible use atomic operation accesses object it’s unstable intermediate state. Making assumptions issue tricky dangerous. The sensible thing follow Brian’s Rule Synchronization. Exercise 12: (3) Repair AtomicityTest.java using synchronized keyword. Can demonstrate correct? Exercise 13: (1) Repair SerialNumberChecker.java using synchronized keyword. Can demonstrate correct? Atomic classes Java SE5 introduces special atomic variable classes Atomiclnteger, AtomicLong, AtomicReference, etc. provide atomic conditional update operation form: boolean compareAndSet(expectedValue, updateValue); These fine-tuning use machine-level atomicity available modern processors, generally don’t need worry using them. Occasionally come handy regular coding, performance tuning involved. For example, rewrite AtomicityTest.java use Atomiclnteger: //: concurrency/AtomicIntegerTest.java import java.util.concurrent.*; import java.util.concurrent.atomic.*; import java.util.*; public class AtomicIntegerTest implements Runnable { private AtomicInteger = new AtomicInteger(0); public int getValue() { return i.get(); } private void evenIncrement() { i.addAndGet(2); } public void run() { while(true) evenIncrement(); } public static void main(String[] args) { new Timer().schedule(new TimerTask() { public void run() { System.err.println("Aborting"); 836 Thinking Java Bruce Eckel System.exit(0); } }, 5000); // Terminate 5 seconds ExecutorService exec = Executors.newCachedThreadPool(); AtomicIntegerTest ait = new AtomicIntegerTest(); exec.execute(ait); while(true) { int val = ait.getValue(); if(val % 2 != 0) { System.out.println(val); System.exit(0); } } } } ///:~ Here we’ve eliminated synchronized keyword using AtomicInteger instead. Because program doesn’t fail, Timer added automatically abort 5 seconds. Here MutexEvenGenerator.java rewritten use Atomiclnteger: //: concurrency/AtomicEvenGenerator.java // Atomic classes occasionally useful regular code. // {RunByHand} import java.util.concurrent.atomic.*; public class AtomicEvenGenerator extends IntGenerator { private AtomicInteger currentEvenValue = new AtomicInteger(0); public int next() { return currentEvenValue.addAndGet(2); } public static void main(String[] args) { EvenChecker.test(new AtomicEvenGenerator()); } } ///:~ Again, forms synchronization eliminated using AtomicInteger. It emphasized Atomic classes designed build classes java.util.concurrent, use code special circumstances, even ensure possible problems. It’s generally safer rely locks (either synchronized keyword explicit Lock objects). Exercise 14: (4) Demonstrate java.util.Timer scales large numbers creating program generates many Timer objects perform simple task timeout completes. Critical sections Sometimes, want prevent multiple thread access part code inside method instead entire method. The section code want isolate way called critical section created using synchronized keyword. Here, synchronized used specify object whose lock used synchronize enclosed code: synchronized(syncObject) { // This code accessed Concurrency 837 } // one task time This also called synchronized block; entered, lock must acquired syncObject. If task already lock, critical section cannot entered lock released. The following example compares synchronization approaches showing time available tasks access object significantly increased using synchronized block instead synchronizing entire method. In addition, shows unprotected class used multithreaded situation controlled protected another class: //: concurrency/CriticalSection.java // Synchronizing blocks instead entire methods. Also // demonstrates protection non-thread-safe class // thread-safe one. package concurrency; import java.util.concurrent.*; import java.util.concurrent.atomic.*; import java.util.*; class Pair { // Not thread-safe private int x, y; public Pair(int x, int y) { this.x = x; this.y = y; } public Pair() { this(0, 0); } public int getX() { return x; } public int getY() { return y; } public void incrementX() { x++; } public void incrementY() { y++; } public String toString() { return "x: " + x + ", y: " + y; } public class PairValuesNotEqualException extends RuntimeException { public PairValuesNotEqualException() { super("Pair values equal: " + Pair.this); } } // Arbitrary invariant -- variables must equal: public void checkState() { if(x != y) throw new PairValuesNotEqualException(); } } // Protect Pair inside thread-safe class: abstract class PairManager { AtomicInteger checkCounter = new AtomicInteger(0); protected Pair p = new Pair(); private List<Pair> storage = Collections.synchronizedList(new ArrayList<Pair>()); public synchronized Pair getPair() { // Make copy keep original safe: return new Pair(p.getX(), p.getY()); } // Assume time consuming operation protected void store(Pair p) { storage.add(p); try { TimeUnit.MILLISECONDS.sleep(50); 838 Thinking Java Bruce Eckel } } catch(InterruptedException ignore) {} } public abstract void increment(); // Synchronize entire method: class PairManager1 extends PairManager { public synchronized void increment() { p.incrementX(); p.incrementY(); store(getPair()); } } // Use critical section: class PairManager2 extends PairManager { public void increment() { Pair temp; synchronized(this) { p.incrementX(); p.incrementY(); temp = getPair(); } store(temp); } } class PairManipulator implements Runnable { private PairManager pm; public PairManipulator(PairManager pm) { this.pm = pm; } public void run() { while(true) pm.increment(); } public String toString() { return "Pair: " + pm.getPair() + " checkCounter = " + pm.checkCounter.get(); } } class PairChecker implements Runnable { private PairManager pm; public PairChecker(PairManager pm) { this.pm = pm; } public void run() { while(true) { pm.checkCounter.incrementAndGet(); pm.getPair().checkState(); } } } public class CriticalSection { // Test two different approaches: static void testApproaches(PairManager pman1, PairManager pman2) { ExecutorService exec = Executors.newCachedThreadPool(); PairManipulator pm1 = new PairManipulator(pman1), pm2 = new PairManipulator(pman2); Concurrency 839 PairChecker pcheck1 = new PairChecker(pman1), pcheck2 = new PairChecker(pman2); exec.execute(pm1); exec.execute(pm2); exec.execute(pcheck1); exec.execute(pcheck2); try { TimeUnit.MILLISECONDS.sleep(500); } catch(InterruptedException e) { System.out.println("Sleep interrupted"); } System.out.println("pm1: " + pm1 + "\npm2: " + pm2); System.exit(0); } public static void main(String[] args) { PairManager pman1 = new PairManager1(), pman2 = new PairManager2(); testApproaches(pman1, pman2); } } /* Output: (Sample) pm1: Pair: x: 15, y: 15 checkCounter = 272565 pm2: Pair: x: 16, y: 16 checkCounter = 3956974 *///:~ As noted, Pair thread-safe invariant (admittedly arbitrary) requires variables maintain values. In addition, seen earlier chapter, increment operations thread-safe, none methods synchronized, can’t trust Pair object stay uncorrupted threaded program. You imagine someone hands non-thread-safe Pair class, need use threaded environment. You creating PairManager class, holds Pair object controls access it. Note public methods getPair( ), synchronized, abstract increment( ). Synchronization increment( ) handled implemented. The structure PairManager, functionality implemented base class uses one abstract methods defined derived classes, called Template Method Design Patterns parlance. 15 Design patterns allow encapsulate change code; here, part changing method increment( ). In PairManager1 entire increment( ) method synchronized, PairManager2 part increment( ) synchronized using synchronized block. Note synchronized keyword part method signature thus may added overriding. The store( ) method adds Pair object synchronized ArrayList, operation thread safe. Thus, doesn’t need guarded, placed outside synchronized block PairManager2. PairManipulator created test two different types PairManagers calling increment( ) task PairChecker run another task. To trace often able run test, PairChecker increments checkCounter every time successful. In main( ), two PairManipulator objects created allowed run while, results PairManipulator shown. Although probably see lot variation output one run next, general see PairManager1.increment( ) allow PairChecker 15 840 See Design Patterns, Gamma et al. (Addison-Wesley, 1995). Thinking Java Bruce Eckel nearly much access PairManager2.increment( ), synchronized block thus provides unlocked time. This typically reason use synchronized block instead synchronizing whole method: allow tasks access (as long safe so). You also use explicit Lock objects create critical sections: //: concurrency/ExplicitCriticalSection.java // Using explicit Lock objects create critical sections. package concurrency; import java.util.concurrent.locks.*; // Synchronize entire method: class ExplicitPairManager1 extends PairManager { private Lock lock = new ReentrantLock(); public synchronized void increment() { lock.lock(); try { p.incrementX(); p.incrementY(); store(getPair()); } finally { lock.unlock(); } } } // Use critical section: class ExplicitPairManager2 extends PairManager { private Lock lock = new ReentrantLock(); public void increment() { Pair temp; lock.lock(); try { p.incrementX(); p.incrementY(); temp = getPair(); } finally { lock.unlock(); } store(temp); } } public class ExplicitCriticalSection { public static void main(String[] args) throws Exception { PairManager pman1 = new ExplicitPairManager1(), pman2 = new ExplicitPairManager2(); CriticalSection.testApproaches(pman1, pman2); } } /* Output: (Sample) pm1: Pair: x: 15, y: 15 checkCounter = 174035 pm2: Pair: x: 16, y: 16 checkCounter = 2608588 *///:~ This reuses CriticalSection.java creates new PairManager types use explicit Lock objects. ExplicitPairManager2 shows creation critical section using Lock object; call store( ) outside critical section. Synchronizing objects Concurrency 841 A synchronized block must given object synchronize upon, usually sensible object use current object method called for: synchronized(this), approach taken PairManager2. That way, lock acquired synchronized block, synchronized methods critical sections object cannot called. So effect critical section, synchronizing this, simply reduce scope synchronization. Sometimes must synchronize another object, must ensure relevant tasks synchronizing object. The following example demonstrates two tasks enter object methods object synchronize different locks: //: concurrency/SyncObject.java // Synchronizing another object. import static net.mindview.util.Print.*; class DualSynch { private Object syncObject = new Object(); public synchronized void f() { for(int = 0; < 5; i++) { print("f()"); Thread.yield(); } } public void g() { synchronized(syncObject) { for(int = 0; < 5; i++) { print("g()"); Thread.yield(); } } } } public class SyncObject { public static void main(String[] args) { final DualSynch ds = new DualSynch(); new Thread() { public void run() { ds.f(); } }.start(); ds.g(); } } /* Output: (Sample) g() f() g() f() g() f() g() f() g() f() *///:~ DualSync.f( ) synchronizes (by synchronizing entire method), g( ) synchronized block synchronizes syncObject. Thus, two synchronizations independent. This demonstrated main( ) creating Thread calls f( ). The main( ) thread used call g( ). You see output methods running time, neither one blocked synchronization other. 842 Thinking Java Bruce Eckel Exercise 15: (1) Create class three methods containing critical sections synchronize object. Create multiple tasks demonstrate one methods run time. Now modify methods one synchronizes different object show three methods running once. Exercise 16: (1) Modify Exercise 15 use explicit Lock objects. Thread local storage A second way prevent tasks colliding shared resources eliminate sharing variables. Thread local storage mechanism automatically creates different storage variable, different thread uses object. Thus, five threads using object variable x, thread local storage generates five different pieces storage x. Basically, allow associate state thread. The creation management thread local storage taken care java.lang.ThreadLocal class, seen here: //: concurrency/ThreadLocalVariableHolder.java // Automatically giving thread storage. import java.util.concurrent.*; import java.util.*; class Accessor implements Runnable { private final int id; public Accessor(int idn) { id = idn; } public void run() { while(!Thread.currentThread().isInterrupted()) { ThreadLocalVariableHolder.increment(); System.out.println(this); Thread.yield(); } } public String toString() { return "#" + id + ": " + ThreadLocalVariableHolder.get(); } } public class ThreadLocalVariableHolder { private static ThreadLocal<Integer> value = new ThreadLocal<Integer>() { private Random rand = new Random(47); protected synchronized Integer initialValue() { return rand.nextInt(10000); } }; public static void increment() { value.set(value.get() + 1); } public static int get() { return value.get(); } public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < 5; i++) exec.execute(new Accessor(i)); TimeUnit.SECONDS.sleep(3); // Run exec.shutdownNow(); // All Accessors quit } } /* Output: (Sample) #0: 9259 Concurrency 843 #1: 556 #2: 6694 #3: 1862 #4: 962 #0: 9260 #1: 557 #2: 6695 #3: 1863 #4: 963 ... *///:~ ThreadLocal objects usually stored static fields. When create ThreadLocal object, able access contents object using get( ) set( ) methods. The get( ) method returns copy object associated thread, set( ) inserts argument object stored thread, returning old object storage. The increment( ) get( ) methods demonstrate ThreadLocalVariableHolder. Notice increment( ) get( ) synchronized, ThreadLocal guarantees race condition occur. When run program, you’ll see evidence individual threads allocated storage, since one keeps count even though there’s one ThreadLocalVariableHolder object. Terminating tasks In previous examples, cancel( ) isCanceled( ) methods placed class seen tasks. The tasks check isCanceled( ) determine terminate themselves. This reasonable approach problem. However, situations task must terminated abruptly. In section, you’ll learn issues problems termination. First, let’s look example demonstrates termination problem also additional example resource sharing. The ornamental garden In simulation, garden committee would like know many people enter garden day multiple gates. Each gate turnstile kind counter, turnstile count incremented, shared count incremented represents total number people garden. //: concurrency/OrnamentalGarden.java import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; class Count { private int count = 0; private Random rand = new Random(47); // Remove synchronized keyword see counting fail: public synchronized int increment() { int temp = count; if(rand.nextBoolean()) // Yield half time Thread.yield(); return (count = ++temp); } 844 Thinking Java Bruce Eckel } public synchronized int value() { return count; } class Entrance implements Runnable { private static Count count = new Count(); private static List<Entrance> entrances = new ArrayList<Entrance>(); private int number = 0; // Doesn’t need synchronization read: private final int id; private static volatile boolean canceled = false; // Atomic operation volatile field: public static void cancel() { canceled = true; } public Entrance(int id) { this.id = id; // Keep task list. Also prevents // garbage collection dead tasks: entrances.add(this); } public void run() { while(!canceled) { synchronized(this) { ++number; } print(this + " Total: " + count.increment()); try { TimeUnit.MILLISECONDS.sleep(100); } catch(InterruptedException e) { print("sleep interrupted"); } } print("Stopping " + this); } public synchronized int getValue() { return number; } public String toString() { return "Entrance " + id + ": " + getValue(); } public static int getTotalCount() { return count.value(); } public static int sumEntrances() { int sum = 0; for(Entrance entrance : entrances) sum += entrance.getValue(); return sum; } } public class OrnamentalGarden { public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < 5; i++) exec.execute(new Entrance(i)); // Run while, stop collect data: TimeUnit.SECONDS.sleep(3); Entrance.cancel(); exec.shutdown(); if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS)) print("Some tasks terminated!"); print("Total: " + Entrance.getTotalCount()); print("Sum Entrances: " + Entrance.sumEntrances()); } } /* Output: (Sample) Concurrency 845 Entrance 0: 1 Total: 1 Entrance 2: 1 Total: 3 Entrance 1: 1 Total: 2 Entrance 4: 1 Total: 5 Entrance 3: 1 Total: 4 Entrance 2: 2 Total: 6 Entrance 4: 2 Total: 7 Entrance 0: 2 Total: 8 ... Entrance 3: 29 Total: 143 Entrance 0: 29 Total: 144 Entrance 4: 29 Total: 145 Entrance 2: 30 Total: 147 Entrance 1: 30 Total: 146 Entrance 0: 30 Total: 149 Entrance 3: 30 Total: 148 Entrance 4: 30 Total: 150 Stopping Entrance 2: 30 Stopping Entrance 1: 30 Stopping Entrance 0: 30 Stopping Entrance 3: 30 Stopping Entrance 4: 30 Total: 150 Sum Entrances: 150 *///:~ A single Count object keeps master count garden visitors, stored static field Entrance class. Count.increment( ) Count.value( ) synchronized control access count field. The increment( ) method uses Random object cause yield( ) roughly half time, fetching count temp incrementing storing temp back count. If comment synchronized keyword increment( ), program breaks multiple tasks accessing modifying count simultaneously (the yield( ) causes problem happen quickly). Each Entrance task keeps local value number containing number visitors passed particular entrance. This provides double check count object make sure proper number visitors recorded. Entrance.run( ) simply increments number count object sleeps 100 milliseconds. Because Entrance.canceled volatile boolean flag read assigned (and never read combination fields), it’s possible get away without synchronizing access it. If doubts something like this, it’s always better use synchronized. This program goes quite bit extra trouble shut everything stable fashion. Part reason show careful must terminating multithreaded program, part reason demonstrate value interrupt( ), learn shortly. After 3 seconds, main( ) sends static cancel( ) message Entrance, calls shutdown( ) exec object, calls awaitTermination( ) exec. ExecutorService.awaitTermination( ) waits task complete, complete timeout value, returns true, otherwise returns false indicate tasks completed. Although causes task exit run( ) method therefore terminate task, Entrance objects still valid because, constructor, Entrance object stored static List<Entrance> called entrances. Thus, sumEntrances( ) still working valid Entrance objects. 846 Thinking Java Bruce Eckel As program runs, see total count count entrance displayed people walk turnstile. If remove synchronized declaration Count.increment( ), you’ll notice total number people expect be. The number people counted turnstile different value count. As long mutex synchronize access Count, things work correctly. Keep mind Count.increment( ) exaggerates potential failure using temp yield( ). In real threading problems, possibility failure may statistically small, easily fall trap believing things working correctly. Just example above, likely hidden problems haven’t occurred you, exceptionally diligent reviewing concurrent code. Exercise 17: (2) Create radiation counter number remote sensors. Terminating blocked Entrance.run( ) previous example includes call sleep( ) loop. We know sleep( ) eventually wake task reach top loop, opportunity break loop checking cancelled flag. However, sleep( ) one situation task blocked executing, sometimes must terminate task that’s blocked. Thread states A thread one four states: 1. New: A thread remains state momentarily, created. It allocates necessary system resources performs initialization. At point becomes eligible receive CPU time. The scheduler transition thread runnable blocked state. 2. Runnable: This means thread run time-slicing mechanism CPU cycles available thread. Thus, thread might might running moment, there’s nothing prevent run scheduler arrange it. That is, it’s dead blocked. 3. Blocked: The thread run, something prevents it. While thread blocked state, scheduler simply skip give CPU time. Until thread reenters runnable state, won’t perform operations. 4. Dead: A thread dead terminated state longer schedulable receive CPU time. Its task completed, longer runnable. One way task die returning run( ) method, task’s thread also interrupted, you’ll see shortly. Becoming blocked A task become blocked following reasons: • You’ve put task sleep calling sleep(milliseconds), case run specified time. • You’ve suspended execution thread wait( ). It become runnable thread gets notify( ) notifyAll( ) message (or equivalent signal( ) signalAll( ) Java SE5 java.util.concurrent library tools). We’ll examine later section. Concurrency 847 • The task waiting I/O complete. • The task trying call synchronized method another object, object’s lock available already acquired another task. In old code, may also see suspend( ) resume( ) used block unblock threads, deprecated modern Java (because deadlock-prone), examined book. The stop( ) method also deprecated, doesn’t release locks thread acquired, objects inconsistent state ("damaged"), tasks view modify state. The resulting problems subtle difficult detect. The problem need look this: Sometimes want terminate task blocked state. If can’t wait get point code check state value decide terminate own, force task blocked state. Interruption As might imagine, it’s much messier break middle Runnable.run( ) method wait method get test "cancel" flag, place programmer ready leave method. When break blocked task, might need clean resources. Because this, breaking middle task’s run( ) like throwing exception anything else, Java threads, exceptions used kind abort. 16 (This walks fine edge inappropriate use exceptions, means often using control flow.) To return known good state terminating task way, must carefully consider execution paths code write catch clause properly clean everything up. So terminate blocked task, Thread class contains interrupt( ) method. This sets interrupted status thread. A thread interrupted status set throw InterruptedException already blocked attempts blocking operation. The interrupted status reset exception thrown task calls Thread.interrupted( ). As you’ll see, Thread.interrupted( ) provides second way leave run( ) loop, without throwing exception. To call interrupt( ), must hold Thread object. You may noticed new concurrent library seems avoid direct manipulation Thread objects instead tries everything Executors. If call shutdownNow( ) Executor, send interrupt( ) call threads started. This makes sense you’ll usually want shut tasks particular Executor once, you’ve finished part project whole program. However, times may want interrupt single task. If you’re using Executors, hold context task start calling submit( ) instead execute( ). submit( ) returns generic Future<?>, unspecified parameter won’t ever call get( ) it— point holding kind Future call cancel( ) thus use interrupt particular task. If pass true cancel( ), permission call interrupt( ) thread order stop it; thus cancel( ) way interrupt individual threads started Executor. Here’s example shows basics interrupt( ) using Executors: //: concurrency/Interrupting.java However, exceptions never delivered asynchronously. Thus, danger something aborting midinstruction/method call. And long use try-finally idiom using object mutexes (vs. synchronized keyword), mutexes automatically released exception thrown. 16 848 Thinking Java Bruce Eckel // Interrupting blocked thread. import java.util.concurrent.*; import java.io.*; import static net.mindview.util.Print.*; class SleepBlocked implements Runnable { public void run() { try { TimeUnit.SECONDS.sleep(100); } catch(InterruptedException e) { print("InterruptedException"); } print("Exiting SleepBlocked.run()"); } } class IOBlocked implements Runnable { private InputStream in; public IOBlocked(InputStream is) { = is; } public void run() { try { print("Waiting read():"); in.read(); } catch(IOException e) { if(Thread.currentThread().isInterrupted()) { print("Interrupted blocked I/O"); } else { throw new RuntimeException(e); } } print("Exiting IOBlocked.run()"); } } class SynchronizedBlocked implements Runnable { public synchronized void f() { while(true) // Never releases lock Thread.yield(); } public SynchronizedBlocked() { new Thread() { public void run() { f(); // Lock acquired thread } }.start(); } public void run() { print("Trying call f()"); f(); print("Exiting SynchronizedBlocked.run()"); } } public class Interrupting { private static ExecutorService exec = Executors.newCachedThreadPool(); static void test(Runnable r) throws InterruptedException{ Future<?> f = exec.submit(r); TimeUnit.MILLISECONDS.sleep(100); print("Interrupting " + r.getClass().getName()); f.cancel(true); // Interrupts running print("Interrupt sent " + r.getClass().getName()); } Concurrency 849 public static void main(String[] args) throws Exception { test(new SleepBlocked()); test(new IOBlocked(System.in)); test(new SynchronizedBlocked()); TimeUnit.SECONDS.sleep(3); print("Aborting System.exit(0)"); System.exit(0); // ... since last 2 interrupts failed } } /* Output: (95% match) Interrupting SleepBlocked InterruptedException Exiting SleepBlocked.run() Interrupt sent SleepBlocked Waiting read(): Interrupting IOBlocked Interrupt sent IOBlocked Trying call f() Interrupting SynchronizedBlocked Interrupt sent SynchronizedBlocked Aborting System.exit(0) *///:~ Each task represents different kind blocking. SleepBlock example interruptible blocking, whereas IOBlocked SynchronizedBlocked uninterruptible blocking. 17 The program proves I/O waiting synchronized lock interruptible, also anticipate looking code—no InterruptedException handler required either I/O attempting call synchronized method. The first two classes straightforward: The run( ) method calls sleep( ) first class read( ) second. To demonstrate SynchronizedBlocked, however, must first acquire lock. This accomplished constructor creating instance anonymous Thread class acquires object lock calling f( ) (the thread must different one driving run( ) SynchronizedBlock one thread acquire object lock multiple times). Since f( ) never returns, lock never released. SynchronizedBlock.run( ) attempts call f( ) blocked waiting lock released. You’ll see output interrupt call sleep( ) (or call requires catch InterruptedException). However, cannot interrupt task trying acquire synchronized lock one trying perform I/O. This little disconcerting, especially you’re creating task performs I/O, means I/O potential locking multithreaded program. Especially Web-based programs, concern. A heavy-handed sometimes effective solution problem close underlying resource task blocked: //: concurrency/CloseResource.java // Interrupting blocked task // closing underlying resource. // {RunByHand} import java.net.*; import java.util.concurrent.*; import java.io.*; import static net.mindview.util.Print.*; 17 Some releases JDK also provided support InterruptedIOException. However, partially implemented, platforms. If exception thrown, causes 10 objects unusable. Future releases unlikely continue support exception. 850 Thinking Java Bruce Eckel public class CloseResource { public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InputStream socketInput = new Socket("localhost", 8080).getInputStream(); exec.execute(new IOBlocked(socketInput)); exec.execute(new IOBlocked(System.in)); TimeUnit.MILLISECONDS.sleep(100); print("Shutting threads"); exec.shutdownNow(); TimeUnit.SECONDS.sleep(1); print("Closing " + socketInput.getClass().getName()); socketInput.close(); // Releases blocked thread TimeUnit.SECONDS.sleep(1); print("Closing " + System.in.getClass().getName()); System.in.close(); // Releases blocked thread } } /* Output: (85% match) Waiting read(): Waiting read(): Shutting threads Closing java.net.SocketInputStream Interrupted blocked I/O Exiting IOBlocked.run() Closing java.io.BufferedInputStream Exiting IOBlocked.run() *///:~ After shutdownNow( ) called, delays calling close( ) two input streams emphasize tasks unblock underlying resource closed. It’s interesting note interrupt( ) appears closing Socket closing System.in. Fortunately, nio classes introduced I/O chapter provide civilized interruption I/O. Blocked nio channels automatically respond interrupts: //: concurrency/NIOInterruption.java // Interrupting blocked NIO channel. import java.net.*; import java.nio.*; import java.nio.channels.*; import java.util.concurrent.*; import java.io.*; import static net.mindview.util.Print.*; class NIOBlocked implements Runnable { private final SocketChannel sc; public NIOBlocked(SocketChannel sc) { this.sc = sc; } public void run() { try { print("Waiting read() " + this); sc.read(ByteBuffer.allocate(1)); } catch(ClosedByInterruptException e) { print("ClosedByInterruptException"); } catch(AsynchronousCloseException e) { print("AsynchronousCloseException"); } catch(IOException e) { throw new RuntimeException(e); } print("Exiting NIOBlocked.run() " + this); } Concurrency 851 } public class NIOInterruption { public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InetSocketAddress isa = new InetSocketAddress("localhost", 8080); SocketChannel sc1 = SocketChannel.open(isa); SocketChannel sc2 = SocketChannel.open(isa); Future<?> f = exec.submit(new NIOBlocked(sc1)); exec.execute(new NIOBlocked(sc2)); exec.shutdown(); TimeUnit.SECONDS.sleep(1); // Produce interrupt via cancel: f.cancel(true); TimeUnit.SECONDS.sleep(1); // Release block closing channel: sc2.close(); } } /* Output: (Sample) Waiting read() NIOBlocked@7a84e4 Waiting read() NIOBlocked@15c7850 ClosedByInterruptException Exiting NIOBlocked.run() NIOBlocked@15c7850 AsynchronousCloseException Exiting NIOBlocked.run() NIOBlocked@7a84e4 *///:~ As shown, also close underlying channel release block, although rarely necessary. Note using execute( ) start tasks calling e.shutdownNow( ) easily terminate everything; capturing Future example necessary send interrupt one thread other. 18 Exercise 18: (2) Create non-task class method calls sleep( ) long interval. Create task calls method non-task class. In main( ), start task, call interrupt( ) terminate it. Make sure task shuts safely. Exercise 19: (4) Modify OrnamentalGarden.java uses interrupt( ). Exercise 20: (1) Modify CachedThreadPool.java tasks receive interrupt( ) completed. Blocked mutex As saw Interrupting.java, try call synchronized method object whose lock already acquired, calling task suspended (blocked) lock becomes available. The following example shows mutex multiply acquired task: //: concurrency/MultiLock.java // One thread reacquire lock. import static net.mindview.util.Print.*; public class MultiLock { public synchronized void f1(int count) { if(count-- > 0) { 18 852 Ervin Varga helped research section. Thinking Java Bruce Eckel print("f1() calling f2() count " + count); f2(count); } } public synchronized void f2(int count) { if(count-- > 0) { print("f2() calling f1() count " + count); f1(count); } } public static void main(String[] args) throws Exception { final MultiLock multiLock = new MultiLock(); new Thread() { public void run() { multiLock.f1(10); } }.start(); } } /* Output: f1() calling f2() count 9 f2() calling f1() count 8 f1() calling f2() count 7 f2() calling f1() count 6 f1() calling f2() count 5 f2() calling f1() count 4 f1() calling f2() count 3 f2() calling f1() count 2 f1() calling f2() count 1 f2() calling f1() count 0 *///:~ In main( ), Thread created call f1( ), f1( ) f2( ) call count becomes zero. Since task already acquired multiLock object lock inside first call f1( ), task reacquiring call f2( ), on. This makes sense one task able call synchronized methods within object; task already holds lock. As observed previously uninterruptible I/O, anytime task blocked way cannot interrupted, potential lock program. One features added Java SE5 concurrency libraries ability tasks blocked ReentrantLocks interrupted, unlike tasks blocked synchronized methods critical sections: //: concurrency/Interrupting2.java // Interrupting task blocked ReentrantLock. import java.util.concurrent.*; import java.util.concurrent.locks.*; import static net.mindview.util.Print.*; class BlockedMutex { private Lock lock = new ReentrantLock(); public BlockedMutex() { // Acquire right away, demonstrate interruption // task blocked ReentrantLock: lock.lock(); } public void f() { try { // This never available second task lock.lockInterruptibly(); // Special call print("lock acquired f()"); } catch(InterruptedException e) { Concurrency 853 } } print("Interrupted lock acquisition f()"); } class Blocked2 implements Runnable { BlockedMutex blocked = new BlockedMutex(); public void run() { print("Waiting f() BlockedMutex"); blocked.f(); print("Broken blocked call"); } } public class Interrupting2 { public static void main(String[] args) throws Exception { Thread = new Thread(new Blocked2()); t.start(); TimeUnit.SECONDS.sleep(1); System.out.println("Issuing t.interrupt()"); t.interrupt(); } } /* Output: Waiting f() BlockedMutex Issuing t.interrupt() Interrupted lock acquisition f() Broken blocked call *///:~ The class BlockedMutex constructor acquires object’s Lock never releases it. For reason, try call f( ) second task (different one created BlockedMutex), always blocked Mutex cannot acquired. In Blocked2, run( ) method stopped call blocked.f( ). When run program, you’ll see that, unlike I/O call, interrupt( ) break call that’s blocked mutex. 19 Checking interrupt Note call interrupt( ) thread, time interrupt occurs task enters, already inside, blocking operation (except, you’ve seen, case uninterruptible I/O blocked synchronized methods, case there’s nothing do). But you’ve written code may may make blocking call, depending conditions run? If exit throwing exception blocking call, won’t always able leave run( ) loop. Thus, call interrupt( ) stop task, task needs second way exit event run( ) loop doesn’t happen making blocking calls. This opportunity presented interrupted status, set call interrupt( ). You check interrupted status calling interrupted( ). This tells whether interrupt( ) called, also clears interrupted status. Clearing interrupted status ensures framework notify twice task interrupted. You notified via either single InterruptedException single successful Thread.interrupted( ) test. If want check see whether interrupted, store result call Thread.interrupted( ). The following example shows typical idiom use run( ) method handle blocked non-blocked possibilities interrupted status set: 19 854 Note that, although it’s unlikely, call t.interrupt( ) could actually happen call blocked.f( ). Thinking Java Bruce Eckel //: concurrency/InterruptingIdiom.java // General idiom interrupting task. // {Args: 1100} import java.util.concurrent.*; import static net.mindview.util.Print.*; class NeedsCleanup { private final int id; public NeedsCleanup(int ident) { id = ident; print("NeedsCleanup " + id); } public void cleanup() { print("Cleaning " + id); } } class Blocked3 implements Runnable { private volatile double = 0.0; public void run() { try { while(!Thread.interrupted()) { // point1 NeedsCleanup n1 = new NeedsCleanup(1); // Start try-finally immediately definition // n1, guarantee proper cleanup n1: try { print("Sleeping"); TimeUnit.SECONDS.sleep(1); // point2 NeedsCleanup n2 = new NeedsCleanup(2); // Guarantee proper cleanup n2: try { print("Calculating"); // A time-consuming, non-blocking operation: for(int = 1; < 2500000; i++) = + (Math.PI + Math.E) / d; print("Finished time-consuming operation"); } finally { n2.cleanup(); } } finally { n1.cleanup(); } } print("Exiting via while() test"); } catch(InterruptedException e) { print("Exiting via InterruptedException"); } } } public class InterruptingIdiom { public static void main(String[] args) throws Exception { if(args.length != 1) { print("usage: java InterruptingIdiom delay-in-mS"); System.exit(1); } Thread = new Thread(new Blocked3()); t.start(); TimeUnit.MILLISECONDS.sleep(new Integer(args[0])); t.interrupt(); } Concurrency 855 } /* Output: (Sample) NeedsCleanup 1 Sleeping NeedsCleanup 2 Calculating Finished time-consuming operation Cleaning 2 Cleaning 1 NeedsCleanup 1 Sleeping Cleaning 1 Exiting via InterruptedException *///:~ The NeedsCleanup class emphasizes necessity proper resource cleanup leave loop via exception. Note NeedsCleanup resources created Blocked3.run( ) must immediately followed try-finally clauses guarantee cleanup( ) method always called. You must give program command-line argument delay time milliseconds calls interrupt( ). By using different delays, exit Blocked3.run( ) different points loop: blocking sleep( ) call, non-blocking mathematical calculation. You’ll see interrupt( ) called comment "point2" (during non-blocking operation), first loop completed, local objects destroyed, finally loop exited top via statement. However, interrupt( ) called "pointi" "point2" (after statement blocking operation sleep( )), task exits via InterruptedException, first time blocking operation attempted. In case, NeedsCleanup objects created point exception thrown cleaned up, opportunity perform cleanup catch clause. A class designed respond interrupt( ) must establish policy ensure remain consistent state. This generally means creation objects require cleanup must followed try-finally clauses cleanup occur regardless run( ) loop exits. Code like work well, alas, due lack automatic destructor calls Java, relies client programmer write proper try-finally clauses. Cooperation tasks As you’ve seen, use threads run one task time, keep one task interfering another task’s resources using lock (mutex) synchronize behavior two tasks. That is, two tasks stepping shared resource (usually memory), use mutex allow one task time access resource. With problem solved, next step learn make tasks cooperate other, multiple tasks work together solve problem. Now issue interfering one another, rather working unison, since portions problems must solved portions solved. It’s much like project planning: The footings house must dug first, steel laid concrete forms built parallel, tasks must finished concrete foundation poured. The plumbing must place concrete slab poured, concrete slab must place start framing, on. Some tasks done parallel, certain steps require tasks completed move ahead. 856 Thinking Java Bruce Eckel The key issue tasks cooperating handshaking tasks. To accomplish handshaking, use foundation: mutex, case guarantees one task respond signal. This eliminates possible race conditions. On top mutex, add way task suspend external state changes (e.g., "The plumbing place"), indicating it’s time task move forward. In section, we’ll look issues handshaking tasks, safely implemented using Object methods wait( ) notifyAll( ). The Java SE5 concurrency library also provides Condition objects await( ) signal( ) methods. We’ll see problems arise, solutions. wait() notifyAll() wait( ) allows wait change condition outside control forces current method. Often, condition changed another task. You don’t want idly loop testing condition inside task; called busy waiting, it’s usually bad use CPU cycles. So wait( ) suspends task waiting world change, notify( ) notifyAll( ) occurs—suggesting something interest may happened—does task wake check changes. Thus, wait( ) provides way synchronize activities tasks. It’s important understand sleep( ) release object lock called, neither yield( ). On hand, task enters call wait( ) inside method, thread’s execution suspended, lock object released. Because wait( ) releases lock, means lock acquired another task, synchronized methods (now unlocked) object called wait( ). This essential, methods typically cause change makes interesting suspended task reawaken. Thus, call wait( ), you’re saying, "I’ve done I right now, I’m going wait right here, I want allow synchronized operations take place can." There two forms wait( ). One version takes argument milliseconds meaning sleep( ): "Pause period time." But unlike sleep( ), wait(pause): 1. The object lock released wait( ). 2. You also come wait( ) due notify( ) notifyAll( ), addition letting clock run out. The second, commonly used form wait( ) takes arguments. This wait( ) continues indefinitely thread receives notify( ) notifyAll( ). One fairly unique aspect wait( ), notify( ), notifyAll( ) methods part base class Object part Thread. Although seems bit strange first—to something that’s exclusively threading part universal base class— it’s essential methods manipulate lock that’s also part every object. As result, put wait( ) inside synchronized method, regardless whether class extends Thread implements Runnable. In fact, place call wait( ), notify( ), notifyAll( ) within synchronized method block (sleep( ) called within non-synchronized methods since doesn’t manipulate lock). If call within method that’s synchronized, program compile, run it, you’ll get IllegalMonitorStateException somewhat nonintuitive message "current thread owner." This message means task calling wait( ), notify( ), notifyAll( ) must "own" (acquire) lock object call methods. Concurrency 857 You ask another object perform operation manipulates lock. To this, must first capture object’s lock. For example, want send notifyAll( ) object x, must inside synchronized block acquires lock x: synchronized(x) { x.notifyAll(); } Let’s look simple example. WaxOMatic.java two processes: one apply wax Car one polish it. The polishing task cannot job application task finished, application task must wait polishing task finished put another coat wax. Both WaxOn WaxOff use Car object, uses wait( ) notifyAll( ) suspend restart tasks they’re waiting condition change: //: concurrency/waxomatic/WaxOMatic.java // Basic task cooperation. package concurrency.waxomatic; import java.util.concurrent.*; import static net.mindview.util.Print.*; class Car { private boolean waxOn = false; public synchronized void waxed() { waxOn = true; // Ready buff notifyAll(); } public synchronized void buffed() { waxOn = false; // Ready another coat wax notifyAll(); } public synchronized void waitForWaxing() throws InterruptedException { while(waxOn == false) wait(); } public synchronized void waitForBuffing() throws InterruptedException { while(waxOn == true) wait(); } } class WaxOn implements Runnable { private Car car; public WaxOn(Car c) { car = c; } public void run() { try { while(!Thread.interrupted()) { printnb("Wax On! "); TimeUnit.MILLISECONDS.sleep(200); car.waxed(); car.waitForBuffing(); } } catch(InterruptedException e) { print("Exiting via interrupt"); } print("Ending Wax On task"); } } class WaxOff implements Runnable { 858 Thinking Java Bruce Eckel } private Car car; public WaxOff(Car c) { car = c; } public void run() { try { while(!Thread.interrupted()) { car.waitForWaxing(); printnb("Wax Off! "); TimeUnit.MILLISECONDS.sleep(200); car.buffed(); } } catch(InterruptedException e) { print("Exiting via interrupt"); } print("Ending Wax Off task"); } public class WaxOMatic { public static void main(String[] args) throws Exception { Car car = new Car(); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new WaxOff(car)); exec.execute(new WaxOn(car)); TimeUnit.SECONDS.sleep(5); // Run while... exec.shutdownNow(); // Interrupt tasks } } /* Output: (95% match) Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt Ending Wax On task Exiting via interrupt Ending Wax Off task *///:~ Here, Car single boolean waxOn, indicates state waxing-polishing process. In waitForWaxing( ), waxOn flag checked, false, calling task suspended calling wait( ). It’s important occur synchronized method, task acquired lock. When call wait( ), thread suspended lock released. It essential lock released because, safely change state object (for example, change waxOn true, must happen suspended task ever continue), lock must available acquired task. In example, another task calls waxed( ) indicate it’s time something, lock must acquired order change waxOn true. Afterward, waxed( ) calls notifyAll( ), wakes task suspended call wait( ). In order task wake wait( ), must first reacquire lock released entered wait( ). The task wake lock becomes available. 20 WaxOn.run( ) represents first step process waxing car, performs operation: call sleep( ) simulate time necessary waxing. It tells car waxing complete, calls waitForBuffing( ), suspends task 20 On platforms there’s third way come wait( ): so-called spurious wake-up. A spurious wake-up essentially means thread may prematurely stop blocking (while waiting condition variable semaphore) without prompted notify( ) notifyAll( ) (or equivalents new Condition objects). The thread wakes up, seemingly itself. Spurious wake-ups exist implementing POSIX threads, equivalent, isn’t always straightforward platforms. Allowing spurious wake-ups makes job building library like pthreads easier platforms. Concurrency 859 wait( ) WaxOff task calls buffed( ) car, changing state calling notifyAll( ). WaxOff.run( ), hand, immediately moves waitForWaxing( ) thus suspended wax applied WaxOn waxed( ) called. When run program, watch two-step process repeat control handed back forth two tasks. After five seconds, interrupt( ) halts threads; call shutdownNow( ) ExecutorService, calls interrupt( ) tasks controlling. The previous example emphasizes must surround wait( ) loop checks condition(s) interest. This important because: • You may multiple tasks waiting lock reason, first task wakes might change situation (even don’t someone might inherit class it). If case, task suspended condition interest changes. • By time task awakens wait( ), it’s possible task changed things task unable perform uninterested performing operation time. Again, resuspended calling wait( ) again. • It’s also possible tasks could waiting object’s lock different reasons (in case must use notifyAll( )). In case, need check whether you’ve woken right reason, not, call wait( ) again. Thus, it’s essential check particular condition interest, go back wait( ) condition met. This idiomatically written using while. Exercise 21: (2) Create two Runnables, one run( ) starts calls wait( ). The second class capture reference first Runnable object. Its run( ) call notifyAll( ) first task number seconds passed first task display message. Test classes using Executor. Exercise 22: (4) Create example busy wait. One task sleeps sets flag true. The second task watches flag inside loop (this busy wait) flag becomes true, sets back false reports change console. Note much wasted time program spends inside busy wait, create second version program uses wait( ) instead busy wait. Missed Signals When two threads coordinated using notify( )/wait( ) notifyAll( )/wait( ), it’s possible miss signal. Suppose T1 thread notifies T2, two threads implemented using following (flawed) approach: T1: synchronized(sharedMonitor) { <setup condition T2> sharedMonitor.notify(); } T2: while(someCondition) { // Point 1 synchronized(sharedMonitor) { sharedMonitor.wait(); } } 860 Thinking Java Bruce Eckel The <setup condition T2> action prevent T2 calling wait( ), hasn’t already. Assume T2 evaluates someCondition finds true. At Point 1, thread scheduler might switch T1. T1 executes setup, calls notify( ). When T2 continues executing, late T2 realize condition changed meantime, blindly enter wait( ). The notify( ) missed T2 wait indefinitely signal already sent, producing deadlock. The solution prevent race condition someCondition variable. Here correct approach T2: synchronized(sharedMonitor) { while(someCondition) sharedMonitor.wait(); } Now, T1 executes first, control returns back T2 figure condition changed, enter wait( ). Conversely, T2 executes first, enter wait( ) later awakened T1. Thus, signal cannot missed. notify() vs. notifyAll() Because one task could technically wait( ) single Car object, safer call notifyAll( ) rather notify( ). However, structure program one task actually wait( ), could use notify( ) instead notifyAll( ). Using notify( ) instead notifyAll( ) optimization. Only one task possible many waiting lock awoken notify( ), must certain right task wake try use notify( ). In addition, tasks must waiting condition order use notify( ), tasks waiting different conditions, don’t know right one wake up. If use notify( ), one task must benefit condition changes. Finally, constraints must always true possible subclasses. If rules cannot met, must use notifyAll( ) rather notify( ). One confusing statements often made discussions Java threading notifyAll( ) wakes "all waiting tasks." Does mean task wait( ), anywhere program, awoken call notifyAll( )? In following example, code associated Task2 shows true—in fact, tasks waiting particular lock awoken notifyAll( ) called/or lock: //: concurrency/NotifyVsNotifyAll.java import java.util.concurrent.*; import java.util.*; class Blocker { synchronized void waitingCall() { try { while(!Thread.interrupted()) { wait(); System.out.print(Thread.currentThread() + " "); } } catch(InterruptedException e) { // OK exit way } } Concurrency 861 synchronized void prod() { notify(); } synchronized void prodAll() { notifyAll(); } } class Task implements Runnable { static Blocker blocker = new Blocker(); public void run() { blocker.waitingCall(); } } class Task2 implements Runnable { // A separate Blocker object: static Blocker blocker = new Blocker(); public void run() { blocker.waitingCall(); } } public class NotifyVsNotifyAll { public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < 5; i++) exec.execute(new Task()); exec.execute(new Task2()); Timer timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() { boolean prod = true; public void run() { if(prod) { System.out.print("\nnotify() "); Task.blocker.prod(); prod = false; } else { System.out.print("\nnotifyAll() "); Task.blocker.prodAll(); prod = true; } } }, 400, 400); // Run every .4 second TimeUnit.SECONDS.sleep(5); // Run while... timer.cancel(); System.out.println("\nTimer canceled"); TimeUnit.MILLISECONDS.sleep(500); System.out.print("Task2.blocker.prodAll() "); Task2.blocker.prodAll(); TimeUnit.MILLISECONDS.sleep(500); System.out.println("\nShutting down"); exec.shutdownNow(); // Interrupt tasks } } /* Output: (Sample) notify() Thread[pool-1-thread-1,5,main] notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main] notify() Thread[pool-1-thread-1,5,main] notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main] notify() Thread[pool-1-thread-1,5,main] notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main] notify() Thread[pool-1-thread-1,5,main] notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main] 862 Thinking Java Bruce Eckel notify() Thread[pool-1-thread-1,5,main] notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread5,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-2,5,main] notify() Thread[pool-1-thread-1,5,main] notifyAll() Thread[pool-1-thread-1,5,main] Thread[pool-1-thread2,5,main] Thread[pool-1-thread-3,5,main] Thread[pool-1-thread-4,5,main] Thread[pool-1-thread-5,5,main] Timer canceled Task2.blocker.prodAll() Thread[pool-1-thread-6,5,main] Shutting *///:~ Task Task2 Blocker object, Task object blocks Task.blocker, Task2 object blocks Task2.blocker. In main( ), java.util.Timer object set execute run( ) method every 4/10 second, run( ) alternates calling notify( ) notifyAll( ) Task.blocker via "prod" methods. From output, see even though Task2 object exists blocked Task2.blocker, none notify( ) notifyAll( ) calls Task.blocker causes Task2 object wake up. Similarly, end main( ), cancel( ) called timer, even though timer canceled, first five tasks still running still blocked calls Task.blocker.waitingCall( ). The output call Task2.blocker.prodAll( ) include tasks waiting lock Task.blocker. This also makes sense look prod( ) prodAll( ) Blocker. These methods synchronized, means acquire lock, call notify( ) notifyAll( ), it’s logical calling lock—and thus wake tasks waiting particular lock. Blocker.waitingCall( ) simple enough could say for(;;) instead while(!Thread.interrupted( )), achieve effect case, example there’s difference leaving loop exception leaving checking interrupted( ) flag— code executed cases. As matter form, however, example checks interrupted( ), two different ways leaving loop. If, sometime later, decide add code loop, risk introducing error don’t cover paths exit loop. Exercise 23: (7) Demonstrate WaxOMatic.java works successfully use notify( ) instead notifyAll( ). Producers consumers Consider restaurant one chef one waitperson. The waitperson must wait chef prepare meal. When chef meal ready, chef notifies waitperson, gets delivers meal goes back waiting. This example task cooperation: The chef represents producer, waitperson represents consumer. Both tasks must handshake meals produced consumed, system must shut orderly fashion. Here story modeled code: //: concurrency/Restaurant.java // The producer-consumer approach task cooperation. import java.util.concurrent.*; import static net.mindview.util.Print.*; class Meal { Concurrency 863 } private final int orderNum; public Meal(int orderNum) { this.orderNum = orderNum; } public String toString() { return "Meal " + orderNum; } class WaitPerson implements Runnable { private Restaurant restaurant; public WaitPerson(Restaurant r) { restaurant = r; } public void run() { try { while(!Thread.interrupted()) { synchronized(this) { while(restaurant.meal == null) wait(); // ... chef produce meal } print("Waitperson got " + restaurant.meal); synchronized(restaurant.chef) { restaurant.meal = null; restaurant.chef.notifyAll(); // Ready another } } } catch(InterruptedException e) { print("WaitPerson interrupted"); } } } class Chef implements Runnable { private Restaurant restaurant; private int count = 0; public Chef(Restaurant r) { restaurant = r; } public void run() { try { while(!Thread.interrupted()) { synchronized(this) { while(restaurant.meal != null) wait(); // ... meal taken } if(++count == 10) { print("Out food, closing"); restaurant.exec.shutdownNow(); } printnb("Order up! "); synchronized(restaurant.waitPerson) { restaurant.meal = new Meal(count); restaurant.waitPerson.notifyAll(); } TimeUnit.MILLISECONDS.sleep(100); } } catch(InterruptedException e) { print("Chef interrupted"); } } } public class Restaurant { Meal meal; ExecutorService exec = Executors.newCachedThreadPool(); WaitPerson waitPerson = new WaitPerson(this); Chef chef = new Chef(this); public Restaurant() { exec.execute(chef); exec.execute(waitPerson); 864 Thinking Java Bruce Eckel } public static void main(String[] args) { new Restaurant(); } } /* Output: Order up! Waitperson got Meal 1 Order up! Waitperson got Meal 2 Order up! Waitperson got Meal 3 Order up! Waitperson got Meal 4 Order up! Waitperson got Meal 5 Order up! Waitperson got Meal 6 Order up! Waitperson got Meal 7 Order up! Waitperson got Meal 8 Order up! Waitperson got Meal 9 Out food, closing WaitPerson interrupted Order up! Chef interrupted *///:~ The Restaurant focal point WaitPerson Chef. Both must know Restaurant working must place fetch meal restaurant’s "meal window," restaurant.meal. In run( ), WaitPerson goes wait( ) mode, stopping task woken notifyAll( ) Chef. Since simple program, know one task waiting WaitPerson’s lock: WaitPerson task itself. For reason, it’s theoretically possible call notify( ) instead notifyAll( ). However, complex situations, multiple tasks may waiting particular object lock, don’t know task awakened. Thus, it’s safer call notifyAll( ), wakes tasks waiting lock. Each task must decide whether notification relevant. Once Chef delivers Meal notifies WaitPerson, Chef waits WaitPerson collects meal notifies Chef, produce next Meal. Notice wait( ) wrapped while( ) statement testing thing waited for. This seems bit strange first—if you’re waiting order, wake up, order must available, right? As noted earlier, problem concurrent application, task might swoop grab order WaitPerson waking up. The safe approach always use following idiom wait( ) (within proper synchronization, course, programming possibility missed signals): while(conditionlsNotMet) wait(); This guarantees condition met get wait loop, notified something doesn’t concern condition (as happen notifyAll( )), condition changes get fully wait loop, guaranteed go back waiting. Observe call notifyAll( ) must first capture lock waitPerson. The call wait( ) WaitPerson.run( ) automatically releases lock, possible. Because lock must owned order notifyAll( ) called, it’s guaranteed two tasks trying call notifyAll( ) one object won’t step other’s toes. Both run( ) methods designed orderly shutdown enclosing entire run( ) try block. The catch clause closes right closing brace run( ) method, task receives InterruptedException, ends immediately catching exception. Concurrency 865 In Chef, note calling shutdownNow( ) could simply return run( ), normally that’s do. However, it’s little interesting way. Remember shutdownNow( ) sends interrupt( ) tasks ExecutorService started. But case Chef, task doesn’t shut immediately upon getting interrupt( ), interrupt throws InterruptedException task attempts enter (interruptible) blocking operation. Thus, you’ll see "Order up!" displayed first, InterruptedException thrown Chef attempts call sleep( ). If remove call sleep( ), task get top run( ) loop exit Thread.interrupted( ) test, without throwing exception. The preceding example single spot one task store object another task later use object. However, typical producerconsumer implementation, use first-in, first-out queue order store objects produced consumed. You’ll learn queues later chapter. Exercise 24: (1) Solve single-producer, single-consumer problem using wait( ) notifyAll( ). The producer must overflow receiver’s buffer, happen producer faster consumer. If consumer faster producer, must read data once. Do assume anything relative speeds producer consumer. Exercise 25: (1) In Chef class Restaurant.java, return run( ) calling shutdownNow( ) observe difference behavior. Exercise 26: (8) Add BusBoy class Restaurant.java. After meal delivered, WaitPerson notify BusBoy clean up. Using explicit Lock Condition objects There additional, explicit tools Java SE5 java.util.concurrent library used rewrite WaxOMatic.java. The basic class uses mutex allows task suspension Condition, suspend task calling await( ) Condition. When external state changes take place might mean task continue processing, notify task calling signal( ), wake one task, signalAll( ), wake tasks suspended Condition object (as notifyAll( ), signalAll( ) safer approach). Here’s WaxOMatic.java rewritten contain Condition uses suspend task inside waitForWaxing( ) waitForBuffing( ): //: concurrency/waxomatic2/WaxOMatic2.java // Using Lock Condition objects. package concurrency.waxomatic2; import java.util.concurrent.*; import java.util.concurrent.locks.*; import static net.mindview.util.Print.*; class Car { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); private boolean waxOn = false; public void waxed() { lock.lock(); try { waxOn = true; // Ready buff condition.signalAll(); } finally { 866 Thinking Java Bruce Eckel } lock.unlock(); } public void buffed() { lock.lock(); try { waxOn = false; // Ready another coat wax condition.signalAll(); } finally { lock.unlock(); } } public void waitForWaxing() throws InterruptedException { lock.lock(); try { while(waxOn == false) condition.await(); } finally { lock.unlock(); } } public void waitForBuffing() throws InterruptedException{ lock.lock(); try { while(waxOn == true) condition.await(); } finally { lock.unlock(); } } } class WaxOn implements Runnable { private Car car; public WaxOn(Car c) { car = c; } public void run() { try { while(!Thread.interrupted()) { printnb("Wax On! "); TimeUnit.MILLISECONDS.sleep(200); car.waxed(); car.waitForBuffing(); } } catch(InterruptedException e) { print("Exiting via interrupt"); } print("Ending Wax On task"); } } class WaxOff implements Runnable { private Car car; public WaxOff(Car c) { car = c; } public void run() { try { while(!Thread.interrupted()) { car.waitForWaxing(); printnb("Wax Off! "); TimeUnit.MILLISECONDS.sleep(200); car.buffed(); } } catch(InterruptedException e) { print("Exiting via interrupt"); Concurrency 867 } print("Ending Wax Off task"); } } public class WaxOMatic2 { public static void main(String[] args) throws Exception { Car car = new Car(); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new WaxOff(car)); exec.execute(new WaxOn(car)); TimeUnit.SECONDS.sleep(5); exec.shutdownNow(); } } /* Output: (90% match) Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt Ending Wax Off task Exiting via interrupt Ending Wax On task *///:~ In Car’s constructor, single Lock produces Condition object used manage inter-task communication. However, Condition object contains information state process, need manage additional information indicate process state, boolean waxOn. Each call lock( ) must immediately followed try-finally clause guarantee unlocking happens cases. As built-in versions, task must lock call await( ), signal( ) signalAll( ). Notice solution complex previous one, complexity doesn’t gain anything case. The Lock Condition objects necessary difficult threading problems. Exercise 27: (2) Modify Restaurant.java use explicit Lock Condition objects. Producer-consumers queues The wait( ) notifyAll( ) methods solve problem task cooperation rather lowlevel fashion, handshaking every interaction. In many cases, move level abstraction solve task cooperation problems using synchronized queue, allows one task time insert remove element. This provided java.util.concurrent.BlockingQueue interface, number standard implementations. You’ll usually use LinkedBlockingQueue, unbounded queue; ArrayBlockingQueue fixed size, put many elements blocks. These queues also suspend consumer task task tries get object queue queue empty, resume elements become available. Blocking queues solve remarkable number problems much simpler reliable fashion wait( ) notifyAll( ). Here’s simple test serializes execution LiftOff objects. The consumer LiftOffRunner, pulls LiftOff object BlockingQueue runs 868 Thinking Java Bruce Eckel directly. (That is, uses thread calling run( ) explicitly rather starting new thread task.) //: concurrency/TestBlockingQueues.java // {RunByHand} import java.util.concurrent.*; import java.io.*; import static net.mindview.util.Print.*; class LiftOffRunner implements Runnable { private BlockingQueue<LiftOff> rockets; public LiftOffRunner(BlockingQueue<LiftOff> queue) { rockets = queue; } public void add(LiftOff lo) { try { rockets.put(lo); } catch(InterruptedException e) { print("Interrupted put()"); } } public void run() { try { while(!Thread.interrupted()) { LiftOff rocket = rockets.take(); rocket.run(); // Use thread } } catch(InterruptedException e) { print("Waking take()"); } print("Exiting LiftOffRunner"); } } public class TestBlockingQueues { static void getkey() { try { // Compensate Windows/Linux difference // length result produced Enter key: new BufferedReader( new InputStreamReader(System.in)).readLine(); } catch(java.io.IOException e) { throw new RuntimeException(e); } } static void getkey(String message) { print(message); getkey(); } static void test(String msg, BlockingQueue<LiftOff> queue) { print(msg); LiftOffRunner runner = new LiftOffRunner(queue); Thread = new Thread(runner); t.start(); for(int = 0; < 5; i++) runner.add(new LiftOff(5)); getkey("Press ‘Enter’ (" + msg + ")"); t.interrupt(); print("Finished " + msg + " test"); } public static void main(String[] args) { test("LinkedBlockingQueue", // Unlimited size Concurrency 869 new LinkedBlockingQueue<LiftOff>()); test("ArrayBlockingQueue", // Fixed size new ArrayBlockingQueue<LiftOff>(3)); test("SynchronousQueue", // Size 1 new SynchronousQueue<LiftOff>()); } } ///:~ The tasks placed BlockingQueue main( ) taken BlockingQueue LiftOffRunner. Notice LiftOffRunner ignore synchronization issues solved BlockingQueue. Exercise 28: (3) Modify TestBlockingQueues.java adding new task places LiftOff BlockingQueue, instead main( ). BlockingQueues toast As example use BlockingQueues, consider machine three tasks: one make toast, one butter toast, one put jam buttered toast. We run toast BlockingQueues processes: //: concurrency/ToastOMatic.java // A toaster uses queues. import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; class Toast { public enum Status { DRY, BUTTERED, JAMMED } private Status status = Status.DRY; private final int id; public Toast(int idn) { id = idn; } public void butter() { status = Status.BUTTERED; } public void jam() { status = Status.JAMMED; } public Status getStatus() { return status; } public int getId() { return id; } public String toString() { return "Toast " + id + ": " + status; } } class ToastQueue extends LinkedBlockingQueue<Toast> {} class Toaster implements Runnable { private ToastQueue toastQueue; private int count = 0; private Random rand = new Random(47); public Toaster(ToastQueue tq) { toastQueue = tq; } public void run() { try { while(!Thread.interrupted()) { TimeUnit.MILLISECONDS.sleep( 100 + rand.nextInt(500)); // Make toast Toast = new Toast(count++); print(t); // Insert queue toastQueue.put(t); } } catch(InterruptedException e) { print("Toaster interrupted"); 870 Thinking Java Bruce Eckel } print("Toaster off"); } } // Apply butter toast: class Butterer implements Runnable { private ToastQueue dryQueue, butteredQueue; public Butterer(ToastQueue dry, ToastQueue buttered) { dryQueue = dry; butteredQueue = buttered; } public void run() { try { while(!Thread.interrupted()) { // Blocks next piece toast available: Toast = dryQueue.take(); t.butter(); print(t); butteredQueue.put(t); } } catch(InterruptedException e) { print("Butterer interrupted"); } print("Butterer off"); } } // Apply jam buttered toast: class Jammer implements Runnable { private ToastQueue butteredQueue, finishedQueue; public Jammer(ToastQueue buttered, ToastQueue finished) { butteredQueue = buttered; finishedQueue = finished; } public void run() { try { while(!Thread.interrupted()) { // Blocks next piece toast available: Toast = butteredQueue.take(); t.jam(); print(t); finishedQueue.put(t); } } catch(InterruptedException e) { print("Jammer interrupted"); } print("Jammer off"); } } // Consume toast: class Eater implements Runnable { private ToastQueue finishedQueue; private int counter = 0; public Eater(ToastQueue finished) { finishedQueue = finished; } public void run() { try { while(!Thread.interrupted()) { // Blocks next piece toast available: Toast = finishedQueue.take(); Concurrency 871 // Verify toast coming order, // pieces getting jammed: if(t.getId() != counter++ || t.getStatus() != Toast.Status.JAMMED) { print(">>>> Error: " + t); System.exit(1); } else print("Chomp! " + t); } } } catch(InterruptedException e) { print("Eater interrupted"); } print("Eater off"); } public class ToastOMatic { public static void main(String[] args) throws Exception { ToastQueue dryQueue = new ToastQueue(), butteredQueue = new ToastQueue(), finishedQueue = new ToastQueue(); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new Toaster(dryQueue)); exec.execute(new Butterer(dryQueue, butteredQueue)); exec.execute(new Jammer(butteredQueue, finishedQueue)); exec.execute(new Eater(finishedQueue)); TimeUnit.SECONDS.sleep(5); exec.shutdownNow(); } } /* (Execute see output) *///:~ Toast excellent example value enums. Note explicit synchronization (using Lock objects synchronized keyword) synchronization implicitly managed queues (which synchronize internally) design system—each piece Toast operated one task time. Because queues block, processes suspend resume automatically. You see simplification produced BlockingQueues quite dramatic. The coupling classes would exist explicit wait( ) notifyAll( ) statements eliminated class communicates BlockingQueues. Exercise 29: (8) Modify ToastOMatic.java create peanut butter jelly toast sandwiches using two separate assembly lines (one peanut butter, second jelly, merging two lines). Using pipes I/O tasks It’s often useful tasks communicate using I/O. Threading libraries may provide support inter-task I/O form pipes. These exist Java I/O library classes PipedWriter (which allows task write pipe) PipedReader (which allows different task read pipe). This thought variation producer-consumer problem, pipe canned solution. The pipe basically blocking queue, existed versions Java BlockingQueue introduced. Here’s simple example two tasks use pipe communicate: //: concurrency/PipedIO.java // Using pipes inter-task I/O import java.util.concurrent.*; 872 Thinking Java Bruce Eckel import java.io.*; import java.util.*; import static net.mindview.util.Print.*; class Sender implements Runnable { private Random rand = new Random(47); private PipedWriter = new PipedWriter(); public PipedWriter getPipedWriter() { return out; } public void run() { try { while(true) for(char c = ‘A’; c <= ‘z’; c++) { out.write(c); TimeUnit.MILLISECONDS.sleep(rand.nextInt(500)); } } catch(IOException e) { print(e + " Sender write exception"); } catch(InterruptedException e) { print(e + " Sender sleep interrupted"); } } } class Receiver implements Runnable { private PipedReader in; public Receiver(Sender sender) throws IOException { = new PipedReader(sender.getPipedWriter()); } public void run() { try { while(true) { // Blocks characters there: printnb("Read: " + (char)in.read() + ", "); } } catch(IOException e) { print(e + " Receiver read exception"); } } } public class PipedIO { public static void main(String[] args) throws Exception { Sender sender = new Sender(); Receiver receiver = new Receiver(sender); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(sender); exec.execute(receiver); TimeUnit.SECONDS.sleep(4); exec.shutdownNow(); } } /* Output: (65% match) Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read: G, Read: H, Read: I, Read: J, Read: K, Read: L, Read: M, java.lang.InterruptedException: sleep interrupted Sender sleep interrupted java.io.InterruptedIOException Receiver read exception *///:~ Sender Receiver represent tasks need communicate other. Sender creates PipedWriter, standalone object, inside Receiver creation PipedReader must associated PipedWriter constructor. The Sender puts data Writer sleeps random amount time. However, Receiver Concurrency 873 sleep( ) wait( ). But read( ), pipe automatically blocks data. Notice sender receiver started main( ), objects completely constructed. If don’t start completely constructed objects, pipe produce inconsistent behavior different platforms. (Note BlockingQueues robust easier use.) An important difference PipedReader normal I/O seen shutdownNow( ) called—the PipedReader interruptible, whereas changed, example, in.read( ) call System.in.read( ), interrupt( ) would fail break read( ) call. Exercise 30: (1) Modify PipedIO.java use BlockingQueue instead pipe. Deadlock Now understand object synchronized methods forms locking prevent tasks accessing object mutex released. You’ve also learned tasks become blocked. Thus it’s possible one task get stuck waiting another task, turn waits another task, on, chain leads back task waiting first one. You get continuous loop tasks waiting other, one move. This called deadlock. 21 If try running program deadlocks right away, immediately track bug. The real problem program seems working fine hidden potential deadlock. In case, may get indication deadlocking possibility, flaw latent program unexpectedly happens customer (in way almost certainly difficult reproduce). Thus, preventing deadlock careful program design critical part developing concurrent systems. The dining philosophers problem, invented Edsger Dijkstra, classic demonstration deadlock. The basic description specifies five philosophers (but example shown allow number). These philosophers spend part time thinking part time eating. While thinking, don’t need shared resources, eat using limited number utensils. In original problem description, utensils forks, two forks required get spaghetti bowl middle table, seems make sense say utensils chopsticks. Clearly, philosopher require two chopsticks order eat. A difficulty introduced problem: As philosophers, little money, afford five chopsticks (more generally, number chopsticks philosophers). These spaced around table them. When philosopher wants eat, philosopher must pick chopstick left one right. If philosopher either side using desired chopstick, philosopher must wait necessary chopsticks become available. //: concurrency/Chopstick.java // Chopsticks dining philosophers. public class Chopstick { private boolean taken = false; public synchronized void take() throws InterruptedException { 21 You also livelock two tasks able change state (they don’t block) never make useful progress. 874 Thinking Java Bruce Eckel while(taken) wait(); taken = true; } public synchronized void drop() { taken = false; notifyAll(); } } ///:~ No two Philosophers successfully take( ) Chopstick time. In addition, Chopstick already taken one Philosopher, another wait( ) Chopstick becomes available current holder calls drop( ). When Philosopher task calls take( ), Philosopher waits taken flag false (until Philosopher currently holding Chopstick releases it). Then task sets taken flag true indicate new Philosopher holds Chopstick. When Philosopher finished Chopstick, calls drop( ) change flag notifyAll( ) Philosophers may wait( )ing Chopstick. //: concurrency/Philosopher.java // A dining philosopher import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; public class Philosopher implements Runnable { private Chopstick left; private Chopstick right; private final int id; private final int ponderFactor; private Random rand = new Random(47); private void pause() throws InterruptedException { if(ponderFactor == 0) return; TimeUnit.MILLISECONDS.sleep( rand.nextInt(ponderFactor * 250)); } public Philosopher(Chopstick left, Chopstick right, int ident, int ponder) { this.left = left; this.right = right; id = ident; ponderFactor = ponder; } public void run() { try { while(!Thread.interrupted()) { print(this + " " + "thinking"); pause(); // Philosopher becomes hungry print(this + " " + "grabbing right"); right.take(); print(this + " " + "grabbing left"); left.take(); print(this + " " + "eating"); pause(); right.drop(); left.drop(); } } catch(InterruptedException e) { print(this + " " + "exiting via interrupt"); } Concurrency 875 } public String toString() { return "Philosopher " + id; } } ///:~ In Philosopher.run( ), Philosopher thinks eats continuously. The pause( ) method sleeps( ) random period ponderFactor nonzero. Using this, see Philosopher thinking randomized amount time, trying take( ) right left Chopsticks, eating randomized amount time, again. Now set version program deadlock: //: concurrency/DeadlockingDiningPhilosophers.java // Demonstrates deadlock hidden program. // {Args: 0 5 timeout} import java.util.concurrent.*; public class DeadlockingDiningPhilosophers { public static void main(String[] args) throws Exception { int ponder = 5; if(args.length > 0) ponder = Integer.parseInt(args[0]); int size = 5; if(args.length > 1) size = Integer.parseInt(args[1]); ExecutorService exec = Executors.newCachedThreadPool(); Chopstick[] sticks = new Chopstick[size]; for(int = 0; < size; i++) sticks[i] = new Chopstick(); for(int = 0; < size; i++) exec.execute(new Philosopher( sticks[i], sticks[(i+1) % size], i, ponder)); if(args.length == 3 && args[2].equals("timeout")) TimeUnit.SECONDS.sleep(5); else { System.out.println("Press ‘Enter’ quit"); System.in.read(); } exec.shutdownNow(); } } /* (Execute see output) *///:~ You observe Philosophers spend little time thinking, competing Chopsticks try eat, deadlock happen much quickly. The first command-line argument adjusts ponder factor, affect amount time Philosopher spends thinking. If lots Philosophers spend lot time thinking, may never see deadlock even though remains possibility. A commandline argument zero tends make program deadlock fairly quickly. Note Chopstick objects need internal identifiers; identified position array sticks. Each Philosopher constructor given reference left right Chopstick object. Every Philosopher except last one initialized situating Philosopher next pair Chopstick objects. The last Philosopher given zeroth Chopstick right Chopstick, round table completed. That’s last Philosopher sitting right next first one, share zeroth Chopstick. Now it’s possible Philosophers trying eat, waiting Philosopher next put Chopstick. This make program deadlock. 876 Thinking Java Bruce Eckel If Philosophers spending time thinking eating, much lower probability requiring shared resources (Chopsticks), thus convince program deadlock free (using nonzero ponder value, large number Philosophers), even though isn’t. This example interesting precisely demonstrates program appear run correctly actually able deadlock. To repair problem, must understand deadlock occur four conditions simultaneously met: 1. Mutual exclusion. At least one resource used tasks must shareable. In case, Chopstick used one Philosopher time. 2. At least one task must holding resource waiting acquire resource currently held another task. That is, deadlock occur, Philosopher must holding one Chopstick waiting another one. 3. A resource cannot preemptively taken away task. Tasks release resources normal event. Our Philosophers polite don’t grab Chopsticks Philosophers. 4. A circular wait happen, whereby task waits resource held another task, turn waiting resource held another task, on, one tasks waiting resource held first task, thus gridlocking everything. In DeadlockingDiningPhilosophers.java, circular wait happens Philosopher tries get right Chopstick first left. Because conditions must met cause deadlock, need prevent one occurring prohibit deadlock. In program, easiest way prevent deadlock break fourth condition. This condition happens Philosopher trying pick Chopsticks particular sequence: first right, left. Because that, it’s possible get situation holding right Chopstick waiting get left, causing circular wait condition. However, last Philosopher initialized try get left chopstick first right, Philosopher never prevent Philosopher immediate right picking chopstick. In case, circular wait prevented. This one solution problem, could also solve preventing one conditions (see advanced threading books details): //: concurrency/FixedDiningPhilosophers.java // Dining philosophers without deadlock. // {Args: 5 5 timeout} import java.util.concurrent.*; public class FixedDiningPhilosophers { public static void main(String[] args) throws Exception { int ponder = 5; if(args.length > 0) ponder = Integer.parseInt(args[0]); int size = 5; if(args.length > 1) size = Integer.parseInt(args[1]); ExecutorService exec = Executors.newCachedThreadPool(); Chopstick[] sticks = new Chopstick[size]; for(int = 0; < size; i++) sticks[i] = new Chopstick(); for(int = 0; < size; i++) if(i < (size-1)) exec.execute(new Philosopher( sticks[i], sticks[i+1], i, ponder)); else Concurrency 877 exec.execute(new Philosopher( sticks[0], sticks[i], i, ponder)); if(args.length == 3 && args[2].equals("timeout")) TimeUnit.SECONDS.sleep(5); else { System.out.println("Press ‘Enter’ quit"); System.in.read(); } exec.shutdownNow(); } } /* (Execute see output) *///:~ By ensuring last Philosopher picks puts left Chopstick right, remove deadlock, program run smoothly. There language support help prevent deadlock; it’s avoid careful design. These comforting words person who’s trying debug deadlocking program. Exercise 31: (8) Change DeadlockingDiningPhilosophers.java philosopher done chopsticks, drops bin. When philosopher wants eat, takes next two available chopsticks bin. Does eliminate possibility deadlock? Can reintroduce deadlock simply reducing number available chopsticks? 878 Thinking Java Bruce Eckel New library components The java.util.concurrent library Java SE5 introduces significant number new classes designed solve concurrency problems. Learning use help produce simpler robust concurrent programs. This section includes representative set examples various components, components—ones may less likely use encounter—are discussed here. Because components solve various problems, clear way organize them, I shall attempt start simpler examples proceed examples increasing complexity. CountDownLatch This used synchronize one tasks forcing wait completion set operations performed tasks. You give initial count CountDownLatch object, task calls await( ) object block count reaches zero. Other tasks may call countDown( ) object reduce count, presumably task finishes job. A CountDownLatch designed used one-shot fashion; count cannot reset. If need version resets count, use CyclicBarrier instead. The tasks call countDown( ) blocked make call. Only call await( ) blocked count reaches zero. A typical use divide problem n independently solvable tasks create CountDownLatch value n. When task finished calls countDown( ) latch. Tasks waiting problem solved call await( ) latch hold back completed. Here’s skeleton example demonstrates technique: //: concurrency/CountDownLatchDemo.java import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; // Performs portion task: class TaskPortion implements Runnable { private static int counter = 0; private final int id = counter++; private static Random rand = new Random(47); private final CountDownLatch latch; TaskPortion(CountDownLatch latch) { this.latch = latch; } public void run() { try { doWork(); latch.countDown(); } catch(InterruptedException ex) { // Acceptable way exit } } public void doWork() throws InterruptedException { TimeUnit.MILLISECONDS.sleep(rand.nextInt(2000)); Concurrency 879 } print(this + "completed"); } public String toString() { return String.format("%1$-3d ", id); } // Waits CountDownLatch: class WaitingTask implements Runnable { private static int counter = 0; private final int id = counter++; private final CountDownLatch latch; WaitingTask(CountDownLatch latch) { this.latch = latch; } public void run() { try { latch.await(); print("Latch barrier passed " + this); } catch(InterruptedException ex) { print(this + " interrupted"); } } public String toString() { return String.format("WaitingTask %1$-3d ", id); } } public class CountDownLatchDemo { static final int SIZE = 100; public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); // All must share single CountDownLatch object: CountDownLatch latch = new CountDownLatch(SIZE); for(int = 0; < 10; i++) exec.execute(new WaitingTask(latch)); for(int = 0; < SIZE; i++) exec.execute(new TaskPortion(latch)); print("Launched tasks"); exec.shutdown(); // Quit tasks complete } } /* (Execute see output) *///:~ TaskPortion sleeps random period simulate completion part task, WaitingTask indicates part system must wait initial portion problem complete. All tasks work single CountDownLatch, defined main( ). Exercise 32: (7) Use CountDownLatch solve problem correlating results Entrances OrnamentalGarden.java. Remove unnecessary code new version example. Library thread safety Notice TaskPortion contains static Random object, means multiple tasks may calling Random.nextInt( ) time. Is safe? If problem, solved case giving TaskPortion Random object—that is, removing static specifier. But question remains Java standard library methods general: Which ones thread-safe ones aren’t? 880 Thinking Java Bruce Eckel Unfortunately, JDK documentation forthcoming point. It happens Random.nextInt( ) thread-safe, alas, shall discover case-bycase basis, using either Web search inspecting Java library code. This particularly good situation programming language was, least theory, designed support concurrency. CyclicBarrier A CyclicBarrier used situations want create group tasks perform work parallel, wait finished moving next step (something like join( ), would seem). It brings parallel tasks alignment barrier move forward unison. This similar CountDownLatch, except CountDownLatch one-shot event, whereas CyclicBarrier reused over. I’ve fascinated simulations beginning experience computers, concurrency key factor making simulations possible. The first program I remember writing 22 simulation: horse-racing game written BASIC called (because file name limitations) HOSRAC.BAS. Here object-oriented, threaded version program, utilizing CyclicBarrier: //: concurrency/HorseRace.java // Using CyclicBarriers. import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; class Horse implements Runnable { private static int counter = 0; private final int id = counter++; private int strides = 0; private static Random rand = new Random(47); private static CyclicBarrier barrier; public Horse(CyclicBarrier b) { barrier = b; } public synchronized int getStrides() { return strides; } public void run() { try { while(!Thread.interrupted()) { synchronized(this) { strides += rand.nextInt(3); // Produces 0, 1 2 } barrier.await(); } } catch(InterruptedException e) { // A legitimate way exit } catch(BrokenBarrierException e) { // This one want know throw new RuntimeException(e); } } public String toString() { return "Horse " + id + " "; } public String tracks() { StringBuilder = new StringBuilder(); for(int = 0; < getStrides(); i++) s.append("*"); s.append(id); return s.toString(); 22 As freshman high school; classroom ASR-33 teletype 110-baud acoustic-coupler modem accessing HP-1000. Concurrency 881 } } public class HorseRace { static final int FINISH_LINE = 75; private List<Horse> horses = new ArrayList<Horse>(); private ExecutorService exec = Executors.newCachedThreadPool(); private CyclicBarrier barrier; public HorseRace(int nHorses, final int pause) { barrier = new CyclicBarrier(nHorses, new Runnable() { public void run() { StringBuilder = new StringBuilder(); for(int = 0; < FINISH_LINE; i++) s.append("="); // The fence racetrack print(s); for(Horse horse : horses) print(horse.tracks()); for(Horse horse : horses) if(horse.getStrides() >= FINISH_LINE) { print(horse + "won!"); exec.shutdownNow(); return; } try { TimeUnit.MILLISECONDS.sleep(pause); } catch(InterruptedException e) { print("barrier-action sleep interrupted"); } } }); for(int = 0; < nHorses; i++) { Horse horse = new Horse(barrier); horses.add(horse); exec.execute(horse); } } public static void main(String[] args) { int nHorses = 7; int pause = 200; if(args.length > 0) { // Optional argument int n = new Integer(args[0]); nHorses = n > 0 ? n : nHorses; } if(args.length > 1) { // Optional argument int p = new Integer(args[1]); pause = p > -1 ? p : pause; } new HorseRace(nHorses, pause); } } /* (Execute see output) *///:~ A CyclicBarrier given "barrier action," Runnable automatically executed count reaches zero—this another distinction CyclicBarrier CountdownLatch. Here, barrier action created anonymous class handed constructor CyclicBarrier. I tried horse print itself, order display dependent task manager. The CyclicBarrier allows horse whatever needs order move forward, wait barrier horses moved forward. When horses moved, CyclicBarrier automatically calls Runnable barrieraction task display horses order, along fence. 882 Thinking Java Bruce Eckel Once tasks passed barrier, automatically ready next round. To give effect simple animation, make size console window small enough horses show. DelayQueue This unbounded BlockingQueue objects implement Delayed interface. An object taken queue delay expired. The queue sorted object head delay expired longest time. If delay expired, head element poll( ) return null (because this, cannot place null elements queue). Here’s example Delayed objects tasks, DelayedTaskConsumer takes "urgent" task (the one expired longest time) queue runs it. Note DelayQueue thus variation priority queue. //: concurrency/DelayQueueDemo.java import java.util.concurrent.*; import java.util.*; import static java.util.concurrent.TimeUnit.*; import static net.mindview.util.Print.*; class DelayedTask implements Runnable, Delayed { private static int counter = 0; private final int id = counter++; private final int delta; private final long trigger; protected static List<DelayedTask> sequence = new ArrayList<DelayedTask>(); public DelayedTask(int delayInMilliseconds) { delta = delayInMilliseconds; trigger = System.nanoTime() + NANOSECONDS.convert(delta, MILLISECONDS); sequence.add(this); } public long getDelay(TimeUnit unit) { return unit.convert( trigger - System.nanoTime(), NANOSECONDS); } public int compareTo(Delayed arg) { DelayedTask = (DelayedTask)arg; if(trigger < that.trigger) return -1; if(trigger > that.trigger) return 1; return 0; } public void run() { printnb(this + " "); } public String toString() { return String.format("[%1$-4d]", delta) + " Task " + id; } public String summary() { return "(" + id + ":" + delta + ")"; } public static class EndSentinel extends DelayedTask { private ExecutorService exec; public EndSentinel(int delay, ExecutorService e) { super(delay); exec = e; Concurrency 883 } } public void run() { for(DelayedTask pt : sequence) { printnb(pt.summary() + " "); } print(); print(this + " Calling shutdownNow()"); exec.shutdownNow(); } } class DelayedTaskConsumer implements Runnable { private DelayQueue<DelayedTask> q; public DelayedTaskConsumer(DelayQueue<DelayedTask> q) { this.q = q; } public void run() { try { while(!Thread.interrupted()) q.take().run(); // Run task current thread } catch(InterruptedException e) { // Acceptable way exit } print("Finished DelayedTaskConsumer"); } } public class DelayQueueDemo { public static void main(String[] args) { Random rand = new Random(47); ExecutorService exec = Executors.newCachedThreadPool(); DelayQueue<DelayedTask> queue = new DelayQueue<DelayedTask>(); // Fill tasks random delays: for(int = 0; < 20; i++) queue.put(new DelayedTask(rand.nextInt(5000))); // Set stopping point queue.add(new DelayedTask.EndSentinel(5000, exec)); exec.execute(new DelayedTaskConsumer(queue)); } } /* Output: [128 ] Task 11 [200 ] Task 7 [429 ] Task 5 [520 ] Task 18 [555 ] Task 1 [961 ] Task 4 [998 ] Task 16 [1207] Task 9 [1693] Task 2 [1809] Task 14 [1861] Task 3 [2278] Task 15 [3288] Task 10 [3551] Task 12 [4258] Task 0 [4258] Task 19 [4522] Task 8 [4589] Task 13 [4861] Task 17 [4868] Task 6 (0:4258) (1:555) (2:1693) (3:1861) (4:961) (5:429) (6:4868) (7:200) (8:4522) (9:1207) (10:3288) (11:128) (12:3551) (13:4589) (14:1809) (15:2278) (16:998) (17:4861) (18:520) (19:4258) (20:5000) [5000] Task 20 Calling shutdownNow() Finished DelayedTaskConsumer *///:~ DelayedTask contains List<DelayedTask> called sequence preserves order tasks created, see sorting fact take place. The Delayed interface one method, getDelay( ), tells long delay time expires long ago delay time expired. This method forces us use TimeUnit class that’s argument type. This turns convenient class easily convert units without calculations. For example, value delta stored milliseconds, Java SE5 method System.nanoTime( ) 884 Thinking Java Bruce Eckel produces time nanoseconds. You convert value delta saying units units want in, like this: NANOSECONDS.convert(delta, MILLISECONDS); In getDelay( ), desired units passed unit argument, use convert time difference trigger time units requested caller, without even knowing units (this simple example Strategy design pattern, part algorithm passed argument). For sorting, Delayed interface also inherits Comparable interface, compareTo( ) must implemented produces reasonable comparison. toString( ) summary( ) provide output formatting, nested EndSentinel class provides way shut everything placing last element queue. Note DelayedTaskConsumer task, Thread use run task comes queue. Since tasks performed queue priority order, there’s need example start separate threads run DelayedTasks. You see output order tasks created effect execution order—instead, tasks executed delay order expected. PriorityBlockingQueue This basically priority queue blocking retrieval operations. Here’s example objects priority queue tasks emerge queue priority order. A PrioritizedTask given priority number provide order: //: concurrency/PriorityBlockingQueueDemo.java import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; class PrioritizedTask implements Runnable, Comparable<PrioritizedTask> { private Random rand = new Random(47); private static int counter = 0; private final int id = counter++; private final int priority; protected static List<PrioritizedTask> sequence = new ArrayList<PrioritizedTask>(); public PrioritizedTask(int priority) { this.priority = priority; sequence.add(this); } public int compareTo(PrioritizedTask arg) { return priority < arg.priority ? 1 : (priority > arg.priority ? -1 : 0); } public void run() { try { TimeUnit.MILLISECONDS.sleep(rand.nextInt(250)); } catch(InterruptedException e) { // Acceptable way exit } print(this); } public String toString() { Concurrency 885 return String.format("[%1$-3d]", priority) + " Task " + id; } public String summary() { return "(" + id + ":" + priority + ")"; } public static class EndSentinel extends PrioritizedTask { private ExecutorService exec; public EndSentinel(ExecutorService e) { super(-1); // Lowest priority program exec = e; } public void run() { int count = 0; for(PrioritizedTask pt : sequence) { printnb(pt.summary()); if(++count % 5 == 0) print(); } print(); print(this + " Calling shutdownNow()"); exec.shutdownNow(); } } } class PrioritizedTaskProducer implements Runnable { private Random rand = new Random(47); private Queue<Runnable> queue; private ExecutorService exec; public PrioritizedTaskProducer( Queue<Runnable> q, ExecutorService e) { queue = q; exec = e; // Used EndSentinel } public void run() { // Unbounded queue; never blocks. // Fill fast random priorities: for(int = 0; < 20; i++) { queue.add(new PrioritizedTask(rand.nextInt(10))); Thread.yield(); } // Trickle highest-priority jobs: try { for(int = 0; < 10; i++) { TimeUnit.MILLISECONDS.sleep(250); queue.add(new PrioritizedTask(10)); } // Add jobs, lowest priority first: for(int = 0; < 10; i++) queue.add(new PrioritizedTask(i)); // A sentinel stop tasks: queue.add(new PrioritizedTask.EndSentinel(exec)); } catch(InterruptedException e) { // Acceptable way exit } print("Finished PrioritizedTaskProducer"); } } class PrioritizedTaskConsumer implements Runnable { private PriorityBlockingQueue<Runnable> q; public PrioritizedTaskConsumer( 886 Thinking Java Bruce Eckel PriorityBlockingQueue<Runnable> q) { this.q = q; } } public void run() { try { while(!Thread.interrupted()) // Use current thread run task: q.take().run(); } catch(InterruptedException e) { // Acceptable way exit } print("Finished PrioritizedTaskConsumer"); } public class PriorityBlockingQueueDemo { public static void main(String[] args) throws Exception { Random rand = new Random(47); ExecutorService exec = Executors.newCachedThreadPool(); PriorityBlockingQueue<Runnable> queue = new PriorityBlockingQueue<Runnable>(); exec.execute(new PrioritizedTaskProducer(queue, exec)); exec.execute(new PrioritizedTaskConsumer(queue)); } } /* (Execute see output) *///:~ As previous example, creation sequence PrioritizedTask objects remembered sequence List, comparison actual order execution. The run( ) method sleeps short random time prints object information, EndSentinel provides functionality guaranteeing last object queue. The PrioritizedTaskProducer PrioritizedTaskConsumer connect PriorityBlockingQueue. Because blocking nature queue provides necessary synchronization, notice explicit synchronization necessary—you don’t think whether queue elements you’re reading it, queue simply block reader elements. The greenhouse controller ScheduledExecutor The Inner Classes chapter introduced example control system applied hypothetical greenhouse, turning various facilities otherwise adjusting them. This seen kind concurrency problem, desired greenhouse event task run predefined time. The ScheduledThreadPoolExecutor provides service necessary solve problem. Using either schedule( ) (to run task once) scheduleAtFixedRate( ) (to repeat task regular interval), set Runnable objects executed time future. Compare following approach used Inner Classes chapter notice much simpler use predefined tool like ScheduledThreadPoolExecutor: //: concurrency/GreenhouseScheduler.java // Rewriting innerclasses/GreenhouseController.java // use ScheduledThreadPoolExecutor. // {Args: 5000} import java.util.concurrent.*; import java.util.*; public class GreenhouseScheduler { Concurrency 887 private volatile boolean light = false; private volatile boolean water = false; private String thermostat = "Day"; public synchronized String getThermostat() { return thermostat; } public synchronized void setThermostat(String value) { thermostat = value; } ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(10); public void schedule(Runnable event, long delay) { scheduler.schedule(event,delay,TimeUnit.MILLISECONDS); } public void repeat(Runnable event, long initialDelay, long period) { scheduler.scheduleAtFixedRate( event, initialDelay, period, TimeUnit.MILLISECONDS); } class LightOn implements Runnable { public void run() { // Put hardware control code // physically turn light. System.out.println("Turning lights"); light = true; } } class LightOff implements Runnable { public void run() { // Put hardware control code // physically turn light. System.out.println("Turning lights"); light = false; } } class WaterOn implements Runnable { public void run() { // Put hardware control code here. System.out.println("Turning greenhouse water on"); water = true; } } class WaterOff implements Runnable { public void run() { // Put hardware control code here. System.out.println("Turning greenhouse water off"); water = false; } } class ThermostatNight implements Runnable { public void run() { // Put hardware control code here. System.out.println("Thermostat night setting"); setThermostat("Night"); } } class ThermostatDay implements Runnable { public void run() { // Put hardware control code here. System.out.println("Thermostat day setting"); setThermostat("Day"); } } 888 Thinking Java Bruce Eckel class Bell implements Runnable { public void run() { System.out.println("Bing!"); } } class Terminate implements Runnable { public void run() { System.out.println("Terminating"); scheduler.shutdownNow(); // Must start separate task job, // since scheduler shut down: new Thread() { public void run() { for(DataPoint : data) System.out.println(d); } }.start(); } } // New feature: data collection static class DataPoint { final Calendar time; final float temperature; final float humidity; public DataPoint(Calendar d, float temp, float hum) { time = d; temperature = temp; humidity = hum; } public String toString() { return time.getTime() + String.format( " temperature: %1$.1f humidity: %2$.2f", temperature, humidity); } } private Calendar lastTime = Calendar.getInstance(); { // Adjust date half hour lastTime.set(Calendar.MINUTE, 30); lastTime.set(Calendar.SECOND, 00); } private float lastTemp = 65.0f; private int tempDirection = +1; private float lastHumidity = 50.0f; private int humidityDirection = +1; private Random rand = new Random(47); List<DataPoint> data = Collections.synchronizedList( new ArrayList<DataPoint>()); class CollectData implements Runnable { public void run() { System.out.println("Collecting data"); synchronized(GreenhouseScheduler.this) { // Pretend interval longer is: lastTime.set(Calendar.MINUTE, lastTime.get(Calendar.MINUTE) + 30); // One 5 chances reversing direction: if(rand.nextInt(5) == 4) tempDirection = -tempDirection; // Store previous value: lastTemp = lastTemp + tempDirection * (1.0f + rand.nextFloat()); if(rand.nextInt(5) == 4) humidityDirection = -humidityDirection; lastHumidity = lastHumidity + humidityDirection * rand.nextFloat(); Concurrency 889 } // Calendar must cloned, otherwise // DataPoints hold references lastTime. // For basic object like Calendar, clone() OK. data.add(new DataPoint((Calendar)lastTime.clone(), lastTemp, lastHumidity)); } } public static void main(String[] args) { GreenhouseScheduler gh = new GreenhouseScheduler(); gh.schedule(gh.new Terminate(), 5000); // Former "Restart" class necessary: gh.repeat(gh.new Bell(), 0, 1000); gh.repeat(gh.new ThermostatNight(), 0, 2000); gh.repeat(gh.new LightOn(), 0, 200); gh.repeat(gh.new LightOff(), 0, 400); gh.repeat(gh.new WaterOn(), 0, 600); gh.repeat(gh.new WaterOff(), 0, 800); gh.repeat(gh.new ThermostatDay(), 0, 1400); gh.repeat(gh.new CollectData(), 500, 500); } } /* (Execute see output) *///:~ This version reorganizes code adds new feature: collecting temperature humidity readings greenhouse. A DataPoint holds displays single piece data, CollectData scheduled task generates simulated data adds List<DataPoint> Greenhouse time run. Notice use volatile synchronized appropriate places prevent tasks interfering other. All methods List holds DataPoints synchronized using java.util.Collections utility synchronizedList( ) List created. Exercise 33: (7) Modify GreenhouseScheduler.java uses DelayQueue instead ScheduledExecutor. Semaphore A normal lock (from concurrent.locks built-in synchronized lock) allows one task time access resource. A counting semaphore allows n tasks access resource time. You also think semaphore handing "permits" use resource, although actual permit objects used. As example, consider concept object pool, manages limited number objects allowing checked use, checked back user finished. This functionality encapsulated generic class: //: concurrency/Pool.java // Using Semaphore inside Pool, restrict // number tasks use resource. import java.util.concurrent.*; import java.util.*; public class Pool<T> { private int size; private List<T> items = new ArrayList<T>(); private volatile boolean[] checkedOut; private Semaphore available; public Pool(Class<T> classObject, int size) { 890 Thinking Java Bruce Eckel this.size = size; checkedOut = new boolean[size]; available = new Semaphore(size, true); // Load pool objects checked out: for(int = 0; < size; ++i) try { // Assumes default constructor: items.add(classObject.newInstance()); } catch(Exception e) { throw new RuntimeException(e); } } public T checkOut() throws InterruptedException { available.acquire(); return getItem(); } public void checkIn(T x) { if(releaseItem(x)) available.release(); } private synchronized T getItem() { for(int = 0; < size; ++i) if(!checkedOut[i]) { checkedOut[i] = true; return items.get(i); } return null; // Semaphore prevents reaching } private synchronized boolean releaseItem(T item) { int index = items.indexOf(item); if(index == -1) return false; // Not list if(checkedOut[index]) { checkedOut[index] = false; return true; } return false; // Wasn’t checked } } ///:~ In simplified form, constructor uses newInstance( ) load pool objects. If need new object, call checkOut( ), you’re finished object, hand checkIn( ). The boolean checkedOut array keeps track objects checked out, managed getItem( ) releaseItem( ) methods. These, turn, guarded Semaphore available, that, checkOut( ), available blocks progress call semaphore permits available (which means objects pool). In checkIn( ), object checked valid, permit returned semaphore. To create example, use Fat, type object expensive create constructor takes time run: //: concurrency/Fat.java // Objects expensive create. public class Fat { private volatile double d; // Prevent optimization private static int counter = 0; private final int id = counter++; public Fat() { Concurrency 891 // Expensive, interruptible operation: for(int = 1; < 10000; i++) { += (Math.PI + Math.E) / (double)i; } } public void operation() { System.out.println(this); } public String toString() { return "Fat id: " + id; } } ///:~ We’ll pool objects limit impact constructor. We test Pool class creating task check Fat objects, hold while, check back in: //: concurrency/SemaphoreDemo.java // Testing Pool class import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; // A task check resource pool: class CheckoutTask<T> implements Runnable { private static int counter = 0; private final int id = counter++; private Pool<T> pool; public CheckoutTask(Pool<T> pool) { this.pool = pool; } public void run() { try { T item = pool.checkOut(); print(this + "checked " + item); TimeUnit.SECONDS.sleep(1); print(this +"checking " + item); pool.checkIn(item); } catch(InterruptedException e) { // Acceptable way terminate } } public String toString() { return "CheckoutTask " + id + " "; } } public class SemaphoreDemo { final static int SIZE = 25; public static void main(String[] args) throws Exception { final Pool<Fat> pool = new Pool<Fat>(Fat.class, SIZE); ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < SIZE; i++) exec.execute(new CheckoutTask<Fat>(pool)); print("All CheckoutTasks created"); List<Fat> list = new ArrayList<Fat>(); for(int = 0; < SIZE; i++) { Fat f = pool.checkOut(); printnb(i + ": main() thread checked "); f.operation(); list.add(f); } Future<?> blocked = exec.submit(new Runnable() { public void run() { try { 892 Thinking Java Bruce Eckel // Semaphore prevents additional checkout, // call blocked: pool.checkOut(); } catch(InterruptedException e) { print("checkOut() Interrupted"); } } }); TimeUnit.SECONDS.sleep(2); blocked.cancel(true); // Break blocked call print("Checking objects " + list); for(Fat f : list) pool.checkIn(f); for(Fat f : list) pool.checkIn(f); // Second checkIn ignored exec.shutdown(); } } /* (Execute see output) *///:~ In main( ), Pool created hold Fat objects, set CheckoutTasks begins exercising Pool. Then main( ) thread begins checking Fat objects, checking back in. Once checked objects pool, checkouts allowed Semaphore. The run( ) method blocked thus blocked, two seconds cancel( ) method called break Future. Note redundant checkins ignored Pool. This example relies client Pool rigorous voluntarily check items back in, simplest solution works. If cannot always rely this, Thinking Patterns (at www.MindView.net) contains explorations ways manage objects checked object pools. Exchanger An Exchanger barrier swaps objects two tasks. When tasks enter barrier, one object, leave, object formerly held task. Exchangers typically used one task creating objects expensive produce another task consuming objects; way, objects created time consumed. To exercise Exchanger class, we’ll create producer consumer tasks which, via generics Generators, work kind object, we’ll apply Fat class. The ExchangerProducer ExehangerConsumer use List<T> object exchanged; one contains Exchanger List<T>. When call Exchanger.exchange( ) method, blocks partner task calls exchange( ) method, exchange( ) methods completed, List<T> swapped: //: concurrency/ExchangerDemo.java import java.util.concurrent.*; import java.util.*; import net.mindview.util.*; class ExchangerProducer<T> implements Runnable { private Generator<T> generator; private Exchanger<List<T>> exchanger; private List<T> holder; ExchangerProducer(Exchanger<List<T>> exchg, Generator<T> gen, List<T> holder) { exchanger = exchg; Concurrency 893 generator = gen; this.holder = holder; } } public void run() { try { while(!Thread.interrupted()) { for(int = 0; < ExchangerDemo.size; i++) holder.add(generator.next()); // Exchange full empty: holder = exchanger.exchange(holder); } } catch(InterruptedException e) { // OK terminate way. } } class ExchangerConsumer<T> implements Runnable { private Exchanger<List<T>> exchanger; private List<T> holder; private volatile T value; ExchangerConsumer(Exchanger<List<T>> ex, List<T> holder){ exchanger = ex; this.holder = holder; } public void run() { try { while(!Thread.interrupted()) { holder = exchanger.exchange(holder); for(T x : holder) { value = x; // Fetch value holder.remove(x); // OK CopyOnWriteArrayList } } } catch(InterruptedException e) { // OK terminate way. } System.out.println("Final value: " + value); } } public class ExchangerDemo { static int size = 10; static int delay = 5; // Seconds public static void main(String[] args) throws Exception { if(args.length > 0) size = new Integer(args[0]); if(args.length > 1) delay = new Integer(args[1]); ExecutorService exec = Executors.newCachedThreadPool(); Exchanger<List<Fat>> xc = new Exchanger<List<Fat>>(); List<Fat> producerList = new CopyOnWriteArrayList<Fat>(), consumerList = new CopyOnWriteArrayList<Fat>(); exec.execute(new ExchangerProducer<Fat>(xc, BasicGenerator.create(Fat.class), producerList)); exec.execute( new ExchangerConsumer<Fat>(xc,consumerList)); TimeUnit.SECONDS.sleep(delay); exec.shutdownNow(); } } /* Output: (Sample) Final value: Fat id: 29999 894 Thinking Java Bruce Eckel *///:~ In main( ), single Exchanger created tasks use, two CopyOnWriteArrayLists created swapping. This particular variant List tolerate remove( ) method called list traversed, without throwing ConcurrentModificationException. The ExchangerProducer fills List, swaps full list empty one ExchangerConsumer hands it. Because Exchanger, filling one list consuming list happen simultaneously. Exercise 34: (1) Modify ExchangerDemo.java use class instead Fat. Concurrency 895 Simulation One interesting exciting uses concurrency create simulations. Using concurrency, component simulation task, makes simulation much easier program. Many video games CGI animations movies simulations, HorseRace.java GreenhouseScheduler.java, shown earlier, could also considered simulations. Bank teller simulation This classic simulation represent situation objects appear randomly require random amount time served limited number servers. It’s possible build simulation determine ideal number servers. In example, bank customer requires certain amount service time, number time units teller must spend customer serve customer’s needs. The amount service time different customer determined randomly. In addition, won’t know many customers arriving interval, also determined randomly. //: concurrency/BankTellerSimulation.java // Using queues multithreading. // {Args: 5} import java.util.concurrent.*; import java.util.*; // Read-only objects don’t require synchronization: class Customer { private final int serviceTime; public Customer(int tm) { serviceTime = tm; } public int getServiceTime() { return serviceTime; } public String toString() { return "[" + serviceTime + "]"; } } // Teach customer line display itself: class CustomerLine extends ArrayBlockingQueue<Customer> { public CustomerLine(int maxLineSize) { super(maxLineSize); } public String toString() { if(this.size() == 0) return "[Empty]"; StringBuilder result = new StringBuilder(); for(Customer customer : this) result.append(customer); return result.toString(); } } // Randomly add customers queue: class CustomerGenerator implements Runnable { private CustomerLine customers; private static Random rand = new Random(47); public CustomerGenerator(CustomerLine cq) { customers = cq; } public void run() { 896 Thinking Java Bruce Eckel } try { while(!Thread.interrupted()) { TimeUnit.MILLISECONDS.sleep(rand.nextInt(300)); customers.put(new Customer(rand.nextInt(1000))); } } catch(InterruptedException e) { System.out.println("CustomerGenerator interrupted"); } System.out.println("CustomerGenerator terminating"); } class Teller implements Runnable, Comparable<Teller> { private static int counter = 0; private final int id = counter++; // Customers served shift: private int customersServed = 0; private CustomerLine customers; private boolean servingCustomerLine = true; public Teller(CustomerLine cq) { customers = cq; } public void run() { try { while(!Thread.interrupted()) { Customer customer = customers.take(); TimeUnit.MILLISECONDS.sleep( customer.getServiceTime()); synchronized(this) { customersServed++; while(!servingCustomerLine) wait(); } } } catch(InterruptedException e) { System.out.println(this + "interrupted"); } System.out.println(this + "terminating"); } public synchronized void doSomethingElse() { customersServed = 0; servingCustomerLine = false; } public synchronized void serveCustomerLine() { assert !servingCustomerLine:"already serving: " + this; servingCustomerLine = true; notifyAll(); } public String toString() { return "Teller " + id + " "; } public String shortString() { return "T" + id; } // Used priority queue: public synchronized int compareTo(Teller other) { return customersServed < other.customersServed ? -1 : (customersServed == other.customersServed ? 0 : 1); } } class TellerManager implements Runnable { private ExecutorService exec; private CustomerLine customers; private PriorityQueue<Teller> workingTellers = new PriorityQueue<Teller>(); private Queue<Teller> tellersDoingOtherThings = new LinkedList<Teller>(); private int adjustmentPeriod; Concurrency 897 private static Random rand = new Random(47); public TellerManager(ExecutorService e, CustomerLine customers, int adjustmentPeriod) { exec = e; this.customers = customers; this.adjustmentPeriod = adjustmentPeriod; // Start single teller: Teller teller = new Teller(customers); exec.execute(teller); workingTellers.add(teller); } public void adjustTellerNumber() { // This actually control system. By adjusting // numbers, reveal stability issues // control mechanism. // If line long, add another teller: if(customers.size() / workingTellers.size() > 2) { // If tellers break // another job, bring one back: if(tellersDoingOtherThings.size() > 0) { Teller teller = tellersDoingOtherThings.remove(); teller.serveCustomerLine(); workingTellers.offer(teller); return; } // Else create (hire) new teller Teller teller = new Teller(customers); exec.execute(teller); workingTellers.add(teller); return; } // If line short enough, remove teller: if(workingTellers.size() > 1 && customers.size() / workingTellers.size() < 2) reassignOneTeller(); // If line, need one teller: if(customers.size() == 0) while(workingTellers.size() > 1) reassignOneTeller(); } // Give teller different job break: private void reassignOneTeller() { Teller teller = workingTellers.poll(); teller.doSomethingElse(); tellersDoingOtherThings.offer(teller); } public void run() { try { while(!Thread.interrupted()) { TimeUnit.MILLISECONDS.sleep(adjustmentPeriod); adjustTellerNumber(); System.out.print(customers + " { "); for(Teller teller : workingTellers) System.out.print(teller.shortString() + " "); System.out.println("}"); } } catch(InterruptedException e) { System.out.println(this + "interrupted"); } System.out.println(this + "terminating"); } public String toString() { return "TellerManager "; } } 898 Thinking Java Bruce Eckel public class BankTellerSimulation { static final int MAX_LINE_SIZE = 50; static final int ADJUSTMENT_PERIOD = 1000; public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); // If line long, customers leave: CustomerLine customers = new CustomerLine(MAX_LINE_SIZE); exec.execute(new CustomerGenerator(customers)); // Manager add remove tellers necessary: exec.execute(new TellerManager( exec, customers, ADJUSTMENT_PERIOD)); if(args.length > 0) // Optional argument TimeUnit.SECONDS.sleep(new Integer(args[0])); else { System.out.println("Press ‘Enter’ quit"); System.in.read(); } exec.shutdownNow(); } } /* Output: (Sample) [429][200][207] { T0 T1 } [861][258][140][322] { T0 T1 } [575][342][804][826][896][984] { T0 T1 T2 } [984][810][141][12][689][992][976][368][395][354] { T0 T1 T2 T3 } Teller 2 interrupted Teller 2 terminating Teller 1 interrupted Teller 1 terminating TellerManager interrupted TellerManager terminating Teller 3 interrupted Teller 3 terminating Teller 0 interrupted Teller 0 terminating CustomerGenerator interrupted CustomerGenerator terminating *///:~ The Customer objects simple, containing final int field. Because objects never change, read-only objects require synchronization use volatile. On top that, Teller task removes one Customer time input queue, works Customer complete, Customer accessed one task time, anyway. CustomerLine represents single line customers wait served Teller. This ArrayBlockingQueue toString( ) prints results desired fashion. A CustomerGenerator attached CustomerLine puts Customers onto queue randomized intervals. A Teller takes Customers CustomerLine processes one time, keeping track number Customers served particular shift. It told doSomethingElse( ) aren’t enough customers, serveCustomerLine( ) lots customers show up. To choose next teller put back line, compareTo( ) method looks number customers served PriorityQueue automatically put least-worked teller forefront. Concurrency 899 The TellerManager hub activity. It keeps track tellers what’s going customers. One interesting things simulation attempts discover optimum number tellers given customer flow. You see adjustTellerNumber( ), control system add remove tellers stable fashion. All control systems stability issues; react quickly change, unstable, react slowly, system moves one extremes. Exercise 35: (8) Modify BankTellerSimulation.java represents Web clients making requests fixed number servers. The goal determine load group servers handle. The restaurant simulation This simulation fleshes simple Restaurant.java example shown earlier chapter adding simulation components, Orders Plates, reuses menu classes Enumerated Types chapter. It also introduces Java SE5 SynchronousQueue, blocking queue internal capacity, put( ) must wait take( ), vice versa. It’s handing object someone—there’s table put on, works person holding hand out, ready receive object. In example, SynchronousQueue represents place setting front diner, enforce idea one course served time. The rest classes functionality example either follow structure Restaurant.java intended fairly direct mapping operations actual restaurant: //: concurrency/restaurant2/RestaurantWithQueues.java // {Args: 5} package concurrency.restaurant2; import enumerated.menu.*; import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; // This given waiter, gives chef: class Order { // (A data-transfer object) private static int counter = 0; private final int id = counter++; private final Customer customer; private final WaitPerson waitPerson; private final Food food; public Order(Customer cust, WaitPerson wp, Food f) { customer = cust; waitPerson = wp; food = f; } public Food item() { return food; } public Customer getCustomer() { return customer; } public WaitPerson getWaitPerson() { return waitPerson; } public String toString() { return "Order: " + id + " item: " + food + " for: " + customer + " served by: " + waitPerson; } } // This comes back chef: 900 Thinking Java Bruce Eckel class Plate { private final Order order; private final Food food; public Plate(Order ord, Food f) { order = ord; food = f; } public Order getOrder() { return order; } public Food getFood() { return food; } public String toString() { return food.toString(); } } class Customer implements Runnable { private static int counter = 0; private final int id = counter++; private final WaitPerson waitPerson; // Only one course time received: private SynchronousQueue<Plate> placeSetting = new SynchronousQueue<Plate>(); public Customer(WaitPerson w) { waitPerson = w; } public void deliver(Plate p) throws InterruptedException { // Only blocks customer still // eating previous course: placeSetting.put(p); } public void run() { for(Course course : Course.values()) { Food food = course.randomSelection(); try { waitPerson.placeOrder(this, food); // Blocks course delivered: print(this + "eating " + placeSetting.take()); } catch(InterruptedException e) { print(this + "waiting " + course + " interrupted"); break; } } print(this + "finished meal, leaving"); } public String toString() { return "Customer " + id + " "; } } class WaitPerson implements Runnable { private static int counter = 0; private final int id = counter++; private final Restaurant restaurant; BlockingQueue<Plate> filledOrders = new LinkedBlockingQueue<Plate>(); public WaitPerson(Restaurant rest) { restaurant = rest; } public void placeOrder(Customer cust, Food food) { try { // Shouldn’t actually block // LinkedBlockingQueue size limit: restaurant.orders.put(new Order(cust, this, food)); } catch(InterruptedException e) { print(this + " placeOrder interrupted"); } } public void run() { Concurrency 901 try { while(!Thread.interrupted()) { // Blocks course ready Plate plate = filledOrders.take(); print(this + "received " + plate + " delivering " + plate.getOrder().getCustomer()); plate.getOrder().getCustomer().deliver(plate); } } catch(InterruptedException e) { print(this + " interrupted"); } print(this + " duty"); } } public String toString() { return "WaitPerson " + id + " "; } class Chef implements Runnable { private static int counter = 0; private final int id = counter++; private final Restaurant restaurant; private static Random rand = new Random(47); public Chef(Restaurant rest) { restaurant = rest; } public void run() { try { while(!Thread.interrupted()) { // Blocks order appears: Order order = restaurant.orders.take(); Food requestedItem = order.item(); // Time prepare order: TimeUnit.MILLISECONDS.sleep(rand.nextInt(500)); Plate plate = new Plate(order, requestedItem); order.getWaitPerson().filledOrders.put(plate); } } catch(InterruptedException e) { print(this + " interrupted"); } print(this + " duty"); } public String toString() { return "Chef " + id + " "; } } class Restaurant implements Runnable { private List<WaitPerson> waitPersons = new ArrayList<WaitPerson>(); private List<Chef> chefs = new ArrayList<Chef>(); private ExecutorService exec; private static Random rand = new Random(47); BlockingQueue<Order> orders = new LinkedBlockingQueue<Order>(); public Restaurant(ExecutorService e, int nWaitPersons, int nChefs) { exec = e; for(int = 0; < nWaitPersons; i++) { WaitPerson waitPerson = new WaitPerson(this); waitPersons.add(waitPerson); exec.execute(waitPerson); } for(int = 0; < nChefs; i++) { Chef chef = new Chef(this); chefs.add(chef); 902 Thinking Java Bruce Eckel } exec.execute(chef); } public void run() { try { while(!Thread.interrupted()) { // A new customer arrives; assign WaitPerson: WaitPerson wp = waitPersons.get( rand.nextInt(waitPersons.size())); Customer c = new Customer(wp); exec.execute(c); TimeUnit.MILLISECONDS.sleep(100); } } catch(InterruptedException e) { print("Restaurant interrupted"); } print("Restaurant closing"); } } public class RestaurantWithQueues { public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); Restaurant restaurant = new Restaurant(exec, 5, 2); exec.execute(restaurant); if(args.length > 0) // Optional argument TimeUnit.SECONDS.sleep(new Integer(args[0])); else { print("Press ‘Enter’ quit"); System.in.read(); } exec.shutdownNow(); } } /* Output: (Sample) WaitPerson 0 received SPRING_ROLLS delivering Customer 1 Customer 1 eating SPRING_ROLLS WaitPerson 3 received SPRING_ROLLS delivering Customer 0 Customer 0 eating SPRING_ROLLS WaitPerson 0 received BURRITO delivering Customer 1 Customer 1 eating BURRITO WaitPerson 3 received SPRING_ROLLS delivering Customer 2 Customer 2 eating SPRING_ROLLS WaitPerson 1 received SOUP delivering Customer 3 Customer 3 eating SOUP WaitPerson 3 received VINDALOO delivering Customer 0 Customer 0 eating VINDALOO WaitPerson 0 received FRUIT delivering Customer 1 ... *///:~ One important thing observe example management complexity using queues communicate tasks. This single technique greatly simplifies process concurrent programming inverting control: The tasks directly interfere other. Instead, tasks send objects via queues. The receiving task handles object, treating message rather message inflicted upon it. If follow technique whenever can, stand much better chance building robust concurrent systems. Exercise 36: (10) Modify RestaurantWithQueues.java there’s one OrderTicket object per table. Change order orderTicket, add Table class, multiple Customers per table. Concurrency 903 Distributing work Here’s simulation example brings together many concepts chapter. Consider hypothetical robotic assembly line automobiles. Each Car built several stages, starting chassis creation, followed attachment engine, drive train, wheels. //: concurrency/CarBuilder.java // A complex example tasks working together. import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; class Car { private final int id; private boolean engine = false, driveTrain = false, wheels = false; public Car(int idn) { id = idn; } // Empty Car object: public Car() { id = -1; } public synchronized int getId() { return id; } public synchronized void addEngine() { engine = true; } public synchronized void addDriveTrain() { driveTrain = true; } public synchronized void addWheels() { wheels = true; } public synchronized String toString() { return "Car " + id + " [" + " engine: " + engine + " driveTrain: " + driveTrain + " wheels: " + wheels + " ]"; } } class CarQueue extends LinkedBlockingQueue<Car> {} class ChassisBuilder implements Runnable { private CarQueue carQueue; private int counter = 0; public ChassisBuilder(CarQueue cq) { carQueue = cq; } public void run() { try { while(!Thread.interrupted()) { TimeUnit.MILLISECONDS.sleep(500); // Make chassis: Car c = new Car(counter++); print("ChassisBuilder created " + c); // Insert queue carQueue.put(c); } } catch(InterruptedException e) { print("Interrupted: ChassisBuilder"); } print("ChassisBuilder off"); } } class Assembler implements Runnable { private CarQueue chassisQueue, finishingQueue; private Car car; private CyclicBarrier barrier = new CyclicBarrier(4); private RobotPool robotPool; 904 Thinking Java Bruce Eckel public Assembler(CarQueue cq, CarQueue fq, RobotPool rp){ chassisQueue = cq; finishingQueue = fq; robotPool = rp; } public Car car() { return car; } public CyclicBarrier barrier() { return barrier; } public void run() { try { while(!Thread.interrupted()) { // Blocks chassis available: car = chassisQueue.take(); // Hire robots perform work: robotPool.hire(EngineRobot.class, this); robotPool.hire(DriveTrainRobot.class, this); robotPool.hire(WheelRobot.class, this); barrier.await(); // Until robots finish // Put car finishingQueue work finishingQueue.put(car); } } catch(InterruptedException e) { print("Exiting Assembler via interrupt"); } catch(BrokenBarrierException e) { // This one want know throw new RuntimeException(e); } print("Assembler off"); } } class Reporter implements Runnable { private CarQueue carQueue; public Reporter(CarQueue cq) { carQueue = cq; } public void run() { try { while(!Thread.interrupted()) { print(carQueue.take()); } } catch(InterruptedException e) { print("Exiting Reporter via interrupt"); } print("Reporter off"); } } abstract class Robot implements Runnable { private RobotPool pool; public Robot(RobotPool p) { pool = p; } protected Assembler assembler; public Robot assignAssembler(Assembler assembler) { this.assembler = assembler; return this; } private boolean engage = false; public synchronized void engage() { engage = true; notifyAll(); } // The part run() that’s different robot: abstract protected void performService(); public void run() { try { powerDown(); // Wait needed Concurrency 905 while(!Thread.interrupted()) { performService(); assembler.barrier().await(); // Synchronize // We’re done job... powerDown(); } } catch(InterruptedException e) { print("Exiting " + + " via interrupt"); } catch(BrokenBarrierException e) { // This one want know throw new RuntimeException(e); } print(this + " off"); } private synchronized void powerDown() throws InterruptedException { engage = false; assembler = null; // Disconnect Assembler // Put back available pool: pool.release(this); while(engage == false) // Power wait(); } public String toString() { return getClass().getName(); } } class EngineRobot extends Robot { public EngineRobot(RobotPool pool) { super(pool); } protected void performService() { print(this + " installing engine"); assembler.car().addEngine(); } } class DriveTrainRobot extends Robot { public DriveTrainRobot(RobotPool pool) { super(pool); } protected void performService() { print(this + " installing DriveTrain"); assembler.car().addDriveTrain(); } } class WheelRobot extends Robot { public WheelRobot(RobotPool pool) { super(pool); } protected void performService() { print(this + " installing Wheels"); assembler.car().addWheels(); } } class RobotPool { // Quietly prevents identical entries: private Set<Robot> pool = new HashSet<Robot>(); public synchronized void add(Robot r) { pool.add(r); notifyAll(); } public synchronized void hire(Class<? extends Robot> robotType, Assembler d) throws InterruptedException { for(Robot r : pool) if(r.getClass().equals(robotType)) { pool.remove(r); 906 Thinking Java Bruce Eckel r.assignAssembler(d); r.engage(); // Power task return; } wait(); // None available hire(robotType, d); // Try again, recursively } public synchronized void release(Robot r) { add(r); } } public class CarBuilder { public static void main(String[] args) throws Exception { CarQueue chassisQueue = new CarQueue(), finishingQueue = new CarQueue(); ExecutorService exec = Executors.newCachedThreadPool(); RobotPool robotPool = new RobotPool(); exec.execute(new EngineRobot(robotPool)); exec.execute(new DriveTrainRobot(robotPool)); exec.execute(new WheelRobot(robotPool)); exec.execute(new Assembler( chassisQueue, finishingQueue, robotPool)); exec.execute(new Reporter(finishingQueue)); // Start everything running producing chassis: exec.execute(new ChassisBuilder(chassisQueue)); TimeUnit.SECONDS.sleep(7); exec.shutdownNow(); } } /* (Execute see output) *///:~ The Cars transported one place another via CarQueue, type LinkedBlockingQueue. A ChassisBuilder creates unadorned Car places CarQueue. The Assembler takes Car CarQueue hires Robots work it. A CyclicBarrier allows Assembler wait Robots finished, time puts Car onto outgoing CarQueue transported next operation. The consumer final CarQueue Reporter object, prints Car show tasks properly completed. The Robots managed pool, work needs done, appropriate Robot hired pool. After work completed, Robot returns pool. In main( ), necessary objects created tasks initialized, ChassisBuilder begun last start process. (However, behavior LinkedBlockingQueue, wouldn’t matter started first.) Note program follows guidelines regarding object task lifetime presented chapter, shutdown process safe. You’ll notice Car methods synchronized. As turns out, example redundant, within factory Cars move queues one task work car time. Basically, queues force serialized access Cars. But exactly kind trap fall into—you say "Let’s try optimize synchronizing Car class doesn’t look like needs here." But later, system connected another need Car synchronized, breaks. Brian Goetz comments: It’s much easier say, "Car might used multiple threads, let’s make thread-safe obvious way." The way I characterize approach is: At public parks, find guard rails steep drop, may find signs say, "Don’t lean guard rail." Of course, real purpose rule Concurrency 907 prevent leaning rail—it prevent falling cliff. But "Don’t lean rail" much easier rule follow "Don’t fall cliff" Exercise 37: (2) Modify CarBuilder.java add another stage car-building process, whereby add exhaust system, body, fenders. As second stage, assume processes performed simultaneously robots. Exercise 38: (3) Using approach CarBuilder.java, model house-building story given chapter. 908 Thinking Java Bruce Eckel Performance tuning A significant number classes Java SEs’s java.util.concurrent library exist provide performance improvements. When peruse concurrent library, difficult discern classes intended regular use (such BlockingQueues) ones improving performance. In section look issues classes surrounding performance tuning. Comparing mutex technologies Now Java includes old synchronized keyword along new Java SE5 Lock Atomic classes, interesting compare different approaches understand value use them. The naive approach try simple test approach, like this: //: concurrency/SimpleMicroBenchmark.java // The dangers microbenchmarking. import java.util.concurrent.locks.*; abstract class Incrementable { protected long counter = 0; public abstract void increment(); } class SynchronizingTest extends Incrementable { public synchronized void increment() { ++counter; } } class LockingTest extends Incrementable { private Lock lock = new ReentrantLock(); public void increment() { lock.lock(); try { ++counter; } finally { lock.unlock(); } } } public class SimpleMicroBenchmark { static long test(Incrementable incr) { long start = System.nanoTime(); for(long = 0; < 10000000L; i++) incr.increment(); return System.nanoTime() - start; } public static void main(String[] args) { long synchTime = test(new SynchronizingTest()); long lockTime = test(new LockingTest()); System.out.printf("synchronized: %1$10d\n", synchTime); System.out.printf("Lock: %1$10d\n", lockTime); System.out.printf("Lock/synchronized = %1$.3f", (double)lockTime/(double)synchTime); } } /* Output: (75% match) synchronized: 244919117 Lock: 939098964 Concurrency 909 Lock/synchronized = 3.834 *///:~ You see output calls synchronized method appear faster using ReentrantLock. What’s happened here? This example demonstrates dangers so-called "microbenchmarking." 23 This term generally refers performance testing feature isolation, context. Of course, must still write tests verify assertions like "Lock much faster synchronized." But need awareness what’s really happening compilation run time write kinds tests. There number problems example. First foremost, see true performance difference mutexes contention, must multiple tasks trying access mutexed code sections. In example, mutex tested single main( ) thread, isolation. Secondly, it’s possible compiler perform special optimizations sees synchronized keyword, perhaps even notice program single-threaded. The compiler might even identify counter simply incremented fixed number times, precalculate result. Different compilers runtime systems vary, it’s hard know exactly happen, need prevent possibility compiler predict outcome. To create valid test, must make program complex. First need multiple tasks, tasks change internal values, also tasks read values (otherwise optimizer may recognize values never used). In addition, calculation must complex unpredictable enough compiler chance perform aggressive optimizations. This accomplished pre-loading large array random ints (pre-loading reduce impact calls Random.nextInt( ) main loops) using values summation: //: concurrency/SynchronizationComparisons.java // Comparing performance explicit Locks // Atomics versus synchronized keyword. import java.util.concurrent.*; import java.util.concurrent.atomic.*; import java.util.concurrent.locks.*; import java.util.*; import static net.mindview.util.Print.*; abstract class Accumulator { public static long cycles = 50000L; // Number Modifiers Readers test: private static final int N = 4; public static ExecutorService exec = Executors.newFixedThreadPool(N*2); private static CyclicBarrier barrier = new CyclicBarrier(N*2 + 1); protected volatile int index = 0; protected volatile long value = 0; protected long duration = 0; protected String id = "error"; protected final static int SIZE = 100000; protected static int[] preLoaded = new int[SIZE]; static { // Load array random numbers: 23 Brian Goetz helpful explaining issues me. See article www128.ibm.com/developerworks/library/j-jtp12214 performance measurement. 910 Thinking Java Bruce Eckel Random rand = new Random(47); for(int = 0; < SIZE; i++) preLoaded[i] = rand.nextInt(); } public abstract void accumulate(); public abstract long read(); private class Modifier implements Runnable { public void run() { for(long = 0; < cycles; i++) accumulate(); try { barrier.await(); } catch(Exception e) { throw new RuntimeException(e); } } } private class Reader implements Runnable { private volatile long value; public void run() { for(long = 0; < cycles; i++) value = read(); try { barrier.await(); } catch(Exception e) { throw new RuntimeException(e); } } } public void timedTest() { long start = System.nanoTime(); for(int = 0; < N; i++) { exec.execute(new Modifier()); exec.execute(new Reader()); } try { barrier.await(); } catch(Exception e) { throw new RuntimeException(e); } duration = System.nanoTime() - start; printf("%-13s: %13d\n", id, duration); } public static void report(Accumulator acc1, Accumulator acc2) { printf("%-22s: %.2f\n", acc1.id + "/" + acc2.id, (double)acc1.duration/(double)acc2.duration); } } class BaseLine extends Accumulator { { id = "BaseLine"; } public void accumulate() { value += preLoaded[index++]; if(index >= SIZE) index = 0; } public long read() { return value; } } class SynchronizedTest extends Accumulator { { id = "synchronized"; } public synchronized void accumulate() { value += preLoaded[index++]; Concurrency 911 } if(index >= SIZE) index = 0; } public synchronized long read() { return value; } class LockTest extends Accumulator { { id = "Lock"; } private Lock lock = new ReentrantLock(); public void accumulate() { lock.lock(); try { value += preLoaded[index++]; if(index >= SIZE) index = 0; } finally { lock.unlock(); } } public long read() { lock.lock(); try { return value; } finally { lock.unlock(); } } } class AtomicTest extends Accumulator { { id = "Atomic"; } private AtomicInteger index = new AtomicInteger(0); private AtomicLong value = new AtomicLong(0); public void accumulate() { // Oops! Relying one Atomic // time doesn’t work. But still gives us // performance indicator: int = index.getAndIncrement(); value.getAndAdd(preLoaded[i]); if(++i >= SIZE) index.set(0); } public long read() { return value.get(); } } public class SynchronizationComparisons { static BaseLine baseLine = new BaseLine(); static SynchronizedTest synch = new SynchronizedTest(); static LockTest lock = new LockTest(); static AtomicTest atomic = new AtomicTest(); static void test() { print("============================"); printf("%-12s : %13d\n", "Cycles", Accumulator.cycles); baseLine.timedTest(); synch.timedTest(); lock.timedTest(); atomic.timedTest(); Accumulator.report(synch, baseLine); Accumulator.report(lock, baseLine); Accumulator.report(atomic, baseLine); Accumulator.report(synch, lock); Accumulator.report(synch, atomic); Accumulator.report(lock, atomic); 912 Thinking Java Bruce Eckel } public static void main(String[] args) { int iterations = 5; // Default if(args.length > 0) // Optionally change iterations iterations = new Integer(args[0]); // The first time fills thread pool: print("Warmup"); baseLine.timedTest(); // Now initial test doesn’t include cost // starting threads first time. // Produce multiple data points: for(int = 0; < iterations; i++) { test(); Accumulator.cycles *= 2; } Accumulator.exec.shutdown(); } } /* Output: (Sample) Warmup BaseLine : 34237033 ============================ Cycles : 50000 BaseLine : 20966632 synchronized : 24326555 Lock : 53669950 Atomic : 30552487 synchronized/BaseLine : 1.16 Lock/BaseLine : 2.56 Atomic/BaseLine : 1.46 synchronized/Lock : 0.45 synchronized/Atomic : 0.79 Lock/Atomic : 1.76 ============================ Cycles : 100000 BaseLine : 41512818 synchronized : 43843003 Lock : 87430386 Atomic : 51892350 synchronized/BaseLine : 1.06 Lock/BaseLine : 2.11 Atomic/BaseLine : 1.25 synchronized/Lock : 0.50 synchronized/Atomic : 0.84 Lock/Atomic : 1.68 ============================ Cycles : 200000 BaseLine : 80176670 synchronized : 5455046661 Lock : 177686829 Atomic : 101789194 synchronized/BaseLine : 68.04 Lock/BaseLine : 2.22 Atomic/BaseLine : 1.27 synchronized/Lock : 30.70 synchronized/Atomic : 53.59 Lock/Atomic : 1.75 ============================ Cycles : 400000 BaseLine : 160383513 synchronized : 780052493 Lock : 362187652 Atomic : 202030984 synchronized/BaseLine : 4.86 Concurrency 913 Lock/BaseLine : 2.26 Atomic/BaseLine : 1.26 synchronized/Lock : 2.15 synchronized/Atomic : 3.86 Lock/Atomic : 1.79 ============================ Cycles : 800000 BaseLine : 322064955 synchronized : 336155014 Lock : 704615531 Atomic : 393231542 synchronized/BaseLine : 1.04 Lock/BaseLine : 2.19 Atomic/BaseLine : 1.22 synchronized/Lock : 0.47 synchronized/Atomic : 0.85 Lock/Atomic : 1.79 ============================ Cycles : 1600000 BaseLine : 650004120 synchronized : 52235762925 Lock : 1419602771 Atomic : 796950171 synchronized/BaseLine : 80.36 Lock/BaseLine : 2.18 Atomic/BaseLine : 1.23 synchronized/Lock : 36.80 synchronized/Atomic : 65.54 Lock/Atomic : 1.78 ============================ Cycles : 3200000 BaseLine : 1285664519 synchronized : 96336767661 Lock : 2846988654 Atomic : 1590545726 synchronized/BaseLine : 74.93 Lock/BaseLine : 2.21 Atomic/BaseLine : 1.24 synchronized/Lock : 33.84 synchronized/Atomic : 60.57 Lock/Atomic : 1.79 *///:~ This program uses Template Method design pattern 24 put common code base class isolate varying code derivedclass implementations accumulate( ) read( ). In derived classes SynchronizedTest, LockTest, AtomicTest, see accumulate( ) read( ) express different ways implementing mutual exclusion. In program, tasks executed via FixedThreadPool attempt keep thread creation beginning, prevent extra cost tests. Just make sure, initial test duplicated first result discarded includes initial thread creation. A CyclicBarrier necessary want make sure tasks completed declaring test complete. A static clause used pre-load array random numbers, tests begin. This way, overhead generating random numbers, won’t see test. 24 914 See Thinking Patterns www.MindView.net. Thinking Java Bruce Eckel Each time accumulate( ) called, moves next place array preLoaded (wrapping beginning array) adds another randomly generated number value. The multiple Modifier Reader tasks provide contention Accumulator object. Notice AtomicTest, I observe situation complex try use Atomic objects—basically, one Atomic object involved, probably forced give use conventional mutexes (the JDK documentation specifically states using Atomic objects works critical updates object confined single variable). However, test left place still get feel performance benefit Atomic objects. In main( ), test run repeatedly decide ask five repetitions (the default). For repetition, number test cycles doubled, see different mutexes behave running longer longer times. As see output, results rather surprising. For first four iterations, synchronized keyword seems efficient using Lock Atomic. But suddenly, threshold crossed synchronized seems become quite inefficient, Lock Atomic seem roughly maintain proportion BaseLine test, therefore become much efficient synchronized. Keep mind program gives indication differences various mutex approaches, output indicates differences particular machine particular circumstances. As see experiment it, significant shifts behavior different numbers threads used program run longer periods time. Some hotspot runtime optimizations invoked program running several minutes, case server programs, several hours. That said, fairly clear using Lock usually significantly efficient using synchronized, also appears overhead synchronized varies widely, Locks relatively consistent. Does mean never use synchronized keyword? There two factors consider: First, SynchronizationComparisons.java, bodies mutexed methods extremely small. In general, good practice—only mutex sections absolutely must. However, practice mutexed sections may larger example, percentage time body probably significantly bigger overhead entering exiting mutex, could overwhelm benefit speeding mutex. Of course, way know is— you’re tuning performance, sooner—to try different approaches see impact have. Second, it’s clear reading code chapter synchronized keyword produces much readable code lock try/finally-unlock idiom Locks require, that’s chapter primarily uses synchronized keyword. As I’ve stated elsewhere book, code read much written—when programming, important communicate humans communicate computer—and readability code critical. As result, makes sense start synchronized keyword change Lock objects tuning performance. Finally, it’s nice use Atomic classes concurrent program, aware that, saw SynchronizationComparisons.java, Atomic objects useful simple cases, generally one Atomic object that’s modified object independent objects. It’s safer start traditional mutexing approaches attempt change Atomic later, performance requirements dictate. Concurrency 915 Lock-free containers As emphasized Holding Your Objects chapter, containers fundamental tool programming, includes concurrent programming. For reason, early containers like Vector Hashtable many synchronized methods, caused unacceptable overhead used multithreaded applications. In Java 1.2, new containers library unsynchronized, Collections class given various static "synchronized" decoration methods synchronize different types containers. Although improvement gave choice whether use synchronization container, overhead still based synchronized locking. Java SE5 added new containers specifically increase thread-safe performance, using clever techniques eliminate locking. The general strategy behind lock-free containers this: Modifications containers happen time reads occurring, long readers see results completed modifications. A modification performed separate copy portion data structure (or sometimes copy whole thing), copy invisible modification process. Only modification complete modified structure atomically swapped "main" data structure, readers see modification. In CopyOnWriteArrayList, write cause copy entire underlying array created. The original array left place reads safely occur copied array modified. When modification complete, atomic operation swaps new array new reads see new information. One benefits CopyOnWriteArrayList throw ConcurrentModificationException multiple iterators traversing modifying list, don’t write special code protect exceptions, you’ve past. CopyOnWriteArraySet uses CopyOnWriteArrayList achieve lock-free behavior. ConcurrentHashMap ConcurrentLinkedQueue use similar techniques allow concurrent reads writes, portions container copied modified rather entire container. However, readers still see modifications complete. ConcurrentHashMap doesn’t throw ConcurrentModificationExceptions. Performance issues As long primarily reading lock-free container, much faster synchronized counterpart overhead acquiring releasing locks eliminated. This still true small number writes lock-free container, would interesting get idea "small" means. This section produce rough idea performance differences containers different conditions. I’ll start generic framework performing tests type container, including Maps. The generic parameter C represents container type: //: concurrency/Tester.java // Framework test performance concurrency containers. import java.util.concurrent.*; import net.mindview.util.*; public abstract class Tester<C> { static int testReps = 10; static int testCycles = 1000; static int containerSize = 1000; 916 Thinking Java Bruce Eckel abstract C containerInitializer(); abstract void startReadersAndWriters(); C testContainer; String testId; int nReaders; int nWriters; volatile long readResult = 0; volatile long readTime = 0; volatile long writeTime = 0; CountDownLatch endLatch; static ExecutorService exec = Executors.newCachedThreadPool(); Integer[] writeData; Tester(String testId, int nReaders, int nWriters) { this.testId = testId + " " + nReaders + "r " + nWriters + "w"; this.nReaders = nReaders; this.nWriters = nWriters; writeData = Generated.array(Integer.class, new RandomGenerator.Integer(), containerSize); for(int = 0; < testReps; i++) { runTest(); readTime = 0; writeTime = 0; } } void runTest() { endLatch = new CountDownLatch(nReaders + nWriters); testContainer = containerInitializer(); startReadersAndWriters(); try { endLatch.await(); } catch(InterruptedException ex) { System.out.println("endLatch interrupted"); } System.out.printf("%-27s %14d %14d\n", testId, readTime, writeTime); if(readTime != 0 && writeTime != 0) System.out.printf("%-27s %14d\n", "readTime + writeTime =", readTime + writeTime); } abstract class TestTask implements Runnable { abstract void test(); abstract void putResults(); long duration; public void run() { long startTime = System.nanoTime(); test(); duration = System.nanoTime() - startTime; synchronized(Tester.this) { putResults(); } endLatch.countDown(); } } public static void initMain(String[] args) { if(args.length > 0) testReps = new Integer(args[0]); if(args.length > 1) testCycles = new Integer(args[1]); if(args.length > 2) containerSize = new Integer(args[2]); System.out.printf("%-27s %14s %14s\n", Concurrency 917 "Type", "Read time", "Write time"); } } ///:~ The abstract method containerInitializer( ) returns initialized container tested, stored field testContainer. The abstract method, startReadersAndWriters( ), starts reader writer tasks read modify container test. Different tests run varying number readers writers see effects lock contention (for synchronized containers) writes (for lock-free containers). The constructor given various information test (the argument identifiers self-explanatory), calls runTest( ) method repetitions times. runTest( ) creates CountDownLatch (so test know tasks complete), initializes container, calls startReadersAndWriters( ) waits complete. Each "Reader" "Writer" class based TestTask, measures duration abstract test( ) method, calls putResults( ) inside synchronized block store results. To use framework (in you’ll recognize Template Method design pattern), must inherit Tester particular container type wish test, provide appropriate Reader Writer classes: //: concurrency/ListComparisons.java // {Args: 1 10 10} (Fast verification check build) // Rough comparison thread-safe List performance. import java.util.concurrent.*; import java.util.*; import net.mindview.util.*; abstract class ListTest extends Tester<List<Integer>> { ListTest(String testId, int nReaders, int nWriters) { super(testId, nReaders, nWriters); } class Reader extends TestTask { long result = 0; void test() { for(long = 0; < testCycles; i++) for(int index = 0; index < containerSize; index++) result += testContainer.get(index); } void putResults() { readResult += result; readTime += duration; } } class Writer extends TestTask { void test() { for(long = 0; < testCycles; i++) for(int index = 0; index < containerSize; index++) testContainer.set(index, writeData[index]); } void putResults() { writeTime += duration; } } void startReadersAndWriters() { for(int = 0; < nReaders; i++) exec.execute(new Reader()); 918 Thinking Java Bruce Eckel for(int = 0; < nWriters; i++) exec.execute(new Writer()); } } class SynchronizedArrayListTest extends ListTest { List<Integer> containerInitializer() { return Collections.synchronizedList( new ArrayList<Integer>( new CountingIntegerList(containerSize))); } SynchronizedArrayListTest(int nReaders, int nWriters) { super("Synched ArrayList", nReaders, nWriters); } } class CopyOnWriteArrayListTest extends ListTest { List<Integer> containerInitializer() { return new CopyOnWriteArrayList<Integer>( new CountingIntegerList(containerSize)); } CopyOnWriteArrayListTest(int nReaders, int nWriters) { super("CopyOnWriteArrayList", nReaders, nWriters); } } public class ListComparisons { public static void main(String[] args) { Tester.initMain(args); new SynchronizedArrayListTest(10, 0); new SynchronizedArrayListTest(9, 1); new SynchronizedArrayListTest(5, 5); new CopyOnWriteArrayListTest(10, 0); new CopyOnWriteArrayListTest(9, 1); new CopyOnWriteArrayListTest(5, 5); Tester.exec.shutdown(); } } /* Output: (Sample) Type Read time Synched ArrayList 10r 0w 232158294700 Synched ArrayList 9r 1w 198947618203 readTime + writeTime = 223866231602 Synched ArrayList 5r 5w 117367305062 readTime + writeTime = 249543918570 CopyOnWriteArrayList 10r 0w 758386889 CopyOnWriteArrayList 9r 1w 741305671 readTime + writeTime = 877450908 CopyOnWriteArrayList 5r 5w 212763075 readTime + writeTime = 68180227375 *///:~ Write time 0 24918613399 132176613508 0 136145237 67967464300 In ListTest, Reader Writer classes perform specific actions List<Integer>. In Reader.putResults( ), duration stored result, prevent calculations optimized away. startReadersAndWriters( ) defined create execute specific Readers Writers. Once ListTest created, must inherited override containerInitializer( ) create initialize specific test containers. In main( ), see variations tests different numbers readers writers. You change test variables using command-line arguments call Tester.initMain(args). Concurrency 919 The default behavior run test 10 times; helps stabilize output, change JVM activities like hotspot optimization garbage collection. 25 The sample output see edited show last iteration test. From output, see synchronized ArrayList roughly performance regardless number readers writers—readers contend readers locks way writers do. The CopyOnWriteArrayList, however, dramatically faster writers, still significantly faster five writers. It would appear fairly liberal use CopyOnWriteArrayList; impact writing list appear overtake impact synchronizing entire list while. Of course, must try two different approaches specific application know sure one best. Again, note isn’t close good benchmark absolute numbers, numbers almost certainly different. The goal give idea relative behaviors two types container. Since CopyOnWriteArraySet uses CopyOnWriteArrayList, behavior similar doesn’t need separate test here. Comparing Map implementations We use framework get rough idea performance synchronized HashMap compared ConcurrentHashMap: //: concurrency/MapComparisons.java // {Args: 1 10 10} (Fast verification check build) // Rough comparison thread-safe Map performance. import java.util.concurrent.*; import java.util.*; import net.mindview.util.*; abstract class MapTest extends Tester<Map<Integer,Integer>> { MapTest(String testId, int nReaders, int nWriters) { super(testId, nReaders, nWriters); } class Reader extends TestTask { long result = 0; void test() { for(long = 0; < testCycles; i++) for(int index = 0; index < containerSize; index++) result += testContainer.get(index); } void putResults() { readResult += result; readTime += duration; } } class Writer extends TestTask { void test() { for(long = 0; < testCycles; i++) for(int index = 0; index < containerSize; index++) testContainer.put(index, writeData[index]); } void putResults() { writeTime += duration; } 25 For introduction benchmarking influence Java’s dynamic compilation, see www128.ibm.com/developerworks/library/j-jtp12214. 920 Thinking Java Bruce Eckel } } void startReadersAndWriters() { for(int = 0; < nReaders; i++) exec.execute(new Reader()); for(int = 0; < nWriters; i++) exec.execute(new Writer()); } class SynchronizedHashMapTest extends MapTest { Map<Integer,Integer> containerInitializer() { return Collections.synchronizedMap( new HashMap<Integer,Integer>( MapData.map( new CountingGenerator.Integer(), new CountingGenerator.Integer(), containerSize))); } SynchronizedHashMapTest(int nReaders, int nWriters) { super("Synched HashMap", nReaders, nWriters); } } class ConcurrentHashMapTest extends MapTest { Map<Integer,Integer> containerInitializer() { return new ConcurrentHashMap<Integer,Integer>( MapData.map( new CountingGenerator.Integer(), new CountingGenerator.Integer(), containerSize)); } ConcurrentHashMapTest(int nReaders, int nWriters) { super("ConcurrentHashMap", nReaders, nWriters); } } public class MapComparisons { public static void main(String[] args) { Tester.initMain(args); new SynchronizedHashMapTest(10, 0); new SynchronizedHashMapTest(9, 1); new SynchronizedHashMapTest(5, 5); new ConcurrentHashMapTest(10, 0); new ConcurrentHashMapTest(9, 1); new ConcurrentHashMapTest(5, 5); Tester.exec.shutdown(); } } /* Output: (Sample) Type Read time Synched HashMap 10r 0w 306052025049 Synched HashMap 9r 1w 428319156207 readTime + writeTime = 476016503775 Synched HashMap 5r 5w 243956877760 readTime + writeTime = 487968880962 ConcurrentHashMap 10r 0w 23352654318 ConcurrentHashMap 9r 1w 18833089400 readTime + writeTime = 20374942624 ConcurrentHashMap 5r 5w 12037625732 readTime + writeTime = 23888114831 *///:~ Write time 0 47697347568 244012003202 0 1541853224 11850489099 The impact adding writers ConcurrentHashMap even less evident CopyOnWriteArrayList, ConcurrentHashMap uses different technique clearly minimizes impact writes. Concurrency 921 Optimistic locking Although Atomic objects perform atomic operations like decrementAndGet( ), Atomic classes also allow perform called "optimistic locking." This means actually use mutex performing calculation, calculation finished you’re ready update Atomic object, use method called compareAndSet( ). You hand old value new value, old value doesn’t agree value finds Atomic object, operation fails—this means task modified object meantime. Remember would ordinarily use mutex (synchronized Lock) prevent one task modifying object time, "optimistic" leaving data unlocked hoping task comes along modifies it. Again, done name performance—by using Atomic instead synchronized Lock, might gain performance benefits. What happens compareAndSet( ) operation fails? This gets tricky, limited applying technique problems molded requirements. If compareAndSet( ) fails, must decide do; important can’t something recover, cannot use technique must use conventional mutexes instead. Perhaps retry operation OK get second time. Or perhaps it’s OK ignore failure—in simulations, data point lost, eventually made grand scheme things (of course, must understand model well enough know whether true). Consider fictitious simulation consists 100,000 "genes" length 30; perhaps beginning kind genetic algorithm. Suppose "evolution" genetic algorithm, expensive calculations take place, decide use multiprocessor machine distribute tasks improve performance. In addition, use Atomic objects instead Lock objects prevent mutex overhead. (Naturally, produced solution first writing code simplest way could possibly work, using synchronized keyword. Once program running, discover slow, begin applying performance techniques!) Because nature model, there’s collision calculation, task discovers collision ignore update value. Here’s looks like: //: concurrency/FastSimulation.java import java.util.concurrent.*; import java.util.concurrent.atomic.*; import java.util.*; import static net.mindview.util.Print.*; public class FastSimulation { static final int N_ELEMENTS = 100000; static final int N_GENES = 30; static final int N_EVOLVERS = 50; static final AtomicInteger[][] GRID = new AtomicInteger[N_ELEMENTS][N_GENES]; static Random rand = new Random(47); static class Evolver implements Runnable { public void run() { while(!Thread.interrupted()) { // Randomly select element work on: int element = rand.nextInt(N_ELEMENTS); for(int = 0; < N_GENES; i++) { int previous = element - 1; if(previous < 0) previous = N_ELEMENTS - 1; int next = element + 1; if(next >= N_ELEMENTS) next = 0; int oldvalue = GRID[element][i].get(); 922 Thinking Java Bruce Eckel } // Perform kind modeling calculation: int newvalue = oldvalue + GRID[previous][i].get() + GRID[next][i].get(); newvalue /= 3; // Average three values if(!GRID[element][i] .compareAndSet(oldvalue, newvalue)) { // Policy deal failure. Here, // report ignore it; model // eventually deal it. print("Old value changed " + oldvalue); } } } } public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); for(int = 0; < N_ELEMENTS; i++) for(int j = 0; j < N_GENES; j++) GRID[i][j] = new AtomicInteger(rand.nextInt(1000)); for(int = 0; < N_EVOLVERS; i++) exec.execute(new Evolver()); TimeUnit.SECONDS.sleep(5); exec.shutdownNow(); } } /* (Execute see output) *///:~ The elements placed inside array assumption help performance (this assumption tested exercise). Each Evolver object averages value one it, there’s failure goes update, simply prints value goes on. Note mutexes appear program. Exercise 39: (6) Does FastSimulation.java make reasonable assumptions? Try changing array ordinary ints instead AtomicInteger using Lock mutexes. Compare performance two versions program. ReadWriteLocks ReadWriteLocks optimize situation write data structure relatively infrequently, multiple tasks read often. The ReadWriteLock allows many readers one time long one attempting write. If write lock held, readers allowed write lock released. It’s completely uncertain whether ReadWriteLock improve performance program, depends issues like often data read compared often modified, time read write operations (the lock complex, short operations see benefits), much thread contention is, whether running multiprocessor machine. Ultimately, way know whether ReadWriteLock benefit program try out. Here’s example showing basic use ReadWriteLocks: //: concurrency/ReaderWriterList.java import java.util.concurrent.*; import java.util.concurrent.locks.*; import java.util.*; import static net.mindview.util.Print.*; public class ReaderWriterList<T> { Concurrency 923 } private ArrayList<T> lockedList; // Make ordering fair: private ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true); public ReaderWriterList(int size, T initialValue) { lockedList = new ArrayList<T>( Collections.nCopies(size, initialValue)); } public T set(int index, T element) { Lock wlock = lock.writeLock(); wlock.lock(); try { return lockedList.set(index, element); } finally { wlock.unlock(); } } public T get(int index) { Lock rlock = lock.readLock(); rlock.lock(); try { // Show multiple readers // may acquire read lock: if(lock.getReadLockCount() > 1) print(lock.getReadLockCount()); return lockedList.get(index); } finally { rlock.unlock(); } } public static void main(String[] args) throws Exception { new ReaderWriterListTest(30, 1); } class ReaderWriterListTest { ExecutorService exec = Executors.newCachedThreadPool(); private final static int SIZE = 100; private static Random rand = new Random(47); private ReaderWriterList<Integer> list = new ReaderWriterList<Integer>(SIZE, 0); private class Writer implements Runnable { public void run() { try { for(int = 0; < 20; i++) { // 2 second test list.set(i, rand.nextInt()); TimeUnit.MILLISECONDS.sleep(100); } } catch(InterruptedException e) { // Acceptable way exit } print("Writer finished, shutting down"); exec.shutdownNow(); } } private class Reader implements Runnable { public void run() { try { while(!Thread.interrupted()) { for(int = 0; < SIZE; i++) { list.get(i); TimeUnit.MILLISECONDS.sleep(1); } 924 Thinking Java Bruce Eckel } } catch(InterruptedException e) { // Acceptable way exit } } } public ReaderWriterListTest(int readers, int writers) { for(int = 0; < readers; i++) exec.execute(new Reader()); for(int = 0; < writers; i++) exec.execute(new Writer()); } } /* (Execute see output) *///:~ A ReaderWriterList hold fixed number type. You must give constructor desired size list initial object populate list with. The set( ) method acquires write lock order call underlying ArrayList. set( ), get( ) method acquires read lock order call ArrayList.get( ). In addition, get( ) checks see one reader acquired read lock and, so, displays number demonstrate multiple readers may acquire read lock. To test ReaderWriterList, ReaderWriterListTest creates reader writer tasks ReaderWriterList<Integer>. Notice far fewer writes reads. If look JDK documentation ReentrantReadWriteLock, you’ll see number methods available, well issues "fairness" "policy decisions." This rather sophisticated tool, one use casting ways improve performance. Your first draft program use straightforward synchronization, necessary introduce ReadWriteLock. Exercise 40: (6) Following example ReaderWriterList.java, create ReaderWriterMap using HashMap. Investigate performance modifying MapComparisons.java. How compare synchronized HashMap ConcurrentHashMap? Active objects After working way chapter, may observe threading Java seems complex difficult use correctly. In addition, seem bit counterproductive— although tasks work parallel, must invest great effort implement techniques prevent tasks interfering other. If you’ve ever written assembly language, writing threaded programs similar feel: Every detail matters, you’re responsible everything, there’s safety net form compiler checking. Could problem threading model itself? After all, comes relatively unchanged world procedural programming. Perhaps different model concurrency better fit objectoriented programming. One alternative approach called active objects actors. 26 The reason objects called "active" object maintains worker thread message queue, requests object enqueued, run one time. So active objects, 26 Thanks Allen Holub taking time explain me. Concurrency 925 serialize messages rather methods, means longer need guard problems happen task interrupted midway loop. When send message active object, message transformed task goes object’s queue run later point. The Java SE5 Future comes handy implementing scheme. Here’s simple example two methods enqueue method calls: //: concurrency/ActiveObjectDemo.java // Can pass constants, immutables, "disconnected // objects," active objects arguments // asynch methods. import java.util.concurrent.*; import java.util.*; import static net.mindview.util.Print.*; public class ActiveObjectDemo { private ExecutorService ex = Executors.newSingleThreadExecutor(); private Random rand = new Random(47); // Insert random delay produce effect // calculation time: private void pause(int factor) { try { TimeUnit.MILLISECONDS.sleep( 100 + rand.nextInt(factor)); } catch(InterruptedException e) { print("sleep() interrupted"); } } public Future<Integer> calculateInt(final int x, final int y) { return ex.submit(new Callable<Integer>() { public Integer call() { print("starting " + x + " + " + y); pause(500); return x + y; } }); } public Future<Float> calculateFloat(final float x, final float y) { return ex.submit(new Callable<Float>() { public Float call() { print("starting " + x + " + " + y); pause(2000); return x + y; } }); } public void shutdown() { ex.shutdown(); } public static void main(String[] args) { ActiveObjectDemo d1 = new ActiveObjectDemo(); // Prevents ConcurrentModificationException: List<Future<?>> results = new CopyOnWriteArrayList<Future<?>>(); for(float f = 0.0f; f < 1.0f; f += 0.2f) results.add(d1.calculateFloat(f, f)); for(int = 0; < 5; i++) results.add(d1.calculateInt(i, i)); print("All asynch calls made"); while(results.size() > 0) { 926 Thinking Java Bruce Eckel for(Future<?> f : results) if(f.isDone()) { try { print(f.get()); } catch(Exception e) { throw new RuntimeException(e); } results.remove(f); } } d1.shutdown(); } } /* Output: (85% match) All asynch calls made starting 0.0 + 0.0 starting 0.2 + 0.2 0.0 starting 0.4 + 0.4 0.4 starting 0.6 + 0.6 0.8 starting 0.8 + 0.8 1.2 starting 0 + 0 1.6 starting 1 + 1 0 starting 2 + 2 2 starting 3 + 3 4 starting 4 + 4 6 8 *///:~ The "single thread executor" produced call Executors.newSingleThreadExecutor( ) maintains unbounded blocking queue, one thread taking tasks queue running completion. All need calculateInt( ) calculateFloat( ) submit( ) new Callable object response method call, thus converting method calls messages. The method body contained within call( ) method anonymous inner class. Notice return value active object method Future generic parameter actual return type method. This way, method call returns almost immediately, caller uses Future discover task completes collect actual return value. This handles complex case, call return value, process simplified. In main( ), List<Future<?>> created capture Future objects returned calculateFloat( ) calculateInt( ) messages sent active object. This list polled using isDone( ) Future, removed List completes results processed. Notice use CopyOnWriteArrayList removes need copy List order prevent ConcurrentModificationExceptions. In order inadvertently prevent coupling threads, arguments pass active-object method call must either read-only, active objects, disconnected objects (my term), objects connection task (this hard enforce there’s language support it). With active objects: Concurrency 927 1. Each object worker thread. 2. Each object maintains total control fields (which somewhat rigorous normal classes, option guarding fields). 3. All communication active objects happens form messages objects. 4. All messages active objects enqueued. The results quite compelling. Since message one active object another blocked delay enqueuing it, delay always short dependent objects, sending message effectively unblockable (the worst happen short delay). Since active-object system communicates via messages, two objects cannot blocked contending call method another object, means deadlock cannot occur, big step forward. Because worker thread within active object executes one message time, resource contention don’t worry synchronizing methods. Synchronization still happens, happens message level, enqueuing method calls one happen time. Unfortunately, without direct compiler support, coding approach shown cumbersome. However, progress occurring field active objects actors, interestingly, field called agent-based programming. Agents effectively active objects, agent systems also support transparency across networks machines. It would surprise agent-based programming becomes eventual successor objectoriented programming, combines objects relatively easy concurrency solution. You find information active objects, actors agents searching Web. In particular, ideas behind active objects come C.A.R. Hoare’s theory Communicating Sequential Processes (CSP). Exercise 41: (6) Add message handler ActiveObjectDemo.java return value, call within main( ). Exercise 42: (7) Modify WaxOMatic.java implements active objects. Project: 27 Use annotations Javassist create class annotation @Active transforms target class active object. 27 Projects suggestions used (for example) term projects. Solutions projects included solution guide. 928 Thinking Java Bruce Eckel Summary The goal chapter give foundations concurrent programming Java threads, understand that: 1. You run multiple independent tasks. 2. You must consider possible problems tasks shut down. 3. Tasks interfere shared resources. The mutex (lock) basic tool used prevent collisions. 4. Tasks deadlock carefully designed. It vital learn use concurrency avoid it. The main reasons use are: • To manage number tasks whose intermingling use computer efficiently (including ability transparently distribute tasks across multiple CPUs). • To allow better code organization. • To convenient user. The classic example resource balancing use CPU I/O waits. Better code organization typically seen simulations. The classic example user convenience monitor "stop" button long downloads. An additional advantage threads provide "light" execution context switches (on order 100 instructions) rather "heavy" process context switches (thousands instructions). Since threads given process share memory space, light context switch changes program execution local variables. A process change—the heavy context switch—must exchange full memory space. The main drawbacks multithreading are: 1. Slowdown occurs threads waiting shared resources. 2. Additional CPU overhead required manage threads. 3. Unrewarded complexity arises poor design decisions. 4. Opportunities created pathologies starving, racing, deadlock, livelock (multiple threads working individual tasks ensemble can’t finish). 5. Inconsistencies occur across platforms. For instance, developing examples book, I discovered race conditions quickly appeared computers wouldn’t appear others. If develop program latter, might get badly surprised distribute it. One biggest difficulties threads occurs one task might sharing resource—such memory object—and must make sure multiple tasks don’t try read change resource time. This requires judicious use available locking mechanisms (for example, synchronized keyword). These essential tools, must understood thoroughly quietly introduce deadlock situations. Concurrency 929 In addition, there’s art application threads. Java designed allow create many objects need solve problem—at least theory. (Creating millions objects engineering finite-element analysis, example, might practical Java without use Flyweight design pattern.) However, seems upper bound number threads you’ll want create, number, threads seem become balky. This critical point hard detect often depend OS JVM; less hundred thousands. As often create handful threads solve problem, typically much limit, general design becomes constraint might force add cooperative concurrency scheme. Regardless simple threading seem using particular language library, consider black art. There’s always something bite least expect it. The reason dining philosophers problem interesting adjusted deadlock rarely happens, giving impression everything copacetic. In general, use threading carefully sparingly. If threading issues get large complex, consider using language like Erlang. This one several functional languages specialized threading. It may possible use language portions program demand threading, lots it, it’s complicated enough justify approach. 930 Thinking Java Bruce Eckel Further reading Unfortunately, lot misleading information concurrency— emphasizes confusing be, easy think understand issues (I know, I’ve impression I’ve understood threading numerous times past, I doubt epiphanies future). There’s always bit sleuthing required pick new document concurrency, try understand much writer doesn’t understand. Here books I think I safely say reliable: Java Concurrency Practice, Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, Doug Lea (Addison-Wesley, 2006). Basically, "who’s who" Java threading world. Concurrent Programming Java, Second Edition, Doug Lea (Addison-Wesley, 2000). Although book significantly predates Java SE5, much Doug’s work became new java.util.concurrent libraries, book essential complete understanding concurrency issues. It goes beyond Java concurrency discusses current thinking across languages technologies. Although obtuse places, merits rereading several times (preferably months order internalize information). Doug one people world actually understand concurrency, worthwhile endeavor. The Java Language Specification, Third Edition (Chapter 17), Gosling, Joy, Steele, Bracha (Addison-Wesley, 2005). The technical specification, conveniently available electronic document: http://java.sun.com/docs/books/jls. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Concurrency 931 Graphical User Interfaces A fundamental design guideline "Make simple things easy, difficult things possible." 1 The original design goal graphical user interface (GUI) library Java l.o allow programmer build GUI looks good platforms. That goal achieved. Instead, Java l.o Abstract Windowing Toolkit (AWT) produced GUI looked equally mediocre systems. In addition, restrictive; could use four fonts couldn’t access sophisticated GUI elements exist operating system. The Java 1.0 AWT programming model also awkward non-object-oriented. A student one seminars (who Sun creation Java) explained why: The original AWT conceived, designed, implemented month. Certainly marvel productivity, also object lesson design important. The situation improved Java 1.1 AWT event model, takes much clearer, object-oriented approach, along addition JavaBeans, component programming model oriented toward easy creation visual programming environments. Java 2 (JDK 1.2) finished transformation away old Java 1.0 AWT essentially replacing everything Java Foundation Classes (JFC), GUI portion called "Swing." These rich set easy-to-use, easy-to-understand JavaBeans dragged dropped (as well hand programmed) create reasonable GUI. The "revision 3" rule software industry (a product isn’t good revision 3) seems hold true programming languages well. This chapter introduces modern Java Swing library makes reasonable assumption Swing Sun’s final destination GUI library Java. 2 If reason need use original "old" AWT (because you’re supporting old code browser limitations), find introduction 1st edition book, downloadable www.MindView.net. Note AWT components remain Java, situations must use them. Please aware comprehensive glossary either Swing components methods described classes. What see intended simple introduction. The Swing library vast, goal chapter get started essentials comfortable concepts. If need see here, Swing probably give want you’re willing research. I assume downloaded installed JDK documentation http://java.sun.com browse javax.swing classes documentation see full details methods Swing library. You also search Web, best place start Sun’s Swing Tutorial http://java.sun.com/docs/books/tutorial/uiswing. 1 A variation called "the principle least astonishment," essentially says, "Don’t surprise user." Note IBM created new open-source GUI library Eclipse editor (www.Eclipse.org), may want consider alternative Swing. This introduced later chapter. 2 There numerous (rather thick) books dedicated solely Swing, you’ll want go need depth, want modify default Swing behavior. As learn Swing, you’ll discover: 1. Swing much improved programming model compared many languages development environments (not suggest it’s perfect, step forward path). JavaBeans (introduced toward end chapter) framework library. 2. "GUI builders" (visual programming environments) de rigueur aspect complete Java development environment. JavaBeans Swing allow GUI builder write code place components onto forms using graphical tools. This rapidly speeds development GUI building, also allows greater experimentation thus ability try designs presumably come better ones. 3. Because Swing reasonably straightforward, even use GUI builder rather coding hand, resulting code still comprehensible. This solves big problem GUI builders past, could easily generate unreadable code. Swing contains components expect see modern UI: everything buttons contain pictures trees tables. It’s big library, it’s designed appropriate complexity task hand; something simple, don’t write much code, try complex things, code becomes proportionally complex. Much you’ll like Swing might called "orthogonality use." That is, pick general ideas library, usually apply everywhere. Primarily standard naming conventions, I writing examples I could usually guess successfully method names. This certainly hallmark good library design. In addition, generally plug components components things work correctly. Keyboard navigation automatic; run Swing application without using mouse, doesn’t require extra programming. Scrolling support effortless; simply wrap component JScrollPane add form. Features tool tips typically require single line code use. For portability, Swing written entirely Java. Swing also supports rather radical feature called "pluggable look feel," means appearance UI dynamically changed suit expectations users working different platforms operating systems. It’s even possible (albeit difficult) invent look feel. You find Web. 3 Despite positive aspects, Swing everyone solved user interface problems designers intended. At end chapter, we’ll look two alternative solutions Swing: IBM-sponsored SWT, developed Eclipse editor freely available open-source, standalone GUI library, Macromedia’s Flex tool developing Flash client-side front ends Web applications. 3 My favorite example Ken Arnold’s "Napkin" look feel, makes windows look like scribbled napkin. See http://napkinlaf.sourceforge.net. 934 Thinking Java Bruce Eckel Applets When Java first appeared, much brouhaha around language came applet, program delivered across Internet run (inside so-called sandbox, security) Web browser. People foresaw Java applet next stage evolution Internet, many original books Java assumed reason interested language wanted write applets. For various reasons, revolution never happened. A large part problem machines don’t include necessary Java software run applets, downloading installing 10 MB package order run something you’ve casually encountered Web something users willing do. Many users even frightened idea. Java applets client-side application delivery system never achieved critical mass, although still occasionally see applet, generally relegated backwaters computing. This doesn’t mean applets interesting valuable technology. If situation ensure users JRE installed (such inside corporate environment), applets (or JNLP/Java Web Start, described later chapter) might perfect way distribute client programs automatically update everyone’s machine without usual cost effort distributing installing new software. You’ll find introduction technology applets online supplements book www.MindView.net. Swing basics Most Swing applications built inside basic JFrame, creates window whatever operating system you’re using. The title window set using JFrame constructor, like this: //: gui/HelloSwing.java import javax.swing.*; public class HelloSwing { public static void main(String[] args) { JFrame frame = new JFrame("Hello Swing"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300, 100); frame.setVisible(true); } } ///:~ setDefaultCloseOperation( ) tells JFrame user executes shutdown maneuver. The EXIT_ON_CLOSE constant tells exit program. Without call, default behavior nothing, application wouldn’t close. setSize( ) sets size window pixels. Notice last line: frame.setVisible(true); Without this, won’t see anything screen. Graphical User Interfaces 935 We make things little interesting adding JLabel JFrame: //: gui/HelloLabel.java import javax.swing.*; import java.util.concurrent.*; public class HelloLabel { public static void main(String[] args) throws Exception { JFrame frame = new JFrame("Hello Swing"); JLabel label = new JLabel("A Label"); frame.add(label); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300, 100); frame.setVisible(true); TimeUnit.SECONDS.sleep(1); label.setText("Hey! This Different!"); } } ///:~ After one second, text JLabel changes. While entertaining safe trivial program, it’s really good idea main( ) thread write directly GUI components. Swing thread dedicated receiving UI events updating screen. If start manipulating screen threads, collisions deadlock described Concurrency chapter. Instead, threads—like main( ), here—should submit tasks executed Swing event dispatch thread. 4 You handing task SwingUtilities.invokeLater( ), puts event queue (eventually) executed event dispatch thread. If previous example, looks like this: //: gui/SubmitLabelManipulationTask.java import javax.swing.*; import java.util.concurrent.*; public class SubmitLabelManipulationTask { public static void main(String[] args) throws Exception { JFrame frame = new JFrame("Hello Swing"); final JLabel label = new JLabel("A Label"); frame.add(label); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300, 100); frame.setVisible(true); TimeUnit.SECONDS.sleep(1); SwingUtilities.invokeLater(new Runnable() { public void run() { label.setText("Hey! This Different!"); } }); } } ///:~ Now longer manipulating JLabel directly. Instead, submit Runnable, event dispatch thread actual manipulation, gets task event queue. And it’s executing Runnable, it’s anything else, won’t collisions—if code program follows approach submitting manipulations SwingUtilities.invokeLater( ). This includes starting program itself—main( ) call Swing methods program, 4 936 Technically, event dispatch thread comes AWT library. Thinking Java Bruce Eckel instead submit task event queue. 5 So properly written program look something like this: //: gui/SubmitSwingProgram.java import javax.swing.*; import java.util.concurrent.*; public class SubmitSwingProgram extends JFrame { JLabel label; public SubmitSwingProgram() { super("Hello Swing"); label = new JLabel("A Label"); add(label); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(300, 100); setVisible(true); } static SubmitSwingProgram ssp; public static void main(String[] args) throws Exception { SwingUtilities.invokeLater(new Runnable() { public void run() { ssp = new SubmitSwingProgram(); } }); TimeUnit.SECONDS.sleep(1); SwingUtilities.invokeLater(new Runnable() { public void run() { ssp.label.setText("Hey! This Different!"); } }); } } ///:~ Notice call sleep( ) inside constructor. If put there, original JLabel text never appears, one thing, constructor doesn’t complete sleep( ) finishes new label inserted. But sleep( ) inside constructor, inside UI operation, means you’re halting event dispatch thread sleep( ), generally bad idea. Exercise 1: (1) Modify HelloSwing.java prove application close without call setDefaultCloseOperation( ). Exercise 2: (2) Modify HelloLabel.java show label addition dynamic, adding random number labels. A display framework We combine ideas reduce redundant code creating display framework use Swing examples rest chapter: //: net/mindview/util/SwingConsole.java // Tool running Swing demos // console, applets JFrames. package net.mindview.util; import javax.swing.*; public class SwingConsole { public static void 5 This practice added Java SE5, see lots older programs don’t it. That doesn’t mean authors ignorant. The suggested practices seem constantly evolving. Graphical User Interfaces 937 run(final JFrame f, final int width, final int height) { SwingUtilities.invokeLater(new Runnable() { public void run() { f.setTitle(f.getClass().getSimpleName()); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setSize(width, height); f.setVisible(true); } }); } } ///:~ This tool may want use yourself, it’s placed library net.mindview.util. To use it, application must JFrame (which examples book are). The static run( ) method sets title window simple class name JFrame. Exercise 3: (3) Modify SubmitSwingProgram.java uses SwingConsole. Making button Making button quite simple: You call JButton constructor label want button. You’ll see later fancier things, like putting graphic images buttons. Usually, you’ll want create field button inside class refer later. The JButton component—its little window—that automatically get repainted part update. This means don’t explicitly paint button kind control; simply place form let automatically take care painting themselves. You’ll usually place button form inside constructor: //: gui/Button1.java // Putting buttons Swing application. import javax.swing.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class Button1 extends JFrame { private JButton b1 = new JButton("Button 1"), b2 = new JButton("Button 2"); public Button1() { setLayout(new FlowLayout()); add(b1); add(b2); } public static void main(String[] args) { run(new Button1(), 200, 100); } } ///:~ Something new added here: Before elements placed JFrame, given "layout manager," type FlowLayout. The layout manager way pane implicitly decides place controls form. The normal behavior JFrame use BorderLayout, won’t work (as learn later chapter) defaults covering control entirely every new one added. 938 Thinking Java Bruce Eckel However, FlowLayout causes controls flow evenly onto form, left right top bottom. Exercise 4: (1) Verify without setLayout( ) call Buttoni.java, one button appear resulting program. Capturing event If compile run preceding program, nothing happens press buttons. This must step write code determine happen. The basis event-driven programming, comprises lot GUI about, connecting events code responds events. The way accomplished Swing cleanly separating interface (the graphical components) implementation (the code want run event happens component). Each Swing component report events might happen it, report kind event individually. So you’re interested in, example, whether mouse moved button, don’t register interest event. It’s straightforward elegant way handle event-driven programming, understand basic concepts, easily use Swing components haven’t seen before—in fact, model extends anything classified JavaBean (discussed later chapter). At first, focus main event interest components used. In case JButton, "event interest" button pressed. To register interest button press, call JButton’s addActionListener( ) method. This method expects argument object implements ActionListener interface. That interface contains single method called actionPerformed( ). So attach code JButton, implement ActionListener interface class, register object class JButton via addActionListener( ). The actionPerformed( ) method called button pressed (this normally referred callback). But result pressing button be? We’d like see something change screen, new Swing component introduced: JTextField. This place text typed end user or, case, inserted program. Although number ways create JTextField, simplest tell constructor wide want field be. Once JTextField placed form, modify contents using setText( ) method (there many methods JTextField, must look JDK documentation http://java.sun.com). Here looks like: //: gui/Button2.java // Responding button presses. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class Button2 extends JFrame { private JButton b1 = new JButton("Button 1"), b2 = new JButton("Button 2"); private JTextField txt = new JTextField(10); class ButtonListener implements ActionListener { public void actionPerformed(ActionEvent e) { String name = ((JButton)e.getSource()).getText(); txt.setText(name); Graphical User Interfaces 939 } } private ButtonListener bl = new ButtonListener(); public Button2() { b1.addActionListener(bl); b2.addActionListener(bl); setLayout(new FlowLayout()); add(b1); add(b2); add(txt); } public static void main(String[] args) { run(new Button2(), 200, 150); } } ///:~ Creating JTextField placing canvas takes steps JButtons Swing component. The difference preceding program creation aforementioned ActionListener class ButtonListener. The argument actionPerformed( ) type ActionEvent, contains information event came from. In case, I wanted describe button pressed; getSource( ) produces object event originated, I assumed (using cast) object JButton. getText( ) returns text that’s button, placed JTextField prove code actually called button pressed. In constructor, addActionListener( ) used register ButtonListener object buttons. It often convenient code ActionListener anonymous inner class, especially since tend use single instance listener class. Button2.java modified use anonymous inner class follows: //: gui/Button2b.java // Using anonymous inner classes. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class Button2b extends JFrame { private JButton b1 = new JButton("Button 1"), b2 = new JButton("Button 2"); private JTextField txt = new JTextField(10); private ActionListener bl = new ActionListener() { public void actionPerformed(ActionEvent e) { String name = ((JButton)e.getSource()).getText(); txt.setText(name); } }; public Button2b() { b1.addActionListener(bl); b2.addActionListener(bl); setLayout(new FlowLayout()); add(b1); add(b2); add(txt); } public static void main(String[] args) { run(new Button2b(), 200, 150); 940 Thinking Java Bruce Eckel } } ///:~ The approach using anonymous inner class preferred (when possible) examples book. Exercise 5: (4) Create application using SwingConsole class. Include one text field three buttons. When press button, make different text appear text field. Text areas A JTextArea like JTextField except multiple lines functionality. A particularly useful method append( ); easily pour output JTextArea. Because scroll backwards, improvement command-line programs print standard output. As example, following program fills JTextArea output Countries generator Containers Depth chapter: //: gui/TextArea.java // Using JTextArea control. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.*; import net.mindview.util.*; import static net.mindview.util.SwingConsole.*; public class TextArea extends JFrame { private JButton b = new JButton("Add Data"), c = new JButton("Clear Data"); private JTextArea = new JTextArea(20, 40); private Map<String,String> = new HashMap<String,String>(); public TextArea() { // Use data: m.putAll(Countries.capitals()); b.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(Map.Entry : m.entrySet()) t.append(me.getKey() + ": "+ me.getValue()+"\n"); } }); c.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { t.setText(""); } }); setLayout(new FlowLayout()); add(new JScrollPane(t)); add(b); add(c); } public static void main(String[] args) { run(new TextArea(), 475, 425); } } ///:~ Graphical User Interfaces 941 In constructor, Map filled countries capitals. Note buttons, ActionListener created added without defining intermediate variable, since never need refer listener program. The "Add Data" button formats appends data, "Clear Data" button uses setText( ) remove text JTextArea. As JTextArea added JFrame, wrapped JScrollPane control scrolling much text placed screen. That’s must order produce full scrolling capabilities. Having tried figure equivalent GUI programming environments, I impressed simplicity good design components like JScrollPane. Exercise 6: (7) Turn strings/TestRegularExpression.java interactive Swing program allows put input string one JTextArea regular expression JTextField. The results displayed second JTextArea. Exercise 7: (5) Create application using SwingConsole, add Swing components addActionListener( ) method. (Look JDK documentation http://java.sun.com. Hint: Search addActionListener( ) using index.) Capture events display appropriate message inside text field. Exercise 8: (6) Almost every Swing component derived Component, setCursor( ) method. Look JDK documentation. Create application change cursor one stock cursors Cursor class. Controlling layout The way place components form Java probably different GUI system you’ve used. First, it’s code; "resources" control placement components. Second, way components placed form controlled absolute positioning "layout manager" decides components lie based order add( ) them. The size, shape, placement components remarkably different one layout manager another. In addition, layout managers adapt dimensions applet application window, window dimension changed, size, shape, placement components change response. JApplet, JFrame, JWindow, JDialog, JPanel, etc., contain display Components. In Container, there’s method called setLayout( ) allows choose different layout manager. In section we’ll explore various layout managers placing buttons (since that’s simplest thing do). These examples won’t capture button events intended show buttons laid out. BorderLayout Unless tell otherwise, JFrame use BorderLayout default layout scheme. Without instruction, takes whatever add( ) places center, stretching object way edges. BorderLayout concept four border regions center area. When add something panel that’s using BorderLayout, use overloaded add( ) method takes constant value first argument. This value following: 942 Thinking Java Bruce Eckel BorderLayout.NORTH Top BorderLayout.SOUTH Bottom BorderLayout.EAST Right BorderLayout.WEST Left BorderLayout.CENTER Fill middle, components edges If don’t specify area place object, defaults CENTER. In example, default layout used, since JFrame defaults BorderLayout: //: gui/BorderLayout1.java // Demonstrates BorderLayout. import javax.swing.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class BorderLayout1 extends JFrame { public BorderLayout1() { add(BorderLayout.NORTH, new JButton("North")); add(BorderLayout.SOUTH, new JButton("South")); add(BorderLayout.EAST, new JButton("East")); add(BorderLayout.WEST, new JButton("West")); add(BorderLayout.CENTER, new JButton("Center")); } public static void main(String[] args) { run(new BorderLayout1(), 300, 250); } } ///:~ For every placement CENTER, element add compressed fit smallest amount space along one dimension stretched maximum along dimension. CENTER, however, spreads dimensions occupy middle. FlowLayout This simply "flows" components onto form, left right top space full, moves row continues flowing. Here’s example sets layout manager FlowLayout places buttons form. You’ll notice FlowLayout, components take "natural" size. A JButton, example, size string. //: gui/FlowLayout1.java // Demonstrates FlowLayout. import javax.swing.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class FlowLayout1 extends JFrame { public FlowLayout1() { setLayout(new FlowLayout()); for(int = 0; < 20; i++) add(new JButton("Button " + i)); } Graphical User Interfaces 943 public static void main(String[] args) { run(new FlowLayout1(), 300, 300); } } ///:~ All components compacted smallest size FlowLayout, might get little bit surprising behavior. For example, JLabel size string, attempting right-justify text yields unchanged display using FlowLayout. Notice resize window, layout manager reflow components accordingly. GridLayout A GridLayout allows build table components, add them, placed left right top bottom grid. In constructor, specify number rows columns need, laid equal proportions. //: gui/GridLayout1.java // Demonstrates GridLayout. import javax.swing.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class GridLayout1 extends JFrame { public GridLayout1() { setLayout(new GridLayout(7,3)); for(int = 0; < 20; i++) add(new JButton("Button " + i)); } public static void main(String[] args) { run(new GridLayout1(), 300, 300); } } ///:~ In case 21 slots 20 buttons. The last slot left empty "balancing" goes GridLayout. GridBagLayout The GridBagLayout provides tremendous control deciding exactly regions window lay reformat window resized. However, it’s also complicated layout manager, quite difficult understand. It intended primarily automatic code generation GUI builder (GUI builders might use GridBagLayout instead absolute placement). If design complicated feel need use GridBagLayout, using GUI builder tool generate design. If feel must know intricate details, I’ll refer one dedicated Swing books starting point. As alternative, may want consider TableLayout, part Swing library downloaded http://java.sun.com. This component layered top GridBagLayout hides complexity, greatly simplify approach. 944 Thinking Java Bruce Eckel Absolute positioning It also possible set absolute position graphical components: 1. Set null layout manager Container: setLayout(null). 2. Call setBounds( ) reshape( ) (depending language version) component, passing bounding rectangle pixel coordinates. You constructor paint( ), depending want achieve. Some GUI builders use approach extensively, usually best way generate code. BoxLayout Because people much trouble understanding working GridBagLayout, Swing also includes BoxLayout, gives many benefits GridBagLayout without complexity. You often use need hand-coded layouts (again, design becomes complex, use GUI builder generates layouts you). BoxLayout allows control placement components either vertically horizontally, control space components using something called "struts glue." You find basic examples BoxLayout online supplements book www.MindView.net. The best approach? Swing powerful; get lot done lines code. The examples shown book quite simple, learning purposes makes sense write hand. You actually accomplish quite bit combining simple layouts. At point, however, stops making sense hand-code GUI forms; becomes complicated good use programming time. The Java Swing designers oriented language libraries support GUI-building tools, created express purpose making programming experience easier. As long understand what’s going layouts deal events (described next), it’s particularly important actually know details lay components hand; let appropriate tool (Java is, all, designed increase programmer productivity). The Swing event model In Swing event model, component initiate ("fire") event. Each type event represented distinct class. When event fired, received one "listeners," act event. Thus, source event place event handled separate. Since typically use Swing components are, need write custom code called components receive event, excellent example separation interface implementation. Each event listener object class implements particular type listener interface. So programmer, create listener object register component that’s firing event. This registration performed calling addXXXListener( ) method event-firing component, "XXX" represents type event listened for. You easily know types events handled noticing names "addListener" methods, try listen wrong events, you’ll discover mistake compile time. You’ll see later chapter Graphical User Interfaces 945 JavaBeans also use names "addListener" methods determine events Bean handle. All event logic, then, go inside listener class. When create listener class, sole restriction must implement appropriate interface. You create global listener class, situation inner classes tend quite useful, provide logical grouping listener classes inside UI business logic classes serving, also inner-class object keeps reference parent object, provides nice way call across class subsystem boundaries. All examples far chapter using Swing event model, remainder section fill details model. Event listener types All Swing components include addXXXListener( ) removeXXXListener( ) methods appropriate types listeners added removed component. You’ll notice "XXX" case also represents argument method, example, addMyListener(MyListener m). The following table includes basic associated events, listeners, methods, along basic components support particular events providing addXXXListener( ) removeXXXListener( ) methods. You keep mind event model designed extensible, may encounter events listener types covered table. 946 Event, listener interface, add- remove-methods Components supporting event ActionEvent ActionListener addActionListener( ) removeActionListener( ) JButton, JList, JTextField, JMenuItem derivatives including JCheckBoxMenuItem, JMenu, JRadioButtonMenuItem AdjustmentEvent AdjustmentListener addAdjustmentListener( ) removeAdjustmentListener( ) JScrollbar anything create implements Adjustable interface ComponentEvent ComponentListener addComponentListener( ) removeComponentListener( ) *Component derivatives, including JButton, JCheckBox, JComboBox, Container, JPanel, JApplet, JScrollPane, Window, JDialog, JFileDialog, JFrame, JLabel, JList, JScrollbar, JTextArea, JTextField ContainerEvent addContainerListener( ) removeContainerListener( ) Container derivatives, JScrollPane, Window, JDialog, JFileDialog, JFrame FocusEvent FocusListener addFocusListener( ) removeFocusListener( ) Component derivatives* KeyEvent KeyListener addKeyListener( ) removeKeyListener( ) Component derivatives* Thinking Java Bruce Eckel Event, listener interface, add- remove-methods Components supporting event MouseEvent (for clicks motion) MouseListener addMouseListener( ) removeMouseListener( ) Component derivatives* MouseEvent 6 (for clicks motion) MouseMotionListener addMouseMotionListener( ) removeMouseMotionListener( ) Component derivatives* WindowEvent WindowListener addWindowListener( ) removeWindowListener( ) Window derivatives, including JDialog, JFileDialog, JFrame ItemEvent ItemListener addItemListener( ) removeItemListener( ) JCheckBox, JCheckBoxMenuItem, JComboBox, JList, anything implements ItemSelectable interface TextEvent TextListener addTextListener( ) removeTextListener( ) Anything derived JTextComponent, including JTextArea JTextField You see type component supports certain types events. It turns rather tedious look events supported component. A simpler approach modify ShowMethods.java program Type Information chapter displays event listeners supported Swing component enter. The Type Information chapter introduced reflection used feature look methods particular class—either entire list methods subset whose names match keyword provide. The magic reflection automatically show methods class without forcing walk inheritance hierarchy, examining base classes level. Thus, provides valuable timesaving tool programming; names Java methods made nicely verbose descriptive, search method names contain particular word interest. When find think you’re looking for, check JDK documentation. Here useful GUI version ShowMethods.java, specialized look "addListener" methods Swing components: //: gui/ShowAddListeners.java // Display "addXXXListener" methods Swing class. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.lang.reflect.*; import java.util.regex.*; import static net.mindview.util.SwingConsole.*; public class ShowAddListeners extends JFrame { There MouseMotionEvent even though seems like ought be. Clicking motion combined MouseEvent, second appearance MouseEvent table error. 6 Graphical User Interfaces 947 private JTextField name = new JTextField(25); private JTextArea results = new JTextArea(40, 65); private static Pattern addListener = Pattern.compile("(add\\w+?Listener\\(.*?\\))"); private static Pattern qualifier = Pattern.compile("\\w+\\."); class NameL implements ActionListener { public void actionPerformed(ActionEvent e) { String nm = name.getText().trim(); if(nm.length() == 0) { results.setText("No match"); return; } Class<?> kind; try { kind = Class.forName("javax.swing." + nm); } catch(ClassNotFoundException ex) { results.setText("No match"); return; } Method[] methods = kind.getMethods(); results.setText(""); for(Method : methods) { Matcher matcher = addListener.matcher(m.toString()); if(matcher.find()) results.append(qualifier.matcher( matcher.group(1)).replaceAll("") + "\n"); } } } public ShowAddListeners() { NameL nameListener = new NameL(); name.addActionListener(nameListener); JPanel top = new JPanel(); top.add(new JLabel("Swing class name (press Enter):")); top.add(name); add(BorderLayout.NORTH, top); add(new JScrollPane(results)); // Initial data test: name.setText("JTextArea"); nameListener.actionPerformed( new ActionEvent("", 0 ,"")); } public static void main(String[] args) { run(new ShowAddListeners(), 500, 400); } } ///:~ You enter Swing class name want look name JTextField. The results extracted using regular expressions, displayed JTextArea. You’ll notice buttons components indicate want search begin. That’s JTextField monitored ActionListener. Whenever make change press Enter, list immediately updated. If text field isn’t empty, used inside Class.forName( ) try look class. If name incorrect, Class.forName( ) fail, means throws exception. This trapped, JTextArea set "No match." But type correct name (capitalization counts), Class.forName( ) successful, getMethods( ) return array Method objects. 948 Thinking Java Bruce Eckel Two regular expressions used here. The first, addListener, looks "add" followed word characters, followed "Listener" argument list parentheses. Notice whole regular expression surrounded non-escaped parentheses, means accessible regular expression "group" matches. Inside NameL.ActionPerformed( ), Matcher created passing Method object Pattern.matcher( ) method. When find( ) called Matcher object, returns true match occurs, case select first matching parenthesized group calling group(1). This string still contains qualifiers, strip off, qualifier Pattern object used ShowMethods.java. At end constructor, initial value placed name action event run provide test initial data. This program convenient way investigate capabilities Swing component. Once know events particular component supports, don’t need look anything react event. You simply: 1. Take name event class remove word "Event." Add word "Listener" remains. This listener interface must implement inner class. 2. Implement interface write methods events want capture. For example, might looking mouse movements, write code mouseMoved( ) method MouseMotionListener interface. (You must implement methods, course, there’s often shortcut this, you’ll see soon.) 3. Create object listener class Step 2. Register component method produced prefixing "add" listener name. For example, addMouseMotionListener( ). Here listener interfaces: Listener interface w/ adapter Methods interface ActionListener actionPerformed(ActionEvent) AdjustmentListener adjustmentValueChanged( AdjustmentEvent) ComponentListener ComponentAdapter componentHidden(ComponentEvent) componentShown(ComponentEvent) componentMoved(ComponentEvent) componentResized(ComponentEvent) ContainerListener ContainerAdapter componentAdded(ContainerEvent) componentRemoved(ContainerEvent) FocusListener FocusAdapter focusGained(FocusEvent) focusLost(FocusEvent) KeyListener KeyAdapter keyPressed(KeyEvent) keyReleased(KeyEvent) keyTyped(KeyEvent) MouseListener MouseAdapter mouseClicked(MouseEvent) mouseEntered(MouseEvent) mouseExited(MouseEvent) mousePressed(MouseEvent) mouseReleased(MouseEvent) Graphical User Interfaces 949 Listener interface w/ adapter Methods interface MouseMotionListener MouseMotionAdapter mouseDragged(MouseEvent) mouseMoved(MouseEvent) WindowListener WindowAdapter windowOpened(WindowEvent) windowClosing(WindowEvent) windowClosed(WindowEvent) windowActivated(WindowEvent) windowDeactivated(WindowEvent) windowIconified(WindowEvent) windowDeiconified(WindowEvent) ItemListener itemStateChanged(ItemEvent) This exhaustive listing, partly event model allows create event types associated listeners. Thus, you’ll regularly come across libraries invented events, knowledge gained chapter allow figure use events. Using listener adapters simplicity In table above, see listener interfaces one method. These trivial implement. However, listener interfaces multiple methods less pleasant use. For example, want capture mouse click (that isn’t already captured you, example, button), need write method mouseClicked( ). But since MouseListener interface, must implement methods even don’t anything. This annoying. To solve problem, (but all) listener interfaces one method provided adapters, names see table above. Each adapter provides default empty methods interface methods. When inherit adapter, override methods need change. For example, typical MouseListener you’ll use looks like this: class MyMouseListener extends MouseAdapter { public void mouseClicked(MouseEvent e) { // Respond mouse click... } } The whole point adapters make creation listener classes easy. There downside adapters, however, form pitfall. Suppose write MouseAdapter like previous one: class MyMouseListener extends MouseAdapter { public void MouseClicked(MouseEvent e) { // Respond mouse click... } } This doesn’t work, drive crazy trying figure why, since everything compile run fine—except method won’t called mouse click. Can see problem? It’s name method: MouseClicked( ) instead mouseClicked( ). A simple slip capitalization results addition completely new method. However, method that’s called mouse clicked, don’t get 950 Thinking Java Bruce Eckel desired results. Despite inconvenience, interface guarantee methods properly implemented. An improved alternative way guarantee fact overriding method use built-in @Override annotation code above. Exercise 9: (5) Starting ShowAddListeners.java, create program full functionality typeinfo.ShowMethods.java. Tracking multiple events To prove events fact fired, it’s worth creating program tracks behavior JButton beyond whether pressed. This example also shows inherit button object JButton. 7 In code below, MyButton class inner class TrackEvent, MyButton reach parent window manipulate text fields, necessary order write status information fields parent. Of course, limited solution, since MyButton used conjunction TrackEvent. This kind code sometimes called "highly coupled": //: gui/TrackEvent.java // Show events happen. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.*; import static net.mindview.util.SwingConsole.*; public class TrackEvent extends JFrame { private HashMap<String,JTextField> h = new HashMap<String,JTextField>(); private String[] event = { "focusGained", "focusLost", "keyPressed", "keyReleased", "keyTyped", "mouseClicked", "mouseEntered", "mouseExited", "mousePressed", "mouseReleased", "mouseDragged", "mouseMoved" }; private MyButton b1 = new MyButton(Color.BLUE, "test1"), b2 = new MyButton(Color.RED, "test2"); class MyButton extends JButton { void report(String field, String msg) { h.get(field).setText(msg); } FocusListener fl = new FocusListener() { public void focusGained(FocusEvent e) { report("focusGained", e.paramString()); } public void focusLost(FocusEvent e) { report("focusLost", e.paramString()); } }; KeyListener kl = new KeyListener() { public void keyPressed(KeyEvent e) { report("keyPressed", e.paramString()); 7 In Java 1.0/1.1 could usefully inherit button object. This one numerous fundamental design flaws. Graphical User Interfaces 951 } public void keyReleased(KeyEvent e) { report("keyReleased", e.paramString()); } public void keyTyped(KeyEvent e) { report("keyTyped", e.paramString()); } }; MouseListener ml = new MouseListener() { public void mouseClicked(MouseEvent e) { report("mouseClicked", e.paramString()); } public void mouseEntered(MouseEvent e) { report("mouseEntered", e.paramString()); } public void mouseExited(MouseEvent e) { report("mouseExited", e.paramString()); } public void mousePressed(MouseEvent e) { report("mousePressed", e.paramString()); } public void mouseReleased(MouseEvent e) { report("mouseReleased", e.paramString()); } }; MouseMotionListener mml = new MouseMotionListener() { public void mouseDragged(MouseEvent e) { report("mouseDragged", e.paramString()); } public void mouseMoved(MouseEvent e) { report("mouseMoved", e.paramString()); } }; public MyButton(Color color, String label) { super(label); setBackground(color); addFocusListener(fl); addKeyListener(kl); addMouseListener(ml); addMouseMotionListener(mml); } } public TrackEvent() { setLayout(new GridLayout(event.length + 1, 2)); for(String evt : event) { JTextField = new JTextField(); t.setEditable(false); add(new JLabel(evt, JLabel.RIGHT)); add(t); h.put(evt, t); } add(b1); add(b2); } public static void main(String[] args) { run(new TrackEvent(), 700, 500); } } ///:~ In MyButton constructor, button’s color set call SetBackground( ). The listeners installed simple method calls. 952 Thinking Java Bruce Eckel The TrackEvent class contains HashMap hold strings representing type event JTextFields information event held. Of course, could created statically rather putting HashMap, I think you’ll agree it’s lot easier use change. In particular, need add remove new type event TrackEvent, simply add remove string event array— everything else happens automatically. When report( ) called, given name event parameter string event. It uses HashMap h outer class look actual JTextField associated event name places parameter string field. This example fun play really see what’s going events program. Exercise 10: (6) Create application using SwingConsole, JButton JTextField. Write attach appropriate listener button focus, characters typed appear JTextField. Exercise 11: (4) Inherit new type button JButton. Each time press button, change color randomly selected value. See ColorBoxes.java (later chapter) example generate random color value. Exercise 12: (4) Monitor new type event TrackEvent.java adding new event-handling code. You’ll need discover type event want monitor. A selection Swing components Now understand layout managers event model, you’re ready see Swing components used. This section non-exhaustive tour Swing components features you’ll probably use time. Each example intended reasonably small easily lift code use programs. Keep mind: 1. You easily see examples looks like execution compiling running downloadable source code chapter (www.MindView.net). 2. The JDK documentation http://java.sun.com contains Swing classes methods (only shown here). 3. Because naming convention used Swing events, it’s fairly easy guess write install handler particular type event. Use lookup program ShowAddListeners.java earlier chapter aid investigation particular component. 4. When things start get complicated graduate GUI builder. Buttons Swing includes number different types buttons. All buttons, check boxes, radio buttons, even menu items inherited AbstractButton (which, since menu items included, would probably better named "AbstractSelector" something Graphical User Interfaces 953 equally general). You’ll see use menu items shortly, following example shows various types buttons available: //: gui/Buttons.java // Various Swing buttons. import javax.swing.*; import javax.swing.border.*; import javax.swing.plaf.basic.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class Buttons extends JFrame { private JButton jb = new JButton("JButton"); private BasicArrowButton = new BasicArrowButton(BasicArrowButton.NORTH), = new BasicArrowButton(BasicArrowButton.SOUTH), right = new BasicArrowButton(BasicArrowButton.EAST), left = new BasicArrowButton(BasicArrowButton.WEST); public Buttons() { setLayout(new FlowLayout()); add(jb); add(new JToggleButton("JToggleButton")); add(new JCheckBox("JCheckBox")); add(new JRadioButton("JRadioButton")); JPanel jp = new JPanel(); jp.setBorder(new TitledBorder("Directions")); jp.add(up); jp.add(down); jp.add(left); jp.add(right); add(jp); } public static void main(String[] args) { run(new Buttons(), 350, 200); } } ///:~ This begins BasicArrowButton javax.swing.plaf.basic, continues various specific types buttons. When run example, you’ll see toggle button holds last position, out. But check boxes radio buttons behave identically other, clicking (they inherited JToggleButton). Button groups If want radio buttons behave "exclusive or" fashion, must add "button group." But, following example demonstrates, AbstractButton added ButtonGroup. To avoid repeating lot code, example uses reflection generate groups different types buttons. This seen makeBPanel( ), creates button group JPanel. The second argument makeBPanel( ) array String. For String, button class represented first argument added JPanel: //: gui/ButtonGroups.java // Uses reflection create groups // different types AbstractButton. import javax.swing.*; import javax.swing.border.*; import java.awt.*; import java.lang.reflect.*; 954 Thinking Java Bruce Eckel import static net.mindview.util.SwingConsole.*; public class ButtonGroups extends JFrame { private static String[] ids = { "June", "Ward", "Beaver", "Wally", "Eddie", "Lumpy" }; static JPanel makeBPanel( Class<? extends AbstractButton> kind, String[] ids) { ButtonGroup bg = new ButtonGroup(); JPanel jp = new JPanel(); String title = kind.getName(); title = title.substring(title.lastIndexOf(‘.’) + 1); jp.setBorder(new TitledBorder(title)); for(String id : ids) { AbstractButton ab = new JButton("failed"); try { // Get dynamic constructor method // takes String argument: Constructor ctor = kind.getConstructor(String.class); // Create new object: ab = (AbstractButton)ctor.newInstance(id); } catch(Exception ex) { System.err.println("can’t create " + kind); } bg.add(ab); jp.add(ab); } return jp; } public ButtonGroups() { setLayout(new FlowLayout()); add(makeBPanel(JButton.class, ids)); add(makeBPanel(JToggleButton.class, ids)); add(makeBPanel(JCheckBox.class, ids)); add(makeBPanel(JRadioButton.class, ids)); } public static void main(String[] args) { run(new ButtonGroups(), 500, 350); } } ///:~ The title border taken name class, stripping path information. The AbstractButton initialized JButton label "failed," ignore exception message, you’ll still see problem screen. The getConstructor( ) method produces Constructor object takes array arguments types list Classes passed getConstructor( ). Then call newInstance( ), passing list arguments—in case, String ids array. To get "exclusive or" behavior buttons, create button group add button want behavior group. When run program, you’ll see buttons except JButton exhibit "exclusive or" behavior. Icons You use Icon inside JLabel anything inherits AbstractButton (including JButton, JCheckBox, JRadioButton, different kinds JMenuItem). Using Icons JLabels quite straightforward (you’ll see example later). The following example explores additional ways use Icons buttons descendants. Graphical User Interfaces 955 You use GIF files want, ones used example part book’s code distribution, available www.MindView.net. To open file bring image, simply create ImageIcon hand file name. From on, use resulting Icon program. //: gui/Faces.java // Icon behavior JButtons. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class Faces extends JFrame { private static Icon[] faces; private JButton jb, jb2 = new JButton("Disable"); private boolean mad = false; public Faces() { faces = new Icon[]{ new ImageIcon(getClass().getResource("Face0.gif")), new ImageIcon(getClass().getResource("Face1.gif")), new ImageIcon(getClass().getResource("Face2.gif")), new ImageIcon(getClass().getResource("Face3.gif")), new ImageIcon(getClass().getResource("Face4.gif")), }; jb = new JButton("JButton", faces[3]); setLayout(new FlowLayout()); jb.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if(mad) { jb.setIcon(faces[3]); mad = false; } else { jb.setIcon(faces[0]); mad = true; } jb.setVerticalAlignment(JButton.TOP); jb.setHorizontalAlignment(JButton.LEFT); } }); jb.setRolloverEnabled(true); jb.setRolloverIcon(faces[1]); jb.setPressedIcon(faces[2]); jb.setDisabledIcon(faces[4]); jb.setToolTipText("Yow!"); add(jb); jb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if(jb.isEnabled()) { jb.setEnabled(false); jb2.setText("Enable"); } else { jb.setEnabled(true); jb2.setText("Disable"); } } }); add(jb2); } public static void main(String[] args) { run(new Faces(), 250, 125); } } ///:~ 956 Thinking Java Bruce Eckel An Icon used argument many different Swing component constructors, also use setIcon( ) add change Icon. This example also shows JButton (or AbstractButton) set various different sorts icons appear things happen button: it’s pressed, disabled, "rolled over" (the mouse moves without clicking). You’ll see gives button nice animated feel. Tool tips The previous example added "tool tip" button. Almost classes you’ll using create user interfaces derived JComponent, contains method called setToolTipText(String). So, virtually anything place form, need say (for object j c JComponent-derived class): jc.setToolTipText("My tip"); When mouse stays JComponent predetermined period time, tiny box containing text pop next mouse. Text fields This example shows JTextFields do: //: gui/TextFields.java // Text fields Java events. import javax.swing.*; import javax.swing.event.*; import javax.swing.text.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class TextFields extends JFrame { private JButton b1 = new JButton("Get Text"), b2 = new JButton("Set Text"); private JTextField t1 = new JTextField(30), t2 = new JTextField(30), t3 = new JTextField(30); private String = ""; private UpperCaseDocument ucd = new UpperCaseDocument(); public TextFields() { t1.setDocument(ucd); ucd.addDocumentListener(new T1()); b1.addActionListener(new B1()); b2.addActionListener(new B2()); t1.addActionListener(new T1A()); setLayout(new FlowLayout()); add(b1); add(b2); add(t1); add(t2); add(t3); } class T1 implements DocumentListener { public void changedUpdate(DocumentEvent e) {} public void insertUpdate(DocumentEvent e) { t2.setText(t1.getText()); t3.setText("Text: "+ t1.getText()); Graphical User Interfaces 957 } public void removeUpdate(DocumentEvent e) { t2.setText(t1.getText()); } } } class T1A implements ActionListener { private int count = 0; public void actionPerformed(ActionEvent e) { t3.setText("t1 Action Event " + count++); } } class B1 implements ActionListener { public void actionPerformed(ActionEvent e) { if(t1.getSelectedText() == null) = t1.getText(); else = t1.getSelectedText(); t1.setEditable(true); } } class B2 implements ActionListener { public void actionPerformed(ActionEvent e) { ucd.setUpperCase(false); t1.setText("Inserted Button 2: " + s); ucd.setUpperCase(true); t1.setEditable(false); } } public static void main(String[] args) { run(new TextFields(), 375, 200); } class UpperCaseDocument extends PlainDocument { private boolean upperCase = true; public void setUpperCase(boolean flag) { upperCase = flag; } public void insertString(int offset, String str, AttributeSet attSet) throws BadLocationException { if(upperCase) str = str.toUpperCase(); super.insertString(offset, str, attSet); } } ///:~ The JTextField t3 included place report action listener JTextField t1 fired. You’ll see action listener JTextField fired press Enter key. The JTextField t1 several listeners attached it. The T1 listener DocumentListener responds change "document" (the contents JTextField, case). It automatically copies text t1 t2. In addition, t1’s document set derived class PlainDocument, called UpperCaseDocument, forces characters uppercase. It automatically detects backspaces performs deletion, adjusting caret handling everything expect. Exercise 13: (3) Modify TextFields.java characters t2 retain original case typed in, instead automatically forced uppercase. 958 Thinking Java Bruce Eckel Borders JComponent contains method called setBorder( ), allows place various interesting borders visible component. The following example demonstrates number different borders available, using method called showBorder( ) creates JPanel puts border case. Also, uses RTTI find name border you’re using (stripping path information), puts name JLabel middle panel: //: gui/Borders.java // Different Swing borders. import javax.swing.*; import javax.swing.border.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class Borders extends JFrame { static JPanel showBorder(Border b) { JPanel jp = new JPanel(); jp.setLayout(new BorderLayout()); String nm = b.getClass().toString(); nm = nm.substring(nm.lastIndexOf(‘.’) + 1); jp.add(new JLabel(nm, JLabel.CENTER), BorderLayout.CENTER); jp.setBorder(b); return jp; } public Borders() { setLayout(new GridLayout(2,4)); add(showBorder(new TitledBorder("Title"))); add(showBorder(new EtchedBorder())); add(showBorder(new LineBorder(Color.BLUE))); add(showBorder( new MatteBorder(5,5,30,30,Color.GREEN))); add(showBorder( new BevelBorder(BevelBorder.RAISED))); add(showBorder( new SoftBevelBorder(BevelBorder.LOWERED))); add(showBorder(new CompoundBorder( new EtchedBorder(), new LineBorder(Color.RED)))); } public static void main(String[] args) { run(new Borders(), 500, 300); } } ///:~ You also create borders put inside buttons, labels, etc.—anything derived JComponent. A mini-editor The JTextPane control provides great deal support editing, without much effort. The following example makes simple use component, ignoring bulk functionality: //: gui/TextPane.java // The JTextPane control little editor. import javax.swing.*; Graphical User Interfaces 959 import import import import java.awt.*; java.awt.event.*; net.mindview.util.*; static net.mindview.util.SwingConsole.*; public class TextPane extends JFrame { private JButton b = new JButton("Add Text"); private JTextPane tp = new JTextPane(); private static Generator sg = new RandomGenerator.String(7); public TextPane() { b.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(int = 1; < 10; i++) tp.setText(tp.getText() + sg.next() + "\n"); } }); add(new JScrollPane(tp)); add(BorderLayout.SOUTH, b); } public static void main(String[] args) { run(new TextPane(), 475, 425); } } ///:~ The button adds randomly generated text. The intent JTextPane allow text edited place, see append( ) method. In case (admittedly, poor use capabilities JTextPane), text must captured, modified, placed back pane using setText( ). Elements added JFrame using default BorderLayout. The JTextPane added (inside JScrollPane) without specifying region, fills center pane edges. The JButton added SOUTH, component fit region; case, button nest bottom screen. Notice built-in features JTextPane, automatic line wrapping. There numerous features look using JDK documentation. Exercise 14: (2) Modify TextPane.java use JTextArea instead JTextPane. Check boxes A check box provides way make single on/off choice. It consists tiny box label. The box typically holds little "x" (or indication set) empty, depending whether item selected. You’ll normally create JCheckBox using constructor takes label argument. You get set state, also get set label want read change JCheckBox created. Whenever JCheckBox set cleared, event occurs, capture way button: using ActionListener. The following example uses JTextArea enumerate check boxes checked: //: gui/CheckBoxes.java // Using JCheckBoxes. import javax.swing.*; import java.awt.*; 960 Thinking Java Bruce Eckel import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class CheckBoxes extends JFrame { private JTextArea = new JTextArea(6, 15); private JCheckBox cb1 = new JCheckBox("Check Box 1"), cb2 = new JCheckBox("Check Box 2"), cb3 = new JCheckBox("Check Box 3"); public CheckBoxes() { cb1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { trace("1", cb1); } }); cb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { trace("2", cb2); } }); cb3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { trace("3", cb3); } }); setLayout(new FlowLayout()); add(new JScrollPane(t)); add(cb1); add(cb2); add(cb3); } private void trace(String b, JCheckBox cb) { if(cb.isSelected()) t.append("Box " + b + " Set\n"); else t.append("Box " + b + " Cleared\n"); } public static void main(String[] args) { run(new CheckBoxes(), 200, 300); } } ///:~ The trace( ) method sends name selected JCheckBox current state JTextArea using append( ), you’ll see cumulative list check boxes selected, along state. Exercise 15: (5) Add check box application created Exercise 5, capture event, insert different text text field. Radio buttons The concept radio buttons GUI programming comes pre-electronic car radios mechanical buttons: When push one in, buttons pop out. Thus, allows force single choice among many. To set associated group JRadioButtons, add ButtonGroup (you number ButtonGroups form). One buttons optionally set true (using second argument constructor). If try set one radio button true, last one set true. Graphical User Interfaces 961 Here’s simple example use radio buttons, showing event capture using ActionListener: //: gui/RadioButtons.java // Using JRadioButtons. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class RadioButtons extends JFrame { private JTextField = new JTextField(15); private ButtonGroup g = new ButtonGroup(); private JRadioButton rb1 = new JRadioButton("one", false), rb2 = new JRadioButton("two", false), rb3 = new JRadioButton("three", false); private ActionListener al = new ActionListener() { public void actionPerformed(ActionEvent e) { t.setText("Radio button " + ((JRadioButton)e.getSource()).getText()); } }; public RadioButtons() { rb1.addActionListener(al); rb2.addActionListener(al); rb3.addActionListener(al); g.add(rb1); g.add(rb2); g.add(rb3); t.setEditable(false); setLayout(new FlowLayout()); add(t); add(rb1); add(rb2); add(rb3); } public static void main(String[] args) { run(new RadioButtons(), 200, 125); } } ///:~ To display state, text field used. This field set non-editable it’s used display data, collect it. Thus alternative using JLabel. Combo boxes (drop-down lists) Like group radio buttons, drop-down list way force user select one element group possibilities. However, it’s compact way accomplish this, it’s easier change elements list without surprising user. (You change radio buttons dynamically, tends visibly jarring.) By default, JComboBox box like combo box Windows, lets select list type selection. To produce behavior must call setEditable( ). With JComboBox box, choose one one element list. In following example, JComboBox box starts certain number entries, new entries added box button pressed. //: gui/ComboBoxes.java // Using drop-down lists. import javax.swing.*; import java.awt.*; 962 Thinking Java Bruce Eckel import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class ComboBoxes extends JFrame { private String[] description = { "Ebullient", "Obtuse", "Recalcitrant", "Brilliant", "Somnescent", "Timorous", "Florid", "Putrescent" }; private JTextField = new JTextField(15); private JComboBox c = new JComboBox(); private JButton b = new JButton("Add items"); private int count = 0; public ComboBoxes() { for(int = 0; < 4; i++) c.addItem(description[count++]); t.setEditable(false); b.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if(count < description.length) c.addItem(description[count++]); } }); c.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { t.setText("index: "+ c.getSelectedIndex() + " " + ((JComboBox)e.getSource()).getSelectedItem()); } }); setLayout(new FlowLayout()); add(t); add(c); add(b); } public static void main(String[] args) { run(new ComboBoxes(), 200, 175); } } ///:~ The JTextField displays "selected index," sequence number currently selected element, well text selected item combo box. List boxes List boxes significantly different JComboBox boxes, appearance. While JComboBox box drops activate it, JList occupies fixed number lines screen time doesn’t change. If want see items list, simply call getSelectedValues( ), produces array String items selected. A JList allows multiple selection; control-click one item (holding Control key performing additional mouse clicks), original item stays highlighted select many want. If select item, shift-click another item, items span two selected. To remove item group, control-click it. //: gui/List.java import javax.swing.*; import javax.swing.border.*; import javax.swing.event.*; import java.awt.*; Graphical User Interfaces 963 import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class List extends JFrame { private String[] flavors = { "Chocolate", "Strawberry", "Vanilla Fudge Swirl", "Mint Chip", "Mocha Almond Fudge", "Rum Raisin", "Praline Cream", "Mud Pie" }; private DefaultListModel lItems = new DefaultListModel(); private JList lst = new JList(lItems); private JTextArea = new JTextArea(flavors.length, 20); private JButton b = new JButton("Add Item"); private ActionListener bl = new ActionListener() { public void actionPerformed(ActionEvent e) { if(count < flavors.length) { lItems.add(0, flavors[count++]); } else { // Disable, since // flavors left added List b.setEnabled(false); } } }; private ListSelectionListener = new ListSelectionListener() { public void valueChanged(ListSelectionEvent e) { if(e.getValueIsAdjusting()) return; t.setText(""); for(Object item : lst.getSelectedValues()) t.append(item + "\n"); } }; private int count = 0; public List() { t.setEditable(false); setLayout(new FlowLayout()); // Create Borders components: Border brd = BorderFactory.createMatteBorder( 1, 1, 2, 2, Color.BLACK); lst.setBorder(brd); t.setBorder(brd); // Add first four items List for(int = 0; < 4; i++) lItems.addElement(flavors[count++]); add(t); add(lst); add(b); // Register event listeners lst.addListSelectionListener(ll); b.addActionListener(bl); } public static void main(String[] args) { run(new List(), 250, 375); } } ///:~ You see borders also added lists. If want put array Strings JList, there’s much simpler solution; pass array JList constructor, builds list automatically. The reason 964 Thinking Java Bruce Eckel using "list model" preceding example list manipulated execution program. JLists automatically provide direct support scrolling. Of course, need wrap JList JScrollPane, details automatically managed you. Exercise 16: (5) Simplify List.java passing array constructor eliminating dynamic addition elements list. Tabbed panes The JTabbedPane allows create "tabbed dialog," filefolder tabs running across one edge. When press tab, brings forward different dialog. //: gui/TabbedPane1.java // Demonstrates Tabbed Pane. import javax.swing.*; import javax.swing.event.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class TabbedPane1 extends JFrame { private String[] flavors = { "Chocolate", "Strawberry", "Vanilla Fudge Swirl", "Mint Chip", "Mocha Almond Fudge", "Rum Raisin", "Praline Cream", "Mud Pie" }; private JTabbedPane tabs = new JTabbedPane(); private JTextField txt = new JTextField(20); public TabbedPane1() { int = 0; for(String flavor : flavors) tabs.addTab(flavors[i], new JButton("Tabbed pane " + i++)); tabs.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { txt.setText("Tab selected: " + tabs.getSelectedIndex()); } }); add(BorderLayout.SOUTH, txt); add(tabs); } public static void main(String[] args) { run(new TabbedPane1(), 400, 250); } } ///:~ When run program, you’ll see JTabbedPane automatically stacks tabs many fit one row. You see resizing window run program console command line. Message boxes Windowing environments commonly contain standard set message boxes allow quickly post information user capture information user. In Swing, message boxes contained JOptionPane. You many different possibilities (some quite sophisticated), ones you’ll commonly use probably message Graphical User Interfaces 965 dialog confirmation dialog, invoked using static JOptionPane.showMessageDialog( ) JOptionPane.showConfirmDialog( ). The following example shows subset message boxes available JOptionPane: //: gui/MessageBoxes.java // Demonstrates JOptionPane. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class MessageBoxes extends JFrame { private JButton[] b = { new JButton("Alert"), new JButton("Yes/No"), new JButton("Color"), new JButton("Input"), new JButton("3 Vals") }; private JTextField txt = new JTextField(15); private ActionListener al = new ActionListener() { public void actionPerformed(ActionEvent e) { String id = ((JButton)e.getSource()).getText(); if(id.equals("Alert")) JOptionPane.showMessageDialog(null, "There’s bug you!", "Hey!", JOptionPane.ERROR_MESSAGE); else if(id.equals("Yes/No")) JOptionPane.showConfirmDialog(null, "or no", "choose yes", JOptionPane.YES_NO_OPTION); else if(id.equals("Color")) { Object[] options = { "Red", "Green" }; int sel = JOptionPane.showOptionDialog( null, "Choose Color!", "Warning", JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options[0]); if(sel != JOptionPane.CLOSED_OPTION) txt.setText("Color Selected: " + options[sel]); } else if(id.equals("Input")) { String val = JOptionPane.showInputDialog( "How many fingers see?"); txt.setText(val); } else if(id.equals("3 Vals")) { Object[] selections = {"First", "Second", "Third"}; Object val = JOptionPane.showInputDialog( null, "Choose one", "Input", JOptionPane.INFORMATION_MESSAGE, null, selections, selections[0]); if(val != null) txt.setText(val.toString()); } } }; public MessageBoxes() { setLayout(new FlowLayout()); for(int = 0; < b.length; i++) { b[i].addActionListener(al); add(b[i]); } add(txt); } public static void main(String[] args) { run(new MessageBoxes(), 200, 200); 966 Thinking Java Bruce Eckel } } ///:~ To write single ActionListener, I’ve used somewhat risky approach checking String labels buttons. The problem it’s easy get label little bit wrong, typically capitalization, bug hard spot. Note showOptionDialog( ) showInputDialog( ) provide return objects contain value entered user. Exercise 17: (5) Create application using SwingConsole. In JDK documentation http://java.sun.com, find JPasswordField add program. If user types correct password, use JOptionPane provide success message user. Exercise 18: (4) Modify MessageBoxes.java individual ActionListener button (instead matching button text). Menus Each component capable holding menu, including JApplet, JFrame, JDialog, descendants, setJMenuBar( ) method accepts JMenuBar (you one JMenuBar particular component). You add JMenus JMenuBar, JMenuItems JMenus. Each JMenuItem ActionListener attached it, fired menu item selected. With Java Swing must hand assemble menus source code. Here simple menu example: //: gui/SimpleMenus.java import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class SimpleMenus extends JFrame { private JTextField = new JTextField(15); private ActionListener al = new ActionListener() { public void actionPerformed(ActionEvent e) { t.setText(((JMenuItem)e.getSource()).getText()); } }; private JMenu[] menus = { new JMenu("Winken"), new JMenu("Blinken"), new JMenu("Nod") }; private JMenuItem[] items = { new JMenuItem("Fee"), new JMenuItem("Fi"), new JMenuItem("Fo"), new JMenuItem("Zip"), new JMenuItem("Zap"), new JMenuItem("Zot"), new JMenuItem("Olly"), new JMenuItem("Oxen"), new JMenuItem("Free") }; public SimpleMenus() { for(int = 0; < items.length; i++) { items[i].addActionListener(al); menus[i % 3].add(items[i]); } JMenuBar mb = new JMenuBar(); Graphical User Interfaces 967 for(JMenu jm : menus) mb.add(jm); setJMenuBar(mb); setLayout(new FlowLayout()); add(t); } public static void main(String[] args) { run(new SimpleMenus(), 200, 150); } } ///:~ The use modulus operator "i%3" distributes menu items among three JMenus. Each JMenuItem must ActionListener attached it; here, ActionListener used everywhere, you’ll usually need individual one JMenuItem. JMenuItem inherits AbstractButton, button-like behaviors. By itself, provides item placed drop-down menu. There also three types inherited JMenuItem: JMenu, hold JMenuItems (so cascading menus); JCheckBoxMenuItem, produces check mark indicate whether menu item selected; JRadioButtonMenuItem, contains radio button. As sophisticated example, ice cream flavors again, used create menus. This example also shows cascading menus, keyboard mnemonics, JCheckBoxMenuItems, way dynamically change menus: //: gui/Menus.java // Submenus, check box menu items, swapping menus, // mnemonics (shortcuts) action commands. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class Menus extends JFrame { private String[] flavors = { "Chocolate", "Strawberry", "Vanilla Fudge Swirl", "Mint Chip", "Mocha Almond Fudge", "Rum Raisin", "Praline Cream", "Mud Pie" }; private JTextField = new JTextField("No flavor", 30); private JMenuBar mb1 = new JMenuBar(); private JMenu f = new JMenu("File"), = new JMenu("Flavors"), = new JMenu("Safety"); // Alternative approach: private JCheckBoxMenuItem[] safety = { new JCheckBoxMenuItem("Guard"), new JCheckBoxMenuItem("Hide") }; private JMenuItem[] file = { new JMenuItem("Open") }; // A second menu bar swap to: private JMenuBar mb2 = new JMenuBar(); private JMenu fooBar = new JMenu("fooBar"); private JMenuItem[] = { // Adding menu shortcut (mnemonic) // simple, JMenuItems // constructors: new JMenuItem("Foo", KeyEvent.VK_F), new JMenuItem("Bar", KeyEvent.VK_A), 968 Thinking Java Bruce Eckel // No shortcut: new JMenuItem("Baz"), }; private JButton b = new JButton("Swap Menus"); class BL implements ActionListener { public void actionPerformed(ActionEvent e) { JMenuBar = getJMenuBar(); setJMenuBar(m == mb1 ? mb2 : mb1); validate(); // Refresh frame } } class ML implements ActionListener { public void actionPerformed(ActionEvent e) { JMenuItem target = (JMenuItem)e.getSource(); String actionCommand = target.getActionCommand(); if(actionCommand.equals("Open")) { String = t.getText(); boolean chosen = false; for(String flavor : flavors) if(s.equals(flavor)) chosen = true; if(!chosen) t.setText("Choose flavor first!"); else t.setText("Opening " + + ". Mmm, mm!"); } } } class FL implements ActionListener { public void actionPerformed(ActionEvent e) { JMenuItem target = (JMenuItem)e.getSource(); t.setText(target.getText()); } } // Alternatively, create different // class different MenuItem. Then // don’t figure one is: class FooL implements ActionListener { public void actionPerformed(ActionEvent e) { t.setText("Foo selected"); } } class BarL implements ActionListener { public void actionPerformed(ActionEvent e) { t.setText("Bar selected"); } } class BazL implements ActionListener { public void actionPerformed(ActionEvent e) { t.setText("Baz selected"); } } class CMIL implements ItemListener { public void itemStateChanged(ItemEvent e) { JCheckBoxMenuItem target = (JCheckBoxMenuItem)e.getSource(); String actionCommand = target.getActionCommand(); if(actionCommand.equals("Guard")) t.setText("Guard Ice Cream! " + "Guarding " + target.getState()); else if(actionCommand.equals("Hide")) t.setText("Hide Ice Cream! " + "Is hidden? " + target.getState()); Graphical User Interfaces 969 } } public Menus() { ML ml = new ML(); CMIL cmil = new CMIL(); safety[0].setActionCommand("Guard"); safety[0].setMnemonic(KeyEvent.VK_G); safety[0].addItemListener(cmil); safety[1].setActionCommand("Hide"); safety[1].setMnemonic(KeyEvent.VK_H); safety[1].addItemListener(cmil); other[0].addActionListener(new FooL()); other[1].addActionListener(new BarL()); other[2].addActionListener(new BazL()); FL fl = new FL(); int n = 0; for(String flavor : flavors) { JMenuItem mi = new JMenuItem(flavor); mi.addActionListener(fl); m.add(mi); // Add separators intervals: if((n++ + 1) % 3 == 0) m.addSeparator(); } for(JCheckBoxMenuItem sfty : safety) s.add(sfty); s.setMnemonic(KeyEvent.VK_A); f.add(s); f.setMnemonic(KeyEvent.VK_F); for(int = 0; < file.length; i++) { file[i].addActionListener(ml); f.add(file[i]); } mb1.add(f); mb1.add(m); setJMenuBar(mb1); t.setEditable(false); add(t, BorderLayout.CENTER); // Set system swapping menus: b.addActionListener(new BL()); b.setMnemonic(KeyEvent.VK_S); add(b, BorderLayout.NORTH); for(JMenuItem oth : other) fooBar.add(oth); fooBar.setMnemonic(KeyEvent.VK_B); mb2.add(fooBar); } public static void main(String[] args) { run(new Menus(), 300, 200); } } ///:~ In program I placed menu items arrays stepped array, calling add( ) JMenuItem. This makes adding subtracting menu item somewhat less tedious. This program creates two JMenuBars demonstrate menu bars actively swapped program running. You see JMenuBar made JMenus, JMenu made JMenuItems, JCheckBoxMenuItems, even JMenus (which produce submenus). When JMenuBar assembled, installed current program setJMenuBar( ) method. Note 970 Thinking Java Bruce Eckel button pressed, checks see menu currently installed calling getJMenuBar( ), puts menu bar place. When testing "Open," notice spelling capitalization critical, Java signals error match "Open." This kind string comparison source programming errors. The checking unchecking menu items taken care automatically. The code handling JCheckBoxMenuItems shows two different ways determine checked: string matching (the less-safe approach, although you’ll see used) matching event target object. As shown, getState( ) method used reveal state. You also change state JCheckBoxMenuItem setState( ). The events menus bit inconsistent lead confusion: JMenuItems use ActionListeners, JCheckBoxMenuItems use ItemListeners. The JMenu objects also support ActionListeners, that’s usually helpful. In general, you’ll attach listeners JMenuItem, JCheckBoxMenuItem, JRadioButtonMenuItem, example shows ItemListeners ActionListeners attached various menu components. Swing supports mnemonics, "keyboard shortcuts," select anything derived AbstractButton (button, menu item, etc.) using keyboard instead mouse. These quite simple; JMenuItem, use overloaded constructor takes, second argument, identifier key. However, AbstractButtons constructors like this, general way solve problem use setMnemonic( ) method. The preceding example adds mnemonics button menu items; shortcut indicators automatically appear components. You also see use setActionCommand( ). This seems bit strange case, "action command" exactly label menu component. Why use label instead alternative string? The problem internationalization. If retarget program another language, want change label menu, change code (which would doubt introduce new errors). By using setActionCommand( ), "action command" immutable, menu label change. All code works "action command," it’s unaffected changes menu labels. Note program, menu components examined action commands, aren’t action command set. The bulk work happens listeners. BL performs JMenuBar swapping. In ML, "figure rang" approach taken getting source ActionEvent casting JMenuItem, getting action command string pass cascaded statement. The FL listener simple even though it’s handling different flavors flavor menu. This approach useful enough simplicity logic, general, you’ll want take approach used FooL, BarL, BazL, attached single menu component, extra detection logic necessary, know exactly called listener. Even profusion classes generated way, code inside tends smaller, process foolproof. You see menu code quickly gets long-winded messy. This another case use GUI builder appropriate solution. A good tool also handle maintenance menus. Exercise 19: (3) Modify Menus.java use radio buttons instead check boxes menus. Graphical User Interfaces 971 Exercise 20: (6) Create program breaks text file words. Distribute words labels menus submenus. Pop-up menus The straightforward way implement JPopupMenu create inner class extends MouseAdapter, add object inner class component want produce pop-up behavior: //: gui/Popup.java // Creating popup menus Swing. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class Popup extends JFrame { private JPopupMenu popup = new JPopupMenu(); private JTextField = new JTextField(10); public Popup() { setLayout(new FlowLayout()); add(t); ActionListener al = new ActionListener() { public void actionPerformed(ActionEvent e) { t.setText(((JMenuItem)e.getSource()).getText()); } }; JMenuItem = new JMenuItem("Hither"); m.addActionListener(al); popup.add(m); = new JMenuItem("Yon"); m.addActionListener(al); popup.add(m); = new JMenuItem("Afar"); m.addActionListener(al); popup.add(m); popup.addSeparator(); = new JMenuItem("Stay Here"); m.addActionListener(al); popup.add(m); PopupListener pl = new PopupListener(); addMouseListener(pl); t.addMouseListener(pl); } class PopupListener extends MouseAdapter { public void mousePressed(MouseEvent e) { maybeShowPopup(e); } public void mouseReleased(MouseEvent e) { maybeShowPopup(e); } private void maybeShowPopup(MouseEvent e) { if(e.isPopupTrigger()) popup.show(e.getComponent(), e.getX(), e.getY()); } } public static void main(String[] args) { run(new Popup(), 300, 200); } } ///:~ 972 Thinking Java Bruce Eckel The ActionListener added JMenuItem. It fetches text menu label inserts JTextField. Drawing In good GUI framework, drawing reasonably easy—and is, Swing library. The problem drawing example calculations determine things go typically lot complicated calls drawing routines, calculations often mixed together drawing calls, seem interface complicated actually is. For simplicity, consider problem representing data screenhere, data provided built-in Math.sin( ) method, produces mathematical sine function. To make things little interesting, demonstrate easy use Swing components, slider placed bottom form dynamically control number sine wave cycles displayed. In addition, resize window, you’ll see sine wave refits new window size. Although JComponent may painted thus used canvas, want straightforward drawing surface, typically inherit JPanel. The method need override paintComponent( ), called whenever component must repainted (you normally don’t need worry this, decision managed Swing). When called, Swing passes Graphics object method, use object draw paint surface. In following example, intelligence concerning painting SineDraw class; SineWave class simply configures program slider control. Inside SineDraw, setCycles( ) method provides hook allow another object—the slider control, case—to control number cycles. //: gui/SineWave.java // Drawing Swing, using JSlider. import javax.swing.*; import javax.swing.event.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; class SineDraw extends JPanel { private static final int SCALEFACTOR = 200; private int cycles; private int points; private double[] sines; private int[] pts; public SineDraw() { setCycles(5); } public void paintComponent(Graphics g) { super.paintComponent(g); int maxWidth = getWidth(); double hstep = (double)maxWidth / (double)points; int maxHeight = getHeight(); pts = new int[points]; for(int = 0; < points; i++) pts[i] = (int)(sines[i] * maxHeight/2 * .95 + maxHeight/2); g.setColor(Color.RED); for(int = 1; < points; i++) { int x1 = (int)((i - 1) * hstep); int x2 = (int)(i * hstep); int y1 = pts[i-1]; int y2 = pts[i]; Graphical User Interfaces 973 } } g.drawLine(x1, y1, x2, y2); } public void setCycles(int newCycles) { cycles = newCycles; points = SCALEFACTOR * cycles * 2; sines = new double[points]; for(int = 0; < points; i++) { double radians = (Math.PI / SCALEFACTOR) * i; sines[i] = Math.sin(radians); } repaint(); } public class SineWave extends JFrame { private SineDraw sines = new SineDraw(); private JSlider adjustCycles = new JSlider(1, 30, 5); public SineWave() { add(sines); adjustCycles.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { sines.setCycles( ((JSlider)e.getSource()).getValue()); } }); add(BorderLayout.SOUTH, adjustCycles); } public static void main(String[] args) { run(new SineWave(), 700, 400); } } ///:~ All fields arrays used calculation sine wave points; cycles indicates number complete sine waves desired, points contains total number points graphed, sines contains sine function values, pts contains ycoordinates points drawn JPanel. The setCycles( ) method creates arrays according number points needed fills sines array numbers. By calling repaint( ), setCycles( ) forces paintComponent( ) called rest calculation redraw take place. The first thing must override paintComponent( ) call base-class version method. Then free whatever like; normally, means using Graphics methods find documentation java.awt.Graphics (in JDK documentation http://java.sun.com) draw paint pixels onto JPanel. Here, see almost code involved performing calculations; two method calls actually manipulate screen setColor( ) drawLine( ). You probably similar experience creating program displays graphical data; you’ll spend time figuring want draw, actual drawing process quite simple. When I created program, bulk time spent getting sine wave display. Once I that, I thought would nice dynamically change number cycles. My programming experiences trying things languages made bit reluctant try this, turned easiest part project. I created JSlider (the arguments leftmost value JSIider, rightmost value, starting value, respectively, constructors well) dropped JFrame. Then I looked JDK documentation noticed listener addChangeListener, triggered whenever slider changed enough produce different value. The method obviously named stateChanged( ), provided ChangeEvent object I could look backward 974 Thinking Java Bruce Eckel source change find new value. Calling sines object’s setCycles( ) enabled new value incorporated JPanel redrawn. In general, find Swing problems solved following similar process, you’ll find it’s generally quite simple, even haven’t used particular component before. If problem complex, other, sophisticated alternatives drawing, including third-party JavaBeans components Java 2D API. These solutions beyond scope book, look drawing code becomes onerous. Exercise 21: (5) Modify SineWave.java turn SineDraw JavaBean adding "getter" "setter" methods. Exercise 22: (7) Create application using SwingConsole. This three sliders, one red, green, blue values java.awt.Color. The rest form JPanel displays color determined three sliders. Also include noneditable text fields show current RGB values. Exercise 23: (8) Using SineWave.java starting point, create program displays rotating square screen. One slider control speed rotation, second slider control size box. Exercise 24: (7) Remember "sketching box" toy two knobs, one controls vertical movement drawing point, one controls horizontal movement? Create variation toy, using SineWave.java get started. Instead knobs, use sliders. Add button erase entire sketch. Exercise 25: (8) Starting SineWave.java, create program (an application using SwingConsole class) draws animated sine wave appears scroll past viewing window like oscilloscope, driving animation java.util.Timer. The speed animation controlled javax.swing.JSlider control. Exercise 26: (5) Modify previous exercise multiple sine wave panels created within application. The number sine wave panels controlled command-line parameters. Exercise 27: (5) Modify Exercise 25 javax.swing.Timer class used drive animation. Note difference java.util.Timer. Exercise 28: (7) Create dice class (just class, without GUI). Create five dice throw repeatedly. Draw curve showing sum dots throw, show curve evolving dynamically throw times. Dialog boxes A dialog box window pops another window. Its purpose deal specific issue without cluttering original window details. Dialog boxes commonly used windowed programming environments. To create dialog box, inherit JDialog, another kind Window, like JFrame. A JDialog layout manager (which defaults BorderLayout), add event listeners deal events. Here’s simple example: Graphical User Interfaces 975 //: gui/Dialogs.java // Creating using Dialog Boxes. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; class MyDialog extends JDialog { public MyDialog(JFrame parent) { super(parent, "My dialog", true); setLayout(new FlowLayout()); add(new JLabel("Here dialog")); JButton ok = new JButton("OK"); ok.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { dispose(); // Closes dialog } }); add(ok); setSize(150,125); } } public class Dialogs extends JFrame { private JButton b1 = new JButton("Dialog Box"); private MyDialog dlg = new MyDialog(null); public Dialogs() { b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { dlg.setVisible(true); } }); add(b1); } public static void main(String[] args) { run(new Dialogs(), 125, 75); } } ///:~ Once JDialog created, setVisible(true) must called display activate it. When dialog window closed, must release resources used dialog’s window calling dispose( ). The following example complex; dialog box made grid (using GridLayout) special kind button defined class ToeButton. This button draws frame around and, depending state, blank, "x," "o" middle. It starts blank, depending whose turn is, changes "x" "o." However, also flip back forth "x" "o" click button, provide interesting variation tic-tac-toe concept. In addition, dialog box set number rows columns changing numbers main application window. //: gui/TicTacToe.java // Dialog boxes creating components. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class TicTacToe extends JFrame { private JTextField rows = new JTextField("3"), 976 Thinking Java Bruce Eckel cols = new JTextField("3"); private enum State { BLANK, XX, OO } static class ToeDialog extends JDialog { private State turn = State.XX; // Start x’s turn ToeDialog(int cellsWide, int cellsHigh) { setTitle("The game itself"); setLayout(new GridLayout(cellsWide, cellsHigh)); for(int = 0; < cellsWide * cellsHigh; i++) add(new ToeButton()); setSize(cellsWide * 50, cellsHigh * 50); setDefaultCloseOperation(DISPOSE_ON_CLOSE); } class ToeButton extends JPanel { private State state = State.BLANK; public ToeButton() { addMouseListener(new ML()); } public void paintComponent(Graphics g) { super.paintComponent(g); int x1 = 0, y1 = 0, x2 = getSize().width - 1, y2 = getSize().height - 1; g.drawRect(x1, y1, x2, y2); x1 = x2/4; y1 = y2/4; int wide = x2/2, high = y2/2; if(state == State.XX) { g.drawLine(x1, y1, x1 + wide, y1 + high); g.drawLine(x1, y1 + high, x1 + wide, y1); } if(state == State.OO) g.drawOval(x1, y1, x1 + wide/2, y1 + high/2); } class ML extends MouseAdapter { public void mousePressed(MouseEvent e) { if(state == State.BLANK) { state = turn; turn = (turn == State.XX ? State.OO : State.XX); } else state = (state == State.XX ? State.OO : State.XX); repaint(); } } } } class BL implements ActionListener { public void actionPerformed(ActionEvent e) { JDialog = new ToeDialog( new Integer(rows.getText()), new Integer(cols.getText())); d.setVisible(true); } } public TicTacToe() { JPanel p = new JPanel(); p.setLayout(new GridLayout(2,2)); p.add(new JLabel("Rows", JLabel.CENTER)); p.add(rows); p.add(new JLabel("Columns", JLabel.CENTER)); p.add(cols); add(p, BorderLayout.NORTH); Graphical User Interfaces 977 JButton b = new JButton("go"); b.addActionListener(new BL()); add(b, BorderLayout.SOUTH); } public static void main(String[] args) { run(new TicTacToe(), 200, 200); } } ///:~ Because statics outer level class, inner classes cannot static data nested classes. The paintComponent( ) method draws square around panel "x" "o." This full tedious calculations, it’s straightforward. A mouse click captured MouseListener, first checks see panel anything written it. If not, parent window queried find whose turn is, establishes state ToeButton. Via inner-class mechanism, ToeButton reaches back parent changes turn. If button already displaying "x" "o," flopped. You see calculations convenient use ternary if-else described Operators chapter. After state change, ToeButton repainted. The constructor ToeDialog quite simple: It adds GridLayout many buttons request, resizes 50 pixels side button. TicTacToe sets whole application creating JTextFields (for inputting rows columns button grid) "go" button ActionListener. When button pressed, data JTextFields must fetched, and, since String form, turned ints using Integer constructor takes String argument. File dialogs Some operating systems number special built-in dialog boxes handle selection things fonts, colors, printers, like. Virtually graphical operating systems support opening saving files, Java’s JFileChooser encapsulates easy use. The following application exercises two forms JFileChooser dialogs, one opening one saving. Most code familiar, interesting activities happen action listeners two different button clicks: //: gui/FileChooserTest.java // Demonstration File dialog boxes. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class FileChooserTest extends JFrame { private JTextField fileName = new JTextField(), dir = new JTextField(); private JButton open = new JButton("Open"), save = new JButton("Save"); public FileChooserTest() { JPanel p = new JPanel(); 978 Thinking Java Bruce Eckel open.addActionListener(new OpenL()); p.add(open); save.addActionListener(new SaveL()); p.add(save); add(p, BorderLayout.SOUTH); dir.setEditable(false); fileName.setEditable(false); p = new JPanel(); p.setLayout(new GridLayout(2,1)); p.add(fileName); p.add(dir); add(p, BorderLayout.NORTH); } class OpenL implements ActionListener { public void actionPerformed(ActionEvent e) { JFileChooser c = new JFileChooser(); // Demonstrate "Open" dialog: int rVal = c.showOpenDialog(FileChooserTest.this); if(rVal == JFileChooser.APPROVE_OPTION) { fileName.setText(c.getSelectedFile().getName()); dir.setText(c.getCurrentDirectory().toString()); } if(rVal == JFileChooser.CANCEL_OPTION) { fileName.setText("You pressed cancel"); dir.setText(""); } } } class SaveL implements ActionListener { public void actionPerformed(ActionEvent e) { JFileChooser c = new JFileChooser(); // Demonstrate "Save" dialog: int rVal = c.showSaveDialog(FileChooserTest.this); if(rVal == JFileChooser.APPROVE_OPTION) { fileName.setText(c.getSelectedFile().getName()); dir.setText(c.getCurrentDirectory().toString()); } if(rVal == JFileChooser.CANCEL_OPTION) { fileName.setText("You pressed cancel"); dir.setText(""); } } } public static void main(String[] args) { run(new FileChooserTest(), 250, 150); } } ///:~ Note many variations apply JFileChooser, including filters narrow file names allow. For "open file" dialog, call showOpenDialog( ), "save file" dialog, call showSaveDialog( ). These commands don’t return dialog closed. The JFileChooser object still exists, read data it. The methods getSelectedFile( ) getCurrentDirectory( ) two ways interrogate results operation. If return null, means user canceled dialog. Exercise 29: (3) In JDK documentation javax.swing, look JColorChooser. Write program button brings color chooser dialog. Graphical User Interfaces 979 HTML Swing components Any component take text also take HTML text, reformat according HTML rules. This means easily add fancy text Swing component. For example: //: gui/HTMLButton.java // Putting HTML text Swing components. import javax.swing.*; import java.awt.*; import java.awt.event.*; import static net.mindview.util.SwingConsole.*; public class HTMLButton extends JFrame { private JButton b = new JButton( "<html><b><font size=+2>" + "<center>Hello!<br><i>Press now!"); public HTMLButton() { b.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { add(new JLabel("<html>" + "<i><font size=+4>Kapow!")); // Force re-layout include new label: validate(); } }); setLayout(new FlowLayout()); add(b); } public static void main(String[] args) { run(new HTMLButton(), 200, 500); } } ///:~ You must start text "<html>," use normal HTML tags. Note forced include normal closing tags. The ActionListener adds new JLabel form, also contains HTML text. However, label added construction, must call container’s validate( ) method order force re-layout components (and thus display new label). You also use HTML text JTabbedPane, JMenuItem, JToolTip, JRadioButton, JCheckBox. Exercise 30: (3) Write program shows use HTML text items previous paragraph. Sliders progress bars A slider (which already used SineWave.java) allows user input data moving point back forth, intuitive situations (volume controls, example). A progress bar displays data relative fashion "full" "empty" user gets perspective. My favorite example simply hook slider progress bar move slider, progress bar changes accordingly. The following example also demonstrates ProgressMonitor, fullfeatured pop-up dialog: //: gui/Progress.java 980 Thinking Java Bruce Eckel // Using sliders, progress bars progress monitors. import javax.swing.*; import javax.swing.border.*; import javax.swing.event.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class Progress extends JFrame { private JProgressBar pb = new JProgressBar(); private ProgressMonitor pm = new ProgressMonitor( this, "Monitoring Progress", "Test", 0, 100); private JSlider sb = new JSlider(JSlider.HORIZONTAL, 0, 100, 60); public Progress() { setLayout(new GridLayout(2,1)); add(pb); pm.setProgress(0); pm.setMillisToPopup(1000); sb.setValue(0); sb.setPaintTicks(true); sb.setMajorTickSpacing(20); sb.setMinorTickSpacing(5); sb.setBorder(new TitledBorder("Slide Me")); pb.setModel(sb.getModel()); // Share model add(sb); sb.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { pm.setProgress(sb.getValue()); } }); } public static void main(String[] args) { run(new Progress(), 300, 200); } } ///:~ The key hooking slider progress bar components together sharing model, line: pb.setModel(sb.getModel()); Of course, could also control two using listener, using model straightforward simple situations. The ProgressMonitor model listener approach required. Note ProgressMonitor moves forward, reaches end closes. The JProgressBar fairly straightforward, JSlider lot options, orientation major minor tick marks. Notice straightforward add titled border. Exercise 31: (8) Create "asymptotic progress indicator" gets slower slower approaches finish point. Add random erratic behavior periodically look like it’s starting speed up. Exercise 32: (6) Modify Progress.java share models, instead uses listener connect slider progress bar. Selecting look & feel "Pluggable look & feel" allows program emulate look feel various operating environments. You even dynamically change look feel program Graphical User Interfaces 981 executing. However, generally want one two things: either select "crossplatform" look feel (which Swing’s "metal"), select look feel system currently Java program looks like created specifically system (this almost certainly best choice cases, avoid confounding user). The code select either behaviors quite simple, must execute create visual components, components made based current look feel, changed happen change look feel midway program (that process complicated uncommon, relegated Swing-specific books). Actually, want use cross-platform ("metal") look feel characteristic Swing programs, don’t anything—it’s default. But want instead use current operating environment’s look feel, 8 insert following code, typically beginning main( ), least components added: try { UIManager.setLookAndFeet( UIManager.getSystemLookAndFeelClassName()); } catch(Exception e) { throw new RuntimeException(e); } You don’t actually need anything catch clause UIManager default cross-platform look feel attempts set alternatives fail. However, debugging, exception quite useful, may least want see results via catch clause. Here program takes command-line argument select look feel, shows several different components look chosen look feel: //: gui/LookAndFeel.java // Selecting different looks & feels. // {Args: motif} import javax.swing.*; import java.awt.*; import static net.mindview.util.SwingConsole.*; public class LookAndFeel extends JFrame { private String[] choices = "Eeny Meeny Minnie Mickey Moe Larry Curly".split(" "); private Component[] samples = { new JButton("JButton"), new JTextField("JTextField"), new JLabel("JLabel"), new JCheckBox("JCheckBox"), new JRadioButton("Radio"), new JComboBox(choices), new JList(choices), }; public LookAndFeel() { super("Look And Feel"); setLayout(new FlowLayout()); for(Component component : samples) add(component); } private static void usageError() { System.out.println( "Usage:LookAndFeel [cross|system|motif]"); 8 982 You may argue whether Swing rendering justice operating environment. Thinking Java Bruce Eckel System.exit(1); } public static void main(String[] args) { if(args.length == 0) usageError(); if(args[0].equals("cross")) { try { UIManager.setLookAndFeel(UIManager. getCrossPlatformLookAndFeelClassName()); } catch(Exception e) { e.printStackTrace(); } } else if(args[0].equals("system")) { try { UIManager.setLookAndFeel(UIManager. getSystemLookAndFeelClassName()); } catch(Exception e) { e.printStackTrace(); } } else if(args[0].equals("motif")) { try { UIManager.setLookAndFeel("com.sun.java."+ "swing.plaf.motif.MotifLookAndFeel"); } catch(Exception e) { e.printStackTrace(); } } else usageError(); // Note look & feel must set // components created. run(new LookAndFeel(), 300, 300); } } ///:~ You see one option explicitly specify string look feel, seen MotifLookAndFeel. However, one default "metal" look feel ones legally used platform; even though look-and-feel strings Windows Macintosh, used respective platforms (these produced call getSystemLookAndFeelClassName( ) you’re particular platform). It also possible create custom look feel package, example, building framework company wants distinctive appearance. This big job far beyond scope book (in fact, you’ll discover beyond scope many dedicated Swing books!). Trees, tables & clipboard You find brief introduction examples topics online supplements chapter www.MindView.net. JNLP Java Web Start It’s possible sign applet security purposes. This shown online supplement chapter www.MindView.net. Signed applets powerful effectively take place application, must run inside Web browser. This requires extra overhead browser running client machine, also means user Graphical User Interfaces 983 interface applet limited often visually confusing. The Web browser set menus toolbars, appear applet. 9 The Java Network Launch Protocol (JNLP) solves problem without sacrificing advantages applets. With JNLP application, download install standalone Java application onto client’s machine. This run command prompt, desktop icon, application manager installed JNLP implementation. The application even run Web site originally downloaded. A JNLP application dynamically download resources Internet run time, automatically check version user connected Internet. This means advantages applet together advantages standalone applications. Like applets, JNLP applications need treated caution client’s system. Because this, JNLP applications subject sandbox security restrictions applets. Like applets, deployed signed JAR files, giving user option trust signer. Unlike applets, deployed unsigned JAR file, still request access certain resources client’s system means services JNLP API. The user must approve requests program execution. JNLP describes protocol, implementation, need implementation order use it. Java Web Start, JAWS, Sun’s freely available official reference implementation distributed part Java SE5- If using development, must ensure JAR file (javaws.jar) classpath; easiest solution add javaws.jar classpath normal Java installation path jre/lib. If deploying JNLP application Web server, must ensure server recognizes MIME type application/x-java-jnlp-file. If using recent version Tomcat server (http://jakarta.apache.org/tomcat) pre-configured. Consult user guide particular server. Creating JNLP application difficult. You create standard application archived JAR file, provide launch file, simple XML file gives client system information needs download install application. If choose sign JAR file, must use services supplied JNLP API type resource want access user’s machine. Here variation FileChooserTest.java using JNLP services open file chooser, class deployed JNLP application unsigned JAR file. //: gui/jnlp/JnlpFileChooser.java // Opening files local machine JNLP. // {Requires: javax.jnlp.FileOpenService; // You must javaws.jar classpath} // To create jnlpfilechooser.jar file, this: // cd .. // cd .. // jar cvf gui/jnlp/jnlpfilechooser.jar gui/jnlp/*.class package gui.jnlp; import javax.jnlp.*; import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.io.*; public class JnlpFileChooser extends JFrame { private JTextField fileName = new JTextField(); 9 984 Jeremy Meyer developed section. Thinking Java Bruce Eckel private JButton open = new JButton("Open"), save = new JButton("Save"); private JEditorPane ep = new JEditorPane(); private JScrollPane jsp = new JScrollPane(); private FileContents fileContents; public JnlpFileChooser() { JPanel p = new JPanel(); open.addActionListener(new OpenL()); p.add(open); save.addActionListener(new SaveL()); p.add(save); jsp.getViewport().add(ep); add(jsp, BorderLayout.CENTER); add(p, BorderLayout.SOUTH); fileName.setEditable(false); p = new JPanel(); p.setLayout(new GridLayout(2,1)); p.add(fileName); add(p, BorderLayout.NORTH); ep.setContentType("text"); save.setEnabled(false); } class OpenL implements ActionListener { public void actionPerformed(ActionEvent e) { FileOpenService fs = null; try { fs = (FileOpenService)ServiceManager.lookup( "javax.jnlp.FileOpenService"); } catch(UnavailableServiceException use) { throw new RuntimeException(use); } if(fs != null) { try { fileContents = fs.openFileDialog(".", new String[]{"txt", "*"}); if(fileContents == null) return; fileName.setText(fileContents.getName()); ep.read(fileContents.getInputStream(), null); } catch(Exception exc) { throw new RuntimeException(exc); } save.setEnabled(true); } } } class SaveL implements ActionListener { public void actionPerformed(ActionEvent e) { FileSaveService fs = null; try { fs = (FileSaveService)ServiceManager.lookup( "javax.jnlp.FileSaveService"); } catch(UnavailableServiceException use) { throw new RuntimeException(use); } if(fs != null) { try { fileContents = fs.saveFileDialog(".", new String[]{"txt"}, new ByteArrayInputStream( ep.getText().getBytes()), fileContents.getName()); Graphical User Interfaces 985 if(fileContents == null) return; fileName.setText(fileContents.getName()); } catch(Exception exc) { throw new RuntimeException(exc); } } } } public static void main(String[] args) { JnlpFileChooser fc = new JnlpFileChooser(); fc.setSize(400, 300); fc.setVisible(true); } } ///:~ Note FileOpenService FileSaveService classes imported javax.jnlp package nowhere code JFileChooser dialog box referred directly. The two services used must requested using ServiceManager.lookup( ) method, resources client system accessed via objects returned method. In case, files client’s file system written read using FileContent interface, provided JNLP. Any attempt access resources directly using, say, File FileReader object would cause SecurityException thrown way would tried use unsigned applet. If want use classes restricted JNLP service interfaces, must sign JAR file. The commented jar command JnlpFileChooser.java produce necessary JAR file. Here appropriate launch file preceding example. //:! gui/jnlp/filechooser.jnlp <?xml version="1.0" encoding="UTF-8"?> <jnlp spec = "1.0+" codebase="file:C:/AAA-TIJ4/code/gui/jnlp" href="filechooser.jnlp"> <information> <title>FileChooser demo application</title> <vendor>Mindview Inc.</vendor> <description> Jnlp File chooser Application </description> <description kind="short"> Demonstrates opening, reading writing text file </description> <icon href="mindview.gif"/> <offline-allowed/> </information> <resources> <j2se version="1.3+" href="http://java.sun.com/products/autodl/j2se"/> <jar href="jnlpfilechooser.jar" download="eager"/> </resources> <application-desc main-class="gui.jnlp.JnlpFileChooser"/> </jnlp> ///:~ You’ll find launch file source-code download book (from www.MindView.net) saved filechooser.jnlp without first last lines, directory JAR file. As see, XML file one <jnlp> tag. This sub-elements, mostly selfexplanatory. 986 Thinking Java Bruce Eckel The spec attribute jnlp element tells client system version JNLP application run with. The codebase attribute points URL launch file resources found. Here, points directory local machine, good means testing application. Note you’ll need change path indicates appropriate directory machine, order program load successfully. The href attribute must specify name file. The information tag various sub-elements provide information application. These used Java Web Start administrative console equivalent, installs JNLP application allows user run command line, make shortcuts, on. The resources tag serves similar purpose applet tag HTML file. The J2se subelement specifies J2SE version required run application, jar sub-element specifies JAR file class archived. The jar element attribute download, values "eager" "lazy" tell JNLP implementation whether entire archive needs downloaded application run. The application-desc attribute tells JNLP implementation class executable class, entry point, JAR file. Another useful sub-element jnlp tag security tag, shown here. Here’s security tag looks like: <security> <all-permissions/> <security/> You use security tag application deployed signed JAR file. It needed preceding example local resources accessed via JNLP services. There tags available, details found specification http://java.sun.com/products/javawehstart/downloadspec. html. To launch program, need download page containing hypertext link .jnlp file. Here’s looks like (without first last lines): //:! gui/jnlp/filechooser.html <html> Follow instructions JnlpFileChooser.java build jnlpfilechooser.jar, then: <a href="filechooser.jnlp">click here</a> </html> ///:~ Once downloaded application once, configure using administrative console. If using Java Web Start Windows, prompted make shortcut application second time use it. This behavior configurable. Only two JNLP services covered here, seven services current release. Each designed specific task printing, cutting pasting clipboard. You find information http://java.sun.com. Graphical User Interfaces 987 Concurrency & Swing When program Swing you’re using threads. You saw beginning chapter learned everything submitted Swing event dispatch thread SwingUtilities.invokeLater( ). However, fact don’t explicitly create Thread object means threading issues catch surprise. You must keep mind Swing event dispatch thread, always there, handling Swing events pulling one event queue executing turn. By remembering event dispatch thread you’ll help ensure application won’t suffer deadlocking race conditions. This section addresses threading issues arise working Swing. Long-running tasks One fundamental mistakes make programming graphical user interface accidentally use event dispatch thread run long task. Here’s simple example: //: gui/LongRunningTask.java // A badly designed program. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.concurrent.*; import static net.mindview.util.SwingConsole.*; public class LongRunningTask extends JFrame { private JButton b1 = new JButton("Start Long Running Task"), b2 = new JButton("End Long Running Task"); public LongRunningTask() { b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent evt) { try { TimeUnit.SECONDS.sleep(3); } catch(InterruptedException e) { System.out.println("Task interrupted"); return; } System.out.println("Task completed"); } }); b2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent evt) { // Interrupt yourself? Thread.currentThread().interrupt(); } }); setLayout(new FlowLayout()); add(b1); add(b2); } public static void main(String[] args) { run(new LongRunningTask(), 200, 150); } } ///:~ 988 Thinking Java Bruce Eckel When press b1, event dispatch thread suddenly occupied performing longrunning task. You’ll see button doesn’t even pop back out, event dispatch thread would normally repaint screen busy. And cannot anything else, like press b2, program won’t respond b1’s task complete event dispatch thread available. The code b2 flawed attempt solve problem interrupting event dispatch thread. The answer, course, execute long-running processes separate threads. Here, single-thread Executor used, automatically queues pending tasks executes one time: //: gui/InterruptableLongRunningTask.java // Long-running tasks threads. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.concurrent.*; import static net.mindview.util.SwingConsole.*; class Task implements Runnable { private static int counter = 0; private final int id = counter++; public void run() { System.out.println(this + " started"); try { TimeUnit.SECONDS.sleep(3); } catch(InterruptedException e) { System.out.println(this + " interrupted"); return; } System.out.println(this + " completed"); } public String toString() { return "Task " + id; } public long id() { return id; } }; public class InterruptableLongRunningTask extends JFrame { private JButton b1 = new JButton("Start Long Running Task"), b2 = new JButton("End Long Running Task"); ExecutorService executor = Executors.newSingleThreadExecutor(); public InterruptableLongRunningTask() { b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Task task = new Task(); executor.execute(task); System.out.println(task + " added queue"); } }); b2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { executor.shutdownNow(); // Heavy-handed } }); setLayout(new FlowLayout()); add(b1); add(b2); } public static void main(String[] args) { run(new InterruptableLongRunningTask(), 200, 150); } Graphical User Interfaces 989 } ///:~ This better, press b2, calls shutdownNow( ) ExecutorService, thereby disabling it. If try add tasks, get exception. Thus, pressing b2 makes program inoperable. What we’d like shut current task (and cancel pending tasks) without stopping everything. The Java SE5 Callable/Future mechanism described Concurrency chapter need. We’ll define new class called TaskManager, contains tuples hold Callable representing task Future comes back Callable. The reason tuple necessary allows us keep track original task, may get extra information available Future. Here is: //: net/mindview/util/TaskItem.java // A Future Callable produced it. package net.mindview.util; import java.util.concurrent.*; public class TaskItem<R,C extends Callable<R>> { public final Future<R> future; public final C task; public TaskItem(Future<R> future, C task) { this.future = future; this.task = task; } } ///:~ In java.util.concurrent library, task available via Future default task would necessarily still around get result Future. Here, force task stay around storing it. TaskManager placed net.mindview.util available general-purpose utility: //: net/mindview/util/TaskManager.java // Managing executing queue tasks. package net.mindview.util; import java.util.concurrent.*; import java.util.*; public class TaskManager<R,C extends Callable<R>> extends ArrayList<TaskItem<R,C>> { private ExecutorService exec = Executors.newSingleThreadExecutor(); public void add(C task) { add(new TaskItem<R,C>(exec.submit(task),task)); } public List<R> getResults() { Iterator<TaskItem<R,C>> items = iterator(); List<R> results = new ArrayList<R>(); while(items.hasNext()) { TaskItem<R,C> item = items.next(); if(item.future.isDone()) { try { results.add(item.future.get()); } catch(Exception e) { throw new RuntimeException(e); } items.remove(); } } return results; 990 Thinking Java Bruce Eckel } public List<String> purge() { Iterator<TaskItem<R,C>> items = iterator(); List<String> results = new ArrayList<String>(); while(items.hasNext()) { TaskItem<R,C> item = items.next(); // Leave completed tasks results reporting: if(!item.future.isDone()) { results.add("Cancelling " + item.task); item.future.cancel(true); // May interrupt items.remove(); } } return results; } } ///:~ TaskManager ArrayList Taskltem. It also contains singlethread Executor, call add( ) Callable, submits Callable stores resulting Future along original task. This way, need anything task, reference task. As simple example, purge( ) task’s toString( ) used. This used manage long-running tasks example: //: gui/InterruptableLongRunningCallable.java // Using Callables long-running tasks. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.concurrent.*; import net.mindview.util.*; import static net.mindview.util.SwingConsole.*; class CallableTask extends Task implements Callable<String> { public String call() { run(); return "Return value " + this; } } public class InterruptableLongRunningCallable extends JFrame { private JButton b1 = new JButton("Start Long Running Task"), b2 = new JButton("End Long Running Task"), b3 = new JButton("Get results"); private TaskManager<String,CallableTask> manager = new TaskManager<String,CallableTask>(); public InterruptableLongRunningCallable() { b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { CallableTask task = new CallableTask(); manager.add(task); System.out.println(task + " added queue"); } }); b2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(String result : manager.purge()) System.out.println(result); Graphical User Interfaces 991 } }); b3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { // Sample call Task method: for(TaskItem<String,CallableTask> tt : manager) tt.task.id(); // No cast required for(String result : manager.getResults()) System.out.println(result); } }); setLayout(new FlowLayout()); add(b1); add(b2); add(b3); } public static void main(String[] args) { run(new InterruptableLongRunningCallable(), 200, 150); } } ///:~ As see, CallableTask exactly thing Task except returns result—in case String identifying task. Non-Swing utilities (not part standard Java distribution) called SwingWorker (from Sun Web site) Foxtrot (from http://foxtrot.sourceforge.net) created solve similar problem, writing, utilities modified take advantage Java SE5 Callable/Future mechanism. It’s often important give end user kind visual cue task running, progress. This normally done either JProgressBar ProgressMonitor. This example uses ProgressMonitor: //: gui/MonitoredLongRunningCallable.java // Displaying task progress ProgressMonitors. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.concurrent.*; import net.mindview.util.*; import static net.mindview.util.SwingConsole.*; class MonitoredCallable implements Callable<String> { private static int counter = 0; private final int id = counter++; private final ProgressMonitor monitor; private final static int MAX = 8; public MonitoredCallable(ProgressMonitor monitor) { this.monitor = monitor; monitor.setNote(toString()); monitor.setMaximum(MAX - 1); monitor.setMillisToPopup(500); } public String call() { System.out.println(this + " started"); try { for(int = 0; < MAX; i++) { TimeUnit.MILLISECONDS.sleep(500); if(monitor.isCanceled()) Thread.currentThread().interrupt(); 992 Thinking Java Bruce Eckel final int progress = i; SwingUtilities.invokeLater( new Runnable() { public void run() { monitor.setProgress(progress); } } ); } } catch(InterruptedException e) { monitor.close(); System.out.println(this + " interrupted"); return "Result: " + + " interrupted"; } System.out.println(this + " completed"); return "Result: " + + " completed"; } public String toString() { return "Task " + id; } }; public class MonitoredLongRunningCallable extends JFrame { private JButton b1 = new JButton("Start Long Running Task"), b2 = new JButton("End Long Running Task"), b3 = new JButton("Get results"); private TaskManager<String,MonitoredCallable> manager = new TaskManager<String,MonitoredCallable>(); public MonitoredLongRunningCallable() { b1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { MonitoredCallable task = new MonitoredCallable( new ProgressMonitor( MonitoredLongRunningCallable.this, "Long-Running Task", "", 0, 0) ); manager.add(task); System.out.println(task + " added queue"); } }); b2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(String result : manager.purge()) System.out.println(result); } }); b3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { for(String result : manager.getResults()) System.out.println(result); } }); setLayout(new FlowLayout()); add(b1); add(b2); add(b3); } public static void main(String[] args) { run(new MonitoredLongRunningCallable(), 200, 500); } } ///:~ The MonitoredCallable constructor takes ProgressMonitor argument, call( ) method updates ProgressMonitor every half second. Notice Graphical User Interfaces 993 MonitoredCallable separate task thus try control UI directly, SwingUtilities.invokeLater( ) used submit progress change information monitor. Sun’s Swing Tutorial (on http://java.sun.com) shows alternate approach using Swing Timer, checks status task updates monitor. If "cancel" button pressed monitor, monitor.isCanceled( ) return true. Here, task calls interrupt ) thread, land catch clause monitor terminated close( ) method. The rest code effectively before, except creation ProgressMonitor part MonitoredLongRunningCallable constructor. Exercise 33: (6) Modify InterruptableLongRunningCallable.java runs tasks parallel rather sequentially. Visual threading The following example makes Runnable JPanel class paints different colors itself. This application set take values command line determine big grid colors long sleep( ) color changes. By playing values, may discover interesting possibly inexplicable features threading implementation platform: //: gui/ColorBoxes.java // A visual demonstration threading. import javax.swing.*; import java.awt.*; import java.util.concurrent.*; import java.util.*; import static net.mindview.util.SwingConsole.*; class CBox extends JPanel implements Runnable { private int pause; private static Random rand = new Random(); private Color color = new Color(0); public void paintComponent(Graphics g) { g.setColor(color); Dimension = getSize(); g.fillRect(0, 0, s.width, s.height); } public CBox(int pause) { this.pause = pause; } public void run() { try { while(!Thread.interrupted()) { color = new Color(rand.nextInt(0xFFFFFF)); repaint(); // Asynchronously request paint() TimeUnit.MILLISECONDS.sleep(pause); } } catch(InterruptedException e) { // Acceptable way exit } } } public class ColorBoxes extends JFrame { private int grid = 12; private int pause = 50; private static ExecutorService exec = Executors.newCachedThreadPool(); 994 Thinking Java Bruce Eckel public void setUp() { setLayout(new GridLayout(grid, grid)); for(int = 0; < grid * grid; i++) { CBox cb = new CBox(pause); add(cb); exec.execute(cb); } } public static void main(String[] args) { ColorBoxes boxes = new ColorBoxes(); if(args.length > 0) boxes.grid = new Integer(args[0]); if(args.length > 1) boxes.pause = new Integer(args[1]); boxes.setUp(); run(boxes, 500, 400); } } ///:~ ColorBoxes configures GridLayout grid cells dimension. Then adds appropriate number CBox objects fill grid, passing pause value one. In main( ) see pause grid default values changed pass command-line arguments. CBox work takes place. This inherited JPanel implements Runnable interface JPanel also independent task. These tasks driven thread pool ExecutorService. The current cell color color. Colors created using Color constructor takes 24-bit number, case created randomly. paintComponent( ) quite simple; sets color color fills entire JPanel color. In run( ), see infinite loop sets color new random color calls repaint( ) show it. Then thread goes sleep( ) amount time specified command line. The call repaint( ) run( ) deserves examination. At first glance, may seem like we’re creating lot threads, forcing paint. It might appear violating principle submit tasks event queue. However, threads actually modifying shared resource. When call repaint( ), doesn’t force paint time, sets "dirty flag" indicating next time event dispatch thread ready repaint things, area candidate repainting. Thus program doesn’t cause Swing threading problems. When event dispatch thread actually perform paint( ), first calls paintComponent( ), paintBorder( ) paintChildren( ). If need override paint( ) derived component, must remember call base-class version paint( ) proper actions still performed. Precisely design flexible threading tied JPanel element, experiment making many threads want. (In reality, restriction imposed number threads JVM comfortably handle.) This program also makes interesting benchmark, since show dramatic performance behavioral differences one JVM threading implementation another, well different platforms. Graphical User Interfaces 995 Exercise 34: (4) Modify ColorBoxes.java begins sprinkling points ("stars") across canvas, randomly changes colors "stars." Visual programming JavaBeans So far book you’ve seen valuable Java creating reusable pieces code. The "most reusable" unit code class, since comprises cohesive unit characteristics (fields) behaviors (methods) reused either directly via composition inheritance. Inheritance polymorphism essential parts object-oriented programming, majority cases you’re putting together application, really want components exactly need. You’d like drop parts design like chips electronic engineer puts circuit board. It seems way accelerate "modular assembly" style programming. "Visual programming" first became successful—very successful—with Microsoft’s Visual BASIC (VB), followed second-generation design Borland’s Delphi (which primary inspiration JavaBeans design). With programming tools components represented visually, makes sense since usually display kind visual component button text field. The visual representation, fact, often exactly way component look running program. So part process visual programming involves dragging component palette dropping onto form. The Application Builder Integrated Development Environment (IDE) writes code this, code cause component created running program. Simply dropping component onto form usually enough complete program. Often, must change characteristics component, color, text that’s it, database it’s connected to, etc. Characteristics modified design time referred properties. You manipulate properties component inside IDE, create program, configuration data saved rejuvenated program started. By you’re probably used idea object characteristics; it’s also set behaviors. At design time, behaviors visual component partially represented events, meaning "Here’s something happen component." Ordinarily, decide want happen event occurs tying code event. Here’s critical part: The IDE uses reflection dynamically interrogate component find properties events component supports. Once knows are, display properties allow change (saving state build program), also display events. In general, something like doubleclicking event, IDE creates code body ties particular event. All must point write code executes event occurs. All adds lot work that’s done IDE. As result, focus program looks like supposed do, rely IDE manage connection details you. The reason visual programming tools successful dramatically speed process building application—certainly user interface, often portions application well. What JavaBean? 996 Thinking Java Bruce Eckel After dust settles, then, component really block code, typically embodied class. The key issue ability IDE discover properties events component. To create VB component, programmer originally write fairly complicated piece code following certain conventions expose properties events (it got easier years passed). Delphi second-generation visual programming tool, language actively designed around visual programming, much easier create visual component. However, Java brought creation visual components advanced state JavaBeans, Bean class. You don’t write extra code use special language extensions order make something Bean. The thing need do, fact, slightly modify way name methods. It method name tells IDE whether property, event, ordinary method. In JDK documentation, naming convention mistakenly termed "design pattern." This unfortunate, since design patterns (see Thinking Patterns www.MindView.net) challenging enough without sort confusion. It’s design pattern, it’s naming convention, it’s fairly simple: 1. For property named xxx, typically create two methods: getXxx( ) setXxx( ). The first letter "get" "set" automatically lowercased tools look methods, order produce property name. The type produced "get" method type argument "set" method. The name property type "get" "set" related. 2. For boolean property, use "get" "set" approach above, also use "is" instead "get." 3. Ordinary methods Bean don’t conform naming convention, they’re public. 4. For events, use Swing "listener" approach. It’s exactly you’ve seeing: addBounceListener(BounceListener) removeBounceListener(BounceListener) handle BounceEvent. Most time, built-in events listeners satisfy needs, also create events listener interfaces. We use guidelines create simple Bean: //: frogbean/Frog.java // A trivial JavaBean. package frogbean; import java.awt.*; import java.awt.event.*; class Spots {} public class Frog { private int jumps; private Color color; private Spots spots; private boolean jmpr; public int getJumps() { return jumps; } public void setJumps(int newJumps) { jumps = newJumps; } public Color getColor() { return color; } public void setColor(Color newColor) { color = newColor; } public Spots getSpots() { return spots; } Graphical User Interfaces 997 public void setSpots(Spots newSpots) { spots = newSpots; } public boolean isJumper() { return jmpr; } public void setJumper(boolean j) { jmpr = j; } public void addActionListener(ActionListener l) { //... } public void removeActionListener(ActionListener l) { // ... } public void addKeyListener(KeyListener l) { // ... } public void removeKeyListener(KeyListener l) { // ... } // An "ordinary" public method: public void croak() { System.out.println("Ribbet!"); } } ///:~ First, see it’s class. Usually, fields private accessible methods properties. Following naming convention, properties jumps, color, spots, jumper (notice case change first letter property name). Although name internal identifier name property first three cases, jumper see property name force use particular identifier internal variables (or, indeed, even internal variables property). The events Bean handles ActionEvent KeyEvent, based naming "add" "remove" methods associated listener. Finally, see ordinary method croak( ) still part Bean simply it’s public method, conforms naming scheme. Extracting Beanlnfo Introspector One critical parts JavaBean scheme occurs drag Bean palette drop onto form. The IDE must able create Bean (which there’s default constructor) then, without access Bean’s source code, extract necessary information create property sheet event handlers. Part solution already evident Type Information chapter: Java reflection discovers methods unknown class. This perfect solving JavaBean problem without requiring extra language keywords like visual programming languages. In fact, one prime reasons reflection added Java support JavaBeans (although reflection also supports object serialization Remote Method Invocation, helpful ordinary programming). So might expect creator IDE would reflect Bean hunt methods find properties events Bean. This certainly possible, Java designers wanted provide standard tool, make Beans simpler use, also provide standard gateway creation complex Beans. This tool Introspector class, important method class static getBeanInfo( ). You pass Class reference method, fully 998 Thinking Java Bruce Eckel interrogates class returns BeanInfo object dissect find properties, methods, events. Usually, won’t care this; you’ll probably get Beans shelf, won’t need know magic that’s going underneath. You’ll simply drag Beans onto form, configure properties write handlers events interest. However, it’s educational exercise use Introspector display information Bean. Here’s tool it: //: gui/BeanDumper.java // Introspecting Bean. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.beans.*; import java.lang.reflect.*; import static net.mindview.util.SwingConsole.*; public class BeanDumper extends JFrame { private JTextField query = new JTextField(20); private JTextArea results = new JTextArea(); public void print(String s) { results.append(s + "\n"); } public void dump(Class<?> bean) { results.setText(""); BeanInfo bi = null; try { bi = Introspector.getBeanInfo(bean, Object.class); } catch(IntrospectionException e) { print("Couldn’t introspect " + bean.getName()); return; } for(PropertyDescriptor d: bi.getPropertyDescriptors()){ Class<?> p = d.getPropertyType(); if(p == null) continue; print("Property type:\n " + p.getName() + "Property name:\n " + d.getName()); Method readMethod = d.getReadMethod(); if(readMethod != null) print("Read method:\n " + readMethod); Method writeMethod = d.getWriteMethod(); if(writeMethod != null) print("Write method:\n " + writeMethod); print("===================="); } print("Public methods:"); for(MethodDescriptor : bi.getMethodDescriptors()) print(m.getMethod().toString()); print("======================"); print("Event support:"); for(EventSetDescriptor e: bi.getEventSetDescriptors()){ print("Listener type:\n " + e.getListenerType().getName()); for(Method lm : e.getListenerMethods()) print("Listener method:\n " + lm.getName()); for(MethodDescriptor lmd : e.getListenerMethodDescriptors() ) print("Method descriptor:\n " + lmd.getMethod()); Method addListener= e.getAddListenerMethod(); print("Add Listener Method:\n " + addListener); Method removeListener = e.getRemoveListenerMethod(); print("Remove Listener Method:\n "+ removeListener); print("===================="); Graphical User Interfaces 999 } } class Dumper implements ActionListener { public void actionPerformed(ActionEvent e) { String name = query.getText(); Class<?> c = null; try { c = Class.forName(name); } catch(ClassNotFoundException ex) { results.setText("Couldn’t find " + name); return; } dump(c); } } public BeanDumper() { JPanel p = new JPanel(); p.setLayout(new FlowLayout()); p.add(new JLabel("Qualified bean name:")); p.add(query); add(BorderLayout.NORTH, p); add(new JScrollPane(results)); Dumper dmpr = new Dumper(); query.addActionListener(dmpr); query.setText("frogbean.Frog"); // Force evaluation dmpr.actionPerformed(new ActionEvent(dmpr, 0, "")); } public static void main(String[] args) { run(new BeanDumper(), 600, 500); } } ///:~ BeanDumper.dump( ) work. First tries create BeanInfo object, successful, calls methods BeanInfo produce information properties, methods, events. In Introspector.getBeanInfo( ), you’ll see second argument tells Introspector stop inheritance hierarchy. Here, stops parses methods Object, since we’re interested seeing those. For properties, getPropertyDescriptors( ) returns array PropertyDescriptors. For PropertyDescriptor, call getPropertyType( ) find class object passed via property methods. Then, property, get pseudonym (extracted method names) getName( ), method reading getReadMethod( ), method writing getWriteMethod( ). These last two methods return Method object actually used invoke corresponding method object (this part reflection). For public methods (including property methods), getMethodDescriptors( ) returns array MethodDescriptors. For one, get associated Method object print name. For events, getEventSetDescriptors( ) returns array EventSetDescriptors. Each queried find class listener, methods listener class, add- removelistener methods. The BeanDumper program displays information. Upon startup, program forces evaluation frogbean.Frog. The output, unnecessary details removed, is: Property type: 1000 Thinking Java Bruce Eckel Color Property name: color Read method: public Color getColor() Write method: public void setColor(Color) ==================== Property type: boolean Property name: jumper Read method: public boolean isJumper() Write method: public void setJumper(boolean) ==================== Property type: int Property name: jumps Read method: public int getJumps() Write method: public void setJumps(int) ==================== Property type: frogbean.Spots Property name: spots Read method: public frogbean.Spots getSpots() Write method: public void setSpots(frogbean.Spots) ==================== Public methods: public void setSpots(frogbean.Spots) public void setColor(Color) public void setJumps(int) public boolean isJumper() public frogbean.Spots getSpots() public void croak() public void addActionListener(ActionListener) public void addKeyListener(KeyListener) public Color getColor() public void setJumper(boolean) public int getJumps() public void removeActionListener(ActionListener) public void removeKeyListener(KeyListener) ===================== Event support: Listener type: KeyListener Listener method: keyPressed Listener method: keyReleased Listener method: keyTyped Method descriptor: public abstract void keyPressed(KeyEvent) Method descriptor: public abstract void keyReleased(KeyEvent) Graphical User Interfaces 1001 Method descriptor: public abstract void keyTyped(KeyEvent) AddListener Method: public void addKeyListener(KeyListener) Remove Listener Method: public void removeKeyListener(KeyListener) ==================== Listener type: ActionListener Listener method: actionPerformed Method descriptor: public abstract void actionPerformed(ActionEvent) Add Listener Method: public void addActionListener(ActionListener) Remove Listener Method: public void removeActionListener(ActionListener) ==================== This reveals Introspector sees produces BeanInfo object Bean. You see type property name independent. Notice lowercasing property name. (The time doesn’t occur property name begins one capital letter row.) And remember method names you’re seeing (such read write methods) actually produced Method object used invoke associated method object. The public method list includes methods associated property event, croak( ), well are. These methods call programmatically Bean, IDE choose list you’re making method calls, ease task. Finally, see events fully parsed listener, methods, add- remove-listener methods. Basically, BeanInfo, find everything importance Bean. You also call methods Bean, even though don’t information except object (again, feature reflection). A sophisticated Bean This next example slightly sophisticated, albeit frivolous. It’s JPanel draws little circle around mouse whenever mouse moved. When press mouse, word "Bang!" appears middle screen, action listener fired. The properties change size circle well color, size, text word displayed press mouse. A BangBean also addActionListener( ) removeActionListener( ), attach listener fired user clicks BangBean. You recognize property event support: //: bangbean/BangBean.java // A graphical Bean. package bangbean; import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.io.*; import java.util.*; public class BangBean extends JPanel implements Serializable { 1002 Thinking Java Bruce Eckel private int xm, ym; private int cSize = 20; // Circle size private String text = "Bang!"; private int fontSize = 48; private Color tColor = Color.RED; private ActionListener actionListener; public BangBean() { addMouseListener(new ML()); addMouseMotionListener(new MML()); } public int getCircleSize() { return cSize; } public void setCircleSize(int newSize) { cSize = newSize; } public String getBangText() { return text; } public void setBangText(String newText) { text = newText; } public int getFontSize() { return fontSize; } public void setFontSize(int newSize) { fontSize = newSize; } public Color getTextColor() { return tColor; } public void setTextColor(Color newColor) { tColor = newColor; } public void paintComponent(Graphics g) { super.paintComponent(g); g.setColor(Color.BLACK); g.drawOval(xm - cSize/2, ym - cSize/2, cSize, cSize); } // This unicast listener, // simplest form listener management: public void addActionListener(ActionListener l) throws TooManyListenersException { if(actionListener != null) throw new TooManyListenersException(); actionListener = l; } public void removeActionListener(ActionListener l) { actionListener = null; } class ML extends MouseAdapter { public void mousePressed(MouseEvent e) { Graphics g = getGraphics(); g.setColor(tColor); g.setFont( new Font("TimesRoman", Font.BOLD, fontSize)); int width = g.getFontMetrics().stringWidth(text); g.drawString(text, (getSize().width - width) /2, getSize().height/2); g.dispose(); // Call listener’s method: if(actionListener != null) actionListener.actionPerformed( new ActionEvent(BangBean.this, ActionEvent.ACTION_PERFORMED, null)); } } class MML extends MouseMotionAdapter { public void mouseMoved(MouseEvent e) { xm = e.getX(); ym = e.getY(); Graphical User Interfaces 1003 } repaint(); } public Dimension getPreferredSize() { return new Dimension(200, 200); } } ///:~ The first thing you’ll notice BangBean implements Serializable interface. This means IDE "pickle" information BangBean using serialization program designer adjusted values properties. When Bean created part running application, "pickled" properties restored get exactly designed. When look signature addActionListener( ), you’ll see throw TooManyListenersException. This indicates unicast, means notifies one listener event occurs. Ordinarily, you’ll use multicast events many listeners notified event. However, runs threading issues, revisited next section, "JavaBeans synchronization." In meantime, unicast event sidesteps problem. When click mouse, text put middle BangBean, actionListener field null, actionPerformed( ) called, creating new ActionEvent object process. Whenever mouse moved, new coordinates captured canvas repainted (erasing text that’s canvas, you’ll see). Here BangBeanTest class test Bean: //: bangbean/BangBeanTest.java // {Timeout: 5} Abort 5 seconds testing package bangbean; import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.*; import static net.mindview.util.SwingConsole.*; public class BangBeanTest extends JFrame { private JTextField txt = new JTextField(20); // During testing, report actions: class BBL implements ActionListener { private int count = 0; public void actionPerformed(ActionEvent e) { txt.setText("BangBean action "+ count++); } } public BangBeanTest() { BangBean bb = new BangBean(); try { bb.addActionListener(new BBL()); } catch(TooManyListenersException e) { txt.setText("Too many listeners"); } add(bb); add(BorderLayout.SOUTH, txt); } public static void main(String[] args) { run(new BangBeanTest(), 400, 500); } } ///:~ 1004 Thinking Java Bruce Eckel When Bean used IDE, class used, it’s helpful provide rapid testing method Beans. BangBeanTest places BangBean within JFrame, attaching simple ActionListener BangBean print event count JTextField whenever ActionEvent occurs. Usually, course, IDE would create code uses Bean. When run BangBean BeanDumper put BangBean inside Beanenabled development environment, you’ll notice many properties actions evident preceding code. That’s BangBean inherited JPanel, JPanel also Bean, you’re seeing properties events well. Exercise 35: (6) Locate download one free GUI builder development environments available Internet, use commercial product one. Discover necessary add BangBean environment use it. JavaBeans synchronization Whenever create Bean, must assume run multithreaded environment. This means that: 1. Whenever possible, public methods Bean synchronized. Of course, incurs synchronized runtime overhead (which significantly reduced recent versions JDK). If that’s problem, methods cause problems critical sections left unsynchronized, keep mind methods always obvious. Methods qualify tend small (such getCircleSize( ) following example) and/or "atomic"; is, method call executes short amount code object cannot changed execution (but review Concurrency chapter— may think atomic might be). Making methods unsynchronized might significant effect execution speed program. You’re better making public methods Bean synchronized removing synchronized keyword method know sure makes difference safely remove keyword. 2. When firing multicast event bunch listeners interested event, must assume listeners might added removed moving list. The first point fairly straightforward, second point requires little thought. BangBean.java ducked concurrency question ignoring synchronized keyword making event unicast. Here modified version works multithreaded environment uses multicasting events: //: gui/BangBean2.java // You write Beans way // run multithreaded environment. import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.io.*; import java.util.*; import static net.mindview.util.SwingConsole.*; public class BangBean2 extends JPanel implements Serializable { private int xm, ym; private int cSize = 20; // Circle size private String text = "Bang!"; private int fontSize = 48; Graphical User Interfaces 1005 private Color tColor = Color.RED; private ArrayList<ActionListener> actionListeners = new ArrayList<ActionListener>(); public BangBean2() { addMouseListener(new ML()); addMouseMotionListener(new MM()); } public synchronized int getCircleSize() { return cSize; } public synchronized void setCircleSize(int newSize) { cSize = newSize; } public synchronized String getBangText() { return text; } public synchronized void setBangText(String newText) { text = newText; } public synchronized int getFontSize(){ return fontSize; } public synchronized void setFontSize(int newSize) { fontSize = newSize; } public synchronized Color getTextColor(){ return tColor;} public synchronized void setTextColor(Color newColor) { tColor = newColor; } public void paintComponent(Graphics g) { super.paintComponent(g); g.setColor(Color.BLACK); g.drawOval(xm - cSize/2, ym - cSize/2, cSize, cSize); } // This multicast listener, typically // used unicast approach taken BangBean.java: public synchronized void addActionListener(ActionListener l) { actionListeners.add(l); } public synchronized void removeActionListener(ActionListener l) { actionListeners.remove(l); } // Notice isn’t synchronized: public void notifyListeners() { ActionEvent = new ActionEvent(BangBean2.this, ActionEvent.ACTION_PERFORMED, null); ArrayList<ActionListener> lv = null; // Make shallow copy List case // someone adds listener we’re // calling listeners: synchronized(this) { lv = new ArrayList<ActionListener>(actionListeners); } // Call listener methods: for(ActionListener al : lv) al.actionPerformed(a); } class ML extends MouseAdapter { public void mousePressed(MouseEvent e) { Graphics g = getGraphics(); g.setColor(tColor); g.setFont( new Font("TimesRoman", Font.BOLD, fontSize)); int width = g.getFontMetrics().stringWidth(text); g.drawString(text, (getSize().width - width) /2, getSize().height/2); g.dispose(); 1006 Thinking Java Bruce Eckel } notifyListeners(); } class MM extends MouseMotionAdapter { public void mouseMoved(MouseEvent e) { xm = e.getX(); ym = e.getY(); repaint(); } } public static void main(String[] args) { BangBean2 bb2 = new BangBean2(); bb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println("ActionEvent" + e); } }); bb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println("BangBean2 action"); } }); bb2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println("More action"); } }); JFrame frame = new JFrame(); frame.add(bb2); run(frame, 300, 300); } } ///:~ Adding synchronized methods easy change. However, notice addActionListener( ) removeActionListener( ) ActionListeners added removed ArrayList, many want. You see method notifyListeners( ) synchronized. It called one thread time. It’s also possible addActionListener( ) removeActionListener( ) called middle call notifyListeners( ), problem traverses ArrayList actionListeners. To alleviate problem, ArrayList duplicated inside synchronized clause, using ArrayList constructor copies elements argument, duplicate traversed. This way, original ArrayList manipulated without impact notifyListeners( ). The paintComponent( ) method also synchronized. Deciding whether synchronize overridden methods clear you’re adding methods. In example, turns paintComponent( ) seems work OK whether it’s synchronized not. But issues must consider are: 1. Does method modify state "critical" variables within object? To discover whether variables "critical," must determine whether read set threads program. (In case, reading setting virtually always accomplished via synchronized methods, examine those.) In case paintComponent( ), modification takes place. 2. Does method depend state "critical" variables? If synchronized method modifies variable method uses, might well want make method synchronized well. Based this, might observe cSize changed synchronized methods, therefore paintComponent( ) Graphical User Interfaces 1007 synchronized. Here, however, ask, "What’s worst thing happen cSize changed paintComponent( )?" When see it’s nothing bad, transient effect that, decide leave paintComponent( ) unsynchronized prevent extra overhead synchronized method call. 3. A third clue notice whether base-class version paintComponent( ) synchronized, isn’t. This isn’t airtight argument, clue. In case, example, field changed via synchronized methods (that is, cSize) mixed paintComponent( ) formula might changed situation. Notice, however, synchronized doesn’t inherit; is, method synchronized base class, automatically synchronized derivedclass overridden version. 4. paint( ) paintComponent( ) methods must fast possible. Anything takes processing overhead methods highly recommended, think need synchronize methods may indicator bad design. The test code main( ) modified seen BangBeanTest demonstrate multicast ability BangBean2 adding extra listeners. Packaging Bean Before bring JavaBean Bean-enabled IDE, must put Bean container, JAR file includes Bean classes well "manifest" file says, "This Bean." A manifest file simply text file follows particular form. For BangBean, manifest file looks like this: Manifest-Version: 1.0 Name: bangbean/BangBean.class Java-Bean: True The first line indicates version manifest scheme, notice Sun 1.0. The second line (empty lines ignored) names BangBean.class file, third says, "It’s Bean." Without third line, program builder tool recognize class Bean. The tricky part must make sure get proper path "Name:" field. If look back BangBean.java, you’ll see it’s package bangbean (and thus subdirectory called bangbean that’s classpath), name manifest file must include package information. In addition, must place manifest file directory root package path, case means placing file directory "bangbean" subdirectory. Then must invoke jar directory manifest file, follows: jar cfm BangBean.jar BangBean.mf bangbean This assumes want resulting JAR file named BangBean.jar, you’ve put manifest file called BangBean.mf. You might wonder, "What classes generated I compiled BangBean.java?" Well, ended inside bangbean subdirectory, you’ll see last argument jar command line bangbean subdirectory. When give jar name subdirectory, packages entire subdirectory JAR file (including, case, original BangBean.java source-code file—you might choose 1008 Thinking Java Bruce Eckel include source Beans). In addition, turn around unpack JAR file you’ve created, you’ll discover manifest file isn’t inside, jar created manifest file (based partly yours) called MANIFEST.MF placed inside subdirectory META-INF (for "meta-information"). If open manifest file, you’ll also notice digital signature information added jar file, form: Digest-Algorithms: SHA MD5 SHA-Digest: pDpEAG9NaeCx8aFtqPI4udSX/O0= MD5-Digest: 04NcSlhE3Smnzlp2hj6qeg== In general, don’t need worry this, make changes, modify original manifest file reinvoke jar create new JAR file Bean. You also add Beans JAR file simply adding information manifest. One thing notice you’ll probably want put Bean subdirectory, since create JAR file hand jar utility name subdirectory, puts everything subdirectory JAR file. You see Frog BangBean subdirectories. Once Bean properly inside JAR file, bring Beans-enabled IDE. The way varies one tool next, Sun provides freely available test bed JavaBeans "Bean Builder." (Download http://java.sun.com/beans.) You place Bean Bean Builder simply copying JAR file correct subdirectory. Exercise 36: (4) Add Frog.class manifest file section run jar create JAR file containing Frog BangBean. Now either download install Bean Builder Sun, use Beans-enabled program builder tool add JAR file environment test two Beans. Exercise 37: (5) Create JavaBean called Valve contains two properties: boolean called "on" int called "level." Create manifest file, use jar package Bean, load Bean Builder Beans-enabled program builder tool test it. More complex Bean support You see remarkably simple make Bean, aren’t limited you’ve seen here. The JavaBeans architecture provides simple point entry also scale complex situations. These situations beyond scope book, briefly introduced here. You find details http://java.sun.com/beans. One place add sophistication properties. The examples you’ve seen shown single properties, it’s also possible represent multiple properties array. This called indexed property. You simply provide appropriate methods (again following naming convention method names), Introspector recognizes indexed property IDE respond appropriately. Properties bound, means notify objects via PropertyChangeEvent. The objects choose change based change Bean. Properties constrained, means objects veto change property unacceptable. The objects notified using Graphical User Interfaces 1009 PropertyChangeEvent, throw PropertyVetoException prevent change happening restore old values. You also change way Bean represented design time: 1. You provide custom property sheet particular Bean. The ordinary property sheet used Beans, automatically invoked Bean selected. 2. You create custom editor particular property, ordinary property sheet used, special property edited, editor automatically invoked. 3. You provide custom BeanInfo class Bean produces information different default created Introspector. 4. It’s also possible turn "expert" mode FeatureDescriptors distinguish basic features complicated ones. More Beans There number books JavaBeans; example, JavaBeans Elliotte Rusty Harold (IDG, 1998). Alternatives Swing Although Swing library GUI sanctioned Sun, means way create graphical user interfaces. Two important alternatives Macromedia Flash, using Macromedia’s Flex programming system, client-side GUIs Web, opensource Eclipse Standard Widget Toolkit (SWT) library desktop applications. Why would consider alternatives? For Web clients, make fairly strong argument applets failed. Considering long they’ve around (since beginning) initial hype promise around applets, coming across Web application uses applets still surprise. Even Sun doesn’t use applets everywhere. Here’s example: http://java.sun.c0m/developer/onlineTraining/new2java/javamap/intro.html An interactive map Java features Sun site seems likely candidate Java applet, yet Flash. This appears tacit acknowledgement applets success. More importantly, Flash Player installed upwards 98 percent computing platforms, considered accepted standard. As you’ll see, Flex system provides powerful client-side programming environment, certainly powerful JavaScript look feel often preferable applet. If want use applets, must still convince client download JRE, whereas Flash Player small fast download comparison. For desktop applications, one problem Swing users notice using different kind application, look feel Swing applications different normal desktop. Users generally interested new looks feels application; trying get work done prefer application look feel like applications. SWT creates applications look like native applications, library uses native components much possible, applications tend run faster equivalent Swing applications. 1010 Thinking Java Bruce Eckel Building Flash Web clients Flex Because lightweight Macromedia Flash virtual machine ubiquitous, people able use Flash-based interface without installing anything, look behave way across systems platforms. 10 With Macromedia Flex, develop Flash user interfaces Java applications. Flex consists XML- script-based programming model, similar programming models HTML JavaScript, along robust library components. You use MXML syntax declare layout management widget controls, use dynamic scripting add event-handling service invocation code links user interface Java classes, data models, Web services, etc. The Flex compiler takes MXML script files compiles bytecode. The Flash virtual machine client operates like Java Virtual Machine interprets compiled bytecode. The Flash bytecode format known SWF, SWF files produced Flex compiler. Note there’s open-source alternative Flex http://openlaszlo.org; structure that’s similar Flex may preferable alternative some. Other tools also exist create Flash applications different ways. Hello, Flex Consider MXML code, defines user interface (note first last lines appear code download part book’s source-code package): //:! gui/flex/helloflex1.mxml <?xml version="1.0" encoding="utf-8"?> <mx:Application xmlns:mx="http://www.macromedia.com/2003/mxml" backgroundColor="#ffffff"> <mx:Label id="output" text="Hello, Flex!" /> </mx:Application> ///:~ MXML files XML documents, begin XML version/encoding directive. The outermost MXML element Application element, topmost visual logical container Flex user interface. You declare tags representing visual controls, Label element above, inside Application element. Controls always placed within container, containers encapsulate layout managers, among mechanisms, manage layout controls within them. In simplest case, example, Application acts container. The Application’s default layout manager merely places controls vertically interface order declared. ActionScript version ECMAScript, JavaScript, looks quite similar Java supports classes strong typing addition dynamic scripting. By adding script example, introduce behavior. Here, MXML Script control used place ActionScript directly MXML file: //:! gui/flex/helloflex2.mxml <?xml version="1.0" encoding="utf-8"?> <mx:Application 10 Sean Neville created core material section. Graphical User Interfaces 1011 xmlns:mx="http://www.macromedia.com/2003/mxml" backgroundColor="#ffffff"> <mx:Script> <![CDATA[ function updateOutput() { output.text = "Hello! " + input.text; } ]]> </mx:Script> <mx:TextInput id="input" width="200" change="updateOutput()" /> <mx:Label id="output" text="Hello!" /> </mx:Application> ///:~ A TextInput control accepts user input, Label displays data typed. Note id attribute control becomes accessible script variable name, script reference instances MXML tags. In TextInput field, see change attribute connected updateOutput( ) function function called whenever kind change occurs. Compiling MXML The easiest way get started using Flex free trial, download www.macromedia.com/software/flex/trial. 11 The product packaged number editions, free trials enterprise server versions, Macromedia offers additional tools developing Flex applications. Exact packaging subject change, check Macromedia site specifics. Also note may need modify jvm.config file Flex installation bin directory. To compile MXML code Flash bytecode, two options: 1. You place MXML file Java Web application, alongside JSP HTML pages WAR file, requests .mxml file compiled run time whenever browser requests MXML document’s URL. 2. You compile MXML file using Flex command-line compiler, mxmlc. The first option, Web-based runtime compilation, requires servlet container (such Apache Tomcat) addition Flex. The servlet container’s WAR file(s) must updated Flex configuration information, servlet mappings added web.xml descriptor, must include Flex JAR files—these steps handled automatically install Flex. After WAR file configured, place MXML files Web application request document’s URL browser. Flex compile application upon first request, similar JSP model, thereafter deliver compiled cached SWF within HTML shell. The second option require server. When invoke Flex mxmlc compiler command line, produce SWF files. You deploy desire. The mxmlc executable located bin directory Flex installation, invoking arguments provide list valid command-line options. Typically, you’ll specify location Flex client component library value -flexlib command-line option, simple examples like two we’ve seen far, Flex compiler assume location component library. So compile first two examples like this: 11 1012 Note must download Flex, FlexBuilder. The latter IDE design tool. Thinking Java Bruce Eckel mxmlc.exe helloflexl.mxml mxmlc.exe helloflex2.mxml This produces helloflex2.swf file run Flash, placed alongside HTML HTTP server (once Flash loaded Web browser, often double-click SWF file start browser). For helloflex2.swf, you’ll see following user interface running Flash Player: This hard do…| Hello! This hard do… In complex applications, separate MXML ActionScript referencing functions external ActionScript files. From MXML, use following syntax Script control: <mx:Script source="MyExternalScript.as" /> This code allows MXML controls reference functions located file named MyExternalScript.as located within MXML file. MXML ActionScript MXML declarative shorthand ActionScript classes. Whenever see MXML tag, exists ActionScript class name. When Flex compiler parses MXML, first transforms XML ActionScript loads referenced ActionScript classes, compiles links ActionScript SWF. You write entire Flex application ActionScript alone, without using MXML. Thus, MXML convenience. User interface components containers controls typically declared using MXML, logic event handling client logic handled ActionScript Java. You create MXML controls reference using MXML writing ActionScript classes. You may also combine existing MXML containers controls new MXML document referenced tag another MXML document. The Macromedia Web site contains information this. Containers controls The visual core Flex component library set containers manage layout, array controls go inside containers. Containers include panels, vertical horizontal boxes, tiles, accordions, divided boxes, grids, more. Controls user interface widgets buttons, text areas, sliders, calendars, data grids, forth. The remainder section show Flex application displays sorts list audio files. This application demonstrates containers, controls, connect Java Flash. We start MXML file placing DataGrid control (one sophisticated Flex controls) within Panel container: //:! gui/flex/songs.mxml <?xml version="1.0" encoding="utf-8"?> <mx:Application Graphical User Interfaces 1013 xmlns:mx="http://www.macromedia.com/2003/mxml" backgroundColor="#B9CAD2" pageTitle="Flex Song Manager" initialize="getSongs()"> <mx:Script source="songScript.as" /> <mx:Style source="songStyles.css"/> <mx:Panel id="songListPanel" titleStyleDeclaration="headerText" title="Flex MP3 Library"> <mx:HBox verticalAlign="bottom"> <mx:DataGrid id="songGrid" cellPress="selectSong(event)" rowCount="8"> <mx:columns> <mx:Array> <mx:DataGridColumn columnName="name" headerText="Song Name" width="120" /> <mx:DataGridColumn columnName="artist" headerText="Artist" width="180" /> <mx:DataGridColumn columnName="album" headerText="Album" width="160" /> </mx:Array> </mx:columns> </mx:DataGrid> <mx:VBox> <mx:HBox height="100" > <mx:Image id="albumImage" source="" height="80" width="100" mouseOverEffect="resizeBig" mouseOutEffect="resizeSmall" /> <mx:TextArea id="songInfo" styleName="boldText" height="100%" width="120" vScrollPolicy="off" borderStyle="none" /> </mx:HBox> <mx:MediaPlayback id="songPlayer" contentPath="" mediaType="MP3" height="70" width="230" controllerPolicy="on" autoPlay="false" visible="false" /> </mx:VBox> </mx:HBox> <mx:ControlBar horizontalAlign="right"> <mx:Button id="refreshSongsButton" label="Refresh Songs" width="100" toolTip="Refresh Song List" click="songService.getSongs()" /> </mx:ControlBar> </mx:Panel> <mx:Effect> <mx:Resize name="resizeBig" heightTo="100" duration="500"/> <mx:Resize name="resizeSmall" heightTo="80" duration="500"/> </mx:Effect> <mx:RemoteObject id="songService" source="gui.flex.SongService" result="onSongs(event.result)" fault="alert(event.fault.faultstring, ‘Error’)"> <mx:method name="getSongs"/> </mx:RemoteObject> </mx:Application> ///:~ 1014 Thinking Java Bruce Eckel The DataGrid contains nested tags array columns. When see attribute nested element control, know corresponds property, event, encapsulated object underlying ActionScript class. The DataGrid id attribute value songGrid, ActionScript MXML tags reference grid programmatically using songGrid variable name. The DataGrid exposes many properties shown here; complete API MXML controls containers found online http ://livedocs. macromedia. com/flex/is/asdocs_ en/index.html. The DataGrid followed VBox containing Image show front album along song information, MediaPlayback control play MP3 files. This example streams content order reduce size compiled SWF. When embed images, audio, video files Flex application instead streaming them, files become part compiled SWF delivered along user interface assets instead streamed demand run time. The Flash Player contains embedded codecs playing streaming audio video variety formats. Flash Flex support use Web’s common image formats, Flex also ability translate scalable vector graphics (SVG) files SWF resources embedded Flex clients. Effects styles The Flash Player renders graphics using vectors, perform highly expressive transformations run time. Flex effects provide small taste sorts animations. Effects transformations apply controls containers using MXML syntax. The Effect tag shown MXML produces two results: The first nested tag dynamically grows image mouse hovers it, second dynamically shrinks image mouse moves away. These effects applied mouse events available Image control albumlmage. Flex also provides effects common animations like transitions, wipes, modulating alpha channels. In addition built-in effects, Flex supports Flash drawing API truly innovative animations. Deeper exploration topic involves graphic design animation, beyond scope section. Standard styling available Flex’s support Cascading Style Sheets (CSS). If attach CSS file MXML file, Flex controls follow styles. For example, songStyles.css contains following CSS declaration: //:! gui/flex/songStyles.css .headerText { font-family: Arial, "_sans"; font-size: 16; font-weight: bold; } .boldText { font-family: Arial, "_sans"; font-size: 11; font-weight: bold; } ///:~ This file imported used song library application via Style tag MXML file. After style sheet imported, declarations applied Flex controls Graphical User Interfaces 1015 MXML file. As example, style sheet’s boldText declaration used TextArea control songInfo id. Events A user interface state machine; performs actions state changes occur. In Flex, changes managed events. The Flex class library contains wide variety controls extensive events covering aspects mouse movement keyboard usage. The click attribute Button, example, represents one events available control. The value assigned click function inline bit script. In MXML file, example, ControlBar holds refreshSongsButton refresh list songs. You see tag click event occurs, songService.getSongs( ) called. In example, click event Button refers RemoteObject corresponds Java method. Connecting Java The RemoteObject tag end MXML file sets connection external Java class, gui.flex.SongService. The Flex client use getSongs( ) method Java class retrieve data DataGrid. To so, must appear service—an endpoint client exchange messages. The service defined RemoteObject tag source attribute denotes Java class RemoteObject, specifies ActionScript callback function, onSongs( ), invoked Java method returns. The nested method tag declares method getSongs( ), makes Java method accessible rest Flex application. All invocations services Flex return asynchronously, events fired callback functions. The RemoteObject also raises alert dialog control event error. The getSongs( ) method may invoked Flash using ActionScript: songService.getSongs(); Because MXML configuration, call getSongs( ) SongService class: //: gui/flex/SongService.java package gui.flex; import java.util.*; public class SongService { private List<Song> songs = new ArrayList<Song>(); public SongService() { fillTestData(); } public List<Song> getSongs() { return songs; } public void addSong(Song song) { songs.add(song); } public void removeSong(Song song) { songs.remove(song); } private void fillTestData() { addSong(new Song("Chocolate", "Snow Patrol", "Final Straw", "sp-final-straw.jpg", "chocolate.mp3")); addSong(new Song("Concerto No. 2 E", "Hilary Hahn", "Bach: Violin Concertos", "hahn.jpg", "bachviolin2.mp3")); addSong(new Song("‘Round Midnight", "Wes Montgomery", "The Artistry Wes Montgomery", "wesmontgomery.jpg", "roundmidnight.mp3")); 1016 Thinking Java Bruce Eckel } } ///:~ Each Song object data container: //: gui/flex/Song.java package gui.flex; public class Song implements java.io.Serializable { private String name; private String artist; private String album; private String albumImageUrl; private String songMediaUrl; public Song() {} public Song(String name, String artist, String album, String albumImageUrl, String songMediaUrl) { this.name = name; this.artist = artist; this.album = album; this.albumImageUrl = albumImageUrl; this.songMediaUrl = songMediaUrl; } public void setAlbum(String album) { this.album = album;} public String getAlbum() { return album; } public void setAlbumImageUrl(String albumImageUrl) { this.albumImageUrl = albumImageUrl; } public String getAlbumImageUrl() { return albumImageUrl;} public void setArtist(String artist) { this.artist = artist; } public String getArtist() { return artist; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setSongMediaUrl(String songMediaUrl) { this.songMediaUrl = songMediaUrl; } public String getSongMediaUrl() { return songMediaUrl; } } ///:~ When application initialized press refreshSongsButton, getSongs( ) called, upon returning, ActionScript onSongs(event.result) called populate songGrid. Here ActionScript listing, included MXML file’s Script control: //: gui/flex/songScript.as function getSongs() { songService.getSongs(); } function selectSong(event) { var song = songGrid.getItemAt(event.itemIndex); showSongInfo(song); } function showSongInfo(song) { songInfo.text = song.name + newline; songInfo.text += song.artist + newline; songInfo.text += song.album + newline; Graphical User Interfaces 1017 } albumImage.source = song.albumImageUrl; songPlayer.contentPath = song.songMediaUrl; songPlayer.visible = true; function onSongs(songs) { songGrid.dataProvider = songs; } ///:~ To handle DataGrid cell selections, add cellPress event attribute DataGrid declaration MXML file: cellPress="selectSong(event)" When user clicks song DataGrid, call selectSong( ) ActionScript above. Data models data binding Controls directly invoke services, ActionScript event callbacks give chance programmatically update visual controls services return data. While script updates controls straightforward, get verbose cumbersome, functionality common Flex handles behavior automatically, data binding. In simplest form, data binding allows controls reference data directly instead requiring glue code copy data control. When data updated, control references also automatically updated without need programmer intervention. The Flex infrastructure correctly responds data change events, updates controls bound data. Here simple example data binding syntax: <mx:Slider id="mySlider"/> <mx:Text text="{mySlider.value}" /> To perform data binding, place references within curly braces: {}. Everything within curly braces deemed expression Flex evaluate. The value first control, Slider widget, displayed second control, Text field. As Slider changes, Text field’s text property automatically updated. This way, developer need handle Slider’s change events order update Text field. Some controls, Tree control DataGrid song library application, sophisticated. These controls dataprovider property facilitate binding collections data. The ActionScript onSongs( ) function shows SongService.getSongs( ) method bound dataprovider Flex DataGrid. As declared RemoteObject tag MXML file, function callback ActionScript invokes whenever Java method returns. A sophisticated application complex data modeling, enterprise application making use Data Transfer Objects messaging application data conforming complex schemas, may encourage decoupling source data controls. In Flex development, perform decoupling declaring "Model" object, generic MXML container data. The model contains logic. It mirrors Data Transfer Object found enterprise development, structures programming languages. By using model, databind controls model, 1018 Thinking Java Bruce Eckel time model databind properties service inputs outputs. This decouples sources data, services, visual consumers data, facilitating use Model- View-Controller (MVC) pattern. In larger, sophisticated applications, initial complexity caused inserting model often small tax compared value cleanly decoupled MVC application. In addition Java objects, Flex also access SOAP-based Web services RESTful HTTP services using WebService HttpService controls, respectively. Access services subject security authorization constraints. Building deploying With earlier examples, could get away without -flexlib flag command line, compile program, must specify location flex-config.xml file using -flexlib flag. For installation, following command works, you’ll modify configuration (the command single line, wrapped): //:! gui/flex/buiId-command.txt mxmlc -flexlib C:/"Program Files"/Macromedia/Flex/jrun4/servers/default/flex/WEB-INF/flex songs.mxml ///:~ This command build application SWF file view browser, book’s code distribution file contains MP3 files JPG files, won’t see anything framework run application. In addition, must configure server order successfully talk Java files Flex application. The Flex trial package comes JRun server, start computer’s menus Flex installed, via command line: jrun -start default You verify server successfully started opening http://localhost:8700/samples Web browser viewing various samples (this also good way get familiar abilities Flex). Instead compiling application command line, compile via server. To this, drop song source files, CSS style sheet, etc., jrun4/servers/default/flex directory access browser opening http://localhost:870o/flex/songs.mxml. To successfully run app, must configure Java side Flex side. Java: The compiled Song.java SongService.java files must placed WEBINF/classes directory. This drop WAR classes according J2EE specification. Alternatively, JAR files drop result WEB-INF/lib. It must directory matches Java package structure. If you’re using JRun, would placed jrun4/servers/defauIt/flex/WEBINF/classes/gui/flex/Song.cIass jrun4/servers/default/flex/WEBINF/ classes/gui/flex/SongService.class. You also need image MP3 support files available Web app (for JRun, jrun4/servers/default/flex Web app root). Flex: For security reasons, Flex cannot access Java objects unless give permission modifying flex-config.xml file. For JRun, located jrun4/servers/default/flex/WEB-INF/flex/flex-config.xml. Go <remoteGraphical User Interfaces 1019 objects> entry file, look <whitelist> section within, see following note: <!-For security, whitelist locked default. Uncomment source element enable access classes development. We strongly recommend allowing access source files production, since exposes Java Flex system classes. <source>*</source> --> Uncomment <source> entry allow access, reads <source>*</source>. The meaning entries described Flex configuration docs. Exercise 38: (3) Build "simple example data binding syntax" shown above. Exercise 39: (4) The code download book include MP3S JPGs shown SongService.java. Find MP3S JPGs, modify SongService.java include file names, download Flex trial build application. Creating SWT applications As previously noted, Swing took approach building UI components pixel-bypixel, order provide every component desired whether underlying OS components not. SWT takes middle ground using native components OS provides them, synthesizing components doesn’t. The result application feels user like native application, often noticeably faster performance equivalent Swing program. In addition, SWT tends less complex programming model Swing, desirable large portion applications. 12 Because SWT uses native OS much work possible, automatically take advantage OS features may available Swing—for example, Windows "subpixel rendering" makes fonts LCD screens clearer. It’s even possible create applets using SWT. This section meant comprehensive introduction SWT; it’s enough give flavor it, see SWT contrasts Swing. You’ll discover lots SWT widgets reasonably straightforward use. You explore details full documentation many examples found www.eclipse.org. There also number books programming SWT, way. Installing SWT SWT applications require downloading installing SWT library Eclipse project. Go www.eclipse.org/downloads/ choose mirror. Follow links current Eclipse build locate compressed file name begins "swt" includes name platform (for example, "win32"). Inside file you’ll find swt.jar. The easiest way install swt.jar file put jre/lib/ext directory (that way don’t make modifications classpath). When decompress SWT library, may find additional files need install appropriate places platform. For example, Win32 distribution comes DLL files need placed somewhere java.library.path (this usually 12 1020 Chris Grindstaff helpful translating SWT examples providing SWT information. Thinking Java Bruce Eckel PATH environment variable, run object/ShowProperties.java discover actual value java.library.path). Once you’ve done this, able transparently compile execute SWT application Java program. The documentation SWT separate download. An alternative approach install Eclipse editor, includes SWT SWT documentation view Eclipse help system. Hello, SWT Let’s start simplest possible "hello world"-style application: //: swt/HelloSWT.java // {Requires: org.eclipse.swt.widgets.Display; You must // install SWT library http://www.eclipse.org } import org.eclipse.swt.widgets.*; public class HelloSWT { public static void main(String [] args) { Display display = new Display(); Shell shell = new Shell(display); shell.setText("Hi there, SWT!"); // Title bar shell.open(); while(!shell.isDisposed()) if(!display.readAndDispatch()) display.sleep(); display.dispose(); } } ///:~ If download source code book, you’ll discover "Requires" comment directive ends Ant build.xml prerequisite building swt subdirectory; files import org.eclipse.swt require install SWT library www.eclipse.org. The Display manages connection SWT underlying operating system—it part Bridge operating system SWT. The Shell top-level main window, within components built. When call setText( ), argument becomes label title bar window. To display window thus application, must call open( ) Shell. Whereas Swing hides event-handling loop you, SWT forces write explicitly. At top loop, check see whether shell disposed—note gives option inserting code perform cleanup activities. But means main( ) thread user interface thread. In Swing, second event-dispatching thread created behind scenes, SWT main( ) thread handles UI. Since default there’s one thread two, makes somewhat less likely you’ll clobber UI threads. Notice don’t worry submitting tasks user interface thread like Swing. SWT takes care you, throws exception try manipulate widget wrong thread. However, need spawn threads perform long-running operations, still need submit changes way Swing. For this, SWT provides three methods called Display object: asyncExec(Runnable), syncExec(Runnable) timerExec(int, Runnable). Graphical User Interfaces 1021 The activity main( ) thread point call readAndDispatch( ) Display object (this means one Display object per application). The readAndDispatch( ) method returns true events event queue, waiting processed. In case, want call again, immediately. However, nothing pending, call Display object’s sleep( ) wait short time checking event queue again. Once program complete, must explicitly dispose( ) Display object. SWT often requires explicitly dispose resources, usually resources underlying operating system, may otherwise become exhausted. To prove Shell main window, here’s program makes number Shell objects: //: swt/ShellsAreMainWindows.java import org.eclipse.swt.widgets.*; public class ShellsAreMainWindows { static Shell[] shells = new Shell[10]; public static void main(String [] args) { Display display = new Display(); for(int = 0; < shells.length; i++) { shells[i] = new Shell(display); shells[i].setText("Shell #" + i); shells[i].open(); } while(!shellsDisposed()) if(!display.readAndDispatch()) display.sleep(); display.dispose(); } static boolean shellsDisposed() { for(int = 0; < shells.length; i++) if(shells[i].isDisposed()) return true; return false; } } ///:~ When run it, you’ll get ten main windows. The way program written, close one windows, close them. SWT also uses layout managers—different ones Swing, idea. Here’s slightly complex example takes text System.getProperties( ) adds shell: //: swt/DisplayProperties.java import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import org.eclipse.swt.layout.*; import java.io.*; public class DisplayProperties { public static void main(String [] args) { Display display = new Display(); Shell shell = new Shell(display); shell.setText("Display Properties"); shell.setLayout(new FillLayout()); Text text = new Text(shell, SWT.WRAP | SWT.V_SCROLL); StringWriter props = new StringWriter(); System.getProperties().list(new PrintWriter(props)); 1022 Thinking Java Bruce Eckel text.setText(props.toString()); shell.open(); while(!shell.isDisposed()) if(!display.readAndDispatch()) display.sleep(); display.dispose(); } } ///:~ In SWT, widgets must parent object general type Composite, must provide parent first argument widget constructor. You see Text constructor, shell first argument. Virtually constructors also take flag argument allows provide number style directives, depending particular widget accepts. Multiple style directives bitwise-ORed together seen example. When setting Text( ) object, I added style flags wraps text, automatically adds vertical scroll bar needs to. You’ll discover SWT constructor-based; many attributes widget difficult impossible change except via constructor. Always check widget constructor’s documentation accepted flags. Note constructors require flag argument even "accepted" flags listed documentation. This allows future expansion without modifying interface. Eliminating redundant code Before going on, notice certain things every SWT application, like duplicate actions Swing programs. For SWT, always create Display, make Shell Display, create readAndDispatch( ) loop, etc. Of course, special cases, may this, it’s common enough it’s worth trying eliminate duplicate code net.mindview.util.SwingConsole. We’ll need force application conform interface: //: swt/util/SWTApplication.java package swt.util; import org.eclipse.swt.widgets.*; public interface SWTApplication { void createContents(Composite parent); } ///:~ The application handed Composite object (Shell subclass) must use create contents inside createContents( ). SWTConsole.run( ) calls createContents( ) appropriate point, sets size shell according user passes run( ), opens shell runs event loop, finally disposes shell program exit: //: swt/util/SWTConsole.java package swt.util; import org.eclipse.swt.widgets.*; public class SWTConsole { public static void run(SWTApplication swtApp, int width, int height) { Display display = new Display(); Shell shell = new Shell(display); shell.setText(swtApp.getClass().getSimpleName()); swtApp.createContents(shell); Graphical User Interfaces 1023 shell.setSize(width, height); shell.open(); while(!shell.isDisposed()) { if(!display.readAndDispatch()) display.sleep(); } display.dispose(); } } ///:~ This also sets title bar name SWTApplication class, sets width height Shell. We create variation DisplayProperties.Java displays machine environment, using SWTConsole: //: swt/DisplayEnvironment.java import swt.util.*; import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import org.eclipse.swt.layout.*; import java.util.*; public class DisplayEnvironment implements SWTApplication { public void createContents(Composite parent) { parent.setLayout(new FillLayout()); Text text = new Text(parent, SWT.WRAP | SWT.V_SCROLL); for(Map.Entry entry: System.getenv().entrySet()) { text.append(entry.getKey() + ": " + entry.getValue() + "\n"); } } public static void main(String [] args) { SWTConsole.run(new DisplayEnvironment(), 800, 600); } } ///:~ SWTConsole allows us focus interesting aspects application rather repetitive code. Exercise 40: (4) Modify DisplayProperties.java uses SWTConsole. Exercise 41: (4) Modify Display Environment.java use SWTConsole. Menus To demonstrate basic menus, example reads source code breaks words, populates menus words: //: swt/Menus.java // Fun menus. import swt.util.*; import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import java.util.*; import net.mindview.util.*; public class Menus implements SWTApplication { 1024 Thinking Java Bruce Eckel private static Shell shell; public void createContents(Composite parent) { shell = parent.getShell(); Menu bar = new Menu(shell, SWT.BAR); shell.setMenuBar(bar); Set<String> words = new TreeSet<String>( new TextFile("Menus.java", "\\W+")); Iterator<String> = words.iterator(); while(it.next().matches("[0-9]+")) ; // Move past numbers. MenuItem[] mItem = new MenuItem[7]; for(int = 0; < mItem.length; i++) { mItem[i] = new MenuItem(bar, SWT.CASCADE); mItem[i].setText(it.next()); Menu submenu = new Menu(shell, SWT.DROP_DOWN); mItem[i].setMenu(submenu); } int = 0; while(it.hasNext()) { addItem(bar, it, mItem[i]); = (i + 1) % mItem.length; } } static Listener listener = new Listener() { public void handleEvent(Event e) { System.out.println(e.toString()); } }; void addItem(Menu bar, Iterator<String> it, MenuItem mItem) { MenuItem item = new MenuItem(mItem.getMenu(),SWT.PUSH); item.addListener(SWT.Selection, listener); item.setText(it.next()); } public static void main(String[] args) { SWTConsole.run(new Menus(), 600, 200); } } ///:~ A Menu must placed Shell, Composite allows fetch shell getShell( ). TextFile net.mindview.util described earlier book; TreeSet filled words appear sorted order. The initial elements numbers, discarded. Using stream words, top-level menus menu bar named, submenus created filled words words. In response selecting one menu items, Listener simply prints event see kind information contains. When run program, you’ll see part information includes label menu, base menu response that—or provide different listener menu (which safer approach, internationalization). Tabbed panes, buttons, events SWT rich set controls, call widgets. Look documentation org.eclipse.swt.widgets see basic ones, org.eclipse.swt.custom see fancier ones. Graphical User Interfaces 1025 To demonstrate basic widgets, example places number sub-examples inside tabbed panes. You’ll also see create Composites (roughly Swing JPanels) order put items within items. //: swt/TabbedPane.java // Placing SWT components tabbed panes. import swt.util.*; import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import org.eclipse.swt.events.*; import org.eclipse.swt.graphics.*; import org.eclipse.swt.layout.*; import org.eclipse.swt.browser.*; public class TabbedPane implements SWTApplication { private static TabFolder folder; private static Shell shell; public void createContents(Composite parent) { shell = parent.getShell(); parent.setLayout(new FillLayout()); folder = new TabFolder(shell, SWT.BORDER); labelTab(); directoryDialogTab(); buttonTab(); sliderTab(); scribbleTab(); browserTab(); } public static void labelTab() { TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText("A Label"); // Text tab tab.setToolTipText("A simple label"); Label label = new Label(folder, SWT.CENTER); label.setText("Label text"); tab.setControl(label); } public static void directoryDialogTab() { TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText("Directory Dialog"); tab.setToolTipText("Select directory"); final Button b = new Button(folder, SWT.PUSH); b.setText("Select Directory"); b.addListener(SWT.MouseDown, new Listener() { public void handleEvent(Event e) { DirectoryDialog dd = new DirectoryDialog(shell); String path = dd.open(); if(path != null) b.setText(path); } }); tab.setControl(b); } public static void buttonTab() { TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText("Buttons"); tab.setToolTipText("Different kinds Buttons"); Composite composite = new Composite(folder, SWT.NONE); composite.setLayout(new GridLayout(4, true)); for(int dir : new int[]{ SWT.UP, SWT.RIGHT, SWT.LEFT, SWT.DOWN }) { Button b = new Button(composite, SWT.ARROW | dir); b.addListener(SWT.MouseDown, listener); 1026 Thinking Java Bruce Eckel } newButton(composite, SWT.CHECK, "Check button"); newButton(composite, SWT.PUSH, "Push button"); newButton(composite, SWT.RADIO, "Radio button"); newButton(composite, SWT.TOGGLE, "Toggle button"); newButton(composite, SWT.FLAT, "Flat button"); tab.setControl(composite); } private static Listener listener = new Listener() { public void handleEvent(Event e) { MessageBox = new MessageBox(shell, SWT.OK); m.setMessage(e.toString()); m.open(); } }; private static void newButton(Composite composite, int type, String label) { Button b = new Button(composite, type); b.setText(label); b.addListener(SWT.MouseDown, listener); } public static void sliderTab() { TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText("Sliders Progress bars"); tab.setToolTipText("Tied Slider ProgressBar"); Composite composite = new Composite(folder, SWT.NONE); composite.setLayout(new GridLayout(2, true)); final Slider slider = new Slider(composite, SWT.HORIZONTAL); final ProgressBar progress = new ProgressBar(composite, SWT.HORIZONTAL); slider.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent event) { progress.setSelection(slider.getSelection()); } }); tab.setControl(composite); } public static void scribbleTab() { TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText("Scribble"); tab.setToolTipText("Simple graphics: drawing"); final Canvas canvas = new Canvas(folder, SWT.NONE); ScribbleMouseListener sml= new ScribbleMouseListener(); canvas.addMouseListener(sml); canvas.addMouseMoveListener(sml); tab.setControl(canvas); } private static class ScribbleMouseListener extends MouseAdapter implements MouseMoveListener { private Point p = new Point(0, 0); public void mouseMove(MouseEvent e) { if((e.stateMask & SWT.BUTTON1) == 0) return; GC gc = new GC((Canvas)e.widget); gc.drawLine(p.x, p.y, e.x, e.y); gc.dispose(); updatePoint(e); } public void mouseDown(MouseEvent e) { updatePoint(e); } private void updatePoint(MouseEvent e) { p.x = e.x; p.y = e.y; Graphical User Interfaces 1027 } } public static void browserTab() { TabItem tab = new TabItem(folder, SWT.CLOSE); tab.setText("A Browser"); tab.setToolTipText("A Web browser"); Browser browser = null; try { browser = new Browser(folder, SWT.NONE); } catch(SWTError e) { Label label = new Label(folder, SWT.BORDER); label.setText("Could initialize browser"); tab.setControl(label); } if(browser != null) { browser.setUrl("http://www.mindview.net"); tab.setControl(browser); } } public static void main(String[] args) { SWTConsole.run(new TabbedPane(), 800, 600); } } ///:~ Here, createContents( ) sets layout calls methods create different tab. The text tab set setText( ) (you also create buttons graphics tab), one also sets tool tip text. At end method, you’ll see call setControl( ), places control method created dialog space particular tab. labelTab( ) demonstrates simple text label. directoryDialogTab( ) holds button opens standard DirectoryDialog object user select directory. The result set button’s text. buttonTab( ) shows different basic buttons. sliderTab( ) repeats Swing example earlier chapter tying slider progress bar. scribbleTab( ) fun example graphics. A drawing program produced lines code. Finally, browserTab( ) shows power SWT Browser component—a full-featured Web browser single component. Graphics Here’s Swing SineWave.java program translated SWT: //: swt/SineWave.java // SWT translation Swing SineWave.java. import swt.util.*; import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import org.eclipse.swt.events.*; import org.eclipse.swt.layout.*; class SineDraw extends Canvas { private static final int SCALEFACTOR = 200; private int cycles; private int points; 1028 Thinking Java Bruce Eckel private double[] sines; private int[] pts; public SineDraw(Composite parent, int style) { super(parent, style); addPaintListener(new PaintListener() { public void paintControl(PaintEvent e) { int maxWidth = getSize().x; double hstep = (double)maxWidth / (double)points; int maxHeight = getSize().y; pts = new int[points]; for(int = 0; < points; i++) pts[i] = (int)((sines[i] * maxHeight / 2 * .95) + (maxHeight / 2)); e.gc.setForeground( e.display.getSystemColor(SWT.COLOR_RED)); for(int = 1; < points; i++) { int x1 = (int)((i - 1) * hstep); int x2 = (int)(i * hstep); int y1 = pts[i - 1]; int y2 = pts[i]; e.gc.drawLine(x1, y1, x2, y2); } } }); setCycles(5); } public void setCycles(int newCycles) { cycles = newCycles; points = SCALEFACTOR * cycles * 2; sines = new double[points]; for(int = 0; < points; i++) { double radians = (Math.PI / SCALEFACTOR) * i; sines[i] = Math.sin(radians); } redraw(); } } public class SineWave implements SWTApplication { private SineDraw sines; private Slider slider; public void createContents(Composite parent) { parent.setLayout(new GridLayout(1, true)); sines = new SineDraw(parent, SWT.NONE); sines.setLayoutData( new GridData(SWT.FILL, SWT.FILL, true, true)); sines.setFocus(); slider = new Slider(parent, SWT.HORIZONTAL); slider.setValues(5, 1, 30, 1, 1, 1); slider.setLayoutData( new GridData(SWT.FILL, SWT.DEFAULT, true, false)); slider.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent event) { sines.setCycles(slider.getSelection()); } }); } public static void main(String[] args) { SWTConsole.run(new SineWave(), 700, 400); } } ///:~ Instead JPanel, basic drawing surface SWT Canvas. Graphical User Interfaces 1029 If compare version program Swing version, you’ll see SineDraw virtually identical. In SWT, get graphics context gc event object that’s handed PaintListener, Swing Graphics object handed directly paintComponent( ) method. But activities performed graphics object same, setCycles( ) identical. createContents( ) requires bit code Swing version, lay things set slider listener, again, basic activities roughly same. Concurrency SWT Although AWT/Swing single-threaded, it’s easily possible violate singlethreadedness way produces non-deterministic program. Basically, don’t want multiple threads writing display write surprising ways. SWT doesn’t allow this—it throws exception try write display using one thread. This prevent novice programmer accidentally making mistake introducing hard-to-find bugs program. Here translation Swing ColorBoxes.java program SWT: //: swt/ColorBoxes.java // SWT translation Swing ColorBoxes.java. import swt.util.*; import org.eclipse.swt.*; import org.eclipse.swt.widgets.*; import org.eclipse.swt.events.*; import org.eclipse.swt.graphics.*; import org.eclipse.swt.layout.*; import java.util.concurrent.*; import java.util.*; import net.mindview.util.*; class CBox extends Canvas implements Runnable { class CBoxPaintListener implements PaintListener { public void paintControl(PaintEvent e) { Color color = new Color(e.display, cColor); e.gc.setBackground(color); Point size = getSize(); e.gc.fillRectangle(0, 0, size.x, size.y); color.dispose(); } } private static Random rand = new Random(); private static RGB newColor() { return new RGB(rand.nextInt(255), rand.nextInt(255), rand.nextInt(255)); } private int pause; private RGB cColor = newColor(); public CBox(Composite parent, int pause) { super(parent, SWT.NONE); this.pause = pause; addPaintListener(new CBoxPaintListener()); } public void run() { try { while(!Thread.interrupted()) { cColor = newColor(); 1030 Thinking Java Bruce Eckel getDisplay().asyncExec(new Runnable() { public void run() { try { redraw(); } catch(SWTException e) {} // SWTException OK parent // terminated us. } }); TimeUnit.MILLISECONDS.sleep(pause); } } } catch(InterruptedException e) { // Acceptable way exit } catch(SWTException e) { // Acceptable way exit: parent // terminated us. } } public class ColorBoxes implements SWTApplication { private int grid = 12; private int pause = 50; public void createContents(Composite parent) { GridLayout gridLayout = new GridLayout(grid, true); gridLayout.horizontalSpacing = 0; gridLayout.verticalSpacing = 0; parent.setLayout(gridLayout); ExecutorService exec = new DaemonThreadPoolExecutor(); for(int = 0; < (grid * grid); i++) { final CBox cb = new CBox(parent, pause); cb.setLayoutData(new GridData(GridData.FILL_BOTH)); exec.execute(cb); } } public static void main(String[] args) { ColorBoxes boxes = new ColorBoxes(); if(args.length > 0) boxes.grid = new Integer(args[0]); if(args.length > 1) boxes.pause = new Integer(args[1]); SWTConsole.run(boxes, 500, 400); } } ///:~ As previous example, painting controlled creating PaintListener paintControl( ) method called SWT thread ready paint component. The PaintListener registered CBox constructor. What’s notably different version CBox run( ) method, cannot call redraw( ) directly must submit redraw( ) asyncExec( ) method Display object, roughly SwingUtilities.invokeLater( ). If replace direct call redraw( ), you’ll see program stops. When running program, see little visual artifacts—horizontal lines occasionally running box. This SWT doublebuffered default, Swing is. Try running Swing version side side SWT version you’ll see clearly. You write code double-buffer SWT; you’ll find examples www.eclipse.org Web site. Exercise 42: (4) Modify swt/ColorBoxes.java begins sprinkling points ("stars") across canvas, randomly changes colors "stars." Graphical User Interfaces 1031 SWT vs. Swing? It’s hard get complete picture short introduction, least start see SWT, many situations, straightforward way write code Swing. However, GUI programming SWT still complex, motivation using SWT probably be, first, give user transparent experience using application (because application looks/feels like applications platform), second, responsiveness provided SWT important. Otherwise, Swing may appropriate choice. Exercise 43: (6) Choose one Swing examples wasn’t translated section, translate SWT. (Note: This makes good homework exercise class, since solutions solution guide.) 1032 Thinking Java Bruce Eckel Summary The Java GUI libraries seen dramatic changes lifetime language. The Java 1.0 AWT roundly criticized poor design, allowed create portable programs, resulting GUI "equally mediocre platforms." It also limiting, awkward, unpleasant use compared native application development tools available various platforms. When Java 1.1 introduced new event model JavaBeans, stage set—now possible create GUI components could easily dragged dropped inside visual IDE. In addition, design event model JavaBeans clearly shows strong consideration ease programming maintainable code (something evident 1.0 AWT). But wasn’t JFC/Swing classes appeared transition complete. With Swing components, cross-platform GUI programming civilized experience. IDEs real revolution lies. If want commercial IDE proprietary language get better, must cross fingers hope vendor give want. But Java open environment, allow competing IDEs, encourages them. And tools taken seriously, must support JavaBeans. This means leveled playing field; better IDE comes along, you’re tied one you’ve using. You pick move new one increase productivity. This kind competitive environment GUI IDEs seen before, resulting marketplace generate positive results programmer productivity. This chapter meant give introduction power GUI programming get started see relatively simple feel way libraries. What you’ve seen far probably suffice good portion UI design needs. However, there’s lot Swing, SWT Flash/Flex; meant fully powered UI design toolkits. There’s probably way accomplish everything imagine. Resources Ben Galbraith’s online presentations www.galbraiths.org/presentations provide nice coverage Swing SWT. Solutions selected exercises found electronic document The Thinking Java Annotated Solution Guide, available sale www.MindView.net. Graphical User Interfaces 1033 A: Supplements There number supplements book, including items, seminars, services available MindView Web site. This appendix describes supplements decide helpful you. Note although seminars often held public events, may given private, inhouse seminars location. Downloadable supplements The code book available download www.MindView.net. This includes Ant build files support files necessary successful build execution examples book. In addition, portions book moved electronic form. The subjects include: • Cloning Objects • Passing & Returning Objects • Analysis Design • Portions chapters Thinking Java, 3 Edition relevant th enough put print version 4 edition book. rd Thinking C: Foundations Java At www.MindView.net, find Thinking C seminar free download. This presentation, created Chuck Allison developed MindView, multimedia Flash course gives introduction C syntax, operators functions Java syntax based upon. Note must Flash Player www.Macromedia.com installed system order play Thinking C. Thinking Java seminar My company, MindView, Inc., provides five-day, hands-on, public in-house training seminars based material book. Formerly called Hands-On Java seminar, main introductory seminar provides foundation advanced seminars. Selected material chapter represents lesson, followed monitored exercise period student receives personal attention. You find schedule location information, testimonials, details www.MindView.net. Hands-On Java seminar-on-CD The Hands-On Java CD contains extended version material Thinking Java seminar based book. It provides least experience live seminar without travel expense. There audio lecture slides corresponding every chapter book. I created seminar I narrate material CD. The material Flash format, run platform supports Flash Player. The Hands-On Java CD sale www.MindView.net, find trial demos product. Thinking Objects seminar This seminar introduces ideas object-oriented programming standpoint designer. It explores process developing building system, primarily focusing socalled “Agile Methods” “Lightweight Methodologies,” especially Extreme Programming (XP). I introduce methodologies general, small tools like “index-card” planning techniques described Planning Extreme Programming Beck Fowler (Addison-Wesley, 2001), CRC cards object design, pair programming, iteration planning, unit testing, automated building, source-code control, similar topics. The course includes XP project developed throughout week. If starting project would like begin using object-oriented design techniques, use project example produce first-cut design end week. Visit www.MindView.net schedule location information, testimonials, details. Thinking Enterprise Java This book spawned advanced chapters earlier editions Thinking Java. This book isn’t second volume Thinking Java, rather focused coverage advanced topic enterprise programming. It currently available (in form, likely still development) free download www.MindView.net. Because separate book, expand fit necessary topics. The goal, like Thinking Java, produce understandable introduction basics enterprise programming technologies reader prepared advanced coverage topics. The list topics include, limited to: • • • • • • • • • • • • • 1036 Introduction Enterprise Programming Network Programming Sockets Channels Remote Method Invocation (RMI) Connecting Databases Naming Directory Services Servlets Java Server Pages Tags, JSP Fragments Expression Language Automating Creation User Interfaces Enterprise JavaBeans XML Web Services Automated Testing Thinking Java Bruce Eckel You find current state Thinking Enterprise Java www.MindView.net. Thinking Patterns (with Java) One important steps forward object-oriented design “design patterns” movement, chronicled Design Patterns, Gamma, Helm, Johnson & Vlissides (AddisonWesley, 1995). That book shows 23 general classes problems solutions, primarily written C++. The Design Patterns book source become essential, almost mandatory, vocabulary OOP programmers. Thinking Patterns introduces basic concepts design patterns along examples Java. The book intended simple translation Design Patterns, rather new perspective Java mindset. It limited traditional 23 patterns, also includes ideas problemsolving techniques appropriate. st This book began last chapter Thinking Java, 1 Edition, ideas continued develop, became clear needed book. At time writing, still development, material worked reworked numerous presentations Objects & Patterns seminar (which split Designing Objects & Systems Thinking Patterns seminars). You find book www.MindView.net. Thinking Patterns seminar This seminar evolved Objects & Patterns seminar Bill Venners I gave past several years. That seminar grew full, we’ve split two seminars: one, Designing Objects & Systems seminar, described earlier appendix. The seminar strongly follows material presentation Thinking Patterns book, best way find what’s seminar learn book www.MindView.net. Much presentation emphasizes design evolution process, starting initial solution moving logic process evolving solution appropriate designs. The last project shown (a trash recycling simulation) evolved time, look evolution prototype way design start adequate solution particular problem evolve flexible approach class problems. This seminar help you: • • • Dramatically increase flexibility designs. Build extensibility reusability. Create denser communications designs using language patterns. Following lecture set patterns exercises solve, guided write code apply particular patterns solution programming problems. Visit www.MindView.net schedule location information, testimonials, details. Appendix A: Supplements 1037 Design consulting reviews My company also provides consulting, mentoring, design reviews implementation reviews help guide project development cycle, including company’s first Java project. Visit www.MindView.net availability details. 1038 Thinking Java Bruce Eckel B: Resources Software The JDK http://java.sun.com. Even choose use third-party development environment, it’s always good idea JDK hand case come might compiler error. The JDK touchstone, bug it, chances well known. The JDK documentation http://java.sun.com, HTML. I never found reference book standard Java libraries wasn’t date missing information. Although JDK documentation Sun shot small bugs sometimes unusably terse, classes methods least there. Sometimes people initially uncomfortable using online resource rather printed book, it’s worth get open HTML docs least get big picture. If can’t figure point, reach printed books. Editors & IDEs There healthy competition arena. Many offerings free (and non-free ones usually free trials), best bet simply try see one fits needs. Here few: JEdit, Slava Pestov’s free editor, written Java, get bonus seeing desktop Java application action. This editor based heavily plug-ins, many written active community. Download www.jedit.org. NetBeans, free IDE Sun, www.netbeans.org. Designed drag-and-drop GUI building, code editing, debugging, more. Eclipse, open-source project backed IBM, among others. The Eclipse platform also designed extensible foundation, build standalone applications top Eclipse. This project created SWT described Graphical User Interfaces chapter. Download www.Eclipse.org. IntelliJ IDEA, payware favorite large faction Java programmers, many claim IDEA always step two ahead Eclipse, possibly IntelliJ creating IDE development platform, sticking creating IDE. You download free trial www.jetbrains.com. Books Core JavaTM 2, 7th Edition, Volumes I & II, Horstmann & Cornell (Prentice Hall, 2005). Huge, comprehensive, first place I go I’m hunting answers. The book I recommend you’ve completed Thinking Java need cast bigger net. The JavaTM Class Libraries: An Annotated Reference, Patrick Chan Rosanna Lee (Addison-Wesley, 1997). Although sadly date, JDK reference been: enough description make usable. One technical reviewers Thinking Java said, “If I one Java book, would (well, addition yours, course).” I’m thrilled is. It’s big, it’s expensive, quality examples doesn’t satisfy me. But it’s place look you’re stuck, seems depth (and sheer size) alternatives. However, Core Java 2 recent coverage many library components. Java Network Programming, 2nd Edition, Elliotte Rusty Harold (O’Reilly, 2000). I didn’t begin understand Java networking (or networking general, matter) I found book. I also find Web site, Café au Lait, stimulating, opinionated, upto-date perspective Java developments, unencumbered allegiances vendors. His regular updates keep fast-changing news Java. See www.cafeaulait.org. Design Patterns, Gamma, Helm, Johnson Vlissides (Addison-Wesley, 1995). The seminal book started patterns movement programming, mentioned numerous places book. Refactoring Patterns, Joshua Kerievsky (Addison-Wesley, 2005). Marries refactoring design patterns. The valuable thing book shows evolve design folding patterns needed. The Art UNIX Programming, Eric Raymond (Addison-Wesley, 2004). Although Java cross-platform language, prevalence Java server made knowledge Unix/Linux important. Eric’s book excellent introduction history philosophy operating system, fascinating read want understand roots computing. Analysis & design Extreme Programming Explained, 2nd Edition, Kent Beck Cynthia Andres. (Addison-Wesley, 2005). I’ve always felt might much different, much better program development process, I think XP comes pretty darn close. The book similar impact Peopleware (described later), talks primarily environment dealing corporate culture. Extreme Programming Explained talks programming turns things, even recent “findings,” ear. They even go far say pictures OK long don’t spend much time willing throw away. (You’ll notice book “UML stamp approval” cover.) I could see deciding work company based solely whether used XP. Small book, small chapters, effortless read, exciting think about. You start imagining working atmosphere, brings visions whole new world. UML Distilled, 2nd Edition, Martin Fowler (Addison-Wesley, 2000). When first encounter UML, daunting many diagrams details. According Fowler, stuff unnecessary, cuts essentials. For projects, need know diagramming tools, Fowler’s goal come good design rather worry artifacts getting there. In fact, first half book people need. A nice, thin, readable book; first one get need understand UML. Domain-Driven Design, Eric Evans (Addison-Wesley, 2004). This book focuses domain model primary artifact design process. I found important shift emphasis helps keep designers right level abstraction. The Unified Software Development Process, Ivar Jacobsen, Grady Booch, James Rumbaugh (Addison-Wesley, 1999). I went fully prepared dislike book. It seemed makings boring college text. I pleasantly surprised—although parts explanations seem concepts aren’t clear authors. The bulk book clear, enjoyable. And best all, process makes lot practical sense. It’s Extreme Programming (and clarity 1040 Thinking Java Bruce Eckel testing), it’s also part UML juggernaut; even can’t get XP door, people climbed aboard “UML good” bandwagon (regardless actual level experience it), probably get adopted. I think book flagship UML, one read Fowler’s UML Distilled want detail. Before choose method, it’s helpful gain perspective trying sell one. It’s easy adopt method without really understanding want you. Others using it, seems compelling reason. However, humans strange little psychological quirk: If want believe something solve problems, they’ll try it. (This experimentation, good.) But doesn’t solve problems, may redouble efforts begin announce loudly great thing they’ve discovered. (This denial, good.) The assumption may get people boat, won’t lonely, even it’s going nowhere (or sinking). This suggest methodologies go nowhere, armed teeth mental tools help stay experimentation mode (“It’s working; let’s try something else”) denial mode (“No, that’s really problem. Everything’s wonderful, don’t need change”). I think following books, read choose method, provide tools. Software Creativity, Robert L. Glass (Prentice Hall, 1995). This best book I’ve seen discusses perspective whole methodology issue. It’s collection short essays papers Glass written sometimes acquired (P.J. Plauger one contributor), reflecting many years thinking study subject. They’re entertaining long enough say what’s necessary; doesn’t ramble bore you. He’s blowing smoke, either; hundreds references papers studies. All programmers managers read book wading methodology mire. Software Runaways: Monumental Software Disasters, Robert L. Glass (Prentice Hall, 1998). The great thing book brings forefront don’t talk about: number projects fail, fail spectacularly. I find us still think, “That can’t happen me” (or “That can’t happen again”), I think puts us disadvantage. By keeping mind things always go wrong, you’re much better position make go right. Peopleware, 2nd Edition, Tom DeMarco Timothy Lister (Dorset House, 1999). You must read book. It’s fun, rocks world destroys assumptions. Although DeMarco Lister backgrounds software development, book projects teams general. But focus people needs, rather technology needs. They talk creating environment people happy productive, rather deciding rules people follow adequate components machine. This latter attitude, I think, biggest contributor programmers smiling nodding XYZ method adopted, quietly whatever they’ve always done. Secrets Consulting: A Guide Giving & Getting Advice Successfully, Gerald M. Weinberg (Dorset House, 1985). A superb book, one all-time favorites. It’s perfect trying consultant you’re using consultants trying better job. Short chapters, filled stories anecdotes teach get core issue minimal struggle. Also see More Secrets Consulting, published 2002, Weinberg book. Complexity, M. Mitchell Waldrop (Simon & Schuster, 1992). This chronicles coming together Santa Fe, New Mexico, group scientists different disciplines discuss real problems individual disciplines couldn’t solve (the stock market Appendix B: Resources 1041 economics, initial formation life biology, people sociology, etc.). By crossing physics, economics, chemistry, math, computer science, sociology, others, multidisciplinary approach problems developing. But important, different way thinking ultra-complex problems emerging: away mathematical determinism illusion write equation predicts behavior, toward first observing looking pattern trying emulate pattern means possible. (The book chronicles, example, emergence genetic algorithms.) This kind thinking, I believe, useful observe ways manage complex software projects. Python Learning Python, 2nd Edition, Mark Lutz David Ascher (O’Reilly, 2003). A nice programmer’s introduction favorite language, excellent companion Java. The book includes introduction Jython, allows combine Java Python single program (the Jython interpreter compiled pure Java bytecodes, nothing special need add accomplish this). This language union promises great possibilities. My list books Not currently available, found used-book outlets. Computer Interfacing Pascal & C (self-published Eisys imprint, 1988. Available sale www.MindView.net). An introduction electronics back CP/M still king DOS upstart. I used high-level languages often parallel port computer drive various electronic projects. Adapted columns first best magazine I wrote for, Micro Cornucopia. Alas, Micro C lost long Internet appeared. Creating book extremely satisfying publishing experience. Using C++ (Osborne/McGraw-Hill, 1989). One first books C++. This nd print replaced 2 edition, renamed C++ Inside & Out. nd C++ Inside & Out (Osborne/McGraw-Hill, 1993). As noted, actually 2 edition Using C++. The C++ book reasonably accurate, it’s circa 1992 Thinking C++ intended replace it. You find book download source code www.MindView.net. Thinking C++, 1st Edition (Prentice Hall, 1995). This Software Development Magazine Jolt Award best book year. Thinking C++, 2nd Edition, Volume 1 (Prentice Hall, 2000). Downloadable www.MindView.net. Updated follow finalized language standard. Thinking C++, 2nd Edition, Volume 2, coauthored Chuck Allison (Prentice Hall, 2003). Downloadable www.MindView.net. Black Belt C++: The Master’s Collection, Bruce Eckel, editor (M&T Books, 1994). Out print. A collection chapters various C++ luminaries based presentations C++ track Software Development Conference, I chaired. The cover book stimulated gain control future cover designs. Thinking Java, 1st Edition (Prentice Hall, 1998). The 1st edition book Software Development Magazine Productivity Award, Java Developer’s Journal Editor’s 1042 Thinking Java Bruce Eckel Choice Award, JavaWorld Reader’s Choice Award best book. Downloadable www.MindView.net. Thinking Java, 2nd Edition (Prentice Hall, 2000). This edition JavaWorld Editor’s Choice Award best book. Downloadable www.MindView.net. Thinking Java, 3rd Edition, (Prentice Hall, 2003). This edition Software Development Magazine Jolt Award best book year, along awards listed back cover. Downloadable www.MindView.net. Appendix B: Resources 1043 Index Please note names duplicated capitalized form. Following Java style, capitalized names refer Java classes, lowercase names refer general concept. ! ^ ! · 71 != ∙ 70 ^ · 76 ^= ∙ 76 & | & · 76 && · 71 &= ∙ 76 | · 76 || · 71 |= ∙ 76 . + .NET · 37 .new syntax · 247 .this syntax ∙ 246 + · 69; String conversion operator + · 64, 81, 356 @ @ symbol, annotations · 761 @author · 58 @Deprecated, annotation · 761 @deprecated, Javadoc tag · 58 @docRoot · 57 @inheritDoc · 57 @interface, extends keyword · 769 @link · 57 @Override · 761 @param · 58 @Retention · 762 @return · 58 @see · 57 @since · 58 @SuppressWarnings · 761 @Target · 762 @Test · 762 @Test, @Unit · 778 @TestObjectCleanup, @Unit tag · 785 @TestObjectCreate, @Unit · 782 @throws · 58 @Unit · 778; using · 778 @version ∙ 57 [ [ ], indexing operator · 134 < < · 70 << · 76 <<= · 77 <= ∙ 70 = == · 70 > > · 70 >= · 70 >> · 76 >>= ∙ 77 A abstract: class · 219; inheriting abstract classes · 220; keyword · 220; vs. interface · 231 Abstract Window Toolkit (AWT) · 937 AbstractButton · 958 abstraction · 15 AbstractSequentialList · 616 AbstractSet · 568 access: class · 159; control · 145, 162; control, violating reflection · 432; inner classes & access rights ·245; package access friendly · 153; specifiers · 20, 145, 153; within directory, via default package · 155 action command · 976 ActionEvent · 977, 1011 ActionListener · 946 ActionScript, Macromedia Flex · 1019 active objects, concurrency · 931 Adapter design pattern · 229, 235, 307, 448, 524, 526, 569 Adapter Method idiom · 307 adapters, listener · 954 add( ), ArrayList · 276 addActionListener( ) · 1009, 1014 addChangeListener · 980 addition · 67 addListener · 949 Adler32 · 700 agent-based programming · 934 aggregate array initialization · 134 aggregation · 21 aliasing · 66; String · 356; arrays · 135 Allison, Chuck · 3, 12, 1043, 1050 allocate( ) · 681 allocateDirect( ) · 681 alphabetic sorting · 295 alphabetic vs. lexicographic sorting · 561 AND: bitwise · 82; logical (&&) · 71 annotation · 761; apt processing tool · 771; default element values · 763, 765; default value · 768; elements · 762; elements, allowed types · 765; marker annotation · 762; processor · 764; processor based reflection · 769 anonymous inner class · 251, 649, 944; tabledriven code · 616; generic · 459 application: builder · 1003; framework · 264 applying method sequence · 520 apt, annotation processing tool · 771 argument: constructor · 108; covariant argument types · 504; final · 186, 649; generic type argument inference · 450; variable argument lists (unknown quantity type arguments) · 137 Arnold, Ken · 938 array: array generic objects · 610; associative array · 278; bounds checking · 135; comparing arrays · 557; comparison container · 535; copying array · 555; covariance · 483; dynamic aggregate initialization syntax · 538; element comparisons · 557; first-class objects · 536; initialization · 134; length · 135, 536; multidimensional · 540; Iterable · 306; objects · 537; primitives · 537; ragged · 541; returning array · 539 ArrayBlockingQueue · 872 ArrayList · 283, 586; add( ) · 276; get( ) · 276; size( ) · 276 Arrays: asList( ) · 280, 309, 585; binarySearch( ) · 562; class, container utility · 555 asCharBuffer( ) · 682 aspect-oriented programming (AOP) · 509 assert, @Unit · 780 assigning objects · 65 assignment · 65 associative array · 275, 278; another name map · 596 atomic operation · 833 AtomicInteger · 838 atomicity, concurrent programming · 826 AtomicLong · 838 AtomicReference · 838 autoboxing · 296, 448; generics · 450, 495 auto-decrement operator · 69 auto-increment operator · 69 automatic type conversion · 166 available( ) · 667 B backwards compatibility · 467 bag · 278 bank teller simulation · 900 base 16 · 74 base 8 · 74 base class · 156, 168, 195; abstract base class · 219; base-class interface · 199; constructor · 206; initialization · 170 base types · 22 basic concepts object-oriented programming (OOP) · 15 BASIC, Microsoft Visual BASIC · 1002 BasicArrowButton · 958 BeanInfo, custom · 1017 Beans: Borland’s Delphi · 1002; Microsoft’s Visual BASIC · 1002; application builder · 1003; bound properties · 1017; component · 1003; constrained properties · 1017; custom BeanInfo · 1017; custom property editor · 1017; custom property sheet · 1017; events · 1003; EventSetDescriptors · 1007; FeatureDescriptor · 1017; getBeanInfo( ) · 1005; getEventSetDescriptors( ) · 1007; getMethodDescriptors( ) · 1007; getName( ) · 1007; getPropertyDescriptors( ) · 1007; getPropertyType( ) · 1007; getReadMethod( ) · 1007; getWriteMethod( ) · 1007; indexed property · 1017; Introspector · 1005; JAR files packaging · 1015; manifest file · 1015; Method · 1007; MethodDescriptors · 1007; naming convention · 1003; properties · 1003; PropertyChangeEvent · 1017; PropertyDescriptors · 1007; ProptertyVetoException · 1017; reflection · 1003, 1005; Serializable · 1011; visual programming · 1002 Beck, Kent · 1048 benchmarking · 914 binary: numbers · 74; numbers, printing · 79; operators · 76 binarySearch( ) · 562, 635 binding: dynamic binding · 196; dynamic, late, runtime binding · 193; early · 26; late · 26; late binding · 196; method call binding · 196; runtime binding · 196 BitSet · 644 bitwise: AND · 82; AND operator (&) · 76; EXCLUSIVE OR XOR (^) · 76; NOT ~ · 76; operators · 76; OR · 82; OR operator (|) · 76 blank final · 185 Bloch, Joshua · 121, 725, 823, 836 blocking: available( ) · 668; concurrent programs · 799 BlockingQueue · 872, 887 Booch, Grady · 1048 book errors, reporting · 14 Boolean · 91; algebra · 76; casting · 83; operators won’t work boolean · 70; vs. C C++ · 72 Borland Delphi · 1002 bound properties · 1017 bounds: Class references · 402; generics · 465, 480; self-bounded generic types · 500; superclass Class references · 404 bounds checking, array · 135 boxing · 296, 448; generics · 450, 495 BoxLayout · 949 branching, unconditional · 99 break keyword · 99 Brian’s Rule Synchronization · 830 browser, class · 159 Budd, Timothy · 16 buffer, nio · 679 BufferedInputStream · 660 BufferedOutputStream · 661 BufferedReader · 341, 663, 665 BufferedWriter · 663, 668 busy wait, concurrency · 860 button: creating · 955; radio button · 966; Swing · 942, 958 ButtonGroup · 959, 966 ByteArrayInputStream · 657 ByteArrayOutputStream · 659 ByteBuffer · 679 bytecode engineering · 791; Javassist · 793 C C#: programming language · 37 C++ · 70; exception handling · 348; Standard Template Library (STL) · 646; templates · 440, 464 CachedThreadPool · 805 Callable, concurrency · 807 callback · 648, 943; inner classes · 262 camel-casing · 60 capacity, HashMap HashSet · 630 capitalization package names · 50 Cascading Style Sheets (CSS), Macromedia Flex · 1023 case statement · 105 CASE_INSENSITIVE_ORDER String Comparator · 634, 647 cast · 27; generic types · 497; primitive types · 92; asSubclass( ) · 404; operators · 82; via generic class · 498 cast( ) · 404 catch: catching exception · 316; catching exception · 323; keyword · 316 Chain Responsibility design pattern · 743 chained exceptions · 328, 351 change, vector · 266 channel, nio · 679 CharArrayReader · 663 CharArrayWriter · 663 CharBuffer · 682 CharSequence · 375 Charset · 683 check box · 965 checked exceptions · 322, 347; converting unchecked exceptions · 351 checkedCollection( ) · 506 CheckedInputStream · 699 checkedList( ) · 506 checkedMap( ) · 506 CheckedOutputStream · 699 checkedSet( ) · 506 checkedSortedMap( ) · 506 checkedSortedSet( ) · 506 Checksum class · 700 Index Chiba, Shigeru, Dr. · 793, 795 class · 17; abstract class · 219; access · 159; anonymous inner class · 251, 649, 944; base class · 156, 168, 195; browser · 159; class hierarchies exception handling · 345; class literal · 399, 410; creators · 19; data · 51; derived class · 195; equivalence, instanceof/isInstance( ) · 417; final classes · 188; inheritance diagrams · 182; inheriting abstract classes · 220; inheriting inner classes · 270; initialization · 400; initialization & class loading · 190; initialization fields · 126; initializing base class · 170; initializing derived class · 170; inner class · 243; inner class, access rights · 245; inner class, overriding · 270; inner class, super · 270; inner class, Swing · 950; inner class, upcasting · 248; inner class, identifiers .class files · 273; inner class, methods scopes · 249; inner class, nesting within arbitrary scope · 250; instance · 16; keyword · 21; linking · 400; loading · 191, 400; member initialization · 166; methods · 51; multiply nested · 259; nested class (static inner class) · 257; nesting inside interface · 258; order initialization · 128; private inner classes · 266; public class, compilation units · 146; referring outer-class object inner class · 246; static inner classes · 257; style creating classes · 158; subobject · 170 Class · 960; Class object · 395, 717, 829; forName( ) · 396, 953; getCanonicalName( ) · 398; getClass( ) · 324; getConstructors( ) · 421; getInterfaces( ) · 398; getMethods( ) · 421; getSimpleName( ) · 398; getSuperclass( ) · 398; isAssignableFrom( ) · 413; isInstance( ) · 411; isInterface( ) · 398; newInstance( ) · 398; object creation process · 131; references, bounds · 402; references, generics · 401; references, wildcards · 402; RTTI using Class object · 395 class files, analyzing · 791 class loader · 395 class name, discovering class file · 791 ClassCastException · 216, 405 ClassNotFoundException · 408 classpath · 148 cleanup: garbage collector · 175; performing · 121; verifying termination condition finalize( ) · 122; finally · 334 clear( ), nio · 681 client programmer · 19; vs. library creator · 145 close( ) · 666 closure, inner classes · 262 code: coding standards · 14; coding style · 59; organization · 153; reuse · 165; source code · 12 collecting parameter · 509, 530 collection · 29, 278, 302, 634; classes · 275; filling Generator · 453; list methods · 580; utilities · 631 Collections: addAll( ) · 280; enumeration( ) · 642; fill( ) · 568; unmodifiableList( ) · 584 collision: hashing · 608; name · 150 combo box · 967 comma operator · 96 Command design pattern · 268, 429, 739, 805 comments, embedded documentation · 55 Commitment, Theory Escalating · 823 common interface · 219 Communicating Sequential Processes (CSP) · 934 Comparable · 558, 589, 594 Comparator · 559, 589 1047 compareTo( ), java.lang.Comparable · 558, 591 comparing arrays · 557 compatibility: backwards · 467; migration · 466 compilation unit · 146 compile-time constant · 183 compiling Java program · 54 component, JavaBeans · 1003 composition · 21, 165; design · 213; dynamic behavior change · 214; combining composition & inheritance · 173; vs. inheritance · 179, 183, 595, 642 compression, library · 699 concurrency: active objects · 931; containers · 637; exceptions · 831; Swing · 994; ArrayBlockingQueue · 872; atomicity · 826; BlockingQueue · 872, 887; Brian’s Rule Synchronization · 830; Callable · 807; Condition class · 870; constructors · 816; contention, lock · 914; CountDownLatch · 883; CyclicBarrier · 885; daemon threads · 811; DelayQueue · 887; Exchanger · 898; Executor · 804; I/O tasks using pipes · 876; LinkedBlockingQueue · 872; lock, explicit · 831; lock-free code · 833; long double non-atomicity · 833; missed signals · 864; performance tuning · 913; priority · 809; PriorityBlockingQueue · 889; producer-consumer · 867; race condition · 827; ReadWriteLock · 929; ScheduledExecutor · 892; semaphore · 895; sleep( ) · 808; SynchronousQueue · 904; task interference · 826; terminating tasks · 846; Goetz Test avoiding synchronization · 833; thread local storage · 845; thread vs. task, terminology · 820; UncaughtExceptionHandler · 824; word tearing · 833 ConcurrentHashMap · 598, 921, 925 ConcurrentLinkedQueue · 921 ConcurrentModificationException · 637; using CopyOnWriteArrayList eliminate · 921, 933 Condition class, concurrency · 870 conditional compilation · 152 conditional operator · 80 conference, Software Development Conference · 10 console: sending exceptions · 351; Swing display framework net.mindview.util.SwingConsole · 942 constant: compile-time constant · 183; constant folding · 183; groups constant values · 236; implicit constants, String · 355 constrained properties · 1017 constructor · 107; anonymous inner classes · 251; concurrency · 816; exception handling · 340, 341; finally · 341; overloading · 109; polymorphism · 204; arguments · 108; baseclass constructor · 206; behavior polymorphic methods inside constructors · 210; calling baseclass constructors arguments · 170; calling constructors · 118; Constructor class reflection · 419; default · 115; initialization inheritance composition · 173; instance initialization · 253; name · 107; no-arg · 108, 115; order constructor calls inheritance · 204; return value · 108; static construction clause · 131; static method · 131; synthesized default constructor access · 421 consulting & training provided MindView, Inc. · 1043 container · 29; class · 275; classes · 275; comparison array · 535; performance test · 616 containers: basic behavior · 281; lock-free · 921; typesafe generics · 275 contention, lock, concurrency · 914 context switch · 798 continue keyword · 99 contravariance, generics · 487 control framework, inner classes · 264 control, access · 20, 162 conversion: automatic · 166; narrowing conversion · 83; widening conversion · 83 Coplien, Jim: curiously recurring template pattern · 501 copying array · 555 CopyOnWriteArrayList · 900, 921 CopyOnWriteArraySet · 921 copyright notice, source code · 12 CountDownLatch, concurrency · 883 covariant · 402; argument types · 504; arrays · 483; return types · 212, 415, 504 CRC32 · 700 critical section, synchronized block · 839 CSS (Cascading Style Sheets), Macromedia Flex · 1023 curiously recurring: generics · 501; template pattern C++ · 501 CyclicBarrier, concurrency · 885 D daemon threads · 811 data: final · 183; primitive data types use operators · 84; static initialization · 129 Data Transfer Object · 442, 571 Data Transfer Object (Messenger idiom) · 617 data type, equivalence class · 18 database table, SQL generated via annotations · 766 DatagramChannel · 697 DataInput · 665 DataInputStream · 660, 663, 667 DataOutput · 665 DataOutputStream · 661, 664 deadlock, concurrency · 878 decode( ), character set · 684 decompiler, javap · 356, 434, 470 Decorator design pattern · 512 decoupling, via polymorphism · 26, 193 decrement operator · 69 default constructor · 115; access class · 421; synthesizing default constructor · 170 default keyword, switch statement · 104 default package · 146, 155 defaultReadObject( ) · 714 defaultWriteObject( ) · 714 DeflaterOutputStream · 699 Delayed · 889 DelayQueue, concurrency · 887 delegation · 172, 512 Delphi, Borland · 1002 DeMarco, Tom · 1049 deque, double-ended queue · 290, 595 derived: derived class · 195; derived class, initializing · 170; types · 22 design · 214; adding methods design · 163; composition · 213; inheritance · 213; mistakes · 162; library design · 145 design pattern: Adapter · 229, 235, 448, 524, 526, 569; Adapter method · 307; Chain Responsibility · 743; Command · 268, 429, 739, 805; Data Transfer Object (Messenger idiom) · 442, 571, 617; Decorator · 512; Façade · 411; Factory Method · 239, 414, 446, 666; Factory Method, anonymous classes · 255; Flyweight · 573, 935; Iterator · 246, 287; Null Iterator · 426; Null Object · 426; Proxy · 422; Singleton · 161; State · 214; Strategy · 226, 234, 526, 547, 558, 559, 648, 653, 743, 889; Template Method · 264, 408, 475, 616, 696, 842, 919, 923; Visitor · 775 destructor · 120, 121, 334; Java doesn’t one · 175 diagram: class inheritance diagrams · 182; inheritance · 27 dialog: box · 981; file · 984; tabbed · 970 dictionary · 279 Dijkstra, Edsger · 878 dining philosophers, example deadlock concurrency · 878 directory: packages · 153; creating directories paths · 655; lister · 647 dispatching: double dispatching · 752; multiple, enum · 752 display framework, Swing · 942 dispose( ) · 982 division · 67 documentation · 11; comments & embedded documentation · 55 double: threading · 833; literal value marker (d D) · 74 double dispatching · 752; EnumMap · 757 double-ended queue (deque) · 290 do-while · 95 downcast · 182, 215; type-safe downcast · 405 drawing lines Swing · 978 drop-down list · 967 duck typing · 515, 524 dynamic: aggregate initialization syntax arrays · 538; behavior change composition · 214; binding · 193, 196; proxy · 423; type checking Java · 584; type safety containers · 506 E early binding · 26, 196 East, BorderLayout · 947 editor, creating one using Swing JTextPane · 964 efficiency: arrays · 535; final · 189 else keyword · 93 encapsulation · 158; using reflection break · 432 encode( ), character set · 684 end sentinel · 445 endian: big endian · 688; little endian · 688 entrySet( ), Map · 607 enum: adding methods · 727; Chain Responsibility design pattern · 743; inheritance · 732; interface · 733; multiple dispatching · 752; random selection · 732; state machines · 747; static imports · 726; switch · 728; constant-specific methods · 740, 756; groups constant values C & C++ · 236; keyword · 142, 725; values( ) · 725, 729 enumerated types · 142 Enumeration · 641 EnumMap · 739 EnumSet · 457, 645; instead flags · 737 equals( ) · 70; hashCode( ) · 589, 612; hashed data structures · 605; conditions Index defining properly · 604; overriding HashMap · 604 equivalence: == · 70; object equivalence · 70 erasure · 497; generics · 463 Erlang language · 800 error: handling exceptions · 313; recovery · 313; reporting · 348; reporting errors book · 14; standard error stream · 318 Escalating Commitment, Theory · 823 event: event-driven programming · 943; eventdriven system · 264; events listeners · 950; JavaBeans · 1003; listener · 949; model, Swing · 949; multicast, JavaBeans · 1012; responding Swing event · 943 EventSetDescriptors · 1007 exception: concurrency · 831; constructors · 340; inheritance · 339, 345; console · 351; catching exception · 316; catching exception · 323; chained exceptions · 351; chaining · 328; changing point origin exception · 327; checked · 322, 347; class hierarchies · 345; constructors · 341; converting checked unchecked · 351; creating · 317; design issues · 343; Error class · 331; Exception class · 331; exception handler · 316; exception handling · 313; exception matching · 345; exceptional condition · 314; FileNotFoundException · 342; fillInStackTrace( ) · 325; finally · 333; generics · 507; guarded region · 316; handler · 314; handling · 32; logging · 319; losing exception, pitfall · 337; NullPointerException · 331; printStackTrace( ) · 325; reporting exceptions via logger · 320; restrictions · 339; re-throwing exception · 325; RuntimeException · 331; specification · 322, 348; termination vs. resumption · 317; Throwable · 323; throwing exception · 314, 315; try · 334; try block · 316; typical uses exceptions · 353; unchecked · 331 Exchanger, concurrency class · 898 executing operating system programs within Java · 677 Executor, concurrency · 804 ExecutorService · 805 explicit type argument specification generic methods · 281, 452 exponential notation · 75 extending class inheritance · 23 extends · 156, 169, 215; @interface · 769; interface · 233; keyword · 168 extensible program · 199 extension: sign · 77; zero · 77 extension, vs. pure inheritance · 214 Externalizable · 708; alternative approach using · 712 Extreme Programming (XP) · 1048 F Façade · 411 Factory Method design pattern · 239, 414, 446, 666; anonymous classes · 255 factory object · 199, 473 fail fast containers · 637 false · 71 FeatureDescriptor · 1017 Fibonacci · 448 Field, reflection · 419 fields, initializing fields interfaces · 236 1049 FIFO (first-in, first out) · 299 file: characteristics files · 655; dialogs · 984; File class · 647, 657, 664; File.list( ) · 647; incomplete output files, errors flushing · 668; JAR file · 147; locking · 696; memory-mapped files · 693 FileChannel · 680 FileDescriptor · 657 FileInputReader · 665 FileInputStream · 657 FileLock · 697 FilenameFilter · 647 FileNotFoundException · 342 FileOutputStream · 659 FileReader · 341, 663 FileWriter · 663, 668 fillInStackTrace( ) · 325 FilterInputStream · 657 FilterOutputStream · 659 FilterReader · 663 FilterWriter · 663 final · 223, 442; efficiency · 189; private · 187; static · 183; argument · 186, 649; blank finals · 185; classes · 188; data · 183; keyword · 183; method · 196; methods · 186, 212; static primitives · 185; object references · 183 finalize( ) · 120, 177, 343; inheritance · 206; calling directly · 121 finally · 175, 177; constructors · 341; return · 336; keyword · 333; run daemon threads · 815; pitfall · 337 finding .class files loading · 148 FixedThreadPool · 805 flag, using EnumSet instead · 737 Flex: OpenLaszlo alternative Flex · 1018; tool Macromedia · 1018 flip( ), nio · 681 float: floating point true false · 72; literal value marker (F) · 74 FlowLayout · 947 flushing output files · 668 Flyweight design pattern · 573, 935 focus traversal · 938 folding, constant · 183 keyword · 95 foreach · 97, 100, 138, 139, 152, 265, 277, 298, 303, 386, 448, 449, 495, 725, 744; Adapter Method · 307; Iterable · 305 format: precision · 365; specifiers · 365; string · 363; width · 365 format( ) · 363 Formatter · 364 forName( ) · 396, 953 FORTRAN programming language · 75 forward referencing · 128 Fowler, Martin · 145, 350, 1048 framework, control framework inner classes · 264 function: member function · 18; overriding · 23 function object · 526 functional languages · 800 Future · 808 Generator · 199, 446, 453, 459, 496, 522, 547, 559, 569, 732, 748; filling Collection · 453; general purpose · 454 generics: @Unit testing · 786; type-safe containers · 275; anonymous inner classes · 459; array generic objects · 610; basic introduction · 275; bounds · 465, 480; cast via generic class · 498; casting · 497; Class references · 401; contravariance · 487; curiously recurring · 501; erasure · 463, 497; example framework · 921; exceptions · 507; explicit type argument specification generic methods · 281, 452; inner classes · 459; instanceof · 472, 497; isInstance( ) · 472; methods · 449, 569; overloading · 499; reification · 467; self-bounded types · 500; simplest class definition · 292; supertype wildcards · 487; type tag · 472; unbounded wildcard · 489; varargs generic methods · 452; wildcards · 483 get( ): ArrayList · 276; HashMap · 296; get( ) Collection · 581 getBeanInfo( ) · 1005 getBytes( ) · 667 getCanonicalName( ) · 398 getChannel( ) · 680 getClass( ) · 324, 397 getConstructor( ) · 960 getConstructors( ) · 421 getenv( ) · 306 getEventSetDescriptors( ) · 1007 getInterfaces( ) · 398 getMethodDescriptors( ) · 1007 getMethods( ) · 421 getName( ) · 1007 getPropertyDescriptors( ) · 1007 getPropertyType( ) · 1007 getReadMethod( ) · 1007 getSelectedValues( ) · 968 getSimpleName( ) · 398 getState( ) · 976 getSuperclass( ) · 398 getWriteMethod( ) · 1007 Glass, Robert · 1049 glue, BoxLayout · 949 Goetz Test, avoiding synchronization · 833 Goetz, Brian · 830, 833, 914, 936 goto, lack Java · 101 graphical user interface (GUI) · 264, 937 graphics · 983; Graphics class · 978 greater (>) · 70 greater equal (>=) · 70 greedy quantifiers · 374 GridBagLayout · 948 GridLayout · 948, 1001 Grindstaff, Chris · 1028 group, thread · 823 groups, regular expression · 378 guarded region, exception handling · 316 GUI: graphical user interface · 264, 937; GUI builders · 938 GZIPInputStream · 699 GZIPOutputStream · 699 G H garbage collection · 120, 121; cleanup · 175; collector works · 123; order object reclamation · 177; reachable objects · 638 handler, exception · 316 Harold, Elliotte Rusty · 1017, 1048; XOM XML library · 720 has-a · 21; relationship, composition · 180 hash function · 608 hashCode( ) · 598, 602, 608; hashed data structures · 605; equals( ) · 589; issues writing · 611; recipe generating decent · 612 hashing · 605, 608; hash codes · 602; external chaining · 608; perfect hashing function · 608 HashMap · 598, 629, 925, 957 HashSet · 293, 589, 626 Hashtable · 629, 642 hasNext( ), Iterator · 288 Hexadecimal · 74 hiding, implementation · 158 Holub, Allen · 931 HTML Swing components · 985 I I/O: available( ) · 667; basic usage, examples · 665; tasks using pipes · 876; blocking, available( ) · 668; BufferedInputStream · 660; BufferedOutputStream · 661; BufferedReader · 341, 663, 665; BufferedWriter · 663, 668; ByteArrayInputStream · 657; ByteArrayOutputStream · 659; characteristics files · 655; CharArrayReader · 663; CharArrayWriter · 663; CheckedInputStream · 699; CheckedOutputStream · 699; close( ) · 666; compression library · 699; controlling process serialization · 708; DataInput · 665; DataInputStream · 660, 663, 667; DataOutput · 665; DataOutputStream · 661, 664; DeflaterOutputStream · 699; directory lister · 647; directory, creating directories paths · 655; Externalizable · 708; File · 657, 664; File class · 647; File.list( ) · 647; FileDescriptor · 657; FileInputReader · 665; FileInputStream · 657; FilenameFilter · 647; FileOutputStream · 659; FileReader · 341, 663; FileWriter · 663, 668; FilterInputStream · 657; FilterOutputStream · 659; FilterReader · 663; FilterWriter · 663; standard input · 675; GZIPInputStream · 699; GZIPOutputStream · 699; InflaterInputStream · 699; input · 657; InputStream · 657; InputStreamReader · 662, 663; internationalization · 662; interruptible · 854; library · 647; lightweight persistence · 703; LineNumberInputStream · 660; LineNumberReader · 663; mark( ) · 665; mkdirs( ) · 656; network I/O · 679; new nio · 679; ObjectOutputStream · 704; output · 657; OutputStream · 657, 658; OutputStreamWriter · 662, 663; pipe · 657; piped streams · 672; PipedInputStream · 657; PipedOutputStream · 657, 659; PipedReader · 663; PipedWriter · 663; PrintStream · 661; PrintWriter · 663, 668, 669; PushbackInputStream · 660; PushbackReader · 663; RandomAccessFile · 664, 665, 671; read( ) · 657; readDouble( ) · 670; Reader · 657, 662, 663; readExternal( ) · 708; readLine( ) · 343, 663, 668, 676; readObject( ) · 704; redirecting standard I/O · 677; renameTo( ) · 656; reset( ) · 665; seek( ) · 665, 671; SequenceInputStream · 657, 664; Serializable · 708; setErr(PrintStream) · 677; setIn(InputStream) · 677; setOut(PrintStream) · 677; StreamTokenizer · 663; StringBuffer · 657; StringBufferInputStream · 657; StringReader · 663, 666; StringWriter · 663; System.err · 675; System.in · 675; System.out · 675; transient · 711; Index typical I/O configurations · 665; Unicode · 663; write( ) · 657; writeBytes( ) · 670; writeChars( ) · 670; writeDouble( ) · 670; writeExternal( ) · 708; writeObject( ) · 704; Writer · 657, 662, 663; ZipEntry · 701; ZipInputStream · 699; ZipOutputStream · 699 Icon · 960 IdentityHashMap · 598, 630 if-else statement · 80, 93 IllegalAccessException · 408 IllegalMonitorStateException · 861 ImageIcon · 960 immutable · 427 implementation · 18; interface · 179, 222; interface, separating · 20; interface, separation · 158; hiding · 145, 158, 248; separation interface implementation · 949 implements keyword · 223 import keyword · 146 increment operator · 69; concurrency · 828 indexed property · 1017 indexing operator [ ] · 134 indexOf( ), String · 421 inference, generic type argument inference · 450 InflaterInputStream · 699 inheritance · 21, 156, 165, 168, 193; enum · 732; final · 189; finalize( ) · 206; generic code · 439; synchronized · 1015; class inheritance diagrams · 182; combining composition & inheritance · 173; designing inheritance · 213; diagram · 27; extending class · 23; extending interfaces inheritance · 232; abstract classes · 220; inner classes · 270; initialization inheritance · 190; method overloading vs. overriding · 178; multiple inheritance C++ Java · 230; pure inheritance vs. extension · 214; specialization · 180; vs. composition · 179, 183, 595, 642 initial capacity, HashMap HashSet · 630 initialization: class loading · 190; array initialization · 134; base class · 170; class · 400; class member · 166; constructor initialization inheritance composition · 173; initializing constructor · 107; instance initialization · 132, 253; lazy · 166; member initializers · 206; non-static instance initialization · 132; class fields · 126; method variables · 125; order initialization · 128, 211; static · 191; inheritance · 190 inline method calls · 186 inner class · 243; access rights · 245; overriding · 270; control frameworks · 264; super · 270; Swing · 950; threads · 816; upcasting · 248; anonymous inner class · 649, 944; table-driven code · 616; callback · 262; closure · 262; generic · 459; hidden reference object enclosing class · 246; identifiers .class files · 273; methods & scopes · 249; inheriting inner classes · 270; local · 250; motivation · 260; nesting within arbitrary scope · 250; private inner classes · 266; referring outerclass object · 246; static inner classes · 257 InputStream · 657 InputStreamReader · 662, 663 instance: instance initialization · 253; non-static instance initialization · 132; class · 16 instanceof · 410; generic types · 497; dynamic instanceof isInstance( ) · 411; keyword · 405 Integer: parseInt( ) · 984; wrapper class · 136 1051 interface: enum · 733; generic code · 439; implementation, separation · 20, 158, 949; inheritance · 232; base-class interface · 199; classes nested inside · 258; common interface · 219; object · 17; initializing fields interfaces · 236; keyword · 222; name collisions combining interfaces · 233; nesting interfaces within classes interfaces · 237; private, nested interfaces · 239; upcasting interface · 225; vs. abstract · 231; vs. implementation · 179 internationalization, I/O library · 662 interrupt( ): concurrency · 851; threading · 820 interruptible io · 854 Introspector · 1005 invocation handler, dynamic proxy · 423 is-a · 214; relationship, inheritance · 180; upcasting · 181; vs. is-like-a relationships · 24 isAssignableFrom( ), Class method · 413 isDaemon( ) · 813 isInstance( ) · 411; generics · 472 isInterface( ) · 398 is-like-a · 215 Iterable · 448, 571; array · 306; foreach · 305 Iterator · 287, 289, 302; hasNext( ) · 288; next( ) · 288 Iterator design pattern · 246 J Jacobsen, Ivar · 1048 JApplet · 946; menus · 972 JAR · 1015; file · 147; jar files classpath · 149; utility · 702 Java: set-top boxes · 76; AWT · 937; bytecodes · 357; compiling running program · 54; Java Foundation Classes (JFC/Swing) · 937; Java Virtual Machine (JVM) · 395; Java Web Start · 989; public Java seminars · 10 Java standard library, thread-safety · 884 JavaBeans, see Beans · 1002 javac · 54 javadoc · 55 javap decompiler · 356, 434, 470 Javassist · 793 JButton · 960; Swing · 942 JCheckBox · 960, 965 JCheckBoxMenuItem · 973, 976 JComboBox · 967 JComponent · 961, 978 JDialog · 981; menus · 972 JDK 1.1 I/O streams · 662 JDK, downloading installing · 54 JFC, Java Foundation Classes (Swing) · 937 JFileChooser · 984 JFrame · 946; menus · 972 JIT, just-in-time compilers · 125 JLabel · 963 JList · 968 JMenu · 972, 976 JMenuBar · 972, 977 JMenuItem · 960, 972, 976, 977, 978 JNLP, Java Network Launch Protocol · 989 join( ), threading · 820 JOptionPane · 970 Joy, Bill · 70 JPanel · 959, 978, 1001 JPopupMenu · 977 JProgressBar · 987 JRadioButton · 960, 966 JScrollPane · 946, 969 JSlider · 987 JTabbedPane · 970 JTextArea · 945 JTextField · 943, 961 JTextPane · 964 JToggleButton · 958 JUnit, problems · 778 JVM (Java Virtual Machine) · 395 K keyboard: navigation, Swing · 938; shortcuts · 976 keySet( ) · 629 L label · 101 labeled: break · 101; continue · 101 late binding · 26, 193, 196 latent typing · 515, 524 layout, controlling layout layout managers · 946 lazy initialization · 166 least-recently-used (LRU) · 602 left-shift operator (<<) · 76 length: array member · 135; arrays · 536 less (<) · 70 less equal (<=) · 70 lexicographic: sorting · 295; vs. alphabetic sorting · 561 library: creator, vs. client programmer · 145; design · 145; use · 146 LIFO (last-in, first-out) · 291 lightweight: object · 287; persistence · 703 LineNumberInputStream · 660 LineNumberReader · 663 LinkedBlockingQueue · 872 LinkedHashMap · 598, 601, 630 LinkedHashSet · 294, 589, 626, 627 LinkedList · 283, 290, 299, 586 linking, class · 400 list: boxes · 968; drop-down list · 967 List · 275, 278, 283, 586, 968; performance comparison · 620; sorting searching · 634 listener: adapters · 954; events · 950; interfaces · 953 Lister, Timothy · 1049 ListIterator · 586 literal: class literal · 399, 410; double · 74; float · 74; long · 74; values · 73 little endian · 688 livelock · 935 load factor, HashMap HashSet · 630 loader, class · 395 loading: .class files · 148; class · 191, 400; initialization & class loading · 190 local: inner class · 250; variable · 48 lock: contention, concurrency · 914; explicit, concurrency · 831; concurrency · 829; optimistic locking · 927 lock-free code, concurrent programming · 833 locking, file · 696, 697 logarithms, natural · 75 logging, building logging exceptions · 319 logical: AND · 82; operator short-circuiting · 73; operators · 71; OR · 82 long: threading · 833; literal value marker (L) · 74 look & feel, pluggable · 987 LRU, least-recently-used · 602 lvalue · 65 M machines, state, enum · 747 Macromedia Flex · 1018 main( ) · 169 manifest file, JAR files · 702, 1015 Map · 275, 278, 296; EnumMap · 739; in-depth exploration · 596; performance comparison · 628 Map.Entry · 607 MappedByteBuffer · 694 mark( ) · 665 marker annotation · 762 matcher, regular expression · 375 matches( ), String · 371 Math.random( ) · 296; range results · 625 mathematical operators · 67, 697 member: initializers · 206; member function · 18; object · 20 memory exhaustion, solution via References · 638 memory-mapped files · 693 menu: JDialog, JApplet, JFrame · 972; JPopupMenu · 977 message box, Swing · 970 message, sending · 17 Messenger idiom · 442, 571, 617 meta-annotations · 763 Metadata · 761 method: adding methods design · 163; aliasing method calls · 66; applying method sequence · 520; behavior polymorphic methods inside constructors · 210; distinguishing overloaded methods · 110; final · 186, 196, 212; generic · 449; initialization method variables · 125; inline method calls · 186; inner classes methods & scopes · 249; lookup tool · 951; method call binding · 196; overloading · 109; overriding private · 202; polymorphic method call · 193; private · 212; protected methods · 180; recursive · 360; static · 119, 196 Method · 1007; reflection · 419 MethodDescriptors · 1007 Meyer, Jeremy · 761, 791, 989 Meyers, Scott · 19 microbenchmarks · 625 Microsoft Visual BASIC · 1002 migration compatibility · 466 missed signals, concurrency · 864 mistakes, design · 162 mixin · 509 mkdirs( ) · 656 mnemonics (keyboard shortcuts) · 976 Mock Object · 431 modulus · 67 monitor, concurrency · 829 Mono · 37 multicast · 1011; event, JavaBeans · 1012 Index multidimensional arrays · 540 multiparadigm programming · 16 multiple dispatching: enum · 752; EnumMap · 757 multiple implementation inheritance · 261 multiple inheritance, C++ Java · 230 multiplication · 67 multiply nested class · 259 multitasking · 799 mutual exclusion (mutex), concurrency · 828 MXML, Macromedia Flex input format · 1018 mxmlc, Macromedia Flex compiler · 1020 N name: clash · 146; collisions · 150; collisions combining interfaces · 233; creating unique package names · 148; qualified · 398 namespaces · 146 narrowing conversion · 83 natural logarithms · 75 nested class (static inner class) · 257 nesting interfaces · 237 net.mindview.util.SwingConsole · 942 network I/O · 679 Neville, Sean · 1018 new I/O · 679 new operator · 120; primitives, array · 135 newInstance( ) · 960; reflection · 398 next( ), Iterator · 288 nio · 679; interruption · 854; buffer · 679; channel · 679; performance · 694 no-arg constructor · 108, 115 North, BorderLayout · 947 equivalent (!=) · 70 NOT, logical (!) · 71 notifyAll( ) · 860 notifyListeners( ) · 1015 null · 45 Null Iterator design pattern · 426 Null Object design pattern · 426 NullPointerException · 331 numbers, binary · 74 O object · 16; aliasing · 66; arrays first-class objects · 536; assigning objects copying references · 65; Class object · 395, 717, 829; creation · 108; equals( ) · 70; equivalence · 70; equivalence vs. reference equivalence · 70; final · 183; getClass( ) · 397; hashCode( ) · 598; interface · 17; lock, concurrency · 829; member · 20; object-oriented programming · 393; process creation · 131; serialization · 703; standard root class, default inheritance · 168; wait( ) notifyAll( ) · 860; web objects · 704 object pool · 895 object-oriented, basic concepts object-oriented programming (OOP) · 15 ObjectOutputStream · 704 Octal · 74 ones complement operator · 76 OOP: basic characteristics · 16; basic concepts object-oriented programming · 15; protocol · 222; 1053 Simula-67 programming language · 17; substitutability · 16 OpenLaszlo, alternative Flex · 1018 operating system, executing programs within Java · 677 operation, atomic · 833 operator · 64; + += overloading String · 169; +, String · 356; binary · 76; bitwise · 76; casting · 82; comma operator · 96; common pitfalls · 82; indexing operator [ ] · 134; logical · 71; logical operators short-circuiting · 73; onescomplement · 76; operator overloading String · 356; overloading · 81; precedence · 64; relational · 70; shift · 76; String conversion operator + · 64, 81; ternary · 80; unary · 69, 76 optional methods, Java containers · 583 OR · 82; (||) · 71 order: constructor calls inheritance · 204; initialization · 128, 190, 211 ordinal( ), enum · 726 organization, code · 153 OSExecute · 678 OutputStream · 657, 658 OutputStreamWriter · 662, 663 overflow, primitive types · 92 overloading: constructors · 109; distinguishing overloaded methods · 110; generics · 499; lack name hiding inheritance · 178; method overloading · 109; return values · 114; operator + += overloading String · 169, 356; operator overloading · 81; vs. overriding · 178 overriding: inner classes · 270; function · 23; private methods · 202; vs. overloading · 178 P package · 146; access, friendly · 153; directory structure · 153; creating unique package names · 148; default · 146, 155; names, capitalization · 50; package access, protected · 180 paintComponent( ) · 978, 983 painting JPanel Swing · 978 parameter, collecting · 509, 530 parameterized types · 439 parseInt( ) · 984 pattern, regular expression · 373 perfect hashing function · 608 performance: final · 189; nio · 694; test, containers · 616; tuning, concurrency · 913 persistence · 715; lightweight persistence · 703 PhantomReference · 638 philosophers, dining, example deadlock concurrency · 878 pipe · 657 piped streams · 672 PipedInputStream · 657 PipedOutputStream · 657, 659 PipedReader · 663, 876 PipedWriter · 663, 876 pipes, I/O · 876 Plauger, P.J. · 1049 pluggable look & feel · 987 pointer, Java exclusion pointers · 262 polymorphism · 25, 193, 217, 393, 437; constructors · 204; multiple dispatching · 752; behavior polymorphic methods inside constructors · 210 pool, object · 895 portability C, C++ Java · 84 position, absolute, laying Swing components · 949 possessive quantifiers · 374 post-decrement · 69 postfix · 69 post-increment · 69 pre-decrement · 69 preferences API · 722 prefix · 69 pre-increment · 69 prerequisites, book · 15 primitive: comparison · 70; data types, use operators · 84; final · 183; final static primitives · 185; initialization class fields · 126; types · 43 primordial class loader · 395 printf( ) · 363 printStackTrace( ) · 323, 325 PrintStream · 661 PrintWriter · 663, 668, 669; convenience constructor Java SE5 · 672 priority, concurrency · 809 PriorityBlockingQueue, concurrency · 889 PriorityQueue · 300, 593 private · 20, 145, 153, 155, 180, 829; illusion overriding private methods · 187; inner classes · 266; interfaces, nested · 239; method overriding · 202; methods · 212 problem space · 16 process control · 677 process, concurrent · 799 ProcessBuilder · 678 ProcessFiles · 790 producer-consumer, concurrency · 867 programmer, client · 19 programming: basic concepts object-oriented programming (OOP) · 15; event-driven programming · 943; Extreme Programming (XP) · 1048; multiparadigm · 16; object-oriented · 393 progress bar · 986 promotion, int · 84, 92 property · 1003; bound properties · 1017; constrained properties · 1017; custom property editor · 1017; custom property sheet · 1017; indexed property · 1017 PropertyChangeEvent · 1017 PropertyDescriptors · 1007 ProptertyVetoException · 1017 protected · 20, 145, 153, 156, 180; package access · 180; also package access · 158 protocol · 222 proxy: java.lang.ref.Reference · 638; unmodifiable methods Collections class · 585 Proxy design pattern · 422 public · 20, 145, 153, 154; interface · 222; class, compilation units · 146 pure substitution · 24, 214 PushbackInputStream · 660 PushbackReader · 663 pushdown stack · 291; generic · 444 Python · 1, 3, 6, 35, 39, 515, 564, 799, 1050 Q qualified name · 398 quantifier: greedy · 374; possessive · 374; regular expression · 374; reluctant · 374 queue · 275, 290, 299, 593; performance · 620; synchronized, concurrency · 872 queuing discipline · 300 R race condition, concurrency · 827 RAD (Rapid Application Development) · 418 radio button · 966 ragged array · 541 random selection, enum · 732 random( ) · 296 RandomAccess, tagging interface containers · 312 RandomAccessFile · 664, 665, 671, 680 raw type · 464 reachable objects garbage collection · 638 read( ) · 657; nio · 681 readDouble( ) · 670 Reader · 657, 662, 663 readExternal( ) · 708 reading standard input · 675 readLine( ) · 343, 663, 668, 676 readObject( ) · 704; Serializable · 712 ReadWriteLock · 929 recursion, unintended via toString( ) · 360 redirecting standard I/O · 677 ReentrantLock · 832, 856 refactoring · 145 reference: assigning objects copying references · 65; final · 183; finding exact type base reference · 395; null · 45; reference equivalence vs. object equivalence · 70 reference counting, garbage collection · 123 Reference, java.lang.ref · 638 referencing, forward · 128 reflection · 418, 419, 951, 1005; Beans · 1003; weak typing · 350; annotation processor · 764, 769; breaking encapsulation · 432; difference RTTI reflection · 419; example · 959; latent typing generics · 519 regex · 373 Registered Factories, variation Factory Method design pattern · 414 regular expressions · 370 rehashing · 630 reification, generics · 467 relational operators · 70 reluctant quantifiers · 374 removeActionListener( ) · 1009, 1014 removeXXXListener( ) · 950 renameTo( ) · 656 reporting errors book · 14 request, OOP · 17 reset( ) · 665 responsive user interfaces · 822 resume( ), deadlocks · 850 resumption, termination vs. resumption, exception handling · 317 re-throwing exception · 325 return: array · 539; finally · 336; constructor return value · 108; covariant return types · 212, 504; overloading return value · 114; returning multiple objects · 442 reusability · 20 reuse: code reuse · 165; reusable code · 1002 Index rewind( ) · 684 right-shift operator (>>) · 76 rollover · 961 RoShamBo · 752 Rumbaugh, James · 1048 running Java program · 54 runtime binding · 196; polymorphism · 193 runtime type information (RTTI) · 216; Class object · 395, 960; ClassCastException · 405; Constructor class reflection · 419; Field · 419; getConstructor( ) · 960; instanceof keyword · 405; isInstance( ) · 411; Method · 419; misuse · 437; newInstance( ) · 960; reflection · 418; reflection, difference · 419; shape example · 393; type-safe downcast · 405 RuntimeException · 331, 351 rvalue · 65 S ScheduledExecutor, concurrency · 892 scheduler, thread · 802 scope: inner class nesting within arbitrary scope · 250; inner classes methods & scopes · 249 scrolling Swing · 946 searching: array · 562; sorting searching Lists · 634 section, critical section synchronized block · 839 seek( ) · 665, 671 self-bounded types, generics · 500 semaphore, counting · 895 seminars: public Java seminars · 10; training, provided MindView, Inc. · 1043 sending message · 17 sentinel, end · 445 separation interface implementation · 20, 158, 949 sequence, applying method sequence · 520 SequenceInputStream · 657, 664 Serializable · 703, 708, 711, 719, 1011; readObject( ) · 712; writeObject( ) · 712 serialization: object storage · 715; transient · 711; controlling process serialization · 708; defaultReadObject( ) · 714; defaultWriteObject( ) · 714; Versioning · 714 Set · 275, 278, 293, 589; mathematical relationships · 456; performance comparison · 626 setActionCommand( ) · 976 setBorder( ) · 963 setErr(PrintStream) · 677 setIcon( ) · 961 setIn(InputStream) · 677 setLayout( ) · 946 setMnemonic( ) · 976 setOut(PrintStream) · 677 setToolTipText( ) · 961 shape: example · 22, 197; example, runtime type information · 393 shift operators · 76 short-circuit, logical operators · 73 shortcut, keyboard · 976 shuffle( ) · 635 side effect · 64, 70, 114 sign extension · 77 signals, missed, concurrency · 864 signature, method · 48 signed twos complement · 79 Simula-67 programming language · 17 1055 simulation · 900 sine wave · 978 single dispatching · 752 SingleThreadExecutor · 806 Singleton design pattern · 161 size( ), ArrayList · 276 size, HashMap HashSet · 630 sizeof( ), lack Java · 84 sleep( ), concurrency · 808 slider · 986 Smalltalk · 16 SocketChannel · 697 SoftReference · 638 Software Development Conference · 10 solution space · 15 SortedMap · 600 SortedSet · 592 sorting · 557; alphabetic · 295; searching Lists · 634; lexicographic · 295 source code · 12; copyright notice · 12 South, BorderLayout · 947 space: namespaces · 146; problem space · 16; solution space · 15 specialization · 180 specification, exception specification · 322, 348 specifier, access · 20, 145, 153 split( ), String · 226, 371 sprintf( ) · 369 SQL generated via annotations · 766 stack · 290, 291, 642; generic pushdown · 444 standard input, reading · 675 standards, coding · 14 State design pattern · 214 state machines, enum · 747 stateChanged( ) · 980 static · 223; final · 183; block · 131; construction clause · 131; data initialization · 129; final static primitives · 185; import, enum · 726; initialization · 191, 396; initializer · 414; inner classes · 257; keyword · 51, 119; method · 119, 196; strong type checking · 347; synchronized static · 829; type checking · 437; vs. dynamic type checking · 584 STL, C++ · 646 stop( ), deadlocks · 850 Strategy design pattern · 226, 234, 526, 547, 558, 559, 648, 653, 743, 889 stream, I/O · 657 StreamTokenizer · 663 String: CASE_INSENSITIVE_ORDER Comparator · 634; class methods · 355; concatenation operator += · 81; conversion operator + · 64, 81; format( ) · 369; immutability · 355; indexOf( ) · 421; lexicographic vs. alphabetic sorting · 561; methods · 361; operator + += overloading · 169; regular expression support · 371; sorting, CASE_INSENSITIVE_ORDER · 647; split( ) method · 226; toString( ) · 166 StringBuffer · 657 StringBufferInputStream · 657 StringBuilder, vs. String, toString( ) · 357 StringReader · 663, 666 StringWriter · 663 strong static type checking · 347 Stroustrup, Bjarne · 144 structural typing · 515, 524 struts, BoxLayout · 949 Stub · 431 style: coding style · 59; creating classes · 158 subobject · 170, 179 substitutability, OOP · 16 substitution: inheritance vs. extension · 214; principle · 24 subtraction · 67 suites, @Unit vs. JUnit · 787 super · 171; inner classes · 270; keyword · 169 superclass · 169; bounds · 404 supertype wildcards · 487 suspend( ), deadlocks · 850 SWF, Flash bytecode format · 1018 Swing · 937; concurrency · 994; component examples · 957; components, using HTML · 985; event model · 949 switch: enum · 728; keyword · 104 switch, context switching concurrency · 798 synchronized · 829; inheritance · 1015; wait( ) & notifyAll( ) · 860; block, critical section · 839; Brian’s Rule Synchronization · 830; containers · 637; deciding methods synchronize · 1015; queue · 872; static · 829 SynchronousQueue, concurrency · 904 System.arraycopy( ) · 555 System.err · 318, 675 System.in · 675 System.out · 675 System.out, changing PrintWriter · 676 systemNodeForPackage( ), preferences API · 723 T tabbed dialog · 970 table-driven code · 741; anonymous inner classes · 616 task vs. thread, terminology · 820 tearing, word tearing · 833 Template Method design pattern · 264, 408, 475, 616, 696, 842, 919, 923 templates, C++ · 440, 464 termination condition, finalize( ) · 122 termination vs. resumption, exception handling · 317 ternary operator · 80 testing: annotation-based unit testing @Unit · 778; techniques · 258; unit testing · 169 Theory Escalating Commitment · 823 keyword · 116 thread: group · 823; interrupt( ) · 851; isDaemon( ) · 813; notifyAll( ) · 860; priority · 809; resume( ), deadlocks · 850; safety, Java standard library · 884; scheduler · 802; states · 849; stop( ), deadlocks · 850; suspend( ), deadlocks · 850; thread local storage · 845; vs. task, terminology · 820; wait( ) · 860 ThreadFactory, custom · 812 throw keyword · 315 Throwable base class Exception · 323 throwing exception · 315 time conversion · 889 Timer, repeating · 866 TimeUnit · 809, 889 toArray( ) · 629 tool tips · 961 TooManyListenersException · 1011 toString( ) · 166; guidelines using StringBuilder · 359 training seminars provided MindView, Inc. · 1043 transferFrom( ) · 681 transferTo( ) · 681 transient keyword · 711 translation unit · 146 TreeMap · 598, 600, 629 TreeSet · 294, 589, 592, 626 true · 71 try · 177, 334; try block exceptions · 316 tryLock( ), file locking · 697 tuple · 442, 455, 461 twos complement, signed · 79 type: argument inference, generic · 450; base · 22; checking, static · 347, 437; data type equivalence class · 18; derived · 22; duck typing · 515, 524; dynamic type safety containers · 506; finding exact type base reference · 395; generics type-safe containers · 275; latent typing · 515, 524; parameterized · 439; primitive · 43; primitive data types use operators · 84; structural typing · 515, 524; tag, generics · 472; type checking arrays · 535; type safety Java · 82; type-safe downcast · 405 TYPE field, primitive class literals · 399 U UML: indicating composition · 21; Unified Modeling Language · 18, 1048 unary: minus (-) · 69; operator · 76; operators · 69; plus (+) · 69 unbounded wildcard generics · 489 UncaughtExceptionHandler, Thread class · 824 unchecked exception · 331; converting checked·351 unconditional branching · 99 unicast · 1011 Unicode · 663 Unified Modeling Language (UML) · 18, 1048 unit testing · 169; annotation-based @Unit · 778 unmodifiable, making Collection Map unmodifiable · 635 unmodifiableList( ), Collections · 584 unsupported methods, Java containers · 583 UnsupportedOperationException · 584 upcasting · 27, 181, 193; interface · 225; runtime type information · 394; inner classes upcasting · 248 user interface: graphical user interface (GUI) · 264, 937; responsive, threading · 822 userNodeForPackage( ), preferences API · 723 Utilities, java.util.Collections · 631 Visitor design pattern, annotations, mirror API · 775 Visual BASIC, Microsoft · 1002 visual programming · 1002; environments · 938 volatile · 826, 833, 836 W wait( ) · 860 waiting, busy · 860 Waldrop, M. Mitchell · 1050 WeakHashMap · 598, 640 WeakReference · 638 web objects · 704 Web Start, Java · 989 West, BorderLayout · 947 · 94 widening conversion · 83 wildcards: Class references · 402; generics · 483; supertype · 487; unbounded · 489 windowClosing( ) · 982 word tearing, concurrent programming · 833 write( ) · 657; nio · 681 writeBytes( ) · 670 writeChars( ) · 670 writeDouble( ) · 670 writeExternal( ) · 708 writeObject( ) · 704; Serializable · 712 Writer · 657, 662, 663 X XDoclet · 761 XML · 720 XOM XML library · 720 XOR (Exclusive-OR) · 76 Y You Aren’t Going Need It (YAGNI) · 427 Z zero extension · 77 ZipEntry · 701 ZipInputStream · 699 ZipOutputStream · 699 V value, preventing change run time · 183 values( ), enum · 725, 729 varargs · 137, 520; generic methods · 452 Varga, Ervin · 5, 855 variable: defining variable · 96; initialization method variables · 125; local · 48; variable argument lists (unknown quantity type arguments) · 137 Vector · 624, 641 vector change · 266 Venners, Bill · 122 versioning, serialization · 714 Index 1057